{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimum Spanning Tree - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Algorithm/">Algorithm</a>
    <span class="separator">/</span>
    <span class="current">Minimum Spanning Tree</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Minimum Spanning Tree</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Algorithm/14_Shortest_Path.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Shortest Path</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Algorithm/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Algorithm/16_LCA_and_Tree_Queries.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">26. LCA and Tree Queries</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#overview">Overview</a></li>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#1-mst-concept">1. MST Concept</a><ul>
<li><a href="#spanning-tree">Spanning Tree</a></li>
<li><a href="#minimum-spanning-tree-mst">Minimum Spanning Tree (MST)</a></li>
<li><a href="#mst-properties">MST Properties</a></li>
</ul>
</li>
<li><a href="#2-union-find-disjoint-set-union">2. Union-Find (Disjoint Set Union)</a><ul>
<li><a href="#concept">Concept</a></li>
<li><a href="#basic-implementation">Basic Implementation</a></li>
<li><a href="#optimization-1-path-compression">Optimization 1: Path Compression</a></li>
<li><a href="#optimization-2-union-by-rank">Optimization 2: Union by Rank</a></li>
<li><a href="#cpython-implementation">C++/Python Implementation</a></li>
</ul>
</li>
<li><a href="#3-kruskal-algorithm">3. Kruskal Algorithm</a><ul>
<li><a href="#concept_1">Concept</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#implementation">Implementation</a></li>
</ul>
</li>
<li><a href="#4-prim-algorithm">4. Prim Algorithm</a><ul>
<li><a href="#concept_2">Concept</a></li>
<li><a href="#example_1">Example</a></li>
<li><a href="#implementation-priority-queue">Implementation (Priority Queue)</a></li>
<li><a href="#implementation-adjacency-matrix-v2">Implementation (Adjacency Matrix, V¬≤)</a></li>
</ul>
</li>
<li><a href="#5-algorithm-comparison">5. Algorithm Comparison</a><ul>
<li><a href="#kruskal-vs-prim">Kruskal vs Prim</a></li>
<li><a href="#selection-criteria">Selection Criteria</a></li>
</ul>
</li>
<li><a href="#6-practice-problems">6. Practice Problems</a><ul>
<li><a href="#problem-1-minimum-spanning-tree">Problem 1: Minimum Spanning Tree</a></li>
<li><a href="#problem-2-city-division-plan">Problem 2: City Division Plan</a></li>
<li><a href="#recommended-problems">Recommended Problems</a></li>
</ul>
</li>
<li><a href="#template-summary">Template Summary</a><ul>
<li><a href="#union-find">Union-Find</a></li>
<li><a href="#kruskal">Kruskal</a></li>
<li><a href="#prim">Prim</a></li>
</ul>
</li>
<li><a href="#next-steps">Next Steps</a></li>
<li><a href="#references">References</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="minimum-spanning-tree">Minimum Spanning Tree<a class="header-link" href="#minimum-spanning-tree" title="Permanent link">&para;</a></h1>
<h2 id="overview">Overview<a class="header-link" href="#overview" title="Permanent link">&para;</a></h2>
<p>A Minimum Spanning Tree (MST) is a tree that connects all vertices of a graph while minimizing the sum of edge weights. We'll learn about Kruskal and Prim algorithms, as well as the Union-Find data structure.</p>
<hr />
<h2 id="table-of-contents">Table of Contents<a class="header-link" href="#table-of-contents" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#1-mst-concept">MST Concept</a></li>
<li><a href="#2-union-find">Union-Find</a></li>
<li><a href="#3-kruskal-algorithm">Kruskal Algorithm</a></li>
<li><a href="#4-prim-algorithm">Prim Algorithm</a></li>
<li><a href="#5-algorithm-comparison">Algorithm Comparison</a></li>
<li><a href="#6-practice-problems">Practice Problems</a></li>
</ol>
<hr />
<h2 id="1-mst-concept">1. MST Concept<a class="header-link" href="#1-mst-concept" title="Permanent link">&para;</a></h2>
<h3 id="spanning-tree">Spanning Tree<a class="header-link" href="#spanning-tree" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Spanning Tree: A subgraph that includes all vertices
               with no cycles

Conditions:
- Vertices: V
- Edges: V-1
- All vertices connected
- No cycles
</code></pre></div>

<h3 id="minimum-spanning-tree-mst">Minimum Spanning Tree (MST)<a class="header-link" href="#minimum-spanning-tree-mst" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">MST</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">spanning</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">minimum</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="n">weights</span>

<span class="w">    </span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="err">‚îÄ‚îÄ</span><span class="mi">4</span><span class="err">‚îÄ‚îÄ</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="w">    </span><span class="err">‚îÇ‚ï≤</span><span class="w">      </span><span class="err">‚îÇ‚ï≤</span>
<span class="w">    </span><span class="mi">2</span><span class="w">  </span><span class="mi">1</span><span class="w">    </span><span class="mi">5</span><span class="w">  </span><span class="mi">3</span>
<span class="w">    </span><span class="err">‚îÇ</span><span class="w">    </span><span class="err">‚ï≤</span><span class="w">  </span><span class="err">‚îÇ</span><span class="w">    </span><span class="err">‚ï≤</span>
<span class="w">   </span><span class="o">(</span><span class="mi">3</span><span class="o">)</span><span class="err">‚îÄ‚îÄ</span><span class="mi">6</span><span class="err">‚îÄ‚îÄ</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span><span class="err">‚îÄ‚îÄ</span><span class="mi">7</span><span class="err">‚îÄ‚îÄ</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>

<span class="n">MST</span><span class="w"> </span><span class="o">(</span><span class="n">total</span><span class="w"> </span><span class="n">weight</span><span class="o">:</span><span class="w"> </span><span class="mi">11</span><span class="o">):</span>
<span class="w">    </span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="err">‚îÄ‚îÄ</span><span class="mi">4</span><span class="err">‚îÄ‚îÄ</span><span class="o">(</span><span class="mi">2</span><span class="o">)</span>
<span class="w">     </span><span class="err">‚ï≤</span><span class="w">       </span><span class="err">‚ï≤</span>
<span class="w">      </span><span class="mi">1</span><span class="w">       </span><span class="mi">3</span>
<span class="w">        </span><span class="err">‚ï≤</span><span class="w">      </span><span class="err">‚ï≤</span>
<span class="w">        </span><span class="o">(</span><span class="mi">4</span><span class="o">)</span><span class="err">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
<span class="w">         </span><span class="err">‚îÇ</span>
<span class="w">         </span><span class="mi">2</span><span class="o">(</span><span class="n">connected</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">shown</span><span class="w"> </span><span class="n">properly</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">diagram</span><span class="o">)</span>

<span class="n">Actual</span><span class="w"> </span><span class="n">MST</span><span class="o">:</span>
<span class="o">(</span><span class="mi">1</span><span class="o">)-</span><span class="mi">1</span><span class="o">-(</span><span class="mi">4</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">)-</span><span class="mi">2</span><span class="o">-(</span><span class="mi">3</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="o">)-</span><span class="mi">4</span><span class="o">-(</span><span class="mi">1</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="mi">2</span><span class="o">)-</span><span class="mi">3</span><span class="o">-(</span><span class="mi">5</span><span class="o">)</span>
<span class="err">‚Üí</span><span class="w"> </span><span class="mi">1</span><span class="o">+</span><span class="mi">2</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="mi">3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="o">?</span><span class="w"> </span><span class="n">Or</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">combination</span>
</code></pre></div>

<h3 id="mst-properties">MST Properties<a class="header-link" href="#mst-properties" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">Cut</span><span class="w"> </span><span class="n">Property</span><span class="p">:</span><span class="w"> </span><span class="n">When</span><span class="w"> </span><span class="n">dividing</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">graph</span><span class="w"> </span><span class="nb">int</span><span class="n">o</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">sets</span><span class="p">,</span>
<span class="w">   </span><span class="n">the</span><span class="w"> </span><span class="n">minimum</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="n">crossing</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">cut</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MST</span>

<span class="mf">2.</span><span class="w"> </span><span class="n">Cycle</span><span class="w"> </span><span class="n">Property</span><span class="p">:</span><span class="w"> </span><span class="n">The</span><span class="w"> </span><span class="n">maximum</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">cycle</span>
<span class="w">   </span><span class="n">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MST</span>

<span class="mf">3.</span><span class="w"> </span><span class="n">Uniqueness</span><span class="p">:</span><span class="w"> </span><span class="kr">If</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">edge</span><span class="w"> </span><span class="n">weights</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">distinct</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">MST</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">unique</span>
</code></pre></div>

<hr />
<h2 id="2-union-find-disjoint-set-union">2. Union-Find (Disjoint Set Union)<a class="header-link" href="#2-union-find-disjoint-set-union" title="Permanent link">&para;</a></h2>
<h3 id="concept">Concept<a class="header-link" href="#concept" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Disjoint Sets: Sets with no common elements

Operations:
- Find(x): Returns the representative element of the set containing x
- Union(x, y): Merges the sets containing x and y

Use Cases:
- Cycle detection
- Connected component management
- Kruskal&#39;s algorithm
</code></pre></div>

<h3 id="basic-implementation">Basic Implementation<a class="header-link" href="#basic-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">// C</span>
<span class="cp">#define MAX_N 100001</span>

<span class="kt">int</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">MAX_N</span><span class="p">];</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span><span class="w">  </span><span class="c1">// Each element is its own parent</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">unite</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">py</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">px</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">py</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">parent</span><span class="p">[</span><span class="n">px</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">py</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="optimization-1-path-compression">Optimization 1: Path Compression<a class="header-link" href="#optimization-1-path-compression" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">Connect</span><span class="w"> </span><span class="nv">all</span><span class="w"> </span><span class="nv">nodes</span><span class="w"> </span><span class="nv">on</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">path</span><span class="w"> </span><span class="nv">directly</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">root</span><span class="w"> </span><span class="nv">during</span><span class="w"> </span><span class="nv">Find</span>

<span class="w">     </span><span class="ss">(</span><span class="mi">5</span><span class="ss">)</span><span class="w">              </span><span class="ss">(</span><span class="mi">5</span><span class="ss">)</span>
<span class="w">      </span>‚îÇ<span class="w">               </span><span class="o">/|</span>\
<span class="w">     </span><span class="ss">(</span><span class="mi">3</span><span class="ss">)</span><span class="w">      </span>‚Üí<span class="w">     </span><span class="ss">(</span><span class="mi">1</span><span class="ss">)(</span><span class="mi">2</span><span class="ss">)(</span><span class="mi">3</span><span class="ss">)</span>
<span class="w">     </span><span class="o">/</span>‚îÇ<span class="w">              </span>‚îÇ
<span class="w">   </span><span class="ss">(</span><span class="mi">1</span><span class="ss">)(</span><span class="mi">2</span><span class="ss">)</span><span class="w">            </span><span class="ss">(</span><span class="mi">4</span><span class="ss">)</span>
<span class="w">    </span>‚îÇ
<span class="w">   </span><span class="ss">(</span><span class="mi">4</span><span class="ss">)</span>

<span class="nv">Time</span><span class="w"> </span><span class="nv">Complexity</span>:<span class="w"> </span><span class="nv">Nearly</span><span class="w"> </span><span class="nv">O</span><span class="ss">(</span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="ss">(</span><span class="nv">Amortized</span><span class="ss">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// C - Path Compression</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span><span class="w">  </span><span class="c1">// Recursively connect to root</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="optimization-2-union-by-rank">Optimization 2: Union by Rank<a class="header-link" href="#optimization-2-union-by-rank" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Attach smaller tree to larger tree

  Tree1 (Rank 2)    Tree2 (Rank 1)
       (a)              (b)
      / ‚îÇ \              ‚îÇ
    (c)(d)(e)           (f)

After union:
       (a)
      /‚îÇ‚ï≤  \
    (c)(d)(e)(b)
              ‚îÇ
             (f)
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// C - Path Compression + Union by Rank</span>
<span class="kt">int</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">MAX_N</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">rank_arr</span><span class="p">[</span><span class="n">MAX_N</span><span class="p">];</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">init</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="w">        </span><span class="n">rank_arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">unite</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">py</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">px</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">py</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Attach smaller rank tree to larger rank tree</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank_arr</span><span class="p">[</span><span class="n">px</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rank_arr</span><span class="p">[</span><span class="n">py</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">parent</span><span class="p">[</span><span class="n">px</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">py</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank_arr</span><span class="p">[</span><span class="n">px</span><span class="p">]</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">rank_arr</span><span class="p">[</span><span class="n">py</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">parent</span><span class="p">[</span><span class="n">py</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">px</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">parent</span><span class="p">[</span><span class="n">py</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">px</span><span class="p">;</span>
<span class="w">        </span><span class="n">rank_arr</span><span class="p">[</span><span class="n">px</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="cpython-implementation">C++/Python Implementation<a class="header-link" href="#cpython-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">// C++</span>
<span class="k">class</span><span class="w"> </span><span class="nc">UnionFind</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">parent</span><span class="p">,</span><span class="w"> </span><span class="n">rank_</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">UnionFind</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">parent</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">rank_</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">iota</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">parent</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="mi">0</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">unite</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">px</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">),</span><span class="w"> </span><span class="n">py</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">px</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">py</span><span class="p">)</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank_</span><span class="p">[</span><span class="n">px</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">rank_</span><span class="p">[</span><span class="n">py</span><span class="p">])</span><span class="w"> </span><span class="n">swap</span><span class="p">(</span><span class="n">px</span><span class="p">,</span><span class="w"> </span><span class="n">py</span><span class="p">);</span>
<span class="w">        </span><span class="n">parent</span><span class="p">[</span><span class="n">py</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">px</span><span class="p">;</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">rank_</span><span class="p">[</span><span class="n">px</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rank_</span><span class="p">[</span><span class="n">py</span><span class="p">])</span><span class="w"> </span><span class="n">rank_</span><span class="p">[</span><span class="n">px</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">connected</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1"># Python</span>
<span class="k">class</span><span class="w"> </span><span class="nc">UnionFind</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">py</span><span class="p">]:</span>
            <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="n">py</span><span class="p">,</span> <span class="n">px</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">py</span><span class="p">]</span> <span class="o">=</span> <span class="n">px</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">py</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="3-kruskal-algorithm">3. Kruskal Algorithm<a class="header-link" href="#3-kruskal-algorithm" title="Permanent link">&para;</a></h2>
<h3 id="concept_1">Concept<a class="header-link" href="#concept_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="nv">Sort</span><span class="w"> </span><span class="nv">edges</span><span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="nv">weight</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">select</span><span class="w"> </span><span class="nv">edges</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">don</span><span class="err">&#39;t create cycles</span>

<span class="err">Principle:</span>
<span class="err">1. Sort all edges in ascending order by weight</span>
<span class="err">2. Select from the smallest edge</span>
<span class="err">3. Skip if it creates a cycle (check with Union-Find)</span>
<span class="err">4. Stop when V-1 edges are selected</span>

<span class="err">Time Complexity: O(E log E)</span>
</code></pre></div>

<h3 id="example">Example<a class="header-link" href="#example" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Graph:
   (0)‚îÄ‚îÄ7‚îÄ‚îÄ(1)
    ‚îÇ‚ï≤    ‚ï±‚îÇ
    5  8 9  7
    ‚îÇ    ‚ï≤‚ï± ‚îÇ
   (2)‚îÄ‚îÄ5‚îÄ‚îÄ(3)

Sorted edges: (2,3,5), (0,2,5), (0,1,7), (1,3,7), (0,3,8), (1,2,9)

Selection process:
1. (2,3,5) selected ‚Üí No cycle ‚úì
2. (0,2,5) selected ‚Üí No cycle ‚úì
3. (0,1,7) selected ‚Üí No cycle ‚úì
4. V-1=3 edges selected, complete

MST: (2,3), (0,2), (0,1)
Total weight: 5+5+7 = 17
</code></pre></div>

<h3 id="implementation">Implementation<a class="header-link" href="#implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">// C</span>
<span class="cp">#define MAX_E 100001</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">Edge</span><span class="p">;</span>

<span class="n">Edge</span><span class="w"> </span><span class="n">edges</span><span class="p">[</span><span class="n">MAX_E</span><span class="p">];</span>
<span class="kt">int</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">MAX_E</span><span class="p">];</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">cmp</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">((</span><span class="n">Edge</span><span class="o">*</span><span class="p">)</span><span class="n">a</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">weight</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="p">((</span><span class="n">Edge</span><span class="o">*</span><span class="p">)</span><span class="n">b</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
<span class="w">        </span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">kruskal</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">E</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Initialize</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="w">        </span><span class="n">parent</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>

<span class="w">    </span><span class="c1">// Sort</span>
<span class="w">    </span><span class="n">qsort</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="p">,</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="n">Edge</span><span class="p">),</span><span class="w"> </span><span class="n">cmp</span><span class="p">);</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mstWeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">edgeCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">edgeCount</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pu</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">u</span><span class="p">);</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">pv</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">v</span><span class="p">);</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">pu</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pv</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">parent</span><span class="p">[</span><span class="n">pu</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pv</span><span class="p">;</span>
<span class="w">            </span><span class="n">mstWeight</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">edges</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">weight</span><span class="p">;</span>
<span class="w">            </span><span class="n">edgeCount</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mstWeight</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// C++</span>
<span class="k">struct</span><span class="w"> </span><span class="nc">Edge</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="o">&lt;</span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="n">Edge</span><span class="o">&amp;</span><span class="w"> </span><span class="n">other</span><span class="p">)</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">other</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">kruskal</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Edge</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">sort</span><span class="p">(</span><span class="n">edges</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">edges</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

<span class="w">    </span><span class="n">UnionFind</span><span class="w"> </span><span class="n">uf</span><span class="p">(</span><span class="n">V</span><span class="p">);</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mstWeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">edgeCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">const</span><span class="w"> </span><span class="k">auto</span><span class="o">&amp;</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">edges</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">edgeCount</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">uf</span><span class="p">.</span><span class="n">unite</span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">v</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">mstWeight</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">weight</span><span class="p">;</span>
<span class="w">            </span><span class="n">edgeCount</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mstWeight</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1"># Python</span>
<span class="k">def</span><span class="w"> </span><span class="nf">kruskal</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># Sort by weight</span>
    <span class="n">uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">mst_weight</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">edge_count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">edge_count</span> <span class="o">&gt;=</span> <span class="n">V</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">uf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="n">mst_weight</span> <span class="o">+=</span> <span class="n">w</span>
            <span class="n">edge_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">mst_weight</span>
</code></pre></div>

<hr />
<h2 id="4-prim-algorithm">4. Prim Algorithm<a class="header-link" href="#4-prim-algorithm" title="Permanent link">&para;</a></h2>
<h3 id="concept_2">Concept<a class="header-link" href="#concept_2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Gradually expand the MST starting from a starting vertex

Principle:
1. Start from an arbitrary vertex
2. Among edges going out from vertices in the MST,
   select the edge with the smallest weight
3. Add the new vertex to the MST
4. Stop when all vertices are included

Time Complexity:
- Priority Queue: O(E log V)
- Adjacency Matrix: O(V¬≤)
</code></pre></div>

<h3 id="example_1">Example<a class="header-link" href="#example_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Graph (starting from 0):
   (0)‚îÄ‚îÄ7‚îÄ‚îÄ(1)
    ‚îÇ‚ï≤    ‚ï±‚îÇ
    5  8 9  7
    ‚îÇ    ‚ï≤‚ï± ‚îÇ
   (2)‚îÄ‚îÄ5‚îÄ‚îÄ(3)

Steps:
1. Start: MST = {0}
   Adjacent edges: (0,1,7), (0,2,5), (0,3,8)
   Select: (0,2,5) ‚Üí MST = {0,2}

2. Adjacent edges: (0,1,7), (0,3,8), (2,3,5)
   Select: (2,3,5) ‚Üí MST = {0,2,3}

3. Adjacent edges: (0,1,7), (3,1,7)
   Select: (0,1,7) or (3,1,7) ‚Üí MST = {0,1,2,3}

Result: Total weight = 5+5+7 = 17
</code></pre></div>

<h3 id="implementation-priority-queue">Implementation (Priority Queue)<a class="header-link" href="#implementation-priority-queue" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">// C++</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">prim</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;&gt;&amp;</span><span class="w"> </span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inMST</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// {weight, vertex}</span>
<span class="w">    </span><span class="n">priority_queue</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">,</span><span class="w"> </span><span class="n">greater</span><span class="o">&lt;&gt;&gt;</span><span class="w"> </span><span class="n">pq</span><span class="p">;</span>

<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mstWeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">});</span><span class="w">  </span><span class="c1">// Starting vertex</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">pq</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">pq</span><span class="p">.</span><span class="n">top</span><span class="p">();</span>
<span class="w">        </span><span class="n">pq</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">inMST</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"> </span><span class="k">continue</span><span class="p">;</span>

<span class="w">        </span><span class="n">inMST</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="n">mstWeight</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">w</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="k">auto</span><span class="w"> </span><span class="p">[</span><span class="n">v</span><span class="p">,</span><span class="w"> </span><span class="n">weight</span><span class="p">]</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">inMST</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">pq</span><span class="p">.</span><span class="n">push</span><span class="p">({</span><span class="n">weight</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">});</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mstWeight</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1"># Python</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">heapq</span>

<span class="k">def</span><span class="w"> </span><span class="nf">prim</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">adj</span><span class="p">):</span>
    <span class="n">in_mst</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>  <span class="c1"># (weight, vertex)</span>
    <span class="n">mst_weight</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">pq</span><span class="p">:</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">in_mst</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">continue</span>

        <span class="n">in_mst</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">mst_weight</span> <span class="o">+=</span> <span class="n">w</span>

        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_mst</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">mst_weight</span>
</code></pre></div>

<h3 id="implementation-adjacency-matrix-v2">Implementation (Adjacency Matrix, V¬≤)<a class="header-link" href="#implementation-adjacency-matrix-v2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">// C++ - Better for dense graphs</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">primMatrix</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="w"> </span><span class="n">adj</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">key</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">INT_MAX</span><span class="p">);</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">inMST</span><span class="p">(</span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>

<span class="w">    </span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">mstWeight</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">count</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Select vertex with minimum key value</span>
<span class="w">        </span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">-1</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">inMST</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="p">(</span><span class="n">u</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">u</span><span class="p">]))</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">u</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="n">inMST</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="n">mstWeight</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">u</span><span class="p">];</span>

<span class="w">        </span><span class="c1">// Update key values of adjacent vertices</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">V</span><span class="p">;</span><span class="w"> </span><span class="n">v</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="o">!</span><span class="n">inMST</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">key</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">];</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">mstWeight</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<hr />
<h2 id="5-algorithm-comparison">5. Algorithm Comparison<a class="header-link" href="#5-algorithm-comparison" title="Permanent link">&para;</a></h2>
<h3 id="kruskal-vs-prim">Kruskal vs Prim<a class="header-link" href="#kruskal-vs-prim" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="err">‚îÇ</span><span class="w">             </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Kruskal</span><span class="w">          </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Prim</span><span class="w">             </span><span class="err">‚îÇ</span>
<span class="err">‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Approach</span><span class="w">    </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Edge</span><span class="o">-</span><span class="nx">centric</span><span class="w">     </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Vertex</span><span class="o">-</span><span class="nx">centric</span><span class="w">   </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Data</span><span class="w"> </span><span class="nx">Struct</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Union</span><span class="o">-</span><span class="nx">Find</span><span class="w">       </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Priority</span><span class="w"> </span><span class="nx">Queue</span><span class="w">   </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Time</span><span class="w">        </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">O</span><span class="p">(</span><span class="nx">E</span><span class="w"> </span><span class="nx">log</span><span class="w"> </span><span class="nx">E</span><span class="p">)</span><span class="w">       </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">O</span><span class="p">(</span><span class="nx">E</span><span class="w"> </span><span class="nx">log</span><span class="w"> </span><span class="nx">V</span><span class="p">)</span><span class="w">       </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Best</span><span class="w"> </span><span class="k">for</span><span class="w">    </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Sparse</span><span class="w"> </span><span class="nx">graphs</span><span class="w">    </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Dense</span><span class="w"> </span><span class="nx">graphs</span><span class="w">     </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Complexity</span><span class="w">  </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Relatively</span><span class="w"> </span><span class="nx">simple</span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Relatively</span><span class="w"> </span><span class="nx">complex</span><span class="err">‚îÇ</span>
<span class="err">‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>
</code></pre></div>

<h3 id="selection-criteria">Selection Criteria<a class="header-link" href="#selection-criteria" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Sparse graphs (E ‚âà V): Kruskal is better
Dense graphs (E ‚âà V¬≤): Prim is better

Edge list input: Kruskal is better
Adjacency list input: Prim is better
</code></pre></div>

<hr />
<h2 id="6-practice-problems">6. Practice Problems<a class="header-link" href="#6-practice-problems" title="Permanent link">&para;</a></h2>
<h3 id="problem-1-minimum-spanning-tree">Problem 1: Minimum Spanning Tree<a class="header-link" href="#problem-1-minimum-spanning-tree" title="Permanent link">&para;</a></h3>
<p>Find the total weight of the MST for the given graph.</p>
<details>
<summary>Solution Code</summary>


<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">solution</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="c1"># Kruskal</span>
    <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">V</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="k">if</span> <span class="n">uf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">w</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">total</span>
</code></pre></div>



</details>

<h3 id="problem-2-city-division-plan">Problem 2: City Division Plan<a class="header-link" href="#problem-2-city-division-plan" title="Permanent link">&para;</a></h3>
<p>Divide N villages into 2 groups and connect each group with minimum cost.</p>
<details>
<summary>Hint</summary>

After constructing the MST, remove the largest edge to create 2 groups

</details>

<details>
<summary>Solution Code</summary>


<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">divide_villages</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>

    <span class="n">mst_edges</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">uf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="n">mst_edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mst_edges</span><span class="p">)</span> <span class="o">==</span> <span class="n">V</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

    <span class="c1"># Remove the largest edge</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">mst_edges</span><span class="p">)</span> <span class="o">-</span> <span class="nb">max</span><span class="p">(</span><span class="n">mst_edges</span><span class="p">)</span>
</code></pre></div>



</details>

<h3 id="recommended-problems">Recommended Problems<a class="header-link" href="#recommended-problems" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Difficulty</th>
<th>Problem</th>
<th>Platform</th>
<th>Algorithm</th>
</tr>
</thead>
<tbody>
<tr>
<td>‚≠ê‚≠ê</td>
<td><a href="https://www.acmicpc.net/problem/1197">Minimum Spanning Tree</a></td>
<td>BOJ</td>
<td>Kruskal/Prim</td>
</tr>
<tr>
<td>‚≠ê‚≠ê</td>
<td><a href="https://www.acmicpc.net/problem/9372">Sanggeun's Travel</a></td>
<td>BOJ</td>
<td>MST Concept</td>
</tr>
<tr>
<td>‚≠ê‚≠ê‚≠ê</td>
<td><a href="https://www.acmicpc.net/problem/1647">City Division Plan</a></td>
<td>BOJ</td>
<td>MST Application</td>
</tr>
<tr>
<td>‚≠ê‚≠ê‚≠ê</td>
<td><a href="https://www.acmicpc.net/problem/1922">Network Connection</a></td>
<td>BOJ</td>
<td>MST</td>
</tr>
<tr>
<td>‚≠ê‚≠ê‚≠ê</td>
<td><a href="https://leetcode.com/problems/min-cost-to-connect-all-points/">Min Cost to Connect</a></td>
<td>LeetCode</td>
<td>Prim</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="template-summary">Template Summary<a class="header-link" href="#template-summary" title="Permanent link">&para;</a></h2>
<h3 id="union-find">Union-Find<a class="header-link" href="#union-find" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">UnionFind</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rank</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">!=</span> <span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">px</span> <span class="o">==</span> <span class="n">py</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">py</span><span class="p">]:</span>
            <span class="n">px</span><span class="p">,</span> <span class="n">py</span> <span class="o">=</span> <span class="n">py</span><span class="p">,</span> <span class="n">px</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">[</span><span class="n">py</span><span class="p">]</span> <span class="o">=</span> <span class="n">px</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">py</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rank</span><span class="p">[</span><span class="n">px</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>

<h3 id="kruskal">Kruskal<a class="header-link" href="#kruskal" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">kruskal</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="n">edges</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">uf</span> <span class="o">=</span> <span class="n">UnionFind</span><span class="p">(</span><span class="n">V</span><span class="p">)</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">uf</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="n">total</span> <span class="o">+=</span> <span class="n">w</span>
    <span class="k">return</span> <span class="n">total</span>
</code></pre></div>

<h3 id="prim">Prim<a class="header-link" href="#prim" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">prim</span><span class="p">(</span><span class="n">V</span><span class="p">,</span> <span class="n">adj</span><span class="p">):</span>
    <span class="n">in_mst</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">V</span>
    <span class="n">pq</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">pq</span><span class="p">:</span>
        <span class="n">w</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">heapq</span><span class="o">.</span><span class="n">heappop</span><span class="p">(</span><span class="n">pq</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">in_mst</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">continue</span>
        <span class="n">in_mst</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">total</span> <span class="o">+=</span> <span class="n">w</span>
        <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">adj</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_mst</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">heapq</span><span class="o">.</span><span class="n">heappush</span><span class="p">(</span><span class="n">pq</span><span class="p">,</span> <span class="p">(</span><span class="n">weight</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">total</span>
</code></pre></div>

<hr />
<h2 id="next-steps">Next Steps<a class="header-link" href="#next-steps" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="./16_LCA_and_Tree_Queries.md">16_LCA_and_Tree_Queries.md</a> - LCA, Tree Queries</li>
</ul>
<hr />
<h2 id="references">References<a class="header-link" href="#references" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://visualgo.net/en/mst">MST Visualization</a></li>
<li><a href="https://cp-algorithms.com/data_structures/disjoint_set_union.html">Union-Find Tutorial</a></li>
<li>Introduction to Algorithms (CLRS) - Chapter 23</li>
</ul>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Algorithm/14_Shortest_Path.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Shortest Path</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Algorithm/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Algorithm/16_LCA_and_Tree_Queries.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">26. LCA and Tree Queries</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}