{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>24. Strongly Connected Components (SCC) - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">ğŸ </span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">ğŸ’»</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        í•œêµ­ì–´
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">â˜€ï¸</span>
                    <span class="theme-icon dark">ğŸŒ™</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Algorithm/">Algorithm</a>
    <span class="separator">/</span>
    <span class="current">24. Strongly Connected Components (SCC)</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>24. Strongly Connected Components (SCC)</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Algorithm/16_LCA_and_Tree_Queries.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">26. LCA and Tree Queries</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Algorithm/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Algorithm/18_Dynamic_Programming.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Dynamic Programming</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#learning-objectives">Learning Objectives</a></li>
<li><a href="#1-what-are-strongly-connected-components">1. What are Strongly Connected Components?</a><ul>
<li><a href="#definition">Definition</a></li>
<li><a href="#properties">Properties</a></li>
<li><a href="#applications-of-scc">Applications of SCC</a></li>
</ul>
</li>
<li><a href="#2-kosarajus-algorithm">2. Kosaraju's Algorithm</a><ul>
<li><a href="#core-idea">Core Idea</a></li>
<li><a href="#how-it-works">How It Works</a></li>
<li><a href="#implementation">Implementation</a></li>
<li><a href="#c-implementation">C++ Implementation</a></li>
<li><a href="#time-complexity">Time Complexity</a></li>
</ul>
</li>
<li><a href="#3-tarjans-algorithm">3. Tarjan's Algorithm</a><ul>
<li><a href="#core-idea_1">Core Idea</a></li>
<li><a href="#how-it-works_1">How It Works</a></li>
<li><a href="#visualization">Visualization</a></li>
<li><a href="#implementation_1">Implementation</a></li>
<li><a href="#c-implementation_1">C++ Implementation</a></li>
<li><a href="#kosaraju-vs-tarjan-comparison">Kosaraju vs Tarjan Comparison</a></li>
</ul>
</li>
<li><a href="#4-condensation-graph">4. Condensation Graph</a><ul>
<li><a href="#concept">Concept</a></li>
<li><a href="#implementation_2">Implementation</a></li>
<li><a href="#applications-of-condensation-graph">Applications of Condensation Graph</a></li>
</ul>
</li>
<li><a href="#5-2-sat-problem">5. 2-SAT Problem</a><ul>
<li><a href="#concept_1">Concept</a></li>
<li><a href="#graph-transformation">Graph Transformation</a></li>
<li><a href="#satisfiability-test">Satisfiability Test</a></li>
<li><a href="#implementation_3">Implementation</a></li>
<li><a href="#2-sat-application-problems">2-SAT Application Problems</a></li>
</ul>
</li>
<li><a href="#6-practical-problem-patterns">6. Practical Problem Patterns</a><ul>
<li><a href="#pattern-1-count-sccs">Pattern 1: Count SCCs</a></li>
<li><a href="#pattern-2-universal-source">Pattern 2: Universal Source</a></li>
<li><a href="#pattern-3-minimum-edges-to-make-strongly-connected">Pattern 3: Minimum Edges to Make Strongly Connected</a></li>
<li><a href="#pattern-4-nodes-in-cycles">Pattern 4: Nodes in Cycles</a></li>
</ul>
</li>
<li><a href="#7-time-complexity-summary">7. Time Complexity Summary</a></li>
<li><a href="#8-common-mistakes">8. Common Mistakes</a><ul>
<li><a href="#mistake-1-missing-on_stack-check">Mistake 1: Missing on_stack Check</a></li>
<li><a href="#mistake-2-2-sat-node-number-calculation-error">Mistake 2: 2-SAT Node Number Calculation Error</a></li>
<li><a href="#mistake-3-duplicate-edges-in-condensation-graph">Mistake 3: Duplicate Edges in Condensation Graph</a></li>
</ul>
</li>
<li><a href="#9-practice-problems">9. Practice Problems</a></li>
<li><a href="#next-steps">Next Steps</a></li>
<li><a href="#learning-checklist">Learning Checklist</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="24-strongly-connected-components-scc">24. Strongly Connected Components (SCC)<a class="header-link" href="#24-strongly-connected-components-scc" title="Permanent link">&para;</a></h1>
<h2 id="learning-objectives">Learning Objectives<a class="header-link" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<ul>
<li>Understand the concept of Strongly Connected Components (SCC)</li>
<li>Implement Tarjan's algorithm</li>
<li>Implement Kosaraju's algorithm</li>
<li>Solve 2-SAT problems</li>
<li>Utilize condensation graphs (DAG)</li>
</ul>
<h2 id="1-what-are-strongly-connected-components">1. What are Strongly Connected Components?<a class="header-link" href="#1-what-are-strongly-connected-components" title="Permanent link">&para;</a></h2>
<h3 id="definition">Definition<a class="header-link" href="#definition" title="Permanent link">&para;</a></h3>
<p>In a <strong>directed graph</strong>, a <strong>Strongly Connected Component (SCC)</strong> is a <strong>maximal</strong> subgraph where for every pair of vertices (u, v), there exist paths both uâ†’v and vâ†’u.</p>
<div class="highlight"><pre><span></span><code>    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  SCC 1    â”‚
    â”‚  â”Œâ†’1â†’â”€â”   â”‚
    â”‚  â”‚    â†“   â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”
    â”‚  4â†â”€â”€2    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚ SCC 2 â”‚
    â”‚      â†“    â”‚         â”‚  5â†’6  â”‚
    â”‚      3â†â”€â”€â”€â”‚         â”‚  â†‘ â†“  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚  8â†7  â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></div>

<h3 id="properties">Properties<a class="header-link" href="#properties" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Maximality</strong>: Adding a vertex to an SCC breaks the strong connectivity</li>
<li><strong>Partition</strong>: Every vertex belongs to exactly one SCC</li>
<li><strong>DAG Structure</strong>: Viewing SCCs as single nodes forms a DAG (Directed Acyclic Graph)</li>
</ol>
<h3 id="applications-of-scc">Applications of SCC<a class="header-link" href="#applications-of-scc" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              SCC Applications                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â€¢ 2-SAT problem solving                        â”‚
â”‚  â€¢ Deadlock detection                           â”‚
â”‚  â€¢ Social network analysis (community detection)â”‚
â”‚  â€¢ Web page clustering                          â”‚
â”‚  â€¢ Compiler optimization (circular dependency)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></div>

<hr />
<h2 id="2-kosarajus-algorithm">2. Kosaraju's Algorithm<a class="header-link" href="#2-kosarajus-algorithm" title="Permanent link">&para;</a></h2>
<h3 id="core-idea">Core Idea<a class="header-link" href="#core-idea" title="Permanent link">&para;</a></h3>
<ol>
<li>DFS on original graph, record finish order</li>
<li>DFS on reversed graph in reverse finish order</li>
<li>Each DFS tree is one SCC</li>
</ol>
<h3 id="how-it-works">How It Works<a class="header-link" href="#how-it-works" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Step 1: DFS on original graph (record finish order)
        1 â†’ 2 â†’ 3
        â†‘       â†“
        â””â”€â”€â”€â”€â”€â”€â”€â”˜

        Finish order: [3, 2, 1]

Step 2: Reverse the graph
        1 â† 2 â† 3
        â†“       â†‘
        â””â”€â”€â”€â”€â”€â”€â”€â”˜

Step 3: DFS in reverse order (starting from 1)
        1 â†’ 3 â†’ 2 â†’ (back to 1)

        SCC: {1, 2, 3}
</code></pre></div>

<h3 id="implementation">Implementation<a class="header-link" href="#implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

<span class="k">class</span><span class="w"> </span><span class="nc">KosarajuSCC</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_graph</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reverse_graph</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">find_sccs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Step 1: DFS on original graph, record finish order</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">finish_order</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">dfs1</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                    <span class="n">dfs1</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
            <span class="n">finish_order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">dfs1</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Step 2: DFS on reversed graph in reverse order</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">sccs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">dfs2</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
            <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">component</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">reverse_graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                    <span class="n">dfs2</span><span class="p">(</span><span class="n">neighbor</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>

        <span class="c1"># Process in reverse finish order</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">finish_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">component</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">dfs2</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">component</span><span class="p">)</span>
                <span class="n">sccs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sccs</span>

<span class="c1"># Usage example</span>
<span class="n">scc</span> <span class="o">=</span> <span class="n">KosarajuSCC</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
    <span class="n">scc</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">scc</span><span class="o">.</span><span class="n">find_sccs</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SCCs:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="c1"># SCCs: [[7], [4, 6, 5], [3], [0, 2, 1]]</span>
</code></pre></div>

<h3 id="c-implementation">C++ Implementation<a class="header-link" href="#c-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;bits/stdc++.h&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">KosarajuSCC</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">;</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">graph</span><span class="p">,</span><span class="w"> </span><span class="n">reverseGraph</span><span class="p">;</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">visited</span><span class="p">;</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">finishOrder</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">dfs1</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">])</span><span class="w"> </span><span class="n">dfs1</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="n">finishOrder</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">dfs2</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">component</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">        </span><span class="n">component</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">reverseGraph</span><span class="p">[</span><span class="n">node</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">next</span><span class="p">])</span><span class="w"> </span><span class="n">dfs2</span><span class="p">(</span><span class="n">next</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">KosarajuSCC</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">graph</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">reverseGraph</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">addEdge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">        </span><span class="n">reverseGraph</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">findSCCs</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="c1">// Step 1</span>
<span class="w">        </span><span class="n">visited</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="w"> </span><span class="n">dfs1</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="c1">// Step 2</span>
<span class="w">        </span><span class="n">visited</span><span class="p">.</span><span class="n">assign</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">);</span>
<span class="w">        </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">sccs</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">--</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">finishOrder</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">component</span><span class="p">;</span>
<span class="w">                </span><span class="n">dfs2</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">component</span><span class="p">);</span>
<span class="w">                </span><span class="n">sccs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">component</span><span class="p">);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sccs</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="time-complexity">Time Complexity<a class="header-link" href="#time-complexity" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Time</strong>: O(V + E) - Two DFS passes</li>
<li><strong>Space</strong>: O(V + E) - Storing reversed graph</li>
</ul>
<hr />
<h2 id="3-tarjans-algorithm">3. Tarjan's Algorithm<a class="header-link" href="#3-tarjans-algorithm" title="Permanent link">&para;</a></h2>
<h3 id="core-idea_1">Core Idea<a class="header-link" href="#core-idea_1" title="Permanent link">&para;</a></h3>
<p>Find SCCs in a single DFS using <strong>discovery time</strong> and <strong>low-link values</strong>.</p>
<ul>
<li><strong>Discovery time (disc)</strong>: When a node was first visited</li>
<li><strong>Low-link (low)</strong>: Smallest discovery time reachable from this node</li>
</ul>
<h3 id="how-it-works_1">How It Works<a class="header-link" href="#how-it-works_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">When</span><span class="w"> </span><span class="n">visiting</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nl">node</span><span class="p">:</span>
<span class="mf">1.</span><span class="w"> </span><span class="n">disc</span><span class="o">[</span><span class="n">node</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">low</span><span class="o">[</span><span class="n">node</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">current</span><span class="w"> </span><span class="nc">time</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">Push</span><span class="w"> </span><span class="n">onto</span><span class="w"> </span><span class="n">stack</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">Explore</span><span class="w"> </span><span class="nl">neighbors</span><span class="p">:</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="nl">Unvisited</span><span class="p">:</span><span class="w"> </span><span class="n">Recurse</span><span class="p">,</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="n">low</span><span class="o">[</span><span class="n">node</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="n">low</span><span class="o">[</span><span class="n">node</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="o">[</span><span class="n">neighbor</span><span class="o">]</span><span class="p">)</span>
<span class="w">   </span><span class="o">-</span><span class="w"> </span><span class="k">On</span><span class="w"> </span><span class="nl">stack</span><span class="p">:</span><span class="w"> </span><span class="n">low</span><span class="o">[</span><span class="n">node</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nf">min</span><span class="p">(</span><span class="n">low</span><span class="o">[</span><span class="n">node</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">disc</span><span class="o">[</span><span class="n">neighbor</span><span class="o">]</span><span class="p">)</span>
<span class="mf">4.</span><span class="w"> </span><span class="k">If</span><span class="w"> </span><span class="n">disc</span><span class="o">[</span><span class="n">node</span><span class="o">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">low</span><span class="o">[</span><span class="n">node</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">it</span><span class="err">&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">SCC</span><span class="w"> </span><span class="n">root</span>
<span class="w">   </span><span class="err">â†’</span><span class="w"> </span><span class="n">Pop</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">form</span><span class="w"> </span><span class="n">SCC</span>
</code></pre></div>

<h3 id="visualization">Visualization<a class="header-link" href="#visualization" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>DFS progress:
Nodes:  1 â†’ 2 â†’ 3 â†’ 1(back edge)
disc: [1,  2,  3]
low:  [1,  1,  1]  â† Updated by back edge from 3 to 1

At node 1: disc[1] == low[1] = 1
â†’ SCC found: {1, 2, 3}
</code></pre></div>

<h3 id="implementation_1">Implementation<a class="header-link" href="#implementation_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TarjanSCC</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disc</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>      <span class="c1"># Discovery time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">low</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>       <span class="c1"># Low-link value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_stack</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sccs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disc</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_stack</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">disc</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Unvisited node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_stack</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                <span class="c1"># Node on stack (back edge)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">disc</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span>

        <span class="c1"># If this is an SCC root</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">disc</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">component</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">on_stack</span><span class="p">[</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">component</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">top</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">top</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sccs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">find_sccs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">disc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sccs</span>

<span class="c1"># Usage example</span>
<span class="n">tarjan</span> <span class="o">=</span> <span class="n">TarjanSCC</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">7</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
    <span class="n">tarjan</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">tarjan</span><span class="o">.</span><span class="n">find_sccs</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SCCs:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="c1"># SCCs: [[2, 1, 0], [6, 5, 4], [3], [7]]</span>
</code></pre></div>

<h3 id="c-implementation_1">C++ Implementation<a class="header-link" href="#c-implementation_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;bits/stdc++.h&gt;</span>
<span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TarjanSCC</span><span class="w"> </span><span class="p">{</span>
<span class="k">private</span><span class="o">:</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">timer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">graph</span><span class="p">;</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">disc</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="p">;</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="w"> </span><span class="n">onStack</span><span class="p">;</span>
<span class="w">    </span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">st</span><span class="p">;</span>
<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">sccs</span><span class="p">;</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">disc</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">timer</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="n">st</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
<span class="w">        </span><span class="n">onStack</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>

<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">next</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">disc</span><span class="p">[</span><span class="n">next</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">dfs</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
<span class="w">                </span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="w"> </span><span class="n">low</span><span class="p">[</span><span class="n">next</span><span class="p">]);</span>
<span class="w">            </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">onStack</span><span class="p">[</span><span class="n">next</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">],</span><span class="w"> </span><span class="n">disc</span><span class="p">[</span><span class="n">next</span><span class="p">]);</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">disc</span><span class="p">[</span><span class="n">node</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">component</span><span class="p">;</span>
<span class="w">            </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="nb">true</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">                </span><span class="kt">int</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">top</span><span class="p">();</span><span class="w"> </span><span class="n">st</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>
<span class="w">                </span><span class="n">onStack</span><span class="p">[</span><span class="n">top</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">                </span><span class="n">component</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">top</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">node</span><span class="p">)</span><span class="w"> </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="n">sccs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">component</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>

<span class="k">public</span><span class="o">:</span>
<span class="w">    </span><span class="n">TarjanSCC</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">n</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">graph</span><span class="p">(</span><span class="n">n</span><span class="p">),</span><span class="w"> </span><span class="n">disc</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">),</span><span class="w"> </span><span class="n">low</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="mi">-1</span><span class="p">),</span><span class="w"> </span><span class="n">onStack</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="nb">false</span><span class="p">)</span><span class="w"> </span><span class="p">{}</span>

<span class="w">    </span><span class="kt">void</span><span class="w"> </span><span class="n">addEdge</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">u</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">graph</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">push_back</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="n">findSCCs</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">disc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">sccs</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3 id="kosaraju-vs-tarjan-comparison">Kosaraju vs Tarjan Comparison<a class="header-link" href="#kosaraju-vs-tarjan-comparison" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Kosaraju</th>
<th>Tarjan</th>
</tr>
</thead>
<tbody>
<tr>
<td>DFS passes</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>Extra space</td>
<td>Reversed graph O(V+E)</td>
<td>Stack O(V)</td>
</tr>
<tr>
<td>Implementation</td>
<td>Intuitive</td>
<td>Slightly complex</td>
</tr>
<tr>
<td>Online processing</td>
<td>Impossible</td>
<td>Possible</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="4-condensation-graph">4. Condensation Graph<a class="header-link" href="#4-condensation-graph" title="Permanent link">&para;</a></h2>
<h3 id="concept">Concept<a class="header-link" href="#concept" title="Permanent link">&para;</a></h3>
<p><strong>Compressing</strong> each SCC into a single node creates a <strong>DAG</strong>.</p>
<div class="highlight"><pre><span></span><code><span class="nv">Original</span><span class="w"> </span><span class="nv">graph</span>:<span class="w">                </span><span class="nv">Condensation</span><span class="w"> </span><span class="nv">graph</span><span class="w"> </span><span class="ss">(</span><span class="nv">DAG</span><span class="ss">)</span>:
<span class="w">    </span><span class="mi">1</span><span class="w"> </span>â†â†’<span class="w"> </span><span class="mi">2</span><span class="w">                         </span><span class="nv">SCC0</span>
<span class="w">    </span>â†“<span class="w">     </span>â†“<span class="w">                          </span>â†“
<span class="w">    </span><span class="mi">4</span><span class="w"> </span>â†â†’<span class="w"> </span><span class="mi">3</span><span class="w"> </span>â†’<span class="w"> </span><span class="mi">5</span><span class="w"> </span>â†’<span class="w"> </span><span class="mi">6</span><span class="w">                 </span><span class="nv">SCC1</span><span class="w"> </span>â†’<span class="w"> </span><span class="nv">SCC2</span>
<span class="w">              </span>â†‘<span class="w">   </span>â†“
<span class="w">              </span><span class="mi">8</span><span class="w"> </span>â†<span class="w"> </span><span class="mi">7</span>

<span class="nv">SCC0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>{<span class="mi">1</span>,<span class="mi">2</span>,<span class="mi">3</span>,<span class="mi">4</span>}
<span class="nv">SCC1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>{<span class="mi">5</span>,<span class="mi">6</span>,<span class="mi">7</span>,<span class="mi">8</span>}<span class="w">  </span>â†’<span class="w"> </span><span class="nv">One</span><span class="w"> </span><span class="nv">cycle</span>
<span class="nv">SCC2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>...<span class="w"> </span><span class="ss">(</span><span class="k">if</span><span class="w"> </span><span class="nv">exists</span><span class="ss">)</span>
</code></pre></div>

<h3 id="implementation_2">Implementation<a class="header-link" href="#implementation_2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">build_condensation_graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="c1"># 1. Find SCCs</span>
    <span class="n">tarjan</span> <span class="o">=</span> <span class="n">TarjanSCC</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">tarjan</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="n">sccs</span> <span class="o">=</span> <span class="n">tarjan</span><span class="o">.</span><span class="n">find_sccs</span><span class="p">()</span>

    <span class="c1"># 2. Map each node to its SCC ID</span>
    <span class="n">scc_id</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">component</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sccs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">component</span><span class="p">:</span>
            <span class="n">scc_id</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="c1"># 3. Build condensation graph</span>
    <span class="n">num_sccs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sccs</span><span class="p">)</span>
    <span class="n">condensed</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sccs</span><span class="p">)]</span>

    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">su</span><span class="p">,</span> <span class="n">sv</span> <span class="o">=</span> <span class="n">scc_id</span><span class="p">[</span><span class="n">u</span><span class="p">],</span> <span class="n">scc_id</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">su</span> <span class="o">!=</span> <span class="n">sv</span><span class="p">:</span>
            <span class="n">condensed</span><span class="p">[</span><span class="n">su</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span>

    <span class="c1"># Convert set to list</span>
    <span class="n">condensed</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="k">for</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">condensed</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">sccs</span><span class="p">,</span> <span class="n">scc_id</span><span class="p">,</span> <span class="n">condensed</span>

<span class="c1"># Usage example</span>
<span class="n">edges</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">),</span> <span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">4</span><span class="p">)]</span>
<span class="n">sccs</span><span class="p">,</span> <span class="n">scc_id</span><span class="p">,</span> <span class="n">dag</span> <span class="o">=</span> <span class="n">build_condensation_graph</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SCCs:&quot;</span><span class="p">,</span> <span class="n">sccs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;DAG edges:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dag</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  SCC</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2"> â†’ SCC</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="applications-of-condensation-graph">Applications of Condensation Graph<a class="header-link" href="#applications-of-condensation-graph" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count_reachable_nodes</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count reachable nodes from each node</span>
<span class="sd">    Efficiently compute using DAG DP on condensation graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sccs</span><span class="p">,</span> <span class="n">scc_id</span><span class="p">,</span> <span class="n">dag</span> <span class="o">=</span> <span class="n">build_condensation_graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
    <span class="n">num_sccs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sccs</span><span class="p">)</span>

    <span class="c1"># Process in topological order</span>
    <span class="n">in_degree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_sccs</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sccs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dag</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Set of reachable nodes from each SCC</span>
    <span class="n">reachable</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">(</span><span class="n">sccs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sccs</span><span class="p">)]</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sccs</span><span class="p">)</span> <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
    <span class="n">order</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">order</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="n">dag</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>

    <span class="c1"># Propagate reachable set in reverse order</span>
    <span class="k">for</span> <span class="n">scc</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">order</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">next_scc</span> <span class="ow">in</span> <span class="n">dag</span><span class="p">[</span><span class="n">scc</span><span class="p">]:</span>
            <span class="n">reachable</span><span class="p">[</span><span class="n">scc</span><span class="p">]</span> <span class="o">|=</span> <span class="n">reachable</span><span class="p">[</span><span class="n">next_scc</span><span class="p">]</span>

    <span class="c1"># Count reachable nodes for each original node</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">reachable</span><span class="p">[</span><span class="n">scc_id</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

    <span class="k">return</span> <span class="n">result</span>
</code></pre></div>

<hr />
<h2 id="5-2-sat-problem">5. 2-SAT Problem<a class="header-link" href="#5-2-sat-problem" title="Permanent link">&para;</a></h2>
<h3 id="concept_1">Concept<a class="header-link" href="#concept_1" title="Permanent link">&para;</a></h3>
<p>2-SAT determines satisfiability of Boolean formulas where each clause has <strong>exactly 2 literals</strong>.</p>
<div class="highlight"><pre><span></span><code>Example: (xâ‚ âˆ¨ xâ‚‚) âˆ§ (Â¬xâ‚ âˆ¨ xâ‚ƒ) âˆ§ (Â¬xâ‚‚ âˆ¨ Â¬xâ‚ƒ)

Literals: xâ‚, Â¬xâ‚, xâ‚‚, Â¬xâ‚‚, xâ‚ƒ, Â¬xâ‚ƒ
Clauses: (a âˆ¨ b) form
</code></pre></div>

<h3 id="graph-transformation">Graph Transformation<a class="header-link" href="#graph-transformation" title="Permanent link">&para;</a></h3>
<p><strong>Key</strong>: (a âˆ¨ b) = (Â¬a â†’ b) âˆ§ (Â¬b â†’ a)</p>
<div class="highlight"><pre><span></span><code><span class="n">Clause</span><span class="w"> </span><span class="p">(</span><span class="n">xâ‚</span><span class="w"> </span><span class="err">âˆ¨</span><span class="w"> </span><span class="n">xâ‚‚</span><span class="p">):</span>
<span class="w">  </span><span class="err">Â¬</span><span class="n">xâ‚</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">xâ‚‚</span><span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">xâ‚</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="bp">false</span><span class="p">,</span><span class="w"> </span><span class="n">xâ‚‚</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="bp">true</span><span class="p">)</span>
<span class="w">  </span><span class="err">Â¬</span><span class="n">xâ‚‚</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">xâ‚</span><span class="w">  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">xâ‚‚</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="bp">false</span><span class="p">,</span><span class="w"> </span><span class="n">xâ‚</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="bp">true</span><span class="p">)</span>

<span class="n">For</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">xi</span><span class="p">:</span>
<span class="w">  </span><span class="n">Node</span><span class="w"> </span><span class="mi">2</span><span class="n">i</span><span class="p">:</span><span class="w"> </span><span class="n">xi</span>
<span class="w">  </span><span class="n">Node</span><span class="w"> </span><span class="mi">2</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="w"> </span><span class="err">Â¬</span><span class="n">xi</span>
</code></pre></div>

<h3 id="satisfiability-test">Satisfiability Test<a class="header-link" href="#satisfiability-test" title="Permanent link">&para;</a></h3>
<p><strong>Theorem</strong>: A 2-SAT formula is satisfiable âŸº For no variable x do x and Â¬x belong to the same SCC</p>
<h3 id="implementation_3">Implementation<a class="header-link" href="#implementation_3" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TwoSAT</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;n variables (0 ~ n-1)&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_clause</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">neg_a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">neg_b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add clause (a âˆ¨ b)</span>
<span class="sd">        a, b: variable indices (0 ~ n-1)</span>
<span class="sd">        neg_a, neg_b: True if negated</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Literal â†’ node number</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">to_node</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">negated</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">var</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">negated</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="n">node_a</span> <span class="o">=</span> <span class="n">to_node</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">neg_a</span><span class="p">)</span>
        <span class="n">node_b</span> <span class="o">=</span> <span class="n">to_node</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">neg_b</span><span class="p">)</span>
        <span class="n">not_a</span> <span class="o">=</span> <span class="n">to_node</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="ow">not</span> <span class="n">neg_a</span><span class="p">)</span>
        <span class="n">not_b</span> <span class="o">=</span> <span class="n">to_node</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="ow">not</span> <span class="n">neg_b</span><span class="p">)</span>

        <span class="c1"># Â¬a â†’ b, Â¬b â†’ a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">not_a</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">not_b</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_a</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_or</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;(a âˆ¨ b) - at least one is true&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_implies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;a â†’ b (if a then b)&quot;&quot;&quot;</span>
        <span class="c1"># a â†’ b = Â¬a âˆ¨ b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_xor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;a XOR b (exactly one is true)&quot;&quot;&quot;</span>
        <span class="c1"># (a âˆ¨ b) âˆ§ (Â¬a âˆ¨ Â¬b)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;a = b (both have same value)&quot;&quot;&quot;</span>
        <span class="c1"># (a â†’ b) âˆ§ (b â†’ a)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_implies</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_implies</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_true</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Force variable a to be true&quot;&quot;&quot;</span>
        <span class="c1"># a âˆ¨ a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_false</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Force variable a to be false&quot;&quot;&quot;</span>
        <span class="c1"># Â¬a âˆ¨ Â¬a</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return variable assignments if satisfiable, None otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find SCCs using Tarjan&#39;s algorithm</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">disc</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">low</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">on_stack</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">timer</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">scc_id</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">scc_count</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">disc</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">timer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">timer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">on_stack</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">disc</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">dfs</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
                    <span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">low</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">on_stack</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
                    <span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">disc</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">disc</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">==</span> <span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">on_stack</span><span class="p">[</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">scc_id</span><span class="p">[</span><span class="n">top</span><span class="p">]</span> <span class="o">=</span> <span class="n">scc_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">top</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="n">scc_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">disc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

        <span class="c1"># Check satisfiability</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">scc_id</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">scc_id</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># x and Â¬x in same SCC</span>

        <span class="c1"># Determine values: higher SCC ID is true</span>
        <span class="c1"># (Tarjan assigns SCC IDs in reverse topological order)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">):</span>
            <span class="c1"># x&#39;s SCC ID &gt; Â¬x&#39;s SCC ID means x = True</span>
            <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">scc_id</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">scc_id</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">result</span>

<span class="c1"># Usage example</span>
<span class="n">sat</span> <span class="o">=</span> <span class="n">TwoSAT</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Variables: x0, x1, x2</span>

<span class="c1"># (x0 âˆ¨ x1) âˆ§ (Â¬x0 âˆ¨ x2) âˆ§ (Â¬x1 âˆ¨ Â¬x2)</span>
<span class="n">sat</span><span class="o">.</span><span class="n">add_or</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>                    <span class="c1"># x0 âˆ¨ x1</span>
<span class="n">sat</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>   <span class="c1"># Â¬x0 âˆ¨ x2</span>
<span class="n">sat</span><span class="o">.</span><span class="n">add_clause</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>    <span class="c1"># Â¬x1 âˆ¨ Â¬x2</span>

<span class="n">result</span> <span class="o">=</span> <span class="n">sat</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
<span class="k">if</span> <span class="n">result</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Satisfiable:&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="c1"># Verify</span>
    <span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">result</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;x0=</span><span class="si">{</span><span class="n">x0</span><span class="si">}</span><span class="s2">, x1=</span><span class="si">{</span><span class="n">x1</span><span class="si">}</span><span class="s2">, x2=</span><span class="si">{</span><span class="n">x2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">clause1</span> <span class="o">=</span> <span class="n">x0</span> <span class="ow">or</span> <span class="n">x1</span>
    <span class="n">clause2</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">x0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x2</span>
    <span class="n">clause3</span> <span class="o">=</span> <span class="p">(</span><span class="ow">not</span> <span class="n">x1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">x2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Verification: </span><span class="si">{</span><span class="n">clause1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">clause2</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">clause3</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Unsatisfiable&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="2-sat-application-problems">2-SAT Application Problems<a class="header-link" href="#2-sat-application-problems" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">team_assignment</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">conflicts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assign n people to 2 teams</span>
<span class="sd">    conflicts[i] = (a, b): a and b cannot be on the same team</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sat</span> <span class="o">=</span> <span class="n">TwoSAT</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">conflicts</span><span class="p">:</span>
        <span class="c1"># a and b on different teams</span>
        <span class="c1"># team[a] XOR team[b] = True</span>
        <span class="n">sat</span><span class="o">.</span><span class="n">add_xor</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">sat</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">team1</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">team2</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">result</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">team1</span><span class="p">,</span> <span class="n">team2</span>

<span class="c1"># Example: 0-1 conflict, 1-2 conflict</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">team_assignment</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># ([0, 2], [1]) or ([1], [0, 2])</span>
</code></pre></div>

<hr />
<h2 id="6-practical-problem-patterns">6. Practical Problem Patterns<a class="header-link" href="#6-practical-problem-patterns" title="Permanent link">&para;</a></h2>
<h3 id="pattern-1-count-sccs">Pattern 1: Count SCCs<a class="header-link" href="#pattern-1-count-sccs" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">count_sccs</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
    <span class="n">tarjan</span> <span class="o">=</span> <span class="n">TarjanSCC</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">tarjan</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">tarjan</span><span class="o">.</span><span class="n">find_sccs</span><span class="p">())</span>
</code></pre></div>

<h3 id="pattern-2-universal-source">Pattern 2: Universal Source<a class="header-link" href="#pattern-2-universal-source" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_universal_source</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Is there a starting point that can reach all nodes?</span>
<span class="sd">    Possible if there&#39;s exactly 1 SCC with in-degree 0 in condensation graph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sccs</span><span class="p">,</span> <span class="n">scc_id</span><span class="p">,</span> <span class="n">dag</span> <span class="o">=</span> <span class="n">build_condensation_graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
    <span class="n">num_sccs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sccs</span><span class="p">)</span>

    <span class="n">in_degree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_sccs</span>
    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sccs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dag</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">sources</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sccs</span><span class="p">)</span> <span class="k">if</span> <span class="n">in_degree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sources</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Return any node from this SCC</span>
        <span class="k">return</span> <span class="n">sccs</span><span class="p">[</span><span class="n">sources</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</code></pre></div>

<h3 id="pattern-3-minimum-edges-to-make-strongly-connected">Pattern 3: Minimum Edges to Make Strongly Connected<a class="header-link" href="#pattern-3-minimum-edges-to-make-strongly-connected" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">min_edges_to_strongly_connect</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Minimum edges to add to make entire graph one SCC</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">sccs</span><span class="p">,</span> <span class="n">scc_id</span><span class="p">,</span> <span class="n">dag</span> <span class="o">=</span> <span class="n">build_condensation_graph</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
    <span class="n">num_sccs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sccs</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">num_sccs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">in_degree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_sccs</span>
    <span class="n">out_degree</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_sccs</span>

    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sccs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">dag</span><span class="p">[</span><span class="n">u</span><span class="p">]:</span>
            <span class="n">out_degree</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">in_degree</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">sources</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">in_degree</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># In-degree 0</span>
    <span class="n">sinks</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">out_degree</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>   <span class="c1"># Out-degree 0</span>

    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="n">sources</span><span class="p">,</span> <span class="n">sinks</span><span class="p">)</span>
</code></pre></div>

<h3 id="pattern-4-nodes-in-cycles">Pattern 4: Nodes in Cycles<a class="header-link" href="#pattern-4-nodes-in-cycles" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">nodes_in_cycles</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">edges</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find all nodes that are part of cycles&quot;&quot;&quot;</span>
    <span class="n">tarjan</span> <span class="o">=</span> <span class="n">TarjanSCC</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
        <span class="n">tarjan</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="n">sccs</span> <span class="o">=</span> <span class="n">tarjan</span><span class="o">.</span><span class="n">find_sccs</span><span class="p">()</span>

    <span class="c1"># Nodes in SCCs with size â‰¥ 2</span>
    <span class="n">cycle_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">sccs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">cycle_nodes</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">component</span><span class="p">)</span>

    <span class="c1"># Size-1 SCCs with self-loop also form cycles</span>
    <span class="n">edge_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">sccs</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">component</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">component</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="ow">in</span> <span class="n">edge_set</span><span class="p">:</span>
                <span class="n">cycle_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cycle_nodes</span>
</code></pre></div>

<hr />
<h2 id="7-time-complexity-summary">7. Time Complexity Summary<a class="header-link" href="#7-time-complexity-summary" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Operation</th>
<th>Kosaraju</th>
<th>Tarjan</th>
</tr>
</thead>
<tbody>
<tr>
<td>Find SCCs</td>
<td>O(V + E)</td>
<td>O(V + E)</td>
</tr>
<tr>
<td>Condensation graph</td>
<td>O(V + E)</td>
<td>O(V + E)</td>
</tr>
<tr>
<td>2-SAT</td>
<td>-</td>
<td>O(V + E)</td>
</tr>
<tr>
<td>Space</td>
<td>O(V + E) Ã— 2</td>
<td>O(V + E)</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="8-common-mistakes">8. Common Mistakes<a class="header-link" href="#8-common-mistakes" title="Permanent link">&para;</a></h2>
<h3 id="mistake-1-missing-on_stack-check">Mistake 1: Missing on_stack Check<a class="header-link" href="#mistake-1-missing-on_stack-check" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># Wrong code</span>
<span class="k">if</span> <span class="n">disc</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
    <span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">disc</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span>

<span class="c1"># Correct code</span>
<span class="k">if</span> <span class="n">disc</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">on_stack</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]:</span>
    <span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">low</span><span class="p">[</span><span class="n">node</span><span class="p">],</span> <span class="n">disc</span><span class="p">[</span><span class="n">neighbor</span><span class="p">])</span>
</code></pre></div>

<h3 id="mistake-2-2-sat-node-number-calculation-error">Mistake 2: 2-SAT Node Number Calculation Error<a class="header-link" href="#mistake-2-2-sat-node-number-calculation-error" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># For variable i:</span>
<span class="c1"># - i itself: 2*i</span>
<span class="c1"># - Â¬i: 2*i + 1</span>

<span class="c1"># Wrong negation</span>
<span class="k">def</span><span class="w"> </span><span class="nf">negate</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">node</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># Wrong!</span>

<span class="c1"># Correct negation</span>
<span class="k">def</span><span class="w"> </span><span class="nf">negate</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">node</span> <span class="o">^</span> <span class="mi">1</span>  <span class="c1"># XOR to toggle 0â†”1</span>
</code></pre></div>

<h3 id="mistake-3-duplicate-edges-in-condensation-graph">Mistake 3: Duplicate Edges in Condensation Graph<a class="header-link" href="#mistake-3-duplicate-edges-in-condensation-graph" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># Duplicate edges possible</span>
<span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">scc_id</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">scc_id</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
        <span class="n">condensed</span><span class="p">[</span><span class="n">scc_id</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">scc_id</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>  <span class="c1"># Duplicates!</span>

<span class="c1"># Fix with set</span>
<span class="n">condensed</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sccs</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">scc_id</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">!=</span> <span class="n">scc_id</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
        <span class="n">condensed</span><span class="p">[</span><span class="n">scc_id</span><span class="p">[</span><span class="n">u</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">scc_id</span><span class="p">[</span><span class="n">v</span><span class="p">])</span>
</code></pre></div>

<hr />
<h2 id="9-practice-problems">9. Practice Problems<a class="header-link" href="#9-practice-problems" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Difficulty</th>
<th>Problem Type</th>
<th>Key Concepts</th>
</tr>
</thead>
<tbody>
<tr>
<td>â˜…â˜…â˜†</td>
<td>Count SCCs</td>
<td>Basic Tarjan/Kosaraju</td>
</tr>
<tr>
<td>â˜…â˜…â˜†</td>
<td>Domino</td>
<td>SCC + DAG analysis</td>
</tr>
<tr>
<td>â˜…â˜…â˜…</td>
<td>2-SAT basic</td>
<td>Graph transformation + SCC</td>
</tr>
<tr>
<td>â˜…â˜…â˜…</td>
<td>Team assignment</td>
<td>2-SAT application</td>
</tr>
<tr>
<td>â˜…â˜…â˜…â˜…</td>
<td>Minimum edge addition</td>
<td>Condensation graph utilization</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="next-steps">Next Steps<a class="header-link" href="#next-steps" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="./18_Dynamic_Programming.md">18_Dynamic_Programming.md</a> - Dynamic Programming, Memoization</li>
</ul>
<hr />
<h2 id="learning-checklist">Learning Checklist<a class="header-link" href="#learning-checklist" title="Permanent link">&para;</a></h2>
<ol>
<li>What is the meaning of low-link value in Tarjan's algorithm?</li>
<li>How do you transform (a âˆ¨ b) into a graph in 2-SAT?</li>
<li>Why is the condensation graph always a DAG?</li>
<li>Why does Kosaraju use the reversed graph?</li>
</ol>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Algorithm/16_LCA_and_Tree_Queries.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">26. LCA and Tree Queries</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Algorithm/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Algorithm/18_Dynamic_Programming.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Dynamic Programming</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">â†‘</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}