{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 2: Lexical Analysis - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Lesson 2: Lexical Analysis</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 2: Lexical Analysis</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/01_Introduction_to_Compilers.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 1: Introduction to Compilers</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/03_Finite_Automata.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 3: Finite Automata</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#learning-objectives">Learning Objectives</a></li>
<li><a href="#1-the-role-of-the-lexer">1. The Role of the Lexer</a><ul>
<li><a href="#why-separate-lexical-analysis">Why Separate Lexical Analysis?</a></li>
<li><a href="#what-the-lexer-does">What the Lexer Does</a></li>
<li><a href="#what-the-lexer-does-not-do">What the Lexer Does NOT Do</a></li>
</ul>
</li>
<li><a href="#2-tokens-lexemes-and-patterns">2. Tokens, Lexemes, and Patterns</a><ul>
<li><a href="#token">Token</a></li>
<li><a href="#lexeme">Lexeme</a></li>
<li><a href="#pattern">Pattern</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#token-data-structure">Token Data Structure</a></li>
</ul>
</li>
<li><a href="#3-regular-expressions-formal-definition">3. Regular Expressions -- Formal Definition</a><ul>
<li><a href="#alphabet-and-strings">Alphabet and Strings</a></li>
<li><a href="#language">Language</a></li>
<li><a href="#regular-expression-definition">Regular Expression Definition</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#convenient-shorthands">Convenient Shorthands</a></li>
<li><a href="#token-patterns-as-regular-expressions">Token Patterns as Regular Expressions</a></li>
<li><a href="#algebraic-laws-of-regular-expressions">Algebraic Laws of Regular Expressions</a></li>
</ul>
</li>
<li><a href="#4-from-regular-expressions-to-nfa-thompsons-construction">4. From Regular Expressions to NFA: Thompson's Construction</a><ul>
<li><a href="#nfa-definition-brief">NFA Definition (Brief)</a></li>
<li><a href="#construction-rules">Construction Rules</a></li>
<li><a href="#properties-of-thompsons-construction">Properties of Thompson's Construction</a></li>
<li><a href="#python-implementation">Python Implementation</a></li>
</ul>
</li>
<li><a href="#5-from-nfa-to-dfa-subset-construction">5. From NFA to DFA: Subset Construction</a><ul>
<li><a href="#algorithm">Algorithm</a></li>
<li><a href="#complexity">Complexity</a></li>
<li><a href="#python-implementation_1">Python Implementation</a></li>
</ul>
</li>
<li><a href="#6-dfa-minimization-hopcrofts-algorithm">6. DFA Minimization: Hopcroft's Algorithm</a><ul>
<li><a href="#equivalent-states">Equivalent States</a></li>
<li><a href="#hopcrofts-algorithm-partition-refinement">Hopcroft's Algorithm (Partition Refinement)</a></li>
<li><a href="#python-implementation_2">Python Implementation</a></li>
</ul>
</li>
<li><a href="#7-token-recognition">7. Token Recognition</a><ul>
<li><a href="#the-longest-match-rule">The Longest Match Rule</a></li>
<li><a href="#priority-rule">Priority Rule</a></li>
<li><a href="#combined-dfa-approach">Combined DFA Approach</a></li>
<li><a href="#implementing-the-longest-match">Implementing the Longest Match</a></li>
<li><a href="#error-recovery-in-lexers">Error Recovery in Lexers</a></li>
</ul>
</li>
<li><a href="#8-a-complete-lexer-implementation">8. A Complete Lexer Implementation</a></li>
<li><a href="#9-lexer-generator-specification">9. Lexer Generator Specification</a><ul>
<li><a href="#lexflex-specification-format">Lex/Flex Specification Format</a></li>
<li><a href="#ply-python-lex-yacc-specification">PLY (Python Lex-Yacc) Specification</a></li>
</ul>
</li>
<li><a href="#10-handling-special-cases">10. Handling Special Cases</a><ul>
<li><a href="#string-literals-with-escapes">String Literals with Escapes</a></li>
<li><a href="#multi-line-strings">Multi-Line Strings</a></li>
<li><a href="#nested-comments">Nested Comments</a></li>
<li><a href="#significant-whitespace-python-style-indentation">Significant Whitespace (Python-style Indentation)</a></li>
</ul>
</li>
<li><a href="#11-performance-considerations">11. Performance Considerations</a><ul>
<li><a href="#table-driven-vs-direct-coded-lexers">Table-Driven vs. Direct-Coded Lexers</a></li>
<li><a href="#buffer-management">Buffer Management</a></li>
</ul>
</li>
<li><a href="#summary">Summary</a></li>
<li><a href="#exercises">Exercises</a><ul>
<li><a href="#exercise-1-regular-expressions">Exercise 1: Regular Expressions</a></li>
<li><a href="#exercise-2-thompsons-construction">Exercise 2: Thompson's Construction</a></li>
<li><a href="#exercise-3-subset-construction">Exercise 3: Subset Construction</a></li>
<li><a href="#exercise-4-lexer-extension">Exercise 4: Lexer Extension</a></li>
<li><a href="#exercise-5-error-recovery">Exercise 5: Error Recovery</a></li>
<li><a href="#exercise-6-performance-comparison">Exercise 6: Performance Comparison</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-2-lexical-analysis">Lesson 2: Lexical Analysis<a class="header-link" href="#lesson-2-lexical-analysis" title="Permanent link">&para;</a></h1>
<h2 id="learning-objectives">Learning Objectives<a class="header-link" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<p>After completing this lesson, you will be able to:</p>
<ol>
<li>Explain the role of the lexer (scanner) in the compilation pipeline</li>
<li>Distinguish between tokens, lexemes, and patterns</li>
<li>Define regular expressions formally and use them to specify token patterns</li>
<li>Apply Thompson's construction to convert a regular expression to an NFA</li>
<li>Apply the subset construction to convert an NFA to a DFA</li>
<li>Apply Hopcroft's algorithm to minimize a DFA</li>
<li>Implement the longest-match rule and handle token priorities</li>
<li>Build a complete lexer for a simple programming language in Python</li>
</ol>
<hr />
<h2 id="1-the-role-of-the-lexer">1. The Role of the Lexer<a class="header-link" href="#1-the-role-of-the-lexer" title="Permanent link">&para;</a></h2>
<p>The <strong>lexer</strong> (also called <strong>scanner</strong> or <strong>tokenizer</strong>) is the first phase of a compiler. It reads the source program as a stream of characters and groups them into meaningful sequences called <strong>tokens</strong>.</p>
<div class="highlight"><pre><span></span><code><span class="nt">Source</span><span class="w"> </span><span class="nt">characters</span><span class="o">:</span><span class="w">          </span><span class="s2">&quot;if (x &gt;= 42) return y + 1;&quot;</span>
<span class="w">                                    </span><span class="o">|</span>
<span class="w">                            </span><span class="cp">[</span><span class="nx">Lexer</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="nx">Scanner</span><span class="cp">]</span>
<span class="w">                                    </span><span class="o">|</span>
<span class="w">                                    </span><span class="nt">v</span>
<span class="nt">Token</span><span class="w"> </span><span class="nt">stream</span><span class="o">:</span><span class="w">               </span><span class="nt">KW_IF</span><span class="w">  </span><span class="nt">LPAREN</span><span class="w">  </span><span class="nt">ID</span><span class="o">(</span><span class="nt">x</span><span class="o">)</span><span class="w">  </span><span class="nt">GEQ</span><span class="w">  </span><span class="nt">INT</span><span class="o">(</span><span class="nt">42</span><span class="o">)</span><span class="w">  </span><span class="nt">RPAREN</span>
<span class="w">                            </span><span class="nt">KW_RETURN</span><span class="w">  </span><span class="nt">ID</span><span class="o">(</span><span class="nt">y</span><span class="o">)</span><span class="w">  </span><span class="nt">PLUS</span><span class="w">  </span><span class="nt">INT</span><span class="o">(</span><span class="nt">1</span><span class="o">)</span><span class="w">  </span><span class="nt">SEMI</span>
</code></pre></div>

<h3 id="why-separate-lexical-analysis">Why Separate Lexical Analysis?<a class="header-link" href="#why-separate-lexical-analysis" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p><strong>Simplicity</strong>: The parser operates on tokens (a finite, structured alphabet) rather than raw characters. This drastically simplifies the grammar.</p>
</li>
<li>
<p><strong>Efficiency</strong>: Lexical patterns (identifiers, numbers, strings) are regular and can be recognized by finite automata -- much faster than context-free parsing.</p>
</li>
<li>
<p><strong>Portability</strong>: Character-set issues (ASCII, UTF-8, line endings) are confined to the lexer.</p>
</li>
<li>
<p><strong>Modularity</strong>: The lexer and parser can be developed independently. Different source encodings require changes only in the lexer.</p>
</li>
</ol>
<h3 id="what-the-lexer-does">What the Lexer Does<a class="header-link" href="#what-the-lexer-does" title="Permanent link">&para;</a></h3>
<ul>
<li>Groups characters into tokens</li>
<li>Strips whitespace and comments</li>
<li>Handles line counting (for error messages)</li>
<li>Recognizes keywords vs. identifiers</li>
<li>Handles string and character literal escaping</li>
<li>Reports lexical errors (illegal characters, unterminated strings)</li>
</ul>
<h3 id="what-the-lexer-does-not-do">What the Lexer Does NOT Do<a class="header-link" href="#what-the-lexer-does-not-do" title="Permanent link">&para;</a></h3>
<ul>
<li>Check syntax (that is the parser's job)</li>
<li>Check types (that is the semantic analyzer's job)</li>
<li>Handle operator precedence (that is the parser's job)</li>
</ul>
<hr />
<h2 id="2-tokens-lexemes-and-patterns">2. Tokens, Lexemes, and Patterns<a class="header-link" href="#2-tokens-lexemes-and-patterns" title="Permanent link">&para;</a></h2>
<p>Three related but distinct concepts:</p>
<h3 id="token">Token<a class="header-link" href="#token" title="Permanent link">&para;</a></h3>
<p>A <strong>token</strong> is an abstract symbol representing a class of lexical units. It is the output of the lexer and the input to the parser.</p>
<p>A token typically has:
- A <strong>token type</strong> (or token name): <code>ID</code>, <code>INT</code>, <code>PLUS</code>, <code>KW_IF</code>, etc.
- An optional <strong>attribute value</strong>: the actual text, numeric value, or symbol table pointer</p>
<h3 id="lexeme">Lexeme<a class="header-link" href="#lexeme" title="Permanent link">&para;</a></h3>
<p>A <strong>lexeme</strong> is the actual substring of the source program that matches a token pattern.</p>
<h3 id="pattern">Pattern<a class="header-link" href="#pattern" title="Permanent link">&para;</a></h3>
<p>A <strong>pattern</strong> is a rule (usually a regular expression) that describes the set of lexemes belonging to a token type.</p>
<h3 id="example">Example<a class="header-link" href="#example" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Token Type</th>
<th>Pattern (informal)</th>
<th>Example Lexemes</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ID</code></td>
<td>Letter followed by letters/digits</td>
<td><code>x</code>, <code>count</code>, <code>myVar</code></td>
</tr>
<tr>
<td><code>INT</code></td>
<td>One or more digits</td>
<td><code>0</code>, <code>42</code>, <code>1000</code></td>
</tr>
<tr>
<td><code>FLOAT</code></td>
<td>Digits, dot, digits</td>
<td><code>3.14</code>, <code>0.001</code></td>
</tr>
<tr>
<td><code>STRING</code></td>
<td><code>"</code> ... <code>"</code></td>
<td><code>"hello"</code>, <code>""</code></td>
</tr>
<tr>
<td><code>KW_IF</code></td>
<td><code>if</code></td>
<td><code>if</code></td>
</tr>
<tr>
<td><code>KW_WHILE</code></td>
<td><code>while</code></td>
<td><code>while</code></td>
</tr>
<tr>
<td><code>PLUS</code></td>
<td><code>+</code></td>
<td><code>+</code></td>
</tr>
<tr>
<td><code>GEQ</code></td>
<td><code>&gt;=</code></td>
<td><code>&gt;=</code></td>
</tr>
<tr>
<td><code>ASSIGN</code></td>
<td><code>=</code></td>
<td><code>=</code></td>
</tr>
<tr>
<td><code>LPAREN</code></td>
<td><code>(</code></td>
<td><code>(</code></td>
</tr>
<tr>
<td><code>SEMI</code></td>
<td><code>;</code></td>
<td><code>;</code></td>
</tr>
</tbody>
</table>
<h3 id="token-data-structure">Token Data Structure<a class="header-link" href="#token-data-structure" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TokenType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="c1"># Literals</span>
    <span class="n">INT_LIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">FLOAT_LIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">STRING_LIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">CHAR_LIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

    <span class="c1"># Identifiers</span>
    <span class="n">IDENTIFIER</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

    <span class="c1"># Keywords</span>
    <span class="n">KW_IF</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_ELSE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_WHILE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_FOR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_RETURN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_INT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_FLOAT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_VOID</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

    <span class="c1"># Operators</span>
    <span class="n">PLUS</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>       <span class="c1"># +</span>
    <span class="n">MINUS</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>      <span class="c1"># -</span>
    <span class="n">STAR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>       <span class="c1"># *</span>
    <span class="n">SLASH</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>      <span class="c1"># /</span>
    <span class="n">ASSIGN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>     <span class="c1"># =</span>
    <span class="n">EQ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>         <span class="c1"># ==</span>
    <span class="n">NEQ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># !=</span>
    <span class="n">LT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>         <span class="c1"># &lt;</span>
    <span class="n">GT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>         <span class="c1"># &gt;</span>
    <span class="n">LEQ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># &lt;=</span>
    <span class="n">GEQ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># &gt;=</span>
    <span class="n">AND</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># &amp;&amp;</span>
    <span class="n">OR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>         <span class="c1"># ||</span>
    <span class="n">NOT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># !</span>

    <span class="c1"># Delimiters</span>
    <span class="n">LPAREN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>     <span class="c1"># (</span>
    <span class="n">RPAREN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>     <span class="c1"># )</span>
    <span class="n">LBRACE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>     <span class="c1"># {</span>
    <span class="n">RBRACE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>     <span class="c1"># }</span>
    <span class="n">LBRACKET</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   <span class="c1"># [</span>
    <span class="n">RBRACKET</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   <span class="c1"># ]</span>
    <span class="n">COMMA</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>      <span class="c1"># ,</span>
    <span class="n">SEMI</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>       <span class="c1"># ;</span>

    <span class="c1"># Special</span>
    <span class="n">EOF</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">ERROR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Token</span><span class="p">:</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">TokenType</span>
    <span class="n">lexeme</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>      <span class="c1"># Computed value (e.g., int 42, not string &quot;42&quot;)</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">column</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Token(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lexeme</span><span class="si">!r}</span><span class="s2">, value=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Token(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lexeme</span><span class="si">!r}</span><span class="s2">)&quot;</span>
</code></pre></div>

<hr />
<h2 id="3-regular-expressions-formal-definition">3. Regular Expressions -- Formal Definition<a class="header-link" href="#3-regular-expressions-formal-definition" title="Permanent link">&para;</a></h2>
<p>Token patterns are specified using <strong>regular expressions</strong> (regex). Here we define them formally, as used in compiler theory -- not the extended regex syntax of tools like Python's <code>re</code> module.</p>
<h3 id="alphabet-and-strings">Alphabet and Strings<a class="header-link" href="#alphabet-and-strings" title="Permanent link">&para;</a></h3>
<ul>
<li>An <strong>alphabet</strong> $\Sigma$ is a finite, nonempty set of symbols (characters).</li>
<li>A <strong>string</strong> over $\Sigma$ is a finite sequence of symbols from $\Sigma$.</li>
<li>The <strong>empty string</strong> is denoted $\epsilon$ (epsilon).</li>
<li>The <strong>length</strong> of string $w$ is $|w|$. We have $|\epsilon| = 0$.</li>
<li>$\Sigma^*$ denotes the set of all strings over $\Sigma$ (including $\epsilon$).</li>
<li>$\Sigma^+ = \Sigma^* \setminus \{\epsilon\}$ is the set of all nonempty strings.</li>
</ul>
<h3 id="language">Language<a class="header-link" href="#language" title="Permanent link">&para;</a></h3>
<p>A <strong>language</strong> $L$ over $\Sigma$ is any subset of $\Sigma^*$ -- that is, any set of strings.</p>
<h3 id="regular-expression-definition">Regular Expression Definition<a class="header-link" href="#regular-expression-definition" title="Permanent link">&para;</a></h3>
<p>A regular expression $r$ over alphabet $\Sigma$ is defined inductively:</p>
<p><strong>Base cases:</strong></p>
<ol>
<li>$\epsilon$ is a regular expression denoting the language $\{\epsilon\}$</li>
<li>For each $a \in \Sigma$, the symbol $a$ is a regular expression denoting $\{a\}$</li>
</ol>
<p><strong>Inductive cases (if $r$ and $s$ are regular expressions denoting $L(r)$ and $L(s)$):</strong></p>
<ol>
<li><strong>Union (alternation)</strong>: $r \mid s$ denotes $L(r) \cup L(s)$</li>
<li><strong>Concatenation</strong>: $r \cdot s$ (or simply $rs$) denotes $L(r) \cdot L(s) = \{xy \mid x \in L(r), y \in L(s)\}$</li>
<li><strong>Kleene star (closure)</strong>: $r^*$ denotes $L(r)^* = \bigcup_{i=0}^{\infty} L(r)^i$</li>
</ol>
<p>where $L^0 = \{\epsilon\}$ and $L^{i+1} = L^i \cdot L$.</p>
<p><strong>Operator precedence</strong> (highest to lowest):
1. Kleene star $*$ (postfix, binds tightest)
2. Concatenation (implicit, juxtaposition)
3. Union $\mid$ (binds loosest)</p>
<p>All operators are left-associative.</p>
<h3 id="examples">Examples<a class="header-link" href="#examples" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Regex</th>
<th>Language</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>$a$</td>
<td>$\{a\}$</td>
<td>Just the string "a"</td>
</tr>
<tr>
<td>$a \mid b$</td>
<td>$\{a, b\}$</td>
<td>Either "a" or "b"</td>
</tr>
<tr>
<td>$ab$</td>
<td>$\{ab\}$</td>
<td>The string "ab"</td>
</tr>
<tr>
<td>$a^*$</td>
<td>$\{\epsilon, a, aa, aaa, \ldots\}$</td>
<td>Zero or more a's</td>
</tr>
<tr>
<td>$(a \mid b)^*$</td>
<td>All strings over $\{a, b\}$</td>
<td>Any combination of a's and b's</td>
</tr>
<tr>
<td>$a(a \mid b)^*$</td>
<td>Strings over $\{a,b\}$ starting with $a$</td>
<td>Starts with a</td>
</tr>
<tr>
<td>$(0 \mid 1)^* 0$</td>
<td>Binary strings ending in 0</td>
<td>Even binary numbers</td>
</tr>
</tbody>
</table>
<h3 id="convenient-shorthands">Convenient Shorthands<a class="header-link" href="#convenient-shorthands" title="Permanent link">&para;</a></h3>
<p>These are not part of the formal definition but are commonly used:</p>
<table>
<thead>
<tr>
<th>Shorthand</th>
<th>Meaning</th>
<th>Formal equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td>$r^+$</td>
<td>One or more</td>
<td>$rr^*$</td>
</tr>
<tr>
<td>$r?$</td>
<td>Zero or one</td>
<td>$r \mid \epsilon$</td>
</tr>
<tr>
<td>$[a\text{-}z]$</td>
<td>Character class</td>
<td>$a \mid b \mid \cdots \mid z$</td>
</tr>
<tr>
<td>$[0\text{-}9]$</td>
<td>Digit</td>
<td>$0 \mid 1 \mid \cdots \mid 9$</td>
</tr>
<tr>
<td>$.$</td>
<td>Any character</td>
<td>$\Sigma$ (union of all)</td>
</tr>
<tr>
<td>$r\{n\}$</td>
<td>Exactly $n$ copies</td>
<td>$\underbrace{rr\cdots r}_{n}$</td>
</tr>
</tbody>
</table>
<h3 id="token-patterns-as-regular-expressions">Token Patterns as Regular Expressions<a class="header-link" href="#token-patterns-as-regular-expressions" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="nl">Identifier</span><span class="p">:</span><span class="w">  </span><span class="o">[</span><span class="n">a-zA-Z_</span><span class="o">][</span><span class="n">a-zA-Z0-9_</span><span class="o">]*</span>
<span class="k">Integer</span><span class="err">:</span><span class="w">     </span><span class="o">[</span><span class="n">0-9</span><span class="o">]+</span>
<span class="nc">Float</span><span class="err">:</span><span class="w">       </span><span class="o">[</span><span class="n">0-9</span><span class="o">]+</span><span class="err">\</span><span class="p">.</span><span class="o">[</span><span class="n">0-9</span><span class="o">]+</span><span class="p">(</span><span class="o">[</span><span class="n">eE</span><span class="o">][</span><span class="n">+-</span><span class="o">]</span><span class="vm">?</span><span class="o">[</span><span class="n">0-9</span><span class="o">]+</span><span class="p">)</span><span class="vm">?</span>
<span class="nl">String</span><span class="p">:</span><span class="w">      </span><span class="ss">&quot;[^&quot;</span><span class="err">\\]</span><span class="o">*</span><span class="p">(</span><span class="err">\\</span><span class="p">.</span><span class="o">[</span><span class="n">^&quot;\\</span><span class="o">]*</span><span class="p">)</span><span class="o">*</span><span class="err">&quot;</span>
<span class="nl">Comment</span><span class="p">:</span><span class="w">     </span><span class="o">//[</span><span class="n">^\n</span><span class="o">]*</span>
<span class="nl">Whitespace</span><span class="p">:</span><span class="w">  </span><span class="o">[</span><span class="n"> \t\n\r</span><span class="o">]+</span>
</code></pre></div>

<h3 id="algebraic-laws-of-regular-expressions">Algebraic Laws of Regular Expressions<a class="header-link" href="#algebraic-laws-of-regular-expressions" title="Permanent link">&para;</a></h3>
<p>Regular expressions obey the following identities (useful for simplification):</p>
<table>
<thead>
<tr>
<th>Law</th>
<th>Statement</th>
</tr>
</thead>
<tbody>
<tr>
<td>Union is commutative</td>
<td>$r \mid s = s \mid r$</td>
</tr>
<tr>
<td>Union is associative</td>
<td>$(r \mid s) \mid t = r \mid (s \mid t)$</td>
</tr>
<tr>
<td>Concatenation is associative</td>
<td>$(rs)t = r(st)$</td>
</tr>
<tr>
<td>Concatenation distributes over union</td>
<td>$r(s \mid t) = rs \mid rt$</td>
</tr>
<tr>
<td>$\epsilon$ is identity for concatenation</td>
<td>$\epsilon r = r\epsilon = r$</td>
</tr>
<tr>
<td>$\emptyset$ is identity for union</td>
<td>$r \mid \emptyset = r$</td>
</tr>
<tr>
<td>$\emptyset$ is zero for concatenation</td>
<td>$\emptyset r = r\emptyset = \emptyset$</td>
</tr>
<tr>
<td>Star idempotence</td>
<td>$(r^*)^* = r^*$</td>
</tr>
<tr>
<td>Star of epsilon</td>
<td>$\epsilon^* = \epsilon$</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="4-from-regular-expressions-to-nfa-thompsons-construction">4. From Regular Expressions to NFA: Thompson's Construction<a class="header-link" href="#4-from-regular-expressions-to-nfa-thompsons-construction" title="Permanent link">&para;</a></h2>
<p><strong>Thompson's construction</strong> (Ken Thompson, 1968) converts a regular expression into an equivalent NFA (nondeterministic finite automaton) with $\epsilon$-transitions.</p>
<h3 id="nfa-definition-brief">NFA Definition (Brief)<a class="header-link" href="#nfa-definition-brief" title="Permanent link">&para;</a></h3>
<p>An NFA is a 5-tuple $(Q, \Sigma, \delta, q_0, F)$ where:
- $Q$ is a finite set of states
- $\Sigma$ is the input alphabet
- $\delta: Q \times (\Sigma \cup \{\epsilon\}) \rightarrow \mathcal{P}(Q)$ is the transition function
- $q_0 \in Q$ is the start state
- $F \subseteq Q$ is the set of accept states</p>
<h3 id="construction-rules">Construction Rules<a class="header-link" href="#construction-rules" title="Permanent link">&para;</a></h3>
<p>Each rule produces an NFA with exactly <strong>one start state</strong> and <strong>one accept state</strong>. No transitions enter the start state or leave the accept state.</p>
<p><strong>Base case 1: Empty string $\epsilon$</strong></p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="o">--&gt;</span><span class="p">(</span><span class="n">q0</span><span class="p">)</span><span class="o">---</span><span class="err">Œµ</span><span class="o">---&gt;</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span>
<span class="w">     </span><span class="n">start</span><span class="w">       </span><span class="n">accept</span>
</code></pre></div>

<p><strong>Base case 2: Single symbol $a$</strong></p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="o">--&gt;</span><span class="p">(</span><span class="n">q0</span><span class="p">)</span><span class="o">---</span><span class="n">a</span><span class="o">---&gt;</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span>
<span class="w">     </span><span class="n">start</span><span class="w">       </span><span class="n">accept</span>
</code></pre></div>

<p><strong>Inductive case 1: Union $r \mid s$</strong></p>
<p>Given NFAs $N(r)$ with states $(r_0, r_f)$ and $N(s)$ with states $(s_0, s_f)$:</p>
<div class="highlight"><pre><span></span><code><span class="w">              </span><span class="err">Œµ</span><span class="w"> </span><span class="o">---&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">N</span><span class="p">(</span><span class="n">r</span><span class="p">)]</span><span class="w"> </span><span class="o">---</span><span class="err">Œµ</span><span class="o">---&gt;</span>
<span class="w">            </span><span class="o">/</span><span class="w">                        </span><span class="err">\</span>
<span class="w">  </span><span class="o">--&gt;</span><span class="p">(</span><span class="n">q0</span><span class="p">)</span><span class="w">                              </span><span class="p">(</span><span class="n">q_f</span><span class="p">)</span>
<span class="w">            </span><span class="err">\</span><span class="w">                        </span><span class="o">/</span>
<span class="w">              </span><span class="err">Œµ</span><span class="w"> </span><span class="o">---&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">N</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span><span class="w"> </span><span class="o">---</span><span class="err">Œµ</span><span class="o">---&gt;</span>
<span class="w">     </span><span class="n">start</span><span class="w">                          </span><span class="n">accept</span>
</code></pre></div>

<p><strong>Inductive case 2: Concatenation $rs$</strong></p>
<p>Merge the accept state of $N(r)$ with the start state of $N(s)$:</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="o">--&gt;</span><span class="p">(</span><span class="n">r0</span><span class="p">)</span><span class="o">---</span><span class="p">[</span><span class="n">N</span><span class="p">(</span><span class="n">r</span><span class="p">)]</span><span class="o">---&gt;</span><span class="p">(</span><span class="n">r_f</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s_0</span><span class="p">)</span><span class="o">---</span><span class="p">[</span><span class="n">N</span><span class="p">(</span><span class="n">s</span><span class="p">)]</span><span class="o">---&gt;</span><span class="p">(</span><span class="n">s_f</span><span class="p">)</span>
<span class="w">     </span><span class="n">start</span><span class="w">                                     </span><span class="n">accept</span>
</code></pre></div>

<p><strong>Inductive case 3: Kleene star $r^*$</strong></p>
<div class="highlight"><pre><span></span><code><span class="w">              </span><span class="err">Œµ</span><span class="w"> </span><span class="o">---&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">N</span><span class="p">(</span><span class="n">r</span><span class="p">)]</span><span class="w"> </span><span class="o">---</span><span class="err">Œµ</span><span class="o">---&gt;</span>
<span class="w">            </span><span class="o">/</span><span class="w">           </span><span class="o">|</span><span class="w">            </span><span class="err">\</span>
<span class="w">  </span><span class="o">--&gt;</span><span class="p">(</span><span class="n">q0</span><span class="p">)</span><span class="w">     </span><span class="o">&lt;---</span><span class="err">Œµ</span><span class="o">-----+</span><span class="w">             </span><span class="p">(</span><span class="n">q_f</span><span class="p">)</span>
<span class="w">            </span><span class="err">\</span><span class="w">                        </span><span class="o">/</span>
<span class="w">              </span><span class="o">----------</span><span class="err">Œµ</span><span class="o">----------&gt;</span>
<span class="w">     </span><span class="n">start</span><span class="w">                          </span><span class="n">accept</span>
</code></pre></div>

<h3 id="properties-of-thompsons-construction">Properties of Thompson's Construction<a class="header-link" href="#properties-of-thompsons-construction" title="Permanent link">&para;</a></h3>
<ol>
<li>The resulting NFA has at most $2n$ states for a regex of length $n$</li>
<li>Each state has at most two outgoing transitions</li>
<li>The NFA has exactly one start state and one accept state</li>
<li>Construction is linear in the size of the regex: $O(n)$</li>
</ol>
<h3 id="python-implementation">Python Implementation<a class="header-link" href="#python-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NFAState</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A state in an NFA.&quot;&quot;&quot;</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">is_accept</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">transitions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;NFAState&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_transition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s1">&#39;NFAState&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a transition on symbol (use &#39;Œµ&#39; for epsilon).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">symbol</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">NFAState</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">id</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot; (accept)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_accept</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;q</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">NFA</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Nondeterministic Finite Automaton.&quot;&quot;&quot;</span>

    <span class="n">_state_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">NFAState</span><span class="p">,</span> <span class="n">accept</span><span class="p">:</span> <span class="n">NFAState</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accept</span> <span class="o">=</span> <span class="n">accept</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_new_state</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">is_accept</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NFAState</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">NFAState</span><span class="p">(</span><span class="nb">id</span><span class="o">=</span><span class="bp">cls</span><span class="o">.</span><span class="n">_state_counter</span><span class="p">,</span> <span class="n">is_accept</span><span class="o">=</span><span class="n">is_accept</span><span class="p">)</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_state_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reset_counter</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="n">_state_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_epsilon</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;NFA&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Thompson&#39;s construction: epsilon.&quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_new_state</span><span class="p">()</span>
        <span class="n">accept</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_new_state</span><span class="p">(</span><span class="n">is_accept</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">start</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">accept</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">accept</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_symbol</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;NFA&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Thompson&#39;s construction: single symbol.&quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_new_state</span><span class="p">()</span>
        <span class="n">accept</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_new_state</span><span class="p">(</span><span class="n">is_accept</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">start</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="n">accept</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">accept</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">union</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">nfa1</span><span class="p">:</span> <span class="s1">&#39;NFA&#39;</span><span class="p">,</span> <span class="n">nfa2</span><span class="p">:</span> <span class="s1">&#39;NFA&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;NFA&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Thompson&#39;s construction: r | s.&quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_new_state</span><span class="p">()</span>
        <span class="n">accept</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_new_state</span><span class="p">(</span><span class="n">is_accept</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">start</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">nfa1</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">start</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">nfa2</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

        <span class="n">nfa1</span><span class="o">.</span><span class="n">accept</span><span class="o">.</span><span class="n">is_accept</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">nfa1</span><span class="o">.</span><span class="n">accept</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">accept</span><span class="p">)</span>

        <span class="n">nfa2</span><span class="o">.</span><span class="n">accept</span><span class="o">.</span><span class="n">is_accept</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">nfa2</span><span class="o">.</span><span class="n">accept</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">accept</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">accept</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">concatenation</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">nfa1</span><span class="p">:</span> <span class="s1">&#39;NFA&#39;</span><span class="p">,</span> <span class="n">nfa2</span><span class="p">:</span> <span class="s1">&#39;NFA&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;NFA&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Thompson&#39;s construction: r s.&quot;&quot;&quot;</span>
        <span class="n">nfa1</span><span class="o">.</span><span class="n">accept</span><span class="o">.</span><span class="n">is_accept</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">nfa1</span><span class="o">.</span><span class="n">accept</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">nfa2</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">nfa1</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">nfa2</span><span class="o">.</span><span class="n">accept</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kleene_star</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">nfa1</span><span class="p">:</span> <span class="s1">&#39;NFA&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;NFA&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Thompson&#39;s construction: r*.&quot;&quot;&quot;</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_new_state</span><span class="p">()</span>
        <span class="n">accept</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_new_state</span><span class="p">(</span><span class="n">is_accept</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">start</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">nfa1</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">start</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">accept</span><span class="p">)</span>

        <span class="n">nfa1</span><span class="o">.</span><span class="n">accept</span><span class="o">.</span><span class="n">is_accept</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">nfa1</span><span class="o">.</span><span class="n">accept</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">nfa1</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">nfa1</span><span class="o">.</span><span class="n">accept</span><span class="o">.</span><span class="n">add_transition</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">accept</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">accept</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">regex_to_nfa</span><span class="p">(</span><span class="n">regex</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">NFA</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a simple regex to NFA using Thompson&#39;s construction.</span>

<span class="sd">    Supported operators: | (union), * (star), concatenation (implicit),</span>
<span class="sd">                         ( ) (grouping)</span>

<span class="sd">    This parser handles operator precedence correctly:</span>
<span class="sd">      * &gt; concatenation &gt; |</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">NFA</span><span class="o">.</span><span class="n">reset_counter</span><span class="p">()</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">peek</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">pos</span>
        <span class="k">return</span> <span class="n">regex</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">regex</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">consume</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">pos</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">regex</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ch</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_expr</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NFA</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;expr = term (&#39;|&#39; term)*&quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">parse_term</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;|&#39;</span><span class="p">:</span>
            <span class="n">consume</span><span class="p">()</span>  <span class="c1"># eat &#39;|&#39;</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">parse_term</span><span class="p">()</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">NFA</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">left</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_term</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NFA</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;term = factor+&quot;&quot;&quot;</span>
        <span class="c1"># A term is one or more concatenated factors</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">parse_factor</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">peek</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">peek</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="s1">&#39;)&#39;</span><span class="p">):</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">parse_factor</span><span class="p">()</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">NFA</span><span class="o">.</span><span class="n">concatenation</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_factor</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NFA</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;factor = base (&#39;*&#39;)?&quot;&quot;&quot;</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">parse_base</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
            <span class="n">consume</span><span class="p">()</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">NFA</span><span class="o">.</span><span class="n">kleene_star</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_base</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">NFA</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;base = &#39;(&#39; expr &#39;)&#39; | symbol&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="n">consume</span><span class="p">()</span>  <span class="c1"># eat &#39;(&#39;</span>
            <span class="n">nfa</span> <span class="o">=</span> <span class="n">parse_expr</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">peek</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="s2">&quot;Expected &#39;)&#39;&quot;</span><span class="p">)</span>
            <span class="n">consume</span><span class="p">()</span>  <span class="c1"># eat &#39;)&#39;</span>
            <span class="k">return</span> <span class="n">nfa</span>
        <span class="k">elif</span> <span class="n">peek</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">peek</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">,</span> <span class="s1">&#39;)&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">consume</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">NFA</span><span class="o">.</span><span class="n">from_symbol</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Empty: return epsilon NFA</span>
            <span class="k">return</span> <span class="n">NFA</span><span class="o">.</span><span class="n">from_epsilon</span><span class="p">()</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">parse_expr</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">pos</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">regex</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unexpected character at position </span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">regex</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span><span class="w"> </span><span class="nf">epsilon_closure</span><span class="p">(</span><span class="n">states</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="n">NFAState</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Set</span><span class="p">[</span><span class="n">NFAState</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute the epsilon-closure of a set of NFA states.&quot;&quot;&quot;</span>
    <span class="n">closure</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">closure</span><span class="p">:</span>
                <span class="n">closure</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">closure</span>


<span class="k">def</span><span class="w"> </span><span class="nf">nfa_simulate</span><span class="p">(</span><span class="n">nfa</span><span class="p">:</span> <span class="n">NFA</span><span class="p">,</span> <span class="n">input_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simulate an NFA on an input string.&quot;&quot;&quot;</span>
    <span class="n">current</span> <span class="o">=</span> <span class="n">epsilon_closure</span><span class="p">({</span><span class="n">nfa</span><span class="o">.</span><span class="n">start</span><span class="p">})</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">input_string</span><span class="p">:</span>
        <span class="n">next_states</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">current</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="p">[]):</span>
                <span class="n">next_states</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">epsilon_closure</span><span class="p">(</span><span class="n">next_states</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_accept</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">current</span><span class="p">)</span>


<span class="c1"># Example usage</span>
<span class="n">nfa</span> <span class="o">=</span> <span class="n">regex_to_nfa</span><span class="p">(</span><span class="s2">&quot;(a|b)*abb&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NFA for (a|b)*abb&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;abb&#39;:   </span><span class="si">{</span><span class="n">nfa_simulate</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;abb&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>      <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;aabb&#39;:  </span><span class="si">{</span><span class="n">nfa_simulate</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;aabb&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>     <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;babb&#39;:  </span><span class="si">{</span><span class="n">nfa_simulate</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;babb&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>     <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;ab&#39;:    </span><span class="si">{</span><span class="n">nfa_simulate</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;ab&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>       <span class="c1"># False</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;abab&#39;:  </span><span class="si">{</span><span class="n">nfa_simulate</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;abab&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>     <span class="c1"># False</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;&#39;:      </span><span class="si">{</span><span class="n">nfa_simulate</span><span class="p">(</span><span class="n">nfa</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>          <span class="c1"># False</span>
</code></pre></div>

<hr />
<h2 id="5-from-nfa-to-dfa-subset-construction">5. From NFA to DFA: Subset Construction<a class="header-link" href="#5-from-nfa-to-dfa-subset-construction" title="Permanent link">&para;</a></h2>
<p>While NFAs are easy to construct from regular expressions, they are nondeterministic -- a state can have multiple transitions on the same symbol. <strong>DFAs</strong> (deterministic finite automata) are more efficient to simulate because each state has exactly one transition per symbol.</p>
<p>The <strong>subset construction</strong> (also called the <strong>powerset construction</strong>) converts an NFA to an equivalent DFA.</p>
<h3 id="algorithm">Algorithm<a class="header-link" href="#algorithm" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">Input</span><span class="err">:</span><span class="w">  </span><span class="n">NFA</span><span class="w"> </span><span class="n">N</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Q_N</span><span class="p">,</span><span class="w"> </span><span class="n">Œ£</span><span class="p">,</span><span class="w"> </span><span class="n">Œ¥_N</span><span class="p">,</span><span class="w"> </span><span class="n">q_0</span><span class="p">,</span><span class="w"> </span><span class="n">F_N</span><span class="p">)</span>
<span class="k">Output</span><span class="err">:</span><span class="w"> </span><span class="n">DFA</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">Q_D</span><span class="p">,</span><span class="w"> </span><span class="n">Œ£</span><span class="p">,</span><span class="w"> </span><span class="n">Œ¥_D</span><span class="p">,</span><span class="w"> </span><span class="n">d_0</span><span class="p">,</span><span class="w"> </span><span class="n">F_D</span><span class="p">)</span>

<span class="mf">1.</span><span class="w"> </span><span class="n">d_0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Œµ</span><span class="o">-</span><span class="n">closure</span><span class="p">(</span><span class="err">{</span><span class="n">q_0</span><span class="err">}</span><span class="p">)</span><span class="w">                  </span><span class="o">//</span><span class="w"> </span><span class="k">Start</span><span class="w"> </span><span class="k">state</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">DFA</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">Q_D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="n">d_0</span><span class="err">}</span><span class="w">                              </span><span class="o">//</span><span class="w"> </span><span class="k">Set</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">DFA</span><span class="w"> </span><span class="n">states</span><span class="w"> </span><span class="p">(</span><span class="k">each</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">NFA</span><span class="w"> </span><span class="n">states</span><span class="p">)</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">worklist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">d_0</span><span class="o">]</span><span class="w">                         </span><span class="o">//</span><span class="w"> </span><span class="n">States</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">process</span>
<span class="mf">4.</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="n">worklist</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="nl">empty</span><span class="p">:</span>
<span class="mf">5.</span><span class="w">     </span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">worklist</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
<span class="mf">6.</span><span class="w">     </span><span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">Œ£</span><span class="p">:</span>
<span class="mf">7.</span><span class="w">         </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Œµ</span><span class="o">-</span><span class="n">closure</span><span class="p">(</span><span class="n">move</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">))</span><span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">move</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="ow">union</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">Œ¥_N</span><span class="p">(</span><span class="n">s</span><span class="p">,</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">S</span>
<span class="mf">8.</span><span class="w">         </span><span class="k">if</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="nl">empty</span><span class="p">:</span>
<span class="mf">9.</span><span class="w">             </span><span class="k">if</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">Q_D</span><span class="p">:</span>
<span class="mf">10.</span><span class="w">                </span><span class="n">Q_D</span><span class="p">.</span><span class="k">add</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="mf">11.</span><span class="w">                </span><span class="n">worklist</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
<span class="mf">12.</span><span class="w">            </span><span class="n">Œ¥_D</span><span class="p">(</span><span class="n">S</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span>
<span class="mf">13.</span><span class="w"> </span><span class="n">F_D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="n">S</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">Q_D</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="err">‚à©</span><span class="w"> </span><span class="n">F_N</span><span class="w"> </span><span class="err">‚â†</span><span class="w"> </span><span class="err">‚àÖ}</span><span class="w">         </span><span class="o">//</span><span class="w"> </span><span class="n">DFA</span><span class="w"> </span><span class="k">state</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">accepting</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="k">contains</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">NFA</span><span class="w"> </span><span class="n">accept</span><span class="w"> </span><span class="k">state</span>
</code></pre></div>

<h3 id="complexity">Complexity<a class="header-link" href="#complexity" title="Permanent link">&para;</a></h3>
<p>In the worst case, a DFA can have $2^n$ states for an NFA with $n$ states (hence "powerset" construction). In practice, only a small fraction of these states are reachable.</p>
<h3 id="python-implementation_1">Python Implementation<a class="header-link" href="#python-implementation_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">FrozenSet</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DFAState</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A state in a DFA, corresponding to a set of NFA states.&quot;&quot;&quot;</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">nfa_states</span><span class="p">:</span> <span class="n">FrozenSet</span><span class="p">[</span><span class="n">NFAState</span><span class="p">]</span>
    <span class="n">is_accept</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">transitions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="s1">&#39;DFAState&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">nfa_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfa_states</span><span class="p">)</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="s2">&quot; (accept)&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_accept</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;D</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="se">{{</span><span class="si">{</span><span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span><span class="w"> </span><span class="n">nfa_ids</span><span class="p">))</span><span class="si">}</span><span class="se">}}</span><span class="si">{</span><span class="n">suffix</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DFA</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Deterministic Finite Automaton.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">DFAState</span><span class="p">,</span> <span class="n">states</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">DFAState</span><span class="p">],</span> <span class="n">alphabet</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="n">states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">alphabet</span> <span class="o">=</span> <span class="n">alphabet</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_nfa</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">nfa</span><span class="p">:</span> <span class="n">NFA</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;DFA&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert NFA to DFA using subset construction.&quot;&quot;&quot;</span>

        <span class="c1"># Collect alphabet (all symbols except epsilon)</span>
        <span class="n">alphabet</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">visited_nfa</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">nfa</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">visited_nfa</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">visited_nfa</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">symbol</span><span class="p">,</span> <span class="n">targets</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="s1">&#39;Œµ&#39;</span><span class="p">:</span>
                    <span class="n">alphabet</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="c1"># Subset construction</span>
        <span class="n">dfa_id</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">start_nfa_states</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">epsilon_closure</span><span class="p">({</span><span class="n">nfa</span><span class="o">.</span><span class="n">start</span><span class="p">}))</span>
        <span class="n">start_is_accept</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_accept</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">start_nfa_states</span><span class="p">)</span>
        <span class="n">start_dfa</span> <span class="o">=</span> <span class="n">DFAState</span><span class="p">(</span><span class="n">dfa_id</span><span class="p">,</span> <span class="n">start_nfa_states</span><span class="p">,</span> <span class="n">start_is_accept</span><span class="p">)</span>
        <span class="n">dfa_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Map from frozenset of NFA states -&gt; DFA state</span>
        <span class="n">state_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">start_nfa_states</span><span class="p">:</span> <span class="n">start_dfa</span><span class="p">}</span>
        <span class="n">dfa_states</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_dfa</span><span class="p">]</span>
        <span class="n">worklist</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_dfa</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">alphabet</span><span class="p">):</span>
                <span class="c1"># Compute move(current.nfa_states, symbol)</span>
                <span class="n">move_result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">nfa_state</span> <span class="ow">in</span> <span class="n">current</span><span class="o">.</span><span class="n">nfa_states</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">nfa_state</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">symbol</span><span class="p">,</span> <span class="p">[]):</span>
                        <span class="n">move_result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">move_result</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Compute epsilon-closure of the move result</span>
                <span class="n">closure</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">epsilon_closure</span><span class="p">(</span><span class="n">move_result</span><span class="p">))</span>

                <span class="k">if</span> <span class="n">closure</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">state_map</span><span class="p">:</span>
                    <span class="n">is_accept</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_accept</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">closure</span><span class="p">)</span>
                    <span class="n">new_state</span> <span class="o">=</span> <span class="n">DFAState</span><span class="p">(</span><span class="n">dfa_id</span><span class="p">,</span> <span class="n">closure</span><span class="p">,</span> <span class="n">is_accept</span><span class="p">)</span>
                    <span class="n">dfa_id</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">state_map</span><span class="p">[</span><span class="n">closure</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_state</span>
                    <span class="n">dfa_states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_state</span><span class="p">)</span>
                    <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_state</span><span class="p">)</span>

                <span class="n">current</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">state_map</span><span class="p">[</span><span class="n">closure</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">start_dfa</span><span class="p">,</span> <span class="n">dfa_states</span><span class="p">,</span> <span class="n">alphabet</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">simulate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_string</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simulate the DFA on an input string.&quot;&quot;&quot;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">input_string</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">current</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">current</span><span class="o">.</span><span class="n">is_accept</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print the DFA transition table.&quot;&quot;&quot;</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alphabet</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;State&#39;</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="s1">&#39;Accept&#39;</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2"> | &quot;</span> <span class="o">+</span> <span class="s2">&quot; | &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="si">:</span><span class="s2">&gt;5</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span>
        <span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">id</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;D&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">str</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="si">:</span><span class="s2">&gt;10</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="s1">&#39;yes&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">state</span><span class="o">.</span><span class="n">is_accept</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;no&#39;</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2"> | &quot;</span>
            <span class="n">cells</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
                    <span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;D&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">str</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="o">.</span><span class="n">id</span><span class="p">)</span><span class="si">:</span><span class="s2">&gt;5</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;--&#39;</span><span class="si">:</span><span class="s2">&gt;5</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">+=</span> <span class="s2">&quot; | &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cells</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>


<span class="c1"># Example: Convert NFA for (a|b)*abb to DFA</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== NFA to DFA: (a|b)*abb ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">nfa</span> <span class="o">=</span> <span class="n">regex_to_nfa</span><span class="p">(</span><span class="s2">&quot;(a|b)*abb&quot;</span><span class="p">)</span>
<span class="n">dfa</span> <span class="o">=</span> <span class="n">DFA</span><span class="o">.</span><span class="n">from_nfa</span><span class="p">(</span><span class="n">nfa</span><span class="p">)</span>
<span class="n">dfa</span><span class="o">.</span><span class="n">print_table</span><span class="p">()</span>

<span class="nb">print</span><span class="p">()</span>
<span class="n">test_strings</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;abb&quot;</span><span class="p">,</span> <span class="s2">&quot;aabb&quot;</span><span class="p">,</span> <span class="s2">&quot;babb&quot;</span><span class="p">,</span> <span class="s2">&quot;ababb&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;ba&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">]</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">test_strings</span><span class="p">:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="s1">&#39;accepted&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;rejected&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="6-dfa-minimization-hopcrofts-algorithm">6. DFA Minimization: Hopcroft's Algorithm<a class="header-link" href="#6-dfa-minimization-hopcrofts-algorithm" title="Permanent link">&para;</a></h2>
<p>A DFA produced by subset construction may have more states than necessary. <strong>DFA minimization</strong> produces the smallest DFA that recognizes the same language.</p>
<h3 id="equivalent-states">Equivalent States<a class="header-link" href="#equivalent-states" title="Permanent link">&para;</a></h3>
<p>Two states $p$ and $q$ are <strong>equivalent</strong> (indistinguishable) if for every string $w$:</p>
<p>$$\hat{\delta}(p, w) \in F \iff \hat{\delta}(q, w) \in F$$</p>
<p>In other words, starting from $p$ or $q$, the DFA accepts exactly the same set of strings.</p>
<h3 id="hopcrofts-algorithm-partition-refinement">Hopcroft's Algorithm (Partition Refinement)<a class="header-link" href="#hopcrofts-algorithm-partition-refinement" title="Permanent link">&para;</a></h3>
<p>The algorithm starts with a coarse partition and refines it:</p>
<div class="highlight"><pre><span></span><code><span class="n">Input</span><span class="o">:</span><span class="w">  </span><span class="n">DFA</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">(</span><span class="n">Q</span><span class="o">,</span><span class="w"> </span><span class="err">Œ£</span><span class="o">,</span><span class="w"> </span><span class="err">Œ¥</span><span class="o">,</span><span class="w"> </span><span class="n">q_0</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="o">)</span>
<span class="n">Output</span><span class="o">:</span><span class="w"> </span><span class="n">Minimized</span><span class="w"> </span><span class="n">DFA</span><span class="w"> </span><span class="n">D</span><span class="s1">&#39; with equivalent states merged</span>

<span class="s1">1. Initial partition P = {F, Q \ F}     // Accepting and non-accepting states</span>
<span class="s1">2. worklist W = {F}                      // (or the smaller of F, Q\F)</span>
<span class="s1">3. while W is not empty:</span>
<span class="s1">4.     A = W.pop()</span>
<span class="s1">5.     for each symbol c in Œ£:</span>
<span class="s1">6.         X = {q in Q | Œ¥(q, c) in A}  // States that transition to A on c</span>
<span class="s1">7.         for each group Y in P:</span>
<span class="s1">8.             Y1 = Y ‚à© X                // States in Y that go to A on c</span>
<span class="s1">9.             Y2 = Y \ X               // States in Y that don&#39;</span><span class="n">t</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">c</span>
<span class="mi">10</span><span class="o">.</span><span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">Y1</span><span class="w"> </span><span class="err">‚â†</span><span class="w"> </span><span class="err">‚àÖ</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">Y2</span><span class="w"> </span><span class="err">‚â†</span><span class="w"> </span><span class="err">‚àÖ</span><span class="o">:</span><span class="w">    </span><span class="c1">// Y is split</span>
<span class="mi">11</span><span class="o">.</span><span class="w">                </span><span class="n">Replace</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">Y1</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">Y2</span>
<span class="mi">12</span><span class="o">.</span><span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">W</span><span class="o">:</span>
<span class="mi">13</span><span class="o">.</span><span class="w">                    </span><span class="n">Replace</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">W</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">Y1</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">Y2</span>
<span class="mi">14</span><span class="o">.</span><span class="w">                </span><span class="k">else</span><span class="o">:</span>
<span class="mi">15</span><span class="o">.</span><span class="w">                    </span><span class="n">Add</span><span class="w"> </span><span class="n">smaller</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">Y1</span><span class="o">,</span><span class="w"> </span><span class="n">Y2</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">W</span>
<span class="mi">16</span><span class="o">.</span><span class="w"> </span><span class="n">Return</span><span class="w"> </span><span class="n">DFA</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">partition</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="n">state</span>
</code></pre></div>

<p><strong>Time complexity</strong>: $O(n \log n)$ where $n = |Q|$</p>
<h3 id="python-implementation_2">Python Implementation<a class="header-link" href="#python-implementation_2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">minimize_dfa</span><span class="p">(</span><span class="n">dfa</span><span class="p">:</span> <span class="n">DFA</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DFA</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Minimize a DFA using Hopcroft&#39;s algorithm (partition refinement).</span>
<span class="sd">    Returns a new minimized DFA.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">.</span><span class="n">states</span>
    <span class="n">alphabet</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dfa</span><span class="o">.</span><span class="n">alphabet</span><span class="p">)</span>

    <span class="c1"># Remove unreachable states</span>
    <span class="n">reachable</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">dfa</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">reachable</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">reachable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">alphabet</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
                <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">sym</span><span class="p">])</span>
    <span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">reachable</span><span class="p">]</span>

    <span class="c1"># Add dead state if needed (for completeness)</span>
    <span class="n">dead_state</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">alphabet</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dead_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">dead_state</span> <span class="o">=</span> <span class="n">DFAState</span><span class="p">(</span>
                        <span class="nb">id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
                        <span class="n">nfa_states</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">(),</span>
                        <span class="n">is_accept</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
                    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">alphabet</span><span class="p">:</span>
                        <span class="n">dead_state</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">a</span><span class="p">]</span> <span class="o">=</span> <span class="n">dead_state</span>
                    <span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dead_state</span><span class="p">)</span>
                <span class="n">s</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">dead_state</span>

    <span class="c1"># Initial partition: {accept states, non-accept states}</span>
    <span class="n">accept_group</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span> <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">is_accept</span><span class="p">)</span>
    <span class="n">non_accept_group</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">is_accept</span><span class="p">)</span>

    <span class="n">partition</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">accept_group</span><span class="p">:</span>
        <span class="n">partition</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">accept_group</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">non_accept_group</span><span class="p">:</span>
        <span class="n">partition</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">non_accept_group</span><span class="p">)</span>

    <span class="c1"># Worklist</span>
    <span class="n">worklist</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">accept_group</span> <span class="ow">and</span> <span class="n">non_accept_group</span><span class="p">:</span>
        <span class="c1"># Add the smaller group</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">accept_group</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">non_accept_group</span><span class="p">):</span>
            <span class="n">worklist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">accept_group</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">worklist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">non_accept_group</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">accept_group</span><span class="p">:</span>
        <span class="n">worklist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">accept_group</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">non_accept_group</span><span class="p">:</span>
        <span class="n">worklist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">non_accept_group</span><span class="p">)</span>

    <span class="c1"># Refinement</span>
    <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">alphabet</span><span class="p">:</span>
            <span class="c1"># X = states that transition into A on symbol c</span>
            <span class="n">X</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>
                <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">states</span>
                <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">transitions</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="ow">in</span> <span class="n">A</span>
            <span class="p">)</span>

            <span class="n">new_partition</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">Y</span> <span class="ow">in</span> <span class="n">partition</span><span class="p">:</span>
                <span class="n">Y1</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">&amp;</span> <span class="n">X</span>
                <span class="n">Y2</span> <span class="o">=</span> <span class="n">Y</span> <span class="o">-</span> <span class="n">X</span>

                <span class="k">if</span> <span class="n">Y1</span> <span class="ow">and</span> <span class="n">Y2</span><span class="p">:</span>
                    <span class="n">new_partition</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Y1</span><span class="p">)</span>
                    <span class="n">new_partition</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Y2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">Y</span> <span class="ow">in</span> <span class="n">worklist</span><span class="p">:</span>
                        <span class="n">worklist</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
                        <span class="n">worklist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Y1</span><span class="p">)</span>
                        <span class="n">worklist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Y2</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">Y2</span><span class="p">):</span>
                            <span class="n">worklist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Y1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">worklist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Y2</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_partition</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>

            <span class="n">partition</span> <span class="o">=</span> <span class="n">new_partition</span>

    <span class="c1"># Build minimized DFA</span>
    <span class="c1"># Map each old state to its partition representative</span>
    <span class="n">state_to_group</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">partition</span><span class="p">:</span>
        <span class="n">representative</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
            <span class="n">state_to_group</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="n">representative</span>

    <span class="c1"># Create new DFA states</span>
    <span class="n">new_dfa_id</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">group_to_new_state</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">partition</span><span class="p">:</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rep</span> <span class="o">==</span> <span class="n">dead_state</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># Skip the dead state</span>
        <span class="n">is_accept</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">is_accept</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">group</span><span class="p">)</span>
        <span class="n">new_state</span> <span class="o">=</span> <span class="n">DFAState</span><span class="p">(</span>
            <span class="nb">id</span><span class="o">=</span><span class="n">new_dfa_id</span><span class="p">,</span>
            <span class="n">nfa_states</span><span class="o">=</span><span class="nb">frozenset</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">nfa_states</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">group</span><span class="p">)),</span>
            <span class="n">is_accept</span><span class="o">=</span><span class="n">is_accept</span>
        <span class="p">)</span>
        <span class="n">group_to_new_state</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">group</span><span class="p">)]</span> <span class="o">=</span> <span class="n">new_state</span>
        <span class="n">new_dfa_id</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Add transitions</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">partition</span><span class="p">:</span>
        <span class="n">rep</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="n">s</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rep</span> <span class="o">==</span> <span class="n">dead_state</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">new_state</span> <span class="o">=</span> <span class="n">group_to_new_state</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">group</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">alphabet</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">rep</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">rep</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">c</span><span class="p">]</span>
                <span class="n">target_group</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">partition</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
                        <span class="n">target_group</span> <span class="o">=</span> <span class="n">g</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">target_group</span> <span class="ow">and</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">target_group</span><span class="p">)</span> <span class="ow">in</span> <span class="n">group_to_new_state</span><span class="p">:</span>
                    <span class="n">new_state</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_to_new_state</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">target_group</span><span class="p">)]</span>

    <span class="c1"># Find the new start state</span>
    <span class="n">start_group</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">partition</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dfa</span><span class="o">.</span><span class="n">start</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
            <span class="n">start_group</span> <span class="o">=</span> <span class="n">group</span>
            <span class="k">break</span>

    <span class="n">new_start</span> <span class="o">=</span> <span class="n">group_to_new_state</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">(</span><span class="n">start_group</span><span class="p">)]</span>
    <span class="n">new_states</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">group_to_new_state</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

    <span class="k">return</span> <span class="n">DFA</span><span class="p">(</span><span class="n">new_start</span><span class="p">,</span> <span class="n">new_states</span><span class="p">,</span> <span class="n">dfa</span><span class="o">.</span><span class="n">alphabet</span><span class="p">)</span>


<span class="c1"># Example</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== DFA Minimization ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Before minimization:&quot;</span><span class="p">)</span>
<span class="n">dfa</span><span class="o">.</span><span class="n">print_table</span><span class="p">()</span>

<span class="n">min_dfa</span> <span class="o">=</span> <span class="n">minimize_dfa</span><span class="p">(</span><span class="n">dfa</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After minimization (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">min_dfa</span><span class="o">.</span><span class="n">states</span><span class="p">)</span><span class="si">}</span><span class="s2"> states):&quot;</span><span class="p">)</span>
<span class="n">min_dfa</span><span class="o">.</span><span class="n">print_table</span><span class="p">()</span>

<span class="c1"># Verify correctness</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Verification:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;abb&quot;</span><span class="p">,</span> <span class="s2">&quot;aabb&quot;</span><span class="p">,</span> <span class="s2">&quot;babb&quot;</span><span class="p">,</span> <span class="s2">&quot;ababb&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;ba&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">]:</span>
    <span class="n">orig</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">mini</span> <span class="o">=</span> <span class="n">min_dfa</span><span class="o">.</span><span class="n">simulate</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;OK&quot;</span> <span class="k">if</span> <span class="n">orig</span> <span class="o">==</span> <span class="n">mini</span> <span class="k">else</span> <span class="s2">&quot;MISMATCH!&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&#39;: original=</span><span class="si">{</span><span class="n">orig</span><span class="si">}</span><span class="s2">, minimized=</span><span class="si">{</span><span class="n">mini</span><span class="si">}</span><span class="s2">  [</span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="7-token-recognition">7. Token Recognition<a class="header-link" href="#7-token-recognition" title="Permanent link">&para;</a></h2>
<p>Given DFAs for all token patterns, how does the lexer decide which token to return?</p>
<h3 id="the-longest-match-rule">The Longest Match Rule<a class="header-link" href="#the-longest-match-rule" title="Permanent link">&para;</a></h3>
<p>The lexer always returns the <strong>longest possible token</strong> starting at the current position.</p>
<div class="highlight"><pre><span></span><code><span class="nt">Input</span><span class="o">:</span><span class="w">  </span><span class="s2">&quot;iffy = 10;&quot;</span>

<span class="nt">Without</span><span class="w"> </span><span class="nt">longest</span><span class="w"> </span><span class="nt">match</span><span class="o">:</span><span class="w">  </span><span class="nt">KW_IF</span><span class="o">(</span><span class="s2">&quot;if&quot;</span><span class="o">)</span><span class="w"> </span><span class="nt">ID</span><span class="o">(</span><span class="s2">&quot;fy&quot;</span><span class="o">)</span><span class="w"> </span><span class="o">...</span><span class="w">   </span><span class="nt">WRONG</span><span class="o">!</span>
<span class="nt">With</span><span class="w"> </span><span class="nt">longest</span><span class="w"> </span><span class="nt">match</span><span class="o">:</span><span class="w">     </span><span class="nt">ID</span><span class="o">(</span><span class="s2">&quot;iffy&quot;</span><span class="o">)</span><span class="w"> </span><span class="nt">ASSIGN</span><span class="o">(</span><span class="s2">&quot;=&quot;</span><span class="o">)</span><span class="w"> </span><span class="o">...</span><span class="w">  </span><span class="nt">CORRECT</span><span class="o">!</span>
</code></pre></div>

<h3 id="priority-rule">Priority Rule<a class="header-link" href="#priority-rule" title="Permanent link">&para;</a></h3>
<p>When two patterns match the same longest lexeme, the one listed <strong>first</strong> (highest priority) wins. Keywords are typically listed before identifiers.</p>
<div class="highlight"><pre><span></span><code>Input:  &quot;if&quot;

Pattern order:
  1. KW_IF:   &quot;if&quot;       &lt;--- wins (higher priority)
  2. ID:      [a-z]+     &lt;--- also matches &quot;if&quot;
</code></pre></div>

<h3 id="combined-dfa-approach">Combined DFA Approach<a class="header-link" href="#combined-dfa-approach" title="Permanent link">&para;</a></h3>
<p>In practice, all token pattern DFAs are combined into a single DFA:</p>
<ol>
<li>Build an NFA for each token pattern, marking the accept state with the token type</li>
<li>Create a combined NFA with a new start state and epsilon-transitions to each pattern NFA</li>
<li>Convert to DFA using subset construction</li>
<li>When a DFA state contains accept states from multiple patterns, choose the highest-priority one</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="w">            </span><span class="err">Œµ</span><span class="w"> </span><span class="o">---&gt;</span><span class="w"> </span><span class="n">NFA</span><span class="p">(</span><span class="n">KW_IF</span><span class="p">)</span>
<span class="w">           </span><span class="o">/</span>
<span class="w">  </span><span class="n">start</span><span class="w"> </span><span class="o">--</span><span class="err">Œµ</span><span class="w"> </span><span class="o">---&gt;</span><span class="w"> </span><span class="n">NFA</span><span class="p">(</span><span class="n">KW_WHILE</span><span class="p">)</span>
<span class="w">           </span><span class="err">\</span>
<span class="w">            </span><span class="err">Œµ</span><span class="w"> </span><span class="o">---&gt;</span><span class="w"> </span><span class="n">NFA</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span>
<span class="w">                   </span><span class="p">...</span>
</code></pre></div>

<h3 id="implementing-the-longest-match">Implementing the Longest Match<a class="header-link" href="#implementing-the-longest-match" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">longest_match</span><span class="p">(</span><span class="n">dfa</span><span class="p">:</span> <span class="n">DFA</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the longest match starting at pos.</span>
<span class="sd">    Returns (token_type, length) or (None, 0) if no match.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">dfa</span><span class="o">.</span><span class="n">start</span>
    <span class="n">last_accept</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">last_accept_pos</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">current_pos</span> <span class="o">=</span> <span class="n">pos</span>

    <span class="k">while</span> <span class="n">current_pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">current_pos</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">state</span><span class="o">.</span><span class="n">transitions</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">transitions</span><span class="p">[</span><span class="n">ch</span><span class="p">]</span>
        <span class="n">current_pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">is_accept</span><span class="p">:</span>
            <span class="n">last_accept</span> <span class="o">=</span> <span class="n">state</span>  <span class="c1"># Remember this accept position</span>
            <span class="n">last_accept_pos</span> <span class="o">=</span> <span class="n">current_pos</span>

    <span class="k">if</span> <span class="n">last_accept</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">last_accept</span><span class="p">,</span> <span class="n">last_accept_pos</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<h3 id="error-recovery-in-lexers">Error Recovery in Lexers<a class="header-link" href="#error-recovery-in-lexers" title="Permanent link">&para;</a></h3>
<p>When the lexer encounters a character that doesn't match any token pattern, it has several options:</p>
<ol>
<li><strong>Panic mode</strong>: Skip the offending character and report an error</li>
<li><strong>Insert</strong>: Insert a missing character (rare)</li>
<li><strong>Delete</strong>: Delete the offending character</li>
<li><strong>Replace</strong>: Replace the offending character with a valid one</li>
</ol>
<p>Most compilers use panic mode: report the error and skip one character.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">scan_with_recovery</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Token</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Scan with panic-mode error recovery.&quot;&quot;&quot;</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">line</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">col</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="c1"># Skip whitespace</span>
        <span class="k">if</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="ow">in</span> <span class="s1">&#39; </span><span class="se">\t\r</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">line</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">col</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">continue</span>

        <span class="c1"># Try to match a token</span>
        <span class="n">best_match</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">best_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">best_type</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">token_type</span><span class="p">,</span> <span class="n">pattern_dfa</span> <span class="ow">in</span> <span class="n">token_patterns</span><span class="p">:</span>
            <span class="n">match_state</span><span class="p">,</span> <span class="n">length</span> <span class="o">=</span> <span class="n">longest_match</span><span class="p">(</span><span class="n">pattern_dfa</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">best_length</span><span class="p">:</span>
                <span class="n">best_match</span> <span class="o">=</span> <span class="n">match_state</span>
                <span class="n">best_length</span> <span class="o">=</span> <span class="n">length</span>
                <span class="n">best_type</span> <span class="o">=</span> <span class="n">token_type</span>

        <span class="k">if</span> <span class="n">best_match</span><span class="p">:</span>
            <span class="n">lexeme</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span> <span class="o">+</span> <span class="n">best_length</span><span class="p">]</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Token</span><span class="p">(</span><span class="n">best_type</span><span class="p">,</span> <span class="n">lexeme</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="n">col</span><span class="p">))</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="n">best_length</span>
            <span class="n">col</span> <span class="o">+=</span> <span class="n">best_length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Error recovery: skip one character</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Lexical error at line </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">, col </span><span class="si">{</span><span class="n">col</span><span class="si">}</span><span class="s2">: &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;unexpected character &#39;</span><span class="si">{</span><span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">tokens</span>
</code></pre></div>

<hr />
<h2 id="8-a-complete-lexer-implementation">8. A Complete Lexer Implementation<a class="header-link" href="#8-a-complete-lexer-implementation" title="Permanent link">&para;</a></h2>
<p>Here is a complete, self-contained lexer for a C-like language, built from the ground up using the techniques discussed.</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Complete lexer for a simple C-like language.</span>
<span class="sd">Uses a table-driven approach with longest-match and priority rules.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Any</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TT</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Token types.&quot;&quot;&quot;</span>
    <span class="c1"># Keywords (listed first for priority)</span>
    <span class="n">KW_IF</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_ELSE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_WHILE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_FOR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_RETURN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_INT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_FLOAT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_VOID</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_CHAR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_BREAK</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">KW_CONTINUE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

    <span class="c1"># Literals</span>
    <span class="n">FLOAT_LIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">INT_LIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">STRING_LIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">CHAR_LIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

    <span class="c1"># Identifiers</span>
    <span class="n">IDENT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

    <span class="c1"># Multi-character operators (before single-char ones for longest match)</span>
    <span class="n">LEQ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># &lt;=</span>
    <span class="n">GEQ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># &gt;=</span>
    <span class="n">EQ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>         <span class="c1"># ==</span>
    <span class="n">NEQ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># !=</span>
    <span class="n">AND</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># &amp;&amp;</span>
    <span class="n">OR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>         <span class="c1"># ||</span>
    <span class="n">ARROW</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>      <span class="c1"># -&gt;</span>
    <span class="n">INC</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># ++</span>
    <span class="n">DEC</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># --</span>
    <span class="n">PLUS_ASSIGN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   <span class="c1"># +=</span>
    <span class="n">MINUS_ASSIGN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># -=</span>
    <span class="n">STAR_ASSIGN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   <span class="c1"># *=</span>
    <span class="n">SLASH_ASSIGN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># /=</span>

    <span class="c1"># Single-character operators and delimiters</span>
    <span class="n">PLUS</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>       <span class="c1"># +</span>
    <span class="n">MINUS</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>      <span class="c1"># -</span>
    <span class="n">STAR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>       <span class="c1"># *</span>
    <span class="n">SLASH</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>      <span class="c1"># /</span>
    <span class="n">PERCENT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>    <span class="c1"># %</span>
    <span class="n">ASSIGN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>     <span class="c1"># =</span>
    <span class="n">LT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>         <span class="c1"># &lt;</span>
    <span class="n">GT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>         <span class="c1"># &gt;</span>
    <span class="n">NOT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># !</span>
    <span class="n">AMP</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># &amp;</span>
    <span class="n">PIPE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>       <span class="c1"># |</span>
    <span class="n">LPAREN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>     <span class="c1"># (</span>
    <span class="n">RPAREN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>     <span class="c1"># )</span>
    <span class="n">LBRACE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>     <span class="c1"># {</span>
    <span class="n">RBRACE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>     <span class="c1"># }</span>
    <span class="n">LBRACKET</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   <span class="c1"># [</span>
    <span class="n">RBRACKET</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>   <span class="c1"># ]</span>
    <span class="n">COMMA</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>      <span class="c1"># ,</span>
    <span class="n">SEMI</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>       <span class="c1"># ;</span>
    <span class="n">DOT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># .</span>

    <span class="c1"># Special</span>
    <span class="n">EOF</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">ERROR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Token</span><span class="p">:</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">TT</span>
    <span class="n">lexeme</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">column</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">val</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;, value=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">!r}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Token(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lexeme</span><span class="si">!r}{</span><span class="n">val</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="si">}</span><span class="s2">)&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LexerError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="n">line</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="n">column</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Lexer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A complete lexer for a C-like language.</span>

<span class="sd">    Uses a hand-written state machine approach for correctness</span>
<span class="sd">    and efficiency. Implements longest-match and keyword priority.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">KEYWORDS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;if&#39;</span><span class="p">:</span>       <span class="n">TT</span><span class="o">.</span><span class="n">KW_IF</span><span class="p">,</span>
        <span class="s1">&#39;else&#39;</span><span class="p">:</span>     <span class="n">TT</span><span class="o">.</span><span class="n">KW_ELSE</span><span class="p">,</span>
        <span class="s1">&#39;while&#39;</span><span class="p">:</span>    <span class="n">TT</span><span class="o">.</span><span class="n">KW_WHILE</span><span class="p">,</span>
        <span class="s1">&#39;for&#39;</span><span class="p">:</span>      <span class="n">TT</span><span class="o">.</span><span class="n">KW_FOR</span><span class="p">,</span>
        <span class="s1">&#39;return&#39;</span><span class="p">:</span>   <span class="n">TT</span><span class="o">.</span><span class="n">KW_RETURN</span><span class="p">,</span>
        <span class="s1">&#39;int&#39;</span><span class="p">:</span>      <span class="n">TT</span><span class="o">.</span><span class="n">KW_INT</span><span class="p">,</span>
        <span class="s1">&#39;float&#39;</span><span class="p">:</span>    <span class="n">TT</span><span class="o">.</span><span class="n">KW_FLOAT</span><span class="p">,</span>
        <span class="s1">&#39;void&#39;</span><span class="p">:</span>     <span class="n">TT</span><span class="o">.</span><span class="n">KW_VOID</span><span class="p">,</span>
        <span class="s1">&#39;char&#39;</span><span class="p">:</span>     <span class="n">TT</span><span class="o">.</span><span class="n">KW_CHAR</span><span class="p">,</span>
        <span class="s1">&#39;break&#39;</span><span class="p">:</span>    <span class="n">TT</span><span class="o">.</span><span class="n">KW_BREAK</span><span class="p">,</span>
        <span class="s1">&#39;continue&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">KW_CONTINUE</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">TWO_CHAR_OPS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;&lt;=&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">LEQ</span><span class="p">,</span>
        <span class="s1">&#39;&gt;=&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">GEQ</span><span class="p">,</span>
        <span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">EQ</span><span class="p">,</span>
        <span class="s1">&#39;!=&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">NEQ</span><span class="p">,</span>
        <span class="s1">&#39;&amp;&amp;&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">AND</span><span class="p">,</span>
        <span class="s1">&#39;||&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">OR</span><span class="p">,</span>
        <span class="s1">&#39;-&gt;&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">ARROW</span><span class="p">,</span>
        <span class="s1">&#39;++&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">INC</span><span class="p">,</span>
        <span class="s1">&#39;--&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">DEC</span><span class="p">,</span>
        <span class="s1">&#39;+=&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">PLUS_ASSIGN</span><span class="p">,</span>
        <span class="s1">&#39;-=&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">MINUS_ASSIGN</span><span class="p">,</span>
        <span class="s1">&#39;*=&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">STAR_ASSIGN</span><span class="p">,</span>
        <span class="s1">&#39;/=&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">SLASH_ASSIGN</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">SINGLE_CHAR_OPS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">PLUS</span><span class="p">,</span>
        <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">MINUS</span><span class="p">,</span>
        <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">STAR</span><span class="p">,</span>
        <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">SLASH</span><span class="p">,</span>
        <span class="s1">&#39;%&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">PERCENT</span><span class="p">,</span>
        <span class="s1">&#39;=&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">ASSIGN</span><span class="p">,</span>
        <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">LT</span><span class="p">,</span>
        <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
        <span class="s1">&#39;!&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">NOT</span><span class="p">,</span>
        <span class="s1">&#39;&amp;&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">AMP</span><span class="p">,</span>
        <span class="s1">&#39;|&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span>
        <span class="s1">&#39;(&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">LPAREN</span><span class="p">,</span>
        <span class="s1">&#39;)&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">RPAREN</span><span class="p">,</span>
        <span class="s1">&#39;{&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">LBRACE</span><span class="p">,</span>
        <span class="s1">&#39;}&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">RBRACE</span><span class="p">,</span>
        <span class="s1">&#39;[&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">LBRACKET</span><span class="p">,</span>
        <span class="s1">&#39;]&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">RBRACKET</span><span class="p">,</span>
        <span class="s1">&#39;,&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">COMMA</span><span class="p">,</span>
        <span class="s1">&#39;;&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">SEMI</span><span class="p">,</span>
        <span class="s1">&#39;.&#39;</span><span class="p">:</span> <span class="n">TT</span><span class="o">.</span><span class="n">DOT</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&lt;input&gt;&quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">peek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Look at the character at current position + offset.&quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">advance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Consume and return the current character.&quot;&quot;&quot;</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">line</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">column</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">ch</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">make_token</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">token_type</span><span class="p">:</span> <span class="n">TT</span><span class="p">,</span> <span class="n">lexeme</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                   <span class="n">value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Token</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Token</span><span class="p">(</span><span class="n">token_type</span><span class="p">,</span> <span class="n">lexeme</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">skip_whitespace_and_comments</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Skip whitespace, single-line comments, and multi-line comments.&quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>

            <span class="c1"># Whitespace</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="s1">&#39; </span><span class="se">\t\r\n</span><span class="s1">&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
                <span class="k">continue</span>

            <span class="c1"># Single-line comment: //</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>  <span class="c1"># skip /</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>  <span class="c1"># skip /</span>
                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
                <span class="k">continue</span>

            <span class="c1"># Multi-line comment: /* ... */</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                <span class="n">start_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span>
                <span class="n">start_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>  <span class="c1"># skip /</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>  <span class="c1"># skip *</span>
                <span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                        <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
                        <span class="n">depth</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_col</span><span class="si">}</span><span class="s2">: &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;unterminated comment&quot;</span>
                    <span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">break</span>  <span class="c1"># Not whitespace or comment</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">scan_number</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Token</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scan an integer or float literal.&quot;&quot;&quot;</span>
        <span class="n">start_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span>
        <span class="n">start_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span>
        <span class="n">start_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="n">is_float</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Integer part</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>

        <span class="c1"># Fractional part</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">is_float</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>  <span class="c1"># skip &#39;.&#39;</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>

        <span class="c1"># Exponent part</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;e&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">):</span>
            <span class="n">is_float</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>  <span class="c1"># skip &#39;e&#39;/&#39;E&#39;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="si">}</span><span class="s2">: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;expected digit in exponent&quot;</span>
                <span class="p">)</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>

        <span class="n">lexeme</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">start_pos</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">is_float</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_token</span><span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">FLOAT_LIT</span><span class="p">,</span> <span class="n">lexeme</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">lexeme</span><span class="p">),</span>
                                   <span class="n">start_line</span><span class="p">,</span> <span class="n">start_col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_token</span><span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">INT_LIT</span><span class="p">,</span> <span class="n">lexeme</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">lexeme</span><span class="p">),</span>
                                   <span class="n">start_line</span><span class="p">,</span> <span class="n">start_col</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">scan_string</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Token</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scan a string literal (double-quoted).&quot;&quot;&quot;</span>
        <span class="n">start_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span>
        <span class="n">start_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>  <span class="c1"># skip opening &quot;</span>
        <span class="n">chars</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="o">!=</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="si">}</span><span class="s2">: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;unterminated string literal&quot;</span>
                <span class="p">)</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>  <span class="c1"># skip backslash</span>
                <span class="n">esc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
                <span class="n">escape_map</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="p">}</span>
                <span class="n">chars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">escape_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">esc</span><span class="p">,</span> <span class="n">esc</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>  <span class="c1"># skip closing &quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_col</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;unterminated string literal&quot;</span>
            <span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chars</span><span class="p">)</span>
        <span class="n">lexeme</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span>
            <span class="p">(</span><span class="n">start_col</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_line</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span>
        <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_token</span><span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">STRING_LIT</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s1">&quot;&#39;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
                               <span class="n">start_line</span><span class="p">,</span> <span class="n">start_col</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">scan_char</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Token</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scan a character literal (single-quoted).&quot;&quot;&quot;</span>
        <span class="n">start_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span>
        <span class="n">start_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>  <span class="c1"># skip opening &#39;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
            <span class="n">esc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;&#39;</span>
            <span class="n">escape_map</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span>
                <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">:</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">escape_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">esc</span><span class="p">,</span> <span class="n">esc</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_col</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;empty character literal&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>  <span class="c1"># skip closing &#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_col</span><span class="si">}</span><span class="s2">: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;unterminated character literal&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_token</span><span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">CHAR_LIT</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span>
                               <span class="n">start_line</span><span class="p">,</span> <span class="n">start_col</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">scan_identifier_or_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Token</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Scan an identifier or keyword.&quot;&quot;&quot;</span>
        <span class="n">start_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span>
        <span class="n">start_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span>
        <span class="n">start_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>

        <span class="k">while</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">)</span> <span class="ow">and</span>
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;_&#39;</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>

        <span class="n">lexeme</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="n">start_pos</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>

        <span class="c1"># Check if it&#39;s a keyword</span>
        <span class="k">if</span> <span class="n">lexeme</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">KEYWORDS</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">KEYWORDS</span><span class="p">[</span><span class="n">lexeme</span><span class="p">],</span> <span class="n">lexeme</span><span class="p">,</span>
                                   <span class="n">line</span><span class="o">=</span><span class="n">start_line</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">start_col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_token</span><span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">IDENT</span><span class="p">,</span> <span class="n">lexeme</span><span class="p">,</span>
                                   <span class="n">line</span><span class="o">=</span><span class="n">start_line</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">start_col</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">next_token</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Token</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the next token from the source.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_whitespace_and_comments</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_token</span><span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">EOF</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>

        <span class="n">start_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span>
        <span class="n">start_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">column</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span>

        <span class="c1"># Numbers</span>
        <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_number</span><span class="p">()</span>

        <span class="c1"># Identifiers and keywords</span>
        <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span> <span class="ow">or</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_identifier_or_keyword</span><span class="p">()</span>

        <span class="c1"># String literals</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_string</span><span class="p">()</span>

        <span class="c1"># Character literals</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s2">&quot;&#39;&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">scan_char</span><span class="p">()</span>

        <span class="c1"># Two-character operators (check before single-char)</span>
        <span class="n">two_char</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">two_char</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">TWO_CHAR_OPS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">TWO_CHAR_OPS</span><span class="p">[</span><span class="n">two_char</span><span class="p">],</span> <span class="n">two_char</span><span class="p">,</span>
                                   <span class="n">line</span><span class="o">=</span><span class="n">start_line</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">start_col</span><span class="p">)</span>

        <span class="c1"># Single-character operators and delimiters</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">SINGLE_CHAR_OPS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_token</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">SINGLE_CHAR_OPS</span><span class="p">[</span><span class="n">ch</span><span class="p">],</span> <span class="n">ch</span><span class="p">,</span>
                                   <span class="n">line</span><span class="o">=</span><span class="n">start_line</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">start_col</span><span class="p">)</span>

        <span class="c1"># Error: unexpected character</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">start_col</span><span class="si">}</span><span class="s2">: &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;unexpected character &#39;</span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">make_token</span><span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">ERROR</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="n">start_line</span><span class="p">,</span> <span class="n">col</span><span class="o">=</span><span class="n">start_col</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Token</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Tokenize the entire source and return a list of tokens.&quot;&quot;&quot;</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_token</span><span class="p">()</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TT</span><span class="o">.</span><span class="n">EOF</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">tokens</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Example usage</span>
<span class="c1"># ============================================================</span>

<span class="n">source_code</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">// Compute factorial iteratively</span>
<span class="s2">int factorial(int n) {</span>
<span class="s2">    int result = 1;</span>
<span class="s2">    for (int i = 2; i &lt;= n; i++) {</span>
<span class="s2">        result *= i;</span>
<span class="s2">    }</span>
<span class="s2">    return result;</span>
<span class="s2">}</span>

<span class="s2">/* Multi-line</span>
<span class="s2">   comment */</span>
<span class="s2">int main() {</span>
<span class="s2">    int x = factorial(10);</span>
<span class="s2">    float pi = 3.14159;</span>
<span class="s2">    char ch = &#39;A&#39;;</span>
<span class="s2">    char newline = &#39;</span><span class="se">\\</span><span class="s2">n&#39;;</span>

<span class="s2">    if (x &gt;= 3628800 &amp;&amp; pi != 0.0) {</span>
<span class="s2">        return 0;</span>
<span class="s2">    } else {</span>
<span class="s2">        return -1;</span>
<span class="s2">    }</span>
<span class="s2">}</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Complete Lexer Demo ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">lexer</span> <span class="o">=</span> <span class="n">Lexer</span><span class="p">(</span><span class="n">source_code</span><span class="p">,</span> <span class="s2">&quot;example.c&quot;</span><span class="p">)</span>
<span class="n">tokens</span> <span class="o">=</span> <span class="n">lexer</span><span class="o">.</span><span class="n">tokenize</span><span class="p">()</span>

<span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">tok</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="n">lexer</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Errors:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="n">lexer</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Tokenization successful: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="si">}</span><span class="s2"> tokens, no errors.&quot;</span><span class="p">)</span>

<span class="c1"># Summary statistics</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Counter</span>
<span class="n">type_counts</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Token type distribution:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">tt</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="n">type_counts</span><span class="o">.</span><span class="n">most_common</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">tt</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">20s</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="9-lexer-generator-specification">9. Lexer Generator Specification<a class="header-link" href="#9-lexer-generator-specification" title="Permanent link">&para;</a></h2>
<p>While hand-written lexers offer maximum control, <strong>lexer generators</strong> (Lex, Flex, PLY) automate the process by taking a specification of token patterns and generating lexer code.</p>
<h3 id="lexflex-specification-format">Lex/Flex Specification Format<a class="header-link" href="#lexflex-specification-format" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="cm">%{</span>
<span class="cm">/* C declarations */</span>
<span class="cm">#include &quot;parser.tab.h&quot;</span>
<span class="cm">%}</span>

<span class="o">/*</span><span class="w"> </span><span class="n">Definitions</span><span class="w"> </span><span class="o">*/</span>
<span class="n">DIGIT</span><span class="w">   </span><span class="s">[0-9]</span>
<span class="n">LETTER</span><span class="w">  </span><span class="s">[a-zA-Z_]</span>
<span class="n">ID</span><span class="w">      </span><span class="s">{LETTER}({LETTER}|{DIGIT})*</span>

<span class="c">%%</span>
<span class="o">/*</span><span class="w"> </span><span class="n">Rules</span><span class="p">:</span><span class="w"> </span><span class="nb">pattern</span><span class="w">    </span><span class="n">action</span><span class="w"> </span><span class="o">*/</span>
<span class="s">&quot;if&quot;</span><span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">KW_IF</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;else&quot;</span><span class="w">          </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">KW_ELSE</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;while&quot;</span><span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">KW_WHILE</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;return&quot;</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">KW_RETURN</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;int&quot;</span><span class="w">           </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">KW_INT</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;float&quot;</span><span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">KW_FLOAT</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="p">{</span><span class="n">DIGIT</span><span class="p">}</span><span class="o">+</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="n">yylval</span><span class="p">.</span><span class="n">ival</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">atoi</span><span class="p">(</span><span class="n">yytext</span><span class="p">);</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">INT_LIT</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">{</span><span class="n">DIGIT</span><span class="p">}</span><span class="o">+</span><span class="s">&quot;.&quot;</span><span class="p">{</span><span class="n">DIGIT</span><span class="p">}</span><span class="o">+</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">yylval</span><span class="p">.</span><span class="n">fval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">atof</span><span class="p">(</span><span class="n">yytext</span><span class="p">);</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">FLOAT_LIT</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="p">{</span><span class="n">ID</span><span class="p">}</span><span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="n">yylval</span><span class="p">.</span><span class="n">sval</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">strdup</span><span class="p">(</span><span class="n">yytext</span><span class="p">);</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">IDENT</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="s">&quot;&lt;=&quot;</span><span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">LEQ</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;&gt;=&quot;</span><span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">GEQ</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;==&quot;</span><span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">EQ</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;!=&quot;</span><span class="w">            </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">NEQ</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="s">&quot;+&quot;</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">PLUS</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;-&quot;</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">MINUS</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;*&quot;</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">STAR</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;/&quot;</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">SLASH</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;=&quot;</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">ASSIGN</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="s">&quot;(&quot;</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">LPAREN</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;)&quot;</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">RPAREN</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;{&quot;</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">LBRACE</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;}&quot;</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">RBRACE</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;;&quot;</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">SEMI</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="s">&quot;,&quot;</span><span class="w">             </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">COMMA</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="s">&quot;//&quot;</span><span class="o">.*</span><span class="w">          </span><span class="p">{</span><span class="w"> </span><span class="o">/*</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="nb">single</span><span class="o">-</span><span class="nb">line</span><span class="w"> </span><span class="n">comment</span><span class="w"> </span><span class="o">*/</span><span class="w"> </span><span class="p">}</span>
<span class="p">[</span><span class="w"> </span><span class="o">\</span><span class="n">t</span><span class="o">\</span><span class="n">r</span><span class="p">]</span><span class="o">+</span><span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="o">/*</span><span class="w"> </span><span class="n">skip</span><span class="w"> </span><span class="n">whitespace</span><span class="w"> </span><span class="o">*/</span><span class="w"> </span><span class="p">}</span>
<span class="o">\</span><span class="n">n</span><span class="w">              </span><span class="p">{</span><span class="w"> </span><span class="n">yylineno</span><span class="o">++</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="p">.</span><span class="w">               </span><span class="p">{</span><span class="w"> </span><span class="nb">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;Unexpected: %s\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">yytext</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="c">%%</span>
</code></pre></div>

<h3 id="ply-python-lex-yacc-specification">PLY (Python Lex-Yacc) Specification<a class="header-link" href="#ply-python-lex-yacc-specification" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Token specification using PLY (Python Lex-Yacc).</span>
<span class="sd">Install: pip install ply</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ply.lex</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">lex</span>

<span class="c1"># List of token names (required by PLY)</span>
<span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s1">&#39;IDENT&#39;</span><span class="p">,</span> <span class="s1">&#39;INT_LIT&#39;</span><span class="p">,</span> <span class="s1">&#39;FLOAT_LIT&#39;</span><span class="p">,</span> <span class="s1">&#39;STRING_LIT&#39;</span><span class="p">,</span>
    <span class="s1">&#39;PLUS&#39;</span><span class="p">,</span> <span class="s1">&#39;MINUS&#39;</span><span class="p">,</span> <span class="s1">&#39;STAR&#39;</span><span class="p">,</span> <span class="s1">&#39;SLASH&#39;</span><span class="p">,</span>
    <span class="s1">&#39;ASSIGN&#39;</span><span class="p">,</span> <span class="s1">&#39;EQ&#39;</span><span class="p">,</span> <span class="s1">&#39;NEQ&#39;</span><span class="p">,</span> <span class="s1">&#39;LT&#39;</span><span class="p">,</span> <span class="s1">&#39;GT&#39;</span><span class="p">,</span> <span class="s1">&#39;LEQ&#39;</span><span class="p">,</span> <span class="s1">&#39;GEQ&#39;</span><span class="p">,</span>
    <span class="s1">&#39;LPAREN&#39;</span><span class="p">,</span> <span class="s1">&#39;RPAREN&#39;</span><span class="p">,</span> <span class="s1">&#39;LBRACE&#39;</span><span class="p">,</span> <span class="s1">&#39;RBRACE&#39;</span><span class="p">,</span>
    <span class="s1">&#39;SEMI&#39;</span><span class="p">,</span> <span class="s1">&#39;COMMA&#39;</span><span class="p">,</span>
<span class="p">]</span>

<span class="c1"># Reserved words</span>
<span class="n">reserved</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;if&#39;</span><span class="p">:</span>     <span class="s1">&#39;KW_IF&#39;</span><span class="p">,</span>
    <span class="s1">&#39;else&#39;</span><span class="p">:</span>   <span class="s1">&#39;KW_ELSE&#39;</span><span class="p">,</span>
    <span class="s1">&#39;while&#39;</span><span class="p">:</span>  <span class="s1">&#39;KW_WHILE&#39;</span><span class="p">,</span>
    <span class="s1">&#39;for&#39;</span><span class="p">:</span>    <span class="s1">&#39;KW_FOR&#39;</span><span class="p">,</span>
    <span class="s1">&#39;return&#39;</span><span class="p">:</span> <span class="s1">&#39;KW_RETURN&#39;</span><span class="p">,</span>
    <span class="s1">&#39;int&#39;</span><span class="p">:</span>    <span class="s1">&#39;KW_INT&#39;</span><span class="p">,</span>
    <span class="s1">&#39;float&#39;</span><span class="p">:</span>  <span class="s1">&#39;KW_FLOAT&#39;</span><span class="p">,</span>
    <span class="s1">&#39;void&#39;</span><span class="p">:</span>   <span class="s1">&#39;KW_VOID&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="n">tokens</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="n">reserved</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

<span class="c1"># Simple tokens (single characters)</span>
<span class="n">t_PLUS</span>    <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\+&#39;</span>
<span class="n">t_MINUS</span>   <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;-&#39;</span>
<span class="n">t_STAR</span>    <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\*&#39;</span>
<span class="n">t_SLASH</span>   <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;/&#39;</span>
<span class="n">t_ASSIGN</span>  <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;=&#39;</span>
<span class="n">t_LPAREN</span>  <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\(&#39;</span>
<span class="n">t_RPAREN</span>  <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\)&#39;</span>
<span class="n">t_LBRACE</span>  <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\{&#39;</span>
<span class="n">t_RBRACE</span>  <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\}&#39;</span>
<span class="n">t_SEMI</span>    <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;;&#39;</span>
<span class="n">t_COMMA</span>   <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;,&#39;</span>

<span class="c1"># Multi-character operators (functions, checked before simple tokens)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">t_LEQ</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;&lt;=&#39;</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">t_GEQ</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;&gt;=&#39;</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">t_EQ</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;==&#39;</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">t_NEQ</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;!=&#39;</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">t_LT</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;&lt;&#39;</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">t_GT</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;&gt;&#39;</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="c1"># Float literal (must be before INT_LIT)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">t_FLOAT_LIT</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;\d+\.\d+([eE][+-]?\d+)?&#39;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="c1"># Integer literal</span>
<span class="k">def</span><span class="w"> </span><span class="nf">t_INT_LIT</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;\d+&#39;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="c1"># String literal</span>
<span class="k">def</span><span class="w"> </span><span class="nf">t_STRING_LIT</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;&quot;[^&quot;</span><span class="se">\\</span><span class="s1">]*(</span><span class="se">\\</span><span class="s1">.[^&quot;</span><span class="se">\\</span><span class="s1">]*)*&quot;&#39;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># Strip quotes</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="c1"># Identifier (and keyword check)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">t_IDENT</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;[a-zA-Z_][a-zA-Z0-9_]*&#39;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">reserved</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39;IDENT&#39;</span><span class="p">)</span>  <span class="c1"># Check for keywords</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="c1"># Track line numbers</span>
<span class="k">def</span><span class="w"> </span><span class="nf">t_newline</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;\n+&#39;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">lineno</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># Ignored characters (whitespace)</span>
<span class="n">t_ignore</span> <span class="o">=</span> <span class="s1">&#39; </span><span class="se">\t\r</span><span class="s1">&#39;</span>

<span class="c1"># Comments</span>
<span class="k">def</span><span class="w"> </span><span class="nf">t_COMMENT</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;//[^\n]*&#39;</span>
    <span class="k">pass</span>  <span class="c1"># Discard</span>

<span class="k">def</span><span class="w"> </span><span class="nf">t_BLOCK_COMMENT</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;/\*[\s\S]*?\*/&#39;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">lineno</span> <span class="o">+=</span> <span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

<span class="c1"># Error handling</span>
<span class="k">def</span><span class="w"> </span><span class="nf">t_error</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Illegal character &#39;</span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; at line </span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">lineno</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Build the lexer</span>
<span class="n">lexer</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">lex</span><span class="p">()</span>

<span class="c1"># Test it</span>
<span class="n">lexer</span><span class="o">.</span><span class="n">input</span><span class="p">(</span><span class="s2">&quot;int x = 42 + y * 3.14;&quot;</span><span class="p">)</span>
<span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
    <span class="n">tok</span> <span class="o">=</span> <span class="n">lexer</span><span class="o">.</span><span class="n">token</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">tok</span><span class="p">:</span>
        <span class="k">break</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="10-handling-special-cases">10. Handling Special Cases<a class="header-link" href="#10-handling-special-cases" title="Permanent link">&para;</a></h2>
<h3 id="string-literals-with-escapes">String Literals with Escapes<a class="header-link" href="#string-literals-with-escapes" title="Permanent link">&para;</a></h3>
<p>String scanning requires handling escape sequences, which makes the pattern context-sensitive at the character level:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">scan_string_literal</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Scan a string literal starting at pos (which should be &#39;&quot;&#39;).</span>
<span class="sd">    Returns (raw_lexeme, processed_value, new_pos).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># skip opening quote</span>
    <span class="n">chars</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">ESCAPE_MAP</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\r</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">,</span>
        <span class="s1">&#39;0&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\0</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\a</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\b</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\f</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="s1">&#39;v&#39;</span><span class="p">:</span> <span class="s1">&#39;</span><span class="se">\v</span><span class="s1">&#39;</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;&quot;&#39;</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># skip closing quote</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chars</span><span class="p">),</span> <span class="n">pos</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">LexerError</span><span class="p">(</span><span class="s2">&quot;Unterminated escape in string&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">esc</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">esc</span> <span class="ow">in</span> <span class="n">ESCAPE_MAP</span><span class="p">:</span>
                <span class="n">chars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ESCAPE_MAP</span><span class="p">[</span><span class="n">esc</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">esc</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                <span class="c1"># Hex escape: \xNN</span>
                <span class="n">hex_str</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>
                <span class="n">chars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hex_str</span><span class="p">,</span> <span class="mi">16</span><span class="p">)))</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="n">esc</span> <span class="o">==</span> <span class="s1">&#39;u&#39;</span><span class="p">:</span>
                <span class="c1"># Unicode escape: \uNNNN</span>
                <span class="n">hex_str</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="mi">5</span><span class="p">]</span>
                <span class="n">chars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">hex_str</span><span class="p">,</span> <span class="mi">16</span><span class="p">)))</span>
                <span class="n">pos</span> <span class="o">+=</span> <span class="mi">4</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">chars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">esc</span><span class="p">)</span>  <span class="c1"># Unknown escape, keep literal</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">LexerError</span><span class="p">(</span><span class="s2">&quot;Unterminated string (newline)&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">raise</span> <span class="n">LexerError</span><span class="p">(</span><span class="s2">&quot;Unterminated string (EOF)&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<h3 id="multi-line-strings">Multi-Line Strings<a class="header-link" href="#multi-line-strings" title="Permanent link">&para;</a></h3>
<p>Some languages support multi-line strings:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">scan_multiline_string</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Scan a triple-quoted string (Python-style).&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">pos</span>
    <span class="n">pos</span> <span class="o">+=</span> <span class="mi">3</span>  <span class="c1"># skip opening &quot;&quot;&quot;</span>

    <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;&quot;&quot;&quot;&#39;</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">3</span>
            <span class="n">raw</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">pos</span><span class="p">]</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">raw</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>  <span class="c1"># strip quotes</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">raw</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
        <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">raise</span> <span class="n">LexerError</span><span class="p">(</span><span class="s2">&quot;Unterminated multi-line string&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<h3 id="nested-comments">Nested Comments<a class="header-link" href="#nested-comments" title="Permanent link">&para;</a></h3>
<p>Some languages (Haskell, Swift, Rust) support nested comments:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">skip_nested_comment</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Skip a nested block comment /* ... /* ... */ ... */&quot;&quot;&quot;</span>
    <span class="k">assert</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;/*&#39;</span>
    <span class="n">pos</span> <span class="o">+=</span> <span class="mi">2</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">while</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;/*&#39;</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="n">source</span><span class="p">[</span><span class="n">pos</span><span class="p">:</span><span class="n">pos</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;*/&#39;</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">LexerError</span><span class="p">(</span><span class="s2">&quot;Unterminated nested comment&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">pos</span>
</code></pre></div>

<h3 id="significant-whitespace-python-style-indentation">Significant Whitespace (Python-style Indentation)<a class="header-link" href="#significant-whitespace-python-style-indentation" title="Permanent link">&para;</a></h3>
<p>Python's lexer generates <code>INDENT</code> and <code>DEDENT</code> tokens based on whitespace changes:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">tokenize_with_indentation</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Token</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tokenize with Python-style indentation handling.</span>
<span class="sd">    Generates INDENT and DEDENT tokens.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">indent_stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Stack of indentation levels</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">line_no</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
        <span class="c1"># Skip blank lines</span>
        <span class="n">stripped</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">stripped</span> <span class="ow">or</span> <span class="n">stripped</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># Calculate indentation level</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">stripped</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">indent</span> <span class="o">&gt;</span> <span class="n">indent_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">indent_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indent</span><span class="p">)</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Token</span><span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">IDENT</span><span class="p">,</span> <span class="s2">&quot;&lt;INDENT&gt;&quot;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="n">line_no</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">while</span> <span class="n">indent</span> <span class="o">&lt;</span> <span class="n">indent_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">indent_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Token</span><span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">IDENT</span><span class="p">,</span> <span class="s2">&quot;&lt;DEDENT&gt;&quot;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="n">line_no</span><span class="p">,</span> <span class="n">column</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">indent</span> <span class="o">!=</span> <span class="n">indent_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">LexerError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Inconsistent indentation at line </span><span class="si">{</span><span class="n">line_no</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">line_no</span><span class="p">,</span> <span class="mi">1</span>
                <span class="p">)</span>

        <span class="c1"># Tokenize the rest of the line normally</span>
        <span class="c1"># (omitted for brevity -- use the main lexer)</span>

    <span class="c1"># Emit remaining DEDENTs</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">indent_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">indent_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Token</span><span class="p">(</span><span class="n">TT</span><span class="o">.</span><span class="n">IDENT</span><span class="p">,</span> <span class="s2">&quot;&lt;DEDENT&gt;&quot;</span><span class="p">,</span> <span class="n">line</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">lines</span><span class="p">),</span> <span class="n">column</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">tokens</span>
</code></pre></div>

<hr />
<h2 id="11-performance-considerations">11. Performance Considerations<a class="header-link" href="#11-performance-considerations" title="Permanent link">&para;</a></h2>
<h3 id="table-driven-vs-direct-coded-lexers">Table-Driven vs. Direct-Coded Lexers<a class="header-link" href="#table-driven-vs-direct-coded-lexers" title="Permanent link">&para;</a></h3>
<p><strong>Table-driven</strong> (generated by Lex/Flex):
- Transition table stored as a 2D array: <code>next_state = table[state][char]</code>
- Compact, easy to generate
- Indirect memory access on every character</p>
<p><strong>Direct-coded</strong> (hand-written or re2c):
- Transitions encoded as <code>switch</code> statements or <code>goto</code> chains
- Faster: branch prediction works better, no table lookup
- Larger code size</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Table-driven (simplified)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">state</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">-1</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">table</span><span class="p">[</span><span class="n">state</span><span class="p">][</span><span class="n">c</span><span class="p">];</span><span class="w">  </span><span class="c1">// indirect lookup</span>
<span class="p">}</span>

<span class="c1">// Direct-coded</span>
<span class="nl">s0</span><span class="p">:</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">*</span><span class="n">input</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="sc">&#39;a&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;z&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">goto</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="sc">&#39;0&#39;</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="sc">&#39;9&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">goto</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="n">error</span><span class="p">;</span>
<span class="nl">s1</span><span class="p">:</span>
<span class="w">    </span><span class="p">...</span>
</code></pre></div>

<p><strong>re2c</strong> generates direct-coded lexers and is typically 2-3x faster than Flex.</p>
<h3 id="buffer-management">Buffer Management<a class="header-link" href="#buffer-management" title="Permanent link">&para;</a></h3>
<p>Reading one character at a time from the file system is slow. Lexers use <strong>double buffering</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="nb">+-----------------------------------+-----------------------------------+</span>
<span class="c">| Buffer 1 (4096 bytes)             | Buffer 2 (4096 bytes)             |</span>
<span class="nb">+-----------------------------------+-----------------------------------+</span>
<span class="c">                    ^                                    ^</span>
<span class="c">                lexeme_begin                          forward</span>

<span class="c">When forward reaches the end of Buffer 1</span><span class="nt">,</span><span class="c"> load next block into Buffer 2</span><span class="nt">.</span>
<span class="c">When forward reaches the end of Buffer 2</span><span class="nt">,</span><span class="c"> load next block into Buffer 1</span><span class="nt">.</span>
</code></pre></div>

<p>This is called the <strong>sentinel</strong> technique: place a special EOF character at the end of each buffer so the main scanning loop doesn't need a bounds check on every character.</p>
<hr />
<h2 id="summary">Summary<a class="header-link" href="#summary" title="Permanent link">&para;</a></h2>
<ul>
<li>The <strong>lexer</strong> is the first phase of compilation, transforming characters into tokens</li>
<li><strong>Tokens</strong> have a type and an optional attribute value; <strong>lexemes</strong> are the actual text; <strong>patterns</strong> are the rules</li>
<li>Token patterns are specified using <strong>regular expressions</strong>, which support union, concatenation, and Kleene star</li>
<li><strong>Thompson's construction</strong> converts a regex to an NFA in $O(n)$ time and space</li>
<li><strong>Subset construction</strong> converts an NFA to a DFA; worst case $2^n$ states, but usually much fewer</li>
<li><strong>Hopcroft's algorithm</strong> minimizes the DFA in $O(n \log n)$ time</li>
<li>The <strong>longest match rule</strong> ensures the lexer always returns the longest possible token</li>
<li><strong>Priority rules</strong> resolve ties between patterns (keywords before identifiers)</li>
<li>Hand-written lexers offer flexibility; lexer generators (Lex, Flex, PLY) offer convenience</li>
<li>Special cases include string escapes, nested comments, and significant whitespace</li>
</ul>
<hr />
<h2 id="exercises">Exercises<a class="header-link" href="#exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-regular-expressions">Exercise 1: Regular Expressions<a class="header-link" href="#exercise-1-regular-expressions" title="Permanent link">&para;</a></h3>
<p>Write regular expressions for each of the following:</p>
<ol>
<li>Binary strings with an even number of 0's</li>
<li>C-style identifiers that start with an underscore</li>
<li>Email addresses (simplified: <code>name@domain.tld</code>)</li>
<li>Floating-point numbers in scientific notation (e.g., <code>1.5e-3</code>, <code>-2.0E+10</code>)</li>
<li>C-style comments: <code>/* ... */</code> (non-nested)</li>
</ol>
<h3 id="exercise-2-thompsons-construction">Exercise 2: Thompson's Construction<a class="header-link" href="#exercise-2-thompsons-construction" title="Permanent link">&para;</a></h3>
<p>Apply Thompson's construction to the regex <code>a(b|c)*d</code>. Draw the NFA (label all states). Then simulate the NFA on the inputs:
- <code>"ad"</code> -- should it accept?
- <code>"abcd"</code> -- should it accept?
- <code>"abbd"</code> -- should it accept?
- <code>"abc"</code> -- should it accept?</p>
<h3 id="exercise-3-subset-construction">Exercise 3: Subset Construction<a class="header-link" href="#exercise-3-subset-construction" title="Permanent link">&para;</a></h3>
<p>Given the NFA from Exercise 2, apply the subset construction algorithm. Show the DFA transition table. How many states does the resulting DFA have?</p>
<h3 id="exercise-4-lexer-extension">Exercise 4: Lexer Extension<a class="header-link" href="#exercise-4-lexer-extension" title="Permanent link">&para;</a></h3>
<p>Extend the complete lexer in Section 8 to handle:
1. Hexadecimal integer literals (e.g., <code>0xFF</code>, <code>0x1A3</code>)
2. Octal integer literals (e.g., <code>0o77</code>, <code>0o12</code>)
3. Binary integer literals (e.g., <code>0b1010</code>, <code>0b11001</code>)
4. Numeric separators for readability (e.g., <code>1_000_000</code>, <code>0xFF_FF</code>)</p>
<h3 id="exercise-5-error-recovery">Exercise 5: Error Recovery<a class="header-link" href="#exercise-5-error-recovery" title="Permanent link">&para;</a></h3>
<p>Design and implement an error recovery strategy for the lexer that:
1. Reports unterminated string literals with the line number where the string started
2. Suggests corrections for common typos (e.g., <code>retrun</code> -&gt; <code>return</code>)
3. Groups consecutive illegal characters into a single error message rather than reporting each one individually</p>
<h3 id="exercise-6-performance-comparison">Exercise 6: Performance Comparison<a class="header-link" href="#exercise-6-performance-comparison" title="Permanent link">&para;</a></h3>
<p>Implement a simple benchmark that:
1. Generates a large (1MB+) source file with random tokens
2. Tokenizes it using the hand-written lexer from Section 8
3. Tokenizes it using Python's <code>re</code> module with a combined regex
4. Compare the tokenization times and verify both produce the same tokens</p>
<hr />
<p><a href="./01_Introduction_to_Compilers.md">Previous: Introduction to Compilers</a> | <a href="./03_Finite_Automata.md">Next: Finite Automata</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/01_Introduction_to_Compilers.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 1: Introduction to Compilers</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/03_Finite_Automata.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 3: Finite Automata</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}