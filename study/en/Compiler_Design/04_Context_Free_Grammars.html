{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 4: Context-Free Grammars - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Lesson 4: Context-Free Grammars</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 4: Context-Free Grammars</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/03_Finite_Automata.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 3: Finite Automata</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/05_Top_Down_Parsing.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 5: Top-Down Parsing</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#learning-objectives">Learning Objectives</a></li>
<li><a href="#1-formal-definition-of-a-context-free-grammar">1. Formal Definition of a Context-Free Grammar</a><ul>
<li><a href="#notation-conventions">Notation Conventions</a></li>
<li><a href="#example-cfg">Example CFG</a></li>
<li><a href="#derivation">Derivation</a></li>
<li><a href="#language-of-a-grammar">Language of a Grammar</a></li>
<li><a href="#python-representation">Python Representation</a></li>
</ul>
</li>
<li><a href="#2-bnf-and-ebnf-notation">2. BNF and EBNF Notation</a><ul>
<li><a href="#backus-naur-form-bnf">Backus-Naur Form (BNF)</a></li>
<li><a href="#extended-bnf-ebnf">Extended BNF (EBNF)</a></li>
<li><a href="#ebnf-to-bnf-conversion">EBNF to BNF Conversion</a></li>
<li><a href="#python-implementation">Python Implementation</a></li>
</ul>
</li>
<li><a href="#3-derivations">3. Derivations</a><ul>
<li><a href="#leftmost-derivation">Leftmost Derivation</a></li>
<li><a href="#rightmost-derivation">Rightmost Derivation</a></li>
<li><a href="#why-derivation-order-matters">Why Derivation Order Matters</a></li>
<li><a href="#python-implementation_1">Python Implementation</a></li>
</ul>
</li>
<li><a href="#4-parse-trees">4. Parse Trees</a><ul>
<li><a href="#definition">Definition</a></li>
<li><a href="#example-parse-tree">Example Parse Tree</a></li>
<li><a href="#relationship-to-derivations">Relationship to Derivations</a></li>
<li><a href="#python-implementation_2">Python Implementation</a></li>
</ul>
</li>
<li><a href="#5-ambiguity">5. Ambiguity</a><ul>
<li><a href="#definition_1">Definition</a></li>
<li><a href="#example-of-an-ambiguous-grammar">Example of an Ambiguous Grammar</a></li>
<li><a href="#why-ambiguity-matters">Why Ambiguity Matters</a></li>
<li><a href="#inherent-ambiguity">Inherent Ambiguity</a></li>
<li><a href="#detecting-ambiguity">Detecting Ambiguity</a></li>
</ul>
</li>
<li><a href="#6-resolving-ambiguity">6. Resolving Ambiguity</a><ul>
<li><a href="#strategy-1-operator-precedence">Strategy 1: Operator Precedence</a></li>
<li><a href="#strategy-2-associativity">Strategy 2: Associativity</a></li>
<li><a href="#strategy-3-disambiguation-rules-external">Strategy 3: Disambiguation Rules (External)</a></li>
<li><a href="#strategy-4-the-dangling-else-problem">Strategy 4: The Dangling Else Problem</a></li>
<li><a href="#python-example-resolving-ambiguity">Python Example: Resolving Ambiguity</a></li>
</ul>
</li>
<li><a href="#7-chomsky-normal-form-cnf">7. Chomsky Normal Form (CNF)</a><ul>
<li><a href="#why-cnf-matters">Why CNF Matters</a></li>
<li><a href="#conversion-to-cnf">Conversion to CNF</a></li>
<li><a href="#python-implementation_3">Python Implementation</a></li>
</ul>
</li>
<li><a href="#8-greibach-normal-form-gnf">8. Greibach Normal Form (GNF)</a><ul>
<li><a href="#properties">Properties</a></li>
<li><a href="#comparison-of-normal-forms">Comparison of Normal Forms</a></li>
</ul>
</li>
<li><a href="#9-the-cyk-algorithm">9. The CYK Algorithm</a><ul>
<li><a href="#algorithm">Algorithm</a></li>
<li><a href="#worked-example">Worked Example</a></li>
<li><a href="#python-implementation_4">Python Implementation</a></li>
</ul>
</li>
<li><a href="#10-pushdown-automata-overview">10. Pushdown Automata (Overview)</a><ul>
<li><a href="#formal-definition">Formal Definition</a></li>
<li><a href="#how-a-pda-works">How a PDA Works</a></li>
<li><a href="#equivalence-with-cfgs">Equivalence with CFGs</a></li>
<li><a href="#python-simple-pda-simulation">Python: Simple PDA Simulation</a></li>
</ul>
</li>
<li><a href="#11-the-pumping-lemma-for-context-free-languages">11. The Pumping Lemma for Context-Free Languages</a><ul>
<li><a href="#statement">Statement</a></li>
<li><a href="#proof-idea">Proof Idea</a></li>
<li><a href="#using-the-cfl-pumping-lemma">Using the CFL Pumping Lemma</a></li>
<li><a href="#example-latex201-is-not-context-free">Example:  LATEX201  Is Not Context-Free</a></li>
<li><a href="#languages-beyond-context-free">Languages Beyond Context-Free</a></li>
</ul>
</li>
<li><a href="#12-the-chomsky-hierarchy">12. The Chomsky Hierarchy</a><ul>
<li><a href="#relevance-to-compiler-design">Relevance to Compiler Design</a></li>
</ul>
</li>
<li><a href="#13-grammar-transformations">13. Grammar Transformations</a><ul>
<li><a href="#eliminating-left-recursion">Eliminating Left Recursion</a></li>
<li><a href="#left-factoring">Left Factoring</a></li>
<li><a href="#python-implementation_5">Python Implementation</a></li>
</ul>
</li>
<li><a href="#summary">Summary</a></li>
<li><a href="#exercises">Exercises</a><ul>
<li><a href="#exercise-1-grammar-writing">Exercise 1: Grammar Writing</a></li>
<li><a href="#exercise-2-derivations-and-parse-trees">Exercise 2: Derivations and Parse Trees</a></li>
<li><a href="#exercise-3-ambiguity-analysis">Exercise 3: Ambiguity Analysis</a></li>
<li><a href="#exercise-4-cnf-conversion">Exercise 4: CNF Conversion</a></li>
<li><a href="#exercise-5-cyk-algorithm">Exercise 5: CYK Algorithm</a></li>
<li><a href="#exercise-6-pumping-lemma">Exercise 6: Pumping Lemma</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-4-context-free-grammars">Lesson 4: Context-Free Grammars<a class="header-link" href="#lesson-4-context-free-grammars" title="Permanent link">&para;</a></h1>
<h2 id="learning-objectives">Learning Objectives<a class="header-link" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<p>After completing this lesson, you will be able to:</p>
<ol>
<li>Give the formal definition of a context-free grammar (CFG)</li>
<li>Use BNF and EBNF notation to write grammars</li>
<li>Construct leftmost and rightmost derivations for a given string</li>
<li>Build parse trees and understand their relationship to derivations</li>
<li>Identify and resolve ambiguity in grammars</li>
<li>Convert grammars to Chomsky Normal Form (CNF) and Greibach Normal Form (GNF)</li>
<li>Apply the CYK parsing algorithm</li>
<li>Understand the connection between CFGs and pushdown automata</li>
<li>Apply the pumping lemma for context-free languages</li>
<li>Implement grammar manipulation and CYK parsing in Python</li>
</ol>
<hr />
<h2 id="1-formal-definition-of-a-context-free-grammar">1. Formal Definition of a Context-Free Grammar<a class="header-link" href="#1-formal-definition-of-a-context-free-grammar" title="Permanent link">&para;</a></h2>
<p>A <strong>context-free grammar (CFG)</strong> is a 4-tuple:</p>
<p>$$G = (V, \Sigma, P, S)$$</p>
<p>where:</p>
<ul>
<li>$V$ is a finite set of <strong>variables</strong> (also called <strong>nonterminals</strong>)</li>
<li>$\Sigma$ is a finite set of <strong>terminal symbols</strong> (the alphabet), with $V \cap \Sigma = \emptyset$</li>
<li>$P$ is a finite set of <strong>productions</strong> (rules), each of the form $A \rightarrow \alpha$ where $A \in V$ and $\alpha \in (V \cup \Sigma)^*$</li>
<li>$S \in V$ is the <strong>start symbol</strong></li>
</ul>
<h3 id="notation-conventions">Notation Conventions<a class="header-link" href="#notation-conventions" title="Permanent link">&para;</a></h3>
<p>Throughout this lesson, we use:</p>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Represents</th>
</tr>
</thead>
<tbody>
<tr>
<td>$A, B, C, S$</td>
<td>Variables (nonterminals), uppercase</td>
</tr>
<tr>
<td>$a, b, c$</td>
<td>Terminals, lowercase</td>
</tr>
<tr>
<td>$\alpha, \beta, \gamma$</td>
<td>Strings in $(V \cup \Sigma)^*$</td>
</tr>
<tr>
<td>$w, x, y, z$</td>
<td>Strings in $\Sigma^*$ (terminal strings)</td>
</tr>
<tr>
<td>$\epsilon$</td>
<td>The empty string</td>
</tr>
</tbody>
</table>
<h3 id="example-cfg">Example CFG<a class="header-link" href="#example-cfg" title="Permanent link">&para;</a></h3>
<p>A grammar for simple arithmetic expressions:</p>
<p>$$G = (\{E, T, F\}, \{+, *, (, ), \texttt{id}\}, P, E)$$</p>
<p>Productions $P$:</p>
<p>$$E \rightarrow E + T \mid T$$
$$T \rightarrow T * F \mid F$$
$$F \rightarrow (E) \mid \texttt{id}$$</p>
<p>This grammar defines the language of arithmetic expressions with <code>+</code>, <code>*</code>, parentheses, and identifiers, respecting the conventional precedence (<code>*</code> binds tighter than <code>+</code>).</p>
<h3 id="derivation">Derivation<a class="header-link" href="#derivation" title="Permanent link">&para;</a></h3>
<p>A <strong>derivation</strong> is a sequence of steps that transforms the start symbol into a string of terminals by repeatedly replacing a variable with the right-hand side of one of its productions.</p>
<p>If $A \rightarrow \beta$ is a production and $\alpha A \gamma$ is a sentential form, then:</p>
<p>$$\alpha A \gamma \Rightarrow \alpha \beta \gamma$$</p>
<p>We write $\alpha \xRightarrow{*} \beta$ for zero or more derivation steps.</p>
<h3 id="language-of-a-grammar">Language of a Grammar<a class="header-link" href="#language-of-a-grammar" title="Permanent link">&para;</a></h3>
<p>The <strong>language</strong> generated by $G$ is:</p>
<p>$$L(G) = \{w \in \Sigma^* \mid S \xRightarrow{*} w\}$$</p>
<p>The set of all terminal strings derivable from the start symbol.</p>
<h3 id="python-representation">Python Representation<a class="header-link" href="#python-representation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Optional</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Production</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A grammar production A -&gt; symbols.&quot;&quot;&quot;</span>
    <span class="n">head</span><span class="p">:</span> <span class="nb">str</span>                 <span class="c1"># Left-hand side (nonterminal)</span>
    <span class="n">body</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>     <span class="c1"># Right-hand side (tuple of symbols)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">body_str</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="k">else</span> <span class="s1">&#39;Œµ&#39;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">body_str</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Production</span><span class="p">)</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">head</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Grammar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Context-Free Grammar.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">terminals</span><span class="p">:</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
                 <span class="n">productions</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Production</span><span class="p">],</span> <span class="n">start</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">variables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span> <span class="o">=</span> <span class="n">terminals</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">productions</span> <span class="o">=</span> <span class="n">productions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>

        <span class="c1"># Index productions by head</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prod_index</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Production</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">prod_index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">grammar_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s1">&#39;Grammar&#39;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse a grammar from a multi-line string.</span>
<span class="sd">        Format: &#39;A -&gt; Œ± | Œ≤ | Œ≥&#39; (one nonterminal per line).</span>
<span class="sd">        Nonterminals are uppercase single letters or quoted names.</span>
<span class="sd">        Use &#39;Œµ&#39; or &#39;epsilon&#39; for epsilon productions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">terminals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">productions</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">grammar_str</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span> <span class="ow">or</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="n">head</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">body_str</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;-&gt;&#39;</span><span class="p">)</span>
            <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">head</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">alt</span> <span class="ow">in</span> <span class="n">body_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;|&#39;</span><span class="p">):</span>
                <span class="n">alt</span> <span class="o">=</span> <span class="n">alt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">alt</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="s1">&#39;epsilon&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">):</span>
                    <span class="n">productions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="p">()))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">symbols</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">alt</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
                    <span class="n">productions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">symbols</span><span class="p">))</span>

        <span class="c1"># Infer terminals</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                    <span class="n">terminals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">productions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">head</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">terminals</span><span class="p">,</span> <span class="n">productions</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;Grammar(start=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
            <span class="n">prods</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">prod_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">bodies</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span> <span class="k">else</span> <span class="s1">&#39;Œµ&#39;</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="s1">&#39; | &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bodies</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_terminal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span>


<span class="c1"># Example: Arithmetic expression grammar</span>
<span class="n">expr_grammar</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">E -&gt; E + T | T</span>
<span class="s2">T -&gt; T * F | F</span>
<span class="s2">F -&gt; ( E ) | id</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">expr_grammar</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="2-bnf-and-ebnf-notation">2. BNF and EBNF Notation<a class="header-link" href="#2-bnf-and-ebnf-notation" title="Permanent link">&para;</a></h2>
<h3 id="backus-naur-form-bnf">Backus-Naur Form (BNF)<a class="header-link" href="#backus-naur-form-bnf" title="Permanent link">&para;</a></h3>
<p><strong>BNF</strong> (Backus-Naur Form), introduced by John Backus for the ALGOL 60 report, is the standard notation for context-free grammars.</p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="nc">expression</span><span class="p">&gt;</span>  <span class="o">::=</span> <span class="p">&lt;</span><span class="nc">expression</span><span class="p">&gt;</span> &quot;+&quot; <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> | <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span>        <span class="o">::=</span> <span class="p">&lt;</span><span class="nc">term</span><span class="p">&gt;</span> &quot;*&quot; <span class="p">&lt;</span><span class="nc">factor</span><span class="p">&gt;</span> | <span class="p">&lt;</span><span class="nc">factor</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">factor</span><span class="p">&gt;</span>      <span class="o">::=</span> &quot;(&quot; <span class="p">&lt;</span><span class="nc">expression</span><span class="p">&gt;</span> &quot;)&quot; | <span class="p">&lt;</span><span class="nc">identifier</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">identifier</span><span class="p">&gt;</span>  <span class="o">::=</span> <span class="p">&lt;</span><span class="nc">letter</span><span class="p">&gt;</span> | <span class="p">&lt;</span><span class="nc">identifier</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nc">letter</span><span class="p">&gt;</span> | <span class="p">&lt;</span><span class="nc">identifier</span><span class="p">&gt;</span> <span class="p">&lt;</span><span class="nc">digit</span><span class="p">&gt;</span>
<span class="p">&lt;</span><span class="nc">letter</span><span class="p">&gt;</span>      <span class="o">::=</span> &quot;a&quot; | &quot;b&quot; | ... | &quot;z&quot;
<span class="p">&lt;</span><span class="nc">digit</span><span class="p">&gt;</span>       <span class="o">::=</span> &quot;0&quot; | &quot;1&quot; | ... | &quot;9&quot;
</code></pre></div>

<p>BNF conventions:
- Nonterminals are enclosed in angle brackets: <code>&lt;expression&gt;</code>
- Terminals are enclosed in quotes: <code>"+"</code>
- <code>::=</code> means "is defined as"
- <code>|</code> separates alternatives
- Each rule defines one nonterminal</p>
<h3 id="extended-bnf-ebnf">Extended BNF (EBNF)<a class="header-link" href="#extended-bnf-ebnf" title="Permanent link">&para;</a></h3>
<p><strong>EBNF</strong> adds convenience notation to BNF, reducing the number of rules needed:</p>
<table>
<thead>
<tr>
<th>EBNF Notation</th>
<th>Meaning</th>
<th>BNF Equivalent</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>{X}</code> or <code>X*</code></td>
<td>Zero or more repetitions of X</td>
<td>New nonterminal with recursion</td>
</tr>
<tr>
<td><code>[X]</code> or <code>X?</code></td>
<td>Optional (zero or one)</td>
<td>New nonterminal with epsilon alternative</td>
</tr>
<tr>
<td><code>(X \| Y)</code></td>
<td>Grouping</td>
<td>New nonterminal</td>
</tr>
<tr>
<td><code>X+</code></td>
<td>One or more repetitions</td>
<td>New nonterminal with recursion</td>
</tr>
</tbody>
</table>
<p><strong>Example</strong>: The expression grammar in EBNF:</p>
<div class="highlight"><pre><span></span><code><span class="k">expression </span><span class="o">=</span> <span class="k">term </span><span class="p">{</span> <span class="s2">&quot;+&quot;</span> <span class="k">term </span><span class="p">}</span> <span class="p">.</span>
<span class="k">term       </span><span class="o">=</span> <span class="k">factor </span><span class="p">{</span> <span class="s2">&quot;*&quot;</span> <span class="k">factor </span><span class="p">}</span> <span class="p">.</span>
<span class="k">factor     </span><span class="o">=</span> <span class="s2">&quot;(&quot;</span> <span class="k">expression </span><span class="s2">&quot;)&quot;</span> <span class="p">|</span> <span class="k">identifier </span><span class="p">.</span>
<span class="k">identifier </span><span class="o">=</span> <span class="k">letter </span><span class="p">{</span> <span class="k">letter </span><span class="p">|</span> <span class="k">digit </span><span class="p">}</span> <span class="p">.</span>
</code></pre></div>

<p>This is more concise because repetition (<code>{...}</code>) replaces explicit recursion.</p>
<h3 id="ebnf-to-bnf-conversion">EBNF to BNF Conversion<a class="header-link" href="#ebnf-to-bnf-conversion" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">EBNF</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">Œ±</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="err">Œ≤</span><span class="w"> </span><span class="o">}</span><span class="w"> </span><span class="err">Œ≥</span><span class="w"> </span><span class="o">.</span>
<span class="n">BNF</span><span class="o">:</span><span class="w">  </span><span class="n">A</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="w"> </span><span class="n">A</span><span class="s1">&#39; Œ≥</span>
<span class="s1">      A&#39;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ≤</span><span class="w"> </span><span class="n">A</span><span class="s1">&#39; | Œµ</span>

<span class="s1">EBNF: A = Œ± [ Œ≤ ] Œ≥ .</span>
<span class="s1">BNF:  A -&gt; Œ± Œ≤ Œ≥ | Œ± Œ≥</span>

<span class="s1">EBNF: A = Œ± ( Œ≤ | Œ≥ ) Œ¥ .</span>
<span class="s1">BNF:  A  -&gt; Œ± A&#39;</span><span class="w"> </span><span class="err">Œ¥</span>
<span class="w">      </span><span class="n">A</span><span class="err">&#39;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ≤</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="err">Œ≥</span>
</code></pre></div>

<h3 id="python-implementation">Python Implementation<a class="header-link" href="#python-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">ebnf_to_bnf</span><span class="p">(</span><span class="n">ebnf_rules</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert EBNF notation to BNF.</span>
<span class="sd">    Handles: { } (repetition), [ ] (optional), ( | ) (grouping).</span>

<span class="sd">    This is a simplified converter for demonstration.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bnf_rules</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">aux_counter</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">new_aux</span><span class="p">(</span><span class="n">base_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">aux_counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">base_name</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">aux_counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">ebnf_rules</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">head</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">partition</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">)</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">head</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">body</span> <span class="o">=</span> <span class="n">body</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>

        <span class="c1"># For simplicity, just handle the basic transformations</span>
        <span class="c1"># In practice, you&#39;d need a proper EBNF parser</span>

        <span class="c1"># Handle { X } -&gt; X_rep where X_rep -&gt; X X_rep | Œµ</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
        <span class="k">while</span> <span class="s1">&#39;{&#39;</span> <span class="ow">in</span> <span class="n">body</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\{([^</span><span class="si">{}</span><span class="s1">]+)\}&#39;</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">inner</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">new_aux</span><span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="s2">&quot;_rep&quot;</span><span class="p">)</span>
            <span class="n">body</span> <span class="o">=</span> <span class="n">body</span><span class="p">[:</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span> <span class="o">+</span> <span class="n">aux</span> <span class="o">+</span> <span class="n">body</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span>
            <span class="n">bnf_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">aux</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">inner</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">aux</span><span class="si">}</span><span class="s2"> | Œµ&quot;</span><span class="p">)</span>

        <span class="c1"># Handle [ X ] -&gt; X_opt where X_opt -&gt; X | Œµ</span>
        <span class="k">while</span> <span class="s1">&#39;[&#39;</span> <span class="ow">in</span> <span class="n">body</span><span class="p">:</span>
            <span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\[([^\[\]]+)\]&#39;</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">inner</span> <span class="o">=</span> <span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">aux</span> <span class="o">=</span> <span class="n">new_aux</span><span class="p">(</span><span class="n">head</span> <span class="o">+</span> <span class="s2">&quot;_opt&quot;</span><span class="p">)</span>
            <span class="n">body</span> <span class="o">=</span> <span class="n">body</span><span class="p">[:</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">()]</span> <span class="o">+</span> <span class="n">aux</span> <span class="o">+</span> <span class="n">body</span><span class="p">[</span><span class="n">match</span><span class="o">.</span><span class="n">end</span><span class="p">():]</span>
            <span class="n">bnf_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">aux</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">inner</span><span class="si">}</span><span class="s2"> | Œµ&quot;</span><span class="p">)</span>

        <span class="n">bnf_rules</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">head</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">body</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">bnf_rules</span><span class="p">)</span>


<span class="n">ebnf</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">expr = term { + term } .</span>
<span class="s2">term = factor { * factor } .</span>
<span class="s2">factor = ( expr ) | id .</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== EBNF to BNF Conversion ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;EBNF:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ebnf</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BNF:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ebnf_to_bnf</span><span class="p">(</span><span class="n">ebnf</span><span class="p">))</span>
</code></pre></div>

<hr />
<h2 id="3-derivations">3. Derivations<a class="header-link" href="#3-derivations" title="Permanent link">&para;</a></h2>
<h3 id="leftmost-derivation">Leftmost Derivation<a class="header-link" href="#leftmost-derivation" title="Permanent link">&para;</a></h3>
<p>In a <strong>leftmost derivation</strong>, at each step we replace the <strong>leftmost</strong> variable in the sentential form.</p>
<p><strong>Notation</strong>: $\alpha \xRightarrow{lm} \beta$</p>
<p><strong>Example</strong>: Derive <code>id + id * id</code> using the expression grammar.</p>
<p>$$E \xRightarrow{lm} E + T \xRightarrow{lm} T + T \xRightarrow{lm} F + T \xRightarrow{lm} \texttt{id} + T$$
$$\xRightarrow{lm} \texttt{id} + T * F \xRightarrow{lm} \texttt{id} + F * F \xRightarrow{lm} \texttt{id} + \texttt{id} * F \xRightarrow{lm} \texttt{id} + \texttt{id} * \texttt{id}$$</p>
<h3 id="rightmost-derivation">Rightmost Derivation<a class="header-link" href="#rightmost-derivation" title="Permanent link">&para;</a></h3>
<p>In a <strong>rightmost derivation</strong> (also called <strong>canonical derivation</strong>), at each step we replace the <strong>rightmost</strong> variable.</p>
<p><strong>Notation</strong>: $\alpha \xRightarrow{rm} \beta$</p>
<p>$$E \xRightarrow{rm} E + T \xRightarrow{rm} E + T * F \xRightarrow{rm} E + T * \texttt{id} \xRightarrow{rm} E + F * \texttt{id}$$
$$\xRightarrow{rm} E + \texttt{id} * \texttt{id} \xRightarrow{rm} T + \texttt{id} * \texttt{id} \xRightarrow{rm} F + \texttt{id} * \texttt{id} \xRightarrow{rm} \texttt{id} + \texttt{id} * \texttt{id}$$</p>
<p>Both derivations produce the same parse tree (for unambiguous grammars).</p>
<h3 id="why-derivation-order-matters">Why Derivation Order Matters<a class="header-link" href="#why-derivation-order-matters" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Top-down parsers</strong> (LL) construct a leftmost derivation</li>
<li><strong>Bottom-up parsers</strong> (LR) construct a rightmost derivation in reverse</li>
<li>For unambiguous grammars, both yield the same parse tree</li>
<li>For ambiguous grammars, different derivation orders may yield different parse trees</li>
</ul>
<h3 id="python-implementation_1">Python Implementation<a class="header-link" href="#python-implementation_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">leftmost_derivation</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find a leftmost derivation of target string.</span>
<span class="sd">    Uses brute-force search (only practical for short strings).</span>
<span class="sd">    Returns list of sentential forms, or None if not derivable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">target_symbols</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">target</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>

    <span class="c1"># BFS</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>

    <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">,),</span> <span class="p">[(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">,)]))</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">{(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">,)}</span>

    <span class="n">max_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_symbols</span><span class="p">)</span> <span class="o">*</span> <span class="mi">3</span>  <span class="c1"># Bound to prevent infinite search</span>

    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">current</span><span class="p">,</span> <span class="n">history</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

        <span class="c1"># Check if we&#39;ve derived the target</span>
        <span class="k">if</span> <span class="n">current</span> <span class="o">==</span> <span class="n">target_symbols</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sf</span><span class="p">)</span> <span class="k">for</span> <span class="n">sf</span> <span class="ow">in</span> <span class="n">history</span><span class="p">]</span>

        <span class="c1"># If current is all terminals, no more derivations possible</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">current</span><span class="p">):</span>
            <span class="k">continue</span>

        <span class="c1"># If too long, skip</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_len</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Find leftmost variable</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">is_variable</span><span class="p">(</span><span class="n">sym</span><span class="p">):</span>
                <span class="c1"># Try all productions for this variable</span>
                <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">prod_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="p">[]):</span>
                    <span class="n">new_form</span> <span class="o">=</span> <span class="n">current</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">prod</span><span class="o">.</span><span class="n">body</span> <span class="o">+</span> <span class="n">current</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="k">if</span> <span class="n">new_form</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_form</span><span class="p">)</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_form</span><span class="p">,</span> <span class="n">history</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_form</span><span class="p">]))</span>
                <span class="k">break</span>  <span class="c1"># Only expand leftmost variable</span>

    <span class="k">return</span> <span class="kc">None</span>


<span class="c1"># Example</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Leftmost Derivation ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">derivation</span> <span class="o">=</span> <span class="n">leftmost_derivation</span><span class="p">(</span><span class="n">expr_grammar</span><span class="p">,</span> <span class="s2">&quot;id + id * id&quot;</span><span class="p">)</span>
<span class="k">if</span> <span class="n">derivation</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">step</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">derivation</span><span class="p">):</span>
        <span class="n">arrow</span> <span class="o">=</span> <span class="s2">&quot;  &quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;=&gt;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">arrow</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="4-parse-trees">4. Parse Trees<a class="header-link" href="#4-parse-trees" title="Permanent link">&para;</a></h2>
<p>A <strong>parse tree</strong> (also called a <strong>derivation tree</strong> or <strong>concrete syntax tree</strong>) is a graphical representation of a derivation.</p>
<h3 id="definition">Definition<a class="header-link" href="#definition" title="Permanent link">&para;</a></h3>
<p>For a grammar $G = (V, \Sigma, P, S)$, a parse tree has:</p>
<ol>
<li>The <strong>root</strong> is labeled with the start symbol $S$</li>
<li>Each <strong>interior node</strong> is labeled with a variable $A \in V$</li>
<li>Each <strong>leaf</strong> is labeled with a terminal $a \in \Sigma$ or $\epsilon$</li>
<li>If interior node $A$ has children $X_1, X_2, \ldots, X_k$, then $A \rightarrow X_1 X_2 \cdots X_k \in P$</li>
</ol>
<h3 id="example-parse-tree">Example Parse Tree<a class="header-link" href="#example-parse-tree" title="Permanent link">&para;</a></h3>
<p>For <code>id + id * id</code> with the expression grammar:</p>
<div class="highlight"><pre><span></span><code>             E
           / | \
          E  +  T
          |    /|\
          T  T  *  F
          |  |     |
          F  F    id
          |  |
         id  id
</code></pre></div>

<p>Reading the leaves left-to-right gives the derived string: <code>id + id * id</code>.</p>
<h3 id="relationship-to-derivations">Relationship to Derivations<a class="header-link" href="#relationship-to-derivations" title="Permanent link">&para;</a></h3>
<ul>
<li>Every derivation corresponds to exactly one parse tree (for unambiguous grammars)</li>
<li>Every parse tree corresponds to exactly one leftmost derivation and one rightmost derivation</li>
<li>Different derivations (leftmost, rightmost, or arbitrary order) may correspond to the <strong>same</strong> parse tree</li>
</ul>
<h3 id="python-implementation_2">Python Implementation<a class="header-link" href="#python-implementation_2" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ParseTreeNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A node in a parse tree.&quot;&quot;&quot;</span>
    <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="s1">&#39;ParseTreeNode&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">is_terminal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">leaves</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the leaves (yield) of the parse tree.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span> <span class="o">!=</span> <span class="s1">&#39;Œµ&#39;</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pretty_print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">is_last</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print the tree in a readable format.&quot;&quot;&quot;</span>
        <span class="n">connector</span> <span class="o">=</span> <span class="s2">&quot;‚îî‚îÄ‚îÄ &quot;</span> <span class="k">if</span> <span class="n">is_last</span> <span class="k">else</span> <span class="s2">&quot;‚îú‚îÄ‚îÄ &quot;</span>
        <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol</span><span class="si">}</span><span class="s2">&#39;&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_terminal</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">prefix</span> <span class="o">+</span> <span class="n">connector</span> <span class="o">+</span> <span class="n">label</span><span class="p">)</span>
        <span class="n">new_prefix</span> <span class="o">=</span> <span class="n">prefix</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;    &quot;</span> <span class="k">if</span> <span class="n">is_last</span> <span class="k">else</span> <span class="s2">&quot;‚îÇ   &quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">):</span>
            <span class="n">child</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">(</span><span class="n">new_prefix</span><span class="p">,</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">children</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">build_parse_tree</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">derivation_steps</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ParseTreeNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a parse tree from a leftmost derivation.</span>
<span class="sd">    Each step is a sentential form (list of symbols).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Start with root</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

    <span class="c1"># Track which nodes need expansion</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_leftmost_unexpanded</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the leftmost nonterminal leaf that hasn&#39;t been expanded.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">is_variable</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">symbol</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">node</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">find_leftmost_unexpanded</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="c1"># Process each derivation step</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">derivation_steps</span><span class="p">)):</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">derivation_steps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">derivation_steps</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

        <span class="c1"># Find which variable was expanded</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">find_leftmost_unexpanded</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>

        <span class="c1"># Find the production used</span>
        <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">prod_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">symbol</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="c1"># Check if this production could have been applied</span>
            <span class="n">expanded</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">prev</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">symbol</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="n">prev</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">symbol</span><span class="p">):</span>
                    <span class="n">expanded</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">prod</span><span class="o">.</span><span class="n">body</span> <span class="k">if</span> <span class="n">prod</span><span class="o">.</span><span class="n">body</span> <span class="k">else</span> <span class="p">[</span><span class="s1">&#39;Œµ&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">expanded</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">expanded</span> <span class="o">==</span> <span class="n">current</span> <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">prod</span><span class="o">.</span><span class="n">body</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="c1"># This is the right production</span>
                <span class="k">if</span> <span class="n">prod</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">prod</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                        <span class="n">child</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span>
                            <span class="n">sym</span><span class="p">,</span>
                            <span class="n">is_terminal</span><span class="o">=</span><span class="n">grammar</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">node</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">is_terminal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">break</span>

    <span class="k">return</span> <span class="n">root</span>


<span class="c1"># Manually build a parse tree for &quot;id + id * id&quot;</span>
<span class="k">def</span><span class="w"> </span><span class="nf">make_expr_tree</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Build the parse tree for &#39;id + id * id&#39; manually.&quot;&quot;&quot;</span>
    <span class="c1"># F -&gt; id (three instances)</span>
    <span class="n">id1</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">is_terminal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">id2</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">is_terminal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">id3</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">is_terminal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">f1</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">id1</span><span class="p">])</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">id2</span><span class="p">])</span>
    <span class="n">f3</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">id3</span><span class="p">])</span>

    <span class="c1"># T -&gt; F (left), T -&gt; T * F (right)</span>
    <span class="n">t1</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">f1</span><span class="p">])</span>
    <span class="n">t2</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="p">[</span>
        <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">f2</span><span class="p">]),</span>
        <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">is_terminal</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
        <span class="n">f3</span>
    <span class="p">])</span>

    <span class="c1"># E -&gt; E + T</span>
    <span class="n">plus</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">is_terminal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="p">[</span>
        <span class="n">ParseTreeNode</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">t1</span><span class="p">]),</span>
        <span class="n">plus</span><span class="p">,</span>
        <span class="n">t2</span>
    <span class="p">])</span>

    <span class="k">return</span> <span class="n">e</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">make_expr_tree</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Parse Tree for &#39;id + id * id&#39; ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">tree</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">is_last</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Yield: </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">leaves</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="5-ambiguity">5. Ambiguity<a class="header-link" href="#5-ambiguity" title="Permanent link">&para;</a></h2>
<h3 id="definition_1">Definition<a class="header-link" href="#definition_1" title="Permanent link">&para;</a></h3>
<p>A grammar $G$ is <strong>ambiguous</strong> if there exists a string $w \in L(G)$ that has <strong>two or more distinct parse trees</strong> (equivalently, two or more distinct leftmost derivations).</p>
<h3 id="example-of-an-ambiguous-grammar">Example of an Ambiguous Grammar<a class="header-link" href="#example-of-an-ambiguous-grammar" title="Permanent link">&para;</a></h3>
<p>Consider this simpler expression grammar:</p>
<p>$$E \rightarrow E + E \mid E * E \mid (E) \mid \texttt{id}$$</p>
<p>The string <code>id + id * id</code> has two parse trees:</p>
<p><strong>Tree 1</strong> (multiplication binds tighter):</p>
<div class="highlight"><pre><span></span><code>       E
      /|\
     E + E
     |  /|\
    id E * E
       |   |
      id  id
</code></pre></div>

<p>Interpretation: <code>id + (id * id)</code></p>
<p><strong>Tree 2</strong> (addition binds tighter):</p>
<div class="highlight"><pre><span></span><code>       E
      /|\
     E * E
    /|\   |
   E + E  id
   |   |
  id  id
</code></pre></div>

<p>Interpretation: <code>(id + id) * id</code></p>
<p>These two parse trees give different meanings to the same expression!</p>
<h3 id="why-ambiguity-matters">Why Ambiguity Matters<a class="header-link" href="#why-ambiguity-matters" title="Permanent link">&para;</a></h3>
<ul>
<li>Different parse trees $\rightarrow$ different semantics</li>
<li>A compiler must produce a <strong>unique</strong> interpretation</li>
<li>Ambiguity in a grammar makes parsing nondeterministic</li>
</ul>
<h3 id="inherent-ambiguity">Inherent Ambiguity<a class="header-link" href="#inherent-ambiguity" title="Permanent link">&para;</a></h3>
<p>A context-free <strong>language</strong> is <strong>inherently ambiguous</strong> if every grammar for it is ambiguous. (This is different from a grammar being ambiguous -- you might be able to find an unambiguous grammar for the same language.)</p>
<p>A classic example:</p>
<p>$$L = \{a^i b^j c^k \mid i = j \text{ or } j = k\}$$</p>
<p>This language is inherently ambiguous. The string $a^n b^n c^n$ can be parsed by matching $i = j$ or $j = k$, and no unambiguous grammar exists for this language.</p>
<h3 id="detecting-ambiguity">Detecting Ambiguity<a class="header-link" href="#detecting-ambiguity" title="Permanent link">&para;</a></h3>
<p><strong>Undecidable</strong>: There is no algorithm that, given an arbitrary CFG, determines whether it is ambiguous. (This can be reduced to Post's Correspondence Problem.)</p>
<p>However, specific classes of grammars (LL(1), LR(1)) are guaranteed to be unambiguous.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">check_ambiguity_brute_force</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">max_length</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Brute-force check: enumerate all leftmost derivations up to a given</span>
<span class="sd">    string length and check for strings with multiple derivations.</span>

<span class="sd">    WARNING: Exponential complexity. Only for very small grammars.</span>
<span class="sd">    Returns list of (string, count) for ambiguous strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span>

    <span class="n">derivation_count</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">derive</span><span class="p">(</span><span class="n">sentential_form</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Enumerate all leftmost derivations.&quot;&quot;&quot;</span>
        <span class="c1"># Check if all terminals</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sentential_form</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentential_form</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_length</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sentential_form</span><span class="p">)</span>
                <span class="n">derivation_count</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span>

        <span class="c1"># Prune: too many symbols</span>
        <span class="n">terminal_count</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sentential_form</span> <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">terminal_count</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="n">max_length</span> <span class="o">*</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># Find leftmost variable</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sentential_form</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">is_variable</span><span class="p">(</span><span class="n">sym</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">prod_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="p">[]):</span>
                    <span class="n">new_form</span> <span class="o">=</span> <span class="n">sentential_form</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">prod</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="o">+</span> <span class="n">sentential_form</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">derive</span><span class="p">(</span><span class="n">new_form</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">break</span>

    <span class="n">derive</span><span class="p">([</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">ambiguous</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">derivation_count</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">c</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ambiguous</span>


<span class="c1"># Test with the ambiguous grammar</span>
<span class="n">ambig_grammar</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">E -&gt; E + E | E * E | ( E ) | id</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Ambiguity Check ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">check_ambiguity_brute_force</span><span class="p">(</span><span class="n">ambig_grammar</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="k">if</span> <span class="n">results</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Ambiguous strings found:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">count</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">results</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">&#39; has </span><span class="si">{</span><span class="n">count</span><span class="si">}</span><span class="s2"> distinct leftmost derivations&quot;</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No ambiguity found (up to given length)&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="6-resolving-ambiguity">6. Resolving Ambiguity<a class="header-link" href="#6-resolving-ambiguity" title="Permanent link">&para;</a></h2>
<h3 id="strategy-1-operator-precedence">Strategy 1: Operator Precedence<a class="header-link" href="#strategy-1-operator-precedence" title="Permanent link">&para;</a></h3>
<p>Introduce a hierarchy of nonterminals, one per precedence level:</p>
<div class="highlight"><pre><span></span><code><span class="n">Level</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="n">lowest</span><span class="p">)</span><span class="o">:</span><span class="w">   </span><span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">T</span><span class="w">        </span><span class="p">(</span><span class="n">addition</span><span class="p">)</span>
<span class="n">Level</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w">            </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">F</span><span class="w">        </span><span class="p">(</span><span class="n">multiplication</span><span class="p">)</span>
<span class="n">Level</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="n">highest</span><span class="p">)</span><span class="o">:</span><span class="w">  </span><span class="n">F</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">id</span><span class="w">       </span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
</code></pre></div>

<p>Higher-precedence operators are "deeper" in the grammar, so they bind tighter.</p>
<p>For a language with four levels of precedence:</p>
<div class="highlight"><pre><span></span><code><span class="n">expr</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">or_t</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">or_t</span><span class="w">            </span><span class="c1">// Level 0: logical OR</span>
<span class="n">or_t</span><span class="w">   </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">or_t</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">and_t</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">and_t</span><span class="w">          </span><span class="c1">// Level 1: logical AND</span>
<span class="n">and_t</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">and_t</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">rel_t</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">rel_t</span><span class="w">         </span><span class="c1">// Level 2: equality</span>
<span class="n">rel_t</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">rel_t</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">factor</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">factor</span><span class="w">        </span><span class="c1">// Level 3: relational</span>
<span class="n">factor</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">num</span><span class="w">            </span><span class="c1">// Level 4: atoms</span>
</code></pre></div>

<h3 id="strategy-2-associativity">Strategy 2: Associativity<a class="header-link" href="#strategy-2-associativity" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Left-associative</strong> operators use <strong>left recursion</strong>: $E \rightarrow E + T$</li>
<li>
<p><code>a + b + c</code> parses as <code>(a + b) + c</code></p>
</li>
<li>
<p><strong>Right-associative</strong> operators use <strong>right recursion</strong>: $E \rightarrow T = E$</p>
</li>
<li>
<p><code>a = b = c</code> parses as <code>a = (b = c)</code></p>
</li>
<li>
<p><strong>Non-associative</strong> operators: no recursion on the same level</p>
</li>
<li><code>a &lt; b &lt; c</code> is a syntax error</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="cp"># Left-associative: a + b + c = (a + b) + c</span>
<span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">T</span>

<span class="cp"># Right-associative: a = b = c = a = (b = c)</span>
<span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">T</span>

<span class="cp"># Non-associative: a &lt; b is ok, a &lt; b &lt; c is error</span>
<span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">T</span>
</code></pre></div>

<h3 id="strategy-3-disambiguation-rules-external">Strategy 3: Disambiguation Rules (External)<a class="header-link" href="#strategy-3-disambiguation-rules-external" title="Permanent link">&para;</a></h3>
<p>Some parser generators allow you to specify precedence and associativity <strong>externally</strong> rather than encoding them in the grammar:</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Yacc/Bison precedence declarations */</span>
<span class="nf">%left</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="w">         </span><span class="cm">/* lowest precedence, left-associative */</span>
<span class="nf">%left</span><span class="w"> </span><span class="sc">&#39;*&#39;</span><span class="w"> </span><span class="sc">&#39;/&#39;</span><span class="w">         </span><span class="cm">/* higher precedence, left-associative */</span>
<span class="nf">%right</span><span class="w"> </span><span class="n">UMINUS</span><span class="w">         </span><span class="cm">/* highest precedence, right-associative (unary minus) */</span>

<span class="o">%%</span>
<span class="nl">expr</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="w"> </span><span class="n">expr</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="w"> </span><span class="n">expr</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="sc">&#39;*&#39;</span><span class="w"> </span><span class="n">expr</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="sc">&#39;/&#39;</span><span class="w"> </span><span class="n">expr</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="nf">%prec</span><span class="w"> </span><span class="n">UMINUS</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="sc">&#39;(&#39;</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="sc">&#39;)&#39;</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">NUMBER</span>
<span class="w">     </span><span class="p">;</span>
</code></pre></div>

<p>This approach keeps the grammar simple (and ambiguous) but resolves ambiguity with explicit rules.</p>
<h3 id="strategy-4-the-dangling-else-problem">Strategy 4: The Dangling Else Problem<a class="header-link" href="#strategy-4-the-dangling-else-problem" title="Permanent link">&para;</a></h3>
<p>The <strong>dangling else</strong> is a classic ambiguity:</p>
<div class="highlight"><pre><span></span><code><span class="n">stmt</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">stmt</span>
<span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">stmt</span><span class="w"> </span><span class="n">else</span><span class="w"> </span><span class="n">stmt</span>
<span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="n">other</span>
</code></pre></div>

<p>For <code>if E1 then if E2 then S1 else S2</code>, two parse trees exist:</p>
<div class="highlight"><pre><span></span><code><span class="nv">Parse</span><span class="w"> </span><span class="nv">tree</span><span class="w"> </span><span class="mi">1</span>:<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">E1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="ss">(</span><span class="k">if</span><span class="w"> </span><span class="nv">E2</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nv">S1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="nv">S2</span><span class="ss">)</span><span class="w">     </span><span class="o">--</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="nv">matches</span><span class="w"> </span><span class="nv">inner</span><span class="w"> </span><span class="k">if</span>
<span class="nv">Parse</span><span class="w"> </span><span class="nv">tree</span><span class="w"> </span><span class="mi">2</span>:<span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nv">E1</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="ss">(</span><span class="k">if</span><span class="w"> </span><span class="nv">E2</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="nv">S1</span><span class="ss">)</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="nv">S2</span><span class="w">      </span><span class="o">--</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="nv">matches</span><span class="w"> </span><span class="nv">outer</span><span class="w"> </span><span class="k">if</span>
</code></pre></div>

<p><strong>Resolution</strong>: The convention is that <code>else</code> matches the <strong>nearest unmatched</strong> <code>if</code>. This can be encoded in the grammar:</p>
<div class="highlight"><pre><span></span><code><span class="n">stmt</span><span class="w">         </span><span class="o">-&gt;</span><span class="w"> </span><span class="nf">matched</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">unmatched</span>
<span class="nf">matched</span><span class="w">      </span><span class="o">-&gt;</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="nf">matched</span><span class="w"> </span><span class="n">else</span><span class="w"> </span><span class="nf">matched</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">other</span>
<span class="n">unmatched</span><span class="w">    </span><span class="o">-&gt;</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">stmt</span>
<span class="w">              </span><span class="o">|</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="nf">matched</span><span class="w"> </span><span class="n">else</span><span class="w"> </span><span class="n">unmatched</span>
</code></pre></div>

<p>Or resolved externally: most parser generators associate <code>else</code> with the nearest <code>if</code> by default.</p>
<h3 id="python-example-resolving-ambiguity">Python Example: Resolving Ambiguity<a class="header-link" href="#python-example-resolving-ambiguity" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># Ambiguous grammar for expressions</span>
<span class="n">ambiguous</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">E -&gt; E + E | E * E | ( E ) | id</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="c1"># Unambiguous grammar (precedence + left-associativity)</span>
<span class="n">unambiguous</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">E -&gt; E + T | T</span>
<span class="s2">T -&gt; T * F | F</span>
<span class="s2">F -&gt; ( E ) | id</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Ambiguous Grammar ===&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ambiguous</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Unambiguous Grammar (same language) ===&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">unambiguous</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="c1"># Verify they generate the same strings (for small strings)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">generate_strings</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">max_depth</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate all strings derivable up to a certain derivation depth.&quot;&quot;&quot;</span>
    <span class="n">strings</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">derive</span><span class="p">(</span><span class="n">form</span><span class="p">,</span> <span class="n">depth</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="n">max_depth</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">is_terminal</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">form</span><span class="p">):</span>
            <span class="n">strings</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">form</span><span class="p">))</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">form</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">grammar</span><span class="o">.</span><span class="n">is_variable</span><span class="p">(</span><span class="n">sym</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">prod</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">prod_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="p">[]):</span>
                    <span class="n">new_form</span> <span class="o">=</span> <span class="n">form</span><span class="p">[:</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">prod</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="o">+</span> <span class="n">form</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="n">derive</span><span class="p">(</span><span class="n">new_form</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">break</span>

    <span class="n">derive</span><span class="p">([</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strings</span><span class="p">}</span>

<span class="n">strings_ambig</span> <span class="o">=</span> <span class="n">generate_strings</span><span class="p">(</span><span class="n">ambiguous</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="n">strings_unambig</span> <span class="o">=</span> <span class="n">generate_strings</span><span class="p">(</span><span class="n">unambiguous</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ambiguous grammar generates </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">strings_ambig</span><span class="p">)</span><span class="si">}</span><span class="s2"> strings (depth 6)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unambiguous grammar generates </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">strings_unambig</span><span class="p">)</span><span class="si">}</span><span class="s2"> strings (depth 8)&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Strings in ambiguous but not unambiguous: </span><span class="si">{</span><span class="n">strings_ambig</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">strings_unambig</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Strings in unambiguous but not ambiguous: </span><span class="si">{</span><span class="n">strings_unambig</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">strings_ambig</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="7-chomsky-normal-form-cnf">7. Chomsky Normal Form (CNF)<a class="header-link" href="#7-chomsky-normal-form-cnf" title="Permanent link">&para;</a></h2>
<p>A CFG is in <strong>Chomsky Normal Form</strong> if every production has one of these forms:</p>
<ol>
<li>$A \rightarrow BC$ where $B, C \in V$ (two nonterminals)</li>
<li>$A \rightarrow a$ where $a \in \Sigma$ (one terminal)</li>
<li>$S \rightarrow \epsilon$ (only if $\epsilon \in L(G)$, and $S$ does not appear on any right-hand side)</li>
</ol>
<h3 id="why-cnf-matters">Why CNF Matters<a class="header-link" href="#why-cnf-matters" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>CYK parsing algorithm</strong> requires CNF (see Section 9)</li>
<li>Every parse tree in CNF is a <strong>binary tree</strong> (useful for analysis)</li>
<li>Every CFG can be converted to an equivalent grammar in CNF</li>
<li>A derivation of a string of length $n$ in CNF has exactly $2n - 1$ steps</li>
</ul>
<h3 id="conversion-to-cnf">Conversion to CNF<a class="header-link" href="#conversion-to-cnf" title="Permanent link">&para;</a></h3>
<p><strong>Input</strong>: CFG $G = (V, \Sigma, P, S)$
<strong>Output</strong>: Equivalent CFG $G'$ in CNF</p>
<p><strong>Step 1: Remove $\epsilon$-productions</strong> (except possibly $S \rightarrow \epsilon$)</p>
<p>Find all <strong>nullable</strong> variables: $A$ is nullable if $A \xRightarrow{*} \epsilon$.</p>
<p>For each production $B \rightarrow \alpha$, add new productions with every possible subset of nullable symbols removed. Then delete all $\epsilon$-productions (except $S \rightarrow \epsilon$ if needed).</p>
<p><strong>Step 2: Remove unit productions</strong> ($A \rightarrow B$)</p>
<p>Find all unit pairs: $(A, B)$ such that $A \xRightarrow{*} B$ using only unit productions. Replace each unit chain with direct productions.</p>
<p><strong>Step 3: Replace long productions</strong></p>
<p>Replace $A \rightarrow B_1 B_2 \cdots B_k$ (where $k > 2$) with:</p>
<p>$$A \rightarrow B_1 C_1$$
$$C_1 \rightarrow B_2 C_2$$
$$\vdots$$
$$C_{k-2} \rightarrow B_{k-1} B_k$$</p>
<p><strong>Step 4: Replace terminal-nonterminal mixtures</strong></p>
<p>In any production $A \rightarrow \alpha$ with $|\alpha| \geq 2$, replace each terminal $a$ with a new variable $T_a$ and add $T_a \rightarrow a$.</p>
<h3 id="python-implementation_3">Python Implementation<a class="header-link" href="#python-implementation_3" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">to_cnf</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Grammar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Convert a grammar to Chomsky Normal Form.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
    <span class="n">terminals</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">terminals</span><span class="p">)</span>
    <span class="n">productions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">start</span>

    <span class="n">aux_counter</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">new_var</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;X&quot;</span><span class="p">):</span>
        <span class="n">aux_counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">aux_counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">name</span>

    <span class="c1"># ============================================================</span>
    <span class="c1"># Step 0: New start symbol (ensure S doesn&#39;t appear on RHS)</span>
    <span class="c1"># ============================================================</span>
    <span class="n">rhs_symbols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
        <span class="n">rhs_symbols</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">rhs_symbols</span><span class="p">:</span>
        <span class="n">new_start</span> <span class="o">=</span> <span class="n">new_var</span><span class="p">(</span><span class="s2">&quot;S&quot;</span><span class="p">)</span>
        <span class="n">productions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">new_start</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,)))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">new_start</span>

    <span class="c1"># ============================================================</span>
    <span class="c1"># Step 1: Remove Œµ-productions</span>
    <span class="c1"># ============================================================</span>

    <span class="c1"># Find nullable variables</span>
    <span class="n">nullable</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span> <span class="ow">or</span> <span class="nb">all</span><span class="p">(</span><span class="n">s</span> <span class="ow">in</span> <span class="n">nullable</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">head</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">nullable</span><span class="p">:</span>
                    <span class="n">nullable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">)</span>
                    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Generate new productions with nullable symbols optionally removed</span>
    <span class="n">new_prods</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
            <span class="c1"># Œµ-production: only keep for start symbol</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
                <span class="n">new_prods</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Find all positions with nullable symbols</span>
        <span class="n">nullable_positions</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">nullable</span><span class="p">]</span>

        <span class="c1"># Generate all subsets of nullable positions</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">combinations</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">nullable_positions</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">positions_to_remove</span> <span class="ow">in</span> <span class="n">combinations</span><span class="p">(</span><span class="n">nullable_positions</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
                <span class="n">new_body</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">s</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">positions_to_remove</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">new_body</span><span class="p">:</span>  <span class="c1"># Don&#39;t add empty unless it&#39;s start</span>
                    <span class="n">new_prods</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="n">new_body</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">p</span><span class="o">.</span><span class="n">head</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
                    <span class="n">new_prods</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="p">()))</span>

    <span class="n">productions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_prods</span><span class="p">)</span>

    <span class="c1"># ============================================================</span>
    <span class="c1"># Step 2: Remove unit productions (A -&gt; B)</span>
    <span class="c1"># ============================================================</span>

    <span class="c1"># Find unit pairs using transitive closure</span>
    <span class="n">unit_pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
        <span class="n">unit_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">v</span><span class="p">))</span>  <span class="c1"># Reflexive</span>

    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">unit_pairs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">:</span>
                        <span class="n">new_pair</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">new_pair</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">unit_pairs</span><span class="p">:</span>
                            <span class="n">unit_pairs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_pair</span><span class="p">)</span>
                            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="c1"># Replace unit productions</span>
    <span class="n">new_prods</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">:</span>
            <span class="k">continue</span>  <span class="c1"># Skip unit productions</span>

        <span class="c1"># For each unit pair (A, B) where B is the head of this production</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="ow">in</span> <span class="n">unit_pairs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">:</span>
                <span class="n">new_prods</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">))</span>

    <span class="n">productions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">new_prods</span><span class="p">)</span>

    <span class="c1"># ============================================================</span>
    <span class="c1"># Step 3: Replace terminals in mixed productions</span>
    <span class="c1"># ============================================================</span>
    <span class="n">term_vars</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># terminal -&gt; variable name</span>
    <span class="n">additional</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">final_prods</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">final_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Replace terminals with new variables</span>
        <span class="n">new_body</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">terminals</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">term_vars</span><span class="p">:</span>
                    <span class="n">tv</span> <span class="o">=</span> <span class="n">new_var</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>
                    <span class="n">term_vars</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">=</span> <span class="n">tv</span>
                    <span class="n">additional</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">tv</span><span class="p">,</span> <span class="p">(</span><span class="n">sym</span><span class="p">,)))</span>
                <span class="n">new_body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">term_vars</span><span class="p">[</span><span class="n">sym</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_body</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="n">final_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">new_body</span><span class="p">)))</span>

    <span class="n">productions</span> <span class="o">=</span> <span class="n">final_prods</span> <span class="o">+</span> <span class="n">additional</span>

    <span class="c1"># ============================================================</span>
    <span class="c1"># Step 4: Break long productions into binary</span>
    <span class="c1"># ============================================================</span>
    <span class="n">final_prods</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">final_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># A -&gt; B1 B2 B3 ... Bk  =&gt;  A -&gt; B1 C1, C1 -&gt; B2 C2, ..., Ck-2 -&gt; Bk-1 Bk</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="n">current_head</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">head</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">new_head</span> <span class="o">=</span> <span class="n">new_var</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>
            <span class="n">final_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">current_head</span><span class="p">,</span> <span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new_head</span><span class="p">)))</span>
            <span class="n">symbols</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">current_head</span> <span class="o">=</span> <span class="n">new_head</span>
        <span class="n">final_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">current_head</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">symbols</span><span class="p">)))</span>

    <span class="n">productions</span> <span class="o">=</span> <span class="n">final_prods</span>

    <span class="k">return</span> <span class="n">Grammar</span><span class="p">(</span><span class="n">variables</span><span class="p">,</span> <span class="n">terminals</span><span class="p">,</span> <span class="n">productions</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>


<span class="c1"># Example</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== CNF Conversion ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">expr_g</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">E -&gt; E + T | T</span>
<span class="s2">T -&gt; T * F | F</span>
<span class="s2">F -&gt; ( E ) | id</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original grammar:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">expr_g</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="n">cnf</span> <span class="o">=</span> <span class="n">to_cnf</span><span class="p">(</span><span class="n">expr_g</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;CNF grammar:&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cnf</span><span class="o">.</span><span class="n">productions</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">p</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Verify: check that some strings are still derivable</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Verification (derivability check):&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;id + id&quot;</span><span class="p">,</span> <span class="s2">&quot;id * id&quot;</span><span class="p">,</span> <span class="s2">&quot;id + id * id&quot;</span><span class="p">]:</span>
    <span class="n">symbols</span> <span class="o">=</span> <span class="n">w</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="c1"># We&#39;ll verify using CYK (next section)</span>
</code></pre></div>

<hr />
<h2 id="8-greibach-normal-form-gnf">8. Greibach Normal Form (GNF)<a class="header-link" href="#8-greibach-normal-form-gnf" title="Permanent link">&para;</a></h2>
<p>A CFG is in <strong>Greibach Normal Form</strong> if every production has the form:</p>
<p>$$A \rightarrow a B_1 B_2 \cdots B_k$$</p>
<p>where $a \in \Sigma$ and $B_1, \ldots, B_k \in V$ (with $k \geq 0$).</p>
<p>In other words, every production starts with exactly one terminal, followed by zero or more nonterminals.</p>
<h3 id="properties">Properties<a class="header-link" href="#properties" title="Permanent link">&para;</a></h3>
<ol>
<li>Every derivation step in GNF consumes exactly one terminal</li>
<li>A string of length $n$ requires exactly $n$ derivation steps (no $\epsilon$-productions, except possibly $S \rightarrow \epsilon$)</li>
<li>GNF is useful for constructing pushdown automata</li>
<li>Conversion to GNF requires eliminating left recursion (covered in Lesson 5)</li>
</ol>
<h3 id="comparison-of-normal-forms">Comparison of Normal Forms<a class="header-link" href="#comparison-of-normal-forms" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>CNF</th>
<th>GNF</th>
</tr>
</thead>
<tbody>
<tr>
<td>Production form</td>
<td>$A \rightarrow BC$ or $A \rightarrow a$</td>
<td>$A \rightarrow a\alpha$ ($\alpha \in V^*$)</td>
</tr>
<tr>
<td>Parse tree shape</td>
<td>Binary tree</td>
<td>High branching factor</td>
</tr>
<tr>
<td>Derivation length for $|w| = n$</td>
<td>$2n - 1$</td>
<td>$n$</td>
</tr>
<tr>
<td>Primary use</td>
<td>CYK algorithm</td>
<td>PDA construction</td>
</tr>
<tr>
<td>Left recursion</td>
<td>Allowed</td>
<td>Not allowed</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="9-the-cyk-algorithm">9. The CYK Algorithm<a class="header-link" href="#9-the-cyk-algorithm" title="Permanent link">&para;</a></h2>
<p>The <strong>Cocke-Younger-Kasami (CYK) algorithm</strong> is a dynamic programming algorithm that determines whether a string $w$ is in $L(G)$ for a grammar $G$ in CNF. It also constructs a parse tree.</p>
<h3 id="algorithm">Algorithm<a class="header-link" href="#algorithm" title="Permanent link">&para;</a></h3>
<p><strong>Input</strong>: Grammar $G$ in CNF, string $w = a_1 a_2 \cdots a_n$
<strong>Output</strong>: Whether $w \in L(G)$, and a parse table</p>
<p><strong>Idea</strong>: Build a triangular table $T$ where $T[i][j]$ is the set of variables that can derive the substring $a_i a_{i+1} \cdots a_j$.</p>
<p>$$T[i][j] = \{A \in V \mid A \xRightarrow{*} a_i a_{i+1} \cdots a_j\}$$</p>
<p><strong>Algorithm</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Base</span><span class="w"> </span><span class="k">case</span><span class="err">:</span><span class="w"> </span><span class="n">substrings</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="mi">1</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="nl">n</span><span class="p">:</span>
<span class="w">       </span><span class="n">T</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="n">A</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">a·µ¢</span><span class="w"> </span><span class="err">‚àà</span><span class="w"> </span><span class="n">P</span><span class="err">}</span>

<span class="mf">2.</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Inductive</span><span class="w"> </span><span class="k">case</span><span class="err">:</span><span class="w"> </span><span class="n">substrings</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">n</span>
<span class="w">   </span><span class="k">for</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="nl">n</span><span class="p">:</span>
<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span>
<span class="w">           </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">           </span><span class="n">T</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">‚àÖ</span>
<span class="w">           </span><span class="k">for</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span>
<span class="w">               </span><span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">production</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nl">BC</span><span class="p">:</span>
<span class="w">                   </span><span class="k">if</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="err">‚àà</span><span class="w"> </span><span class="n">T</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="err">‚àà</span><span class="w"> </span><span class="n">T</span><span class="o">[</span><span class="n">k+1</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="err">:</span>
<span class="w">                       </span><span class="n">T</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">T</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="err">‚à™</span><span class="w"> </span><span class="err">{</span><span class="n">A</span><span class="err">}</span>

<span class="mf">3.</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Accept</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="k">start</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">top</span><span class="o">-</span><span class="nf">right</span><span class="w"> </span><span class="n">cell</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="err">‚àà</span><span class="w"> </span><span class="n">T</span><span class="o">[</span><span class="n">1</span><span class="o">][</span><span class="n">n</span><span class="o">]</span>
</code></pre></div>

<p><strong>Time complexity</strong>: $O(n^3 \cdot |P|)$
<strong>Space complexity</strong>: $O(n^2)$</p>
<h3 id="worked-example">Worked Example<a class="header-link" href="#worked-example" title="Permanent link">&para;</a></h3>
<p>Grammar in CNF:</p>
<p>$$S \rightarrow AB \mid BC$$
$$A \rightarrow BA \mid a$$
$$B \rightarrow CC \mid b$$
$$C \rightarrow AB \mid a$$</p>
<p>Parse <code>"baaba"</code>:</p>
<div class="highlight"><pre><span></span><code><span class="nl">String</span><span class="p">:</span><span class="w">  </span><span class="n">b</span><span class="w">   </span><span class="n">a</span><span class="w">   </span><span class="n">a</span><span class="w">   </span><span class="n">b</span><span class="w">   </span><span class="n">a</span>
<span class="k">Index</span><span class="err">:</span><span class="w">   </span><span class="mi">1</span><span class="w">   </span><span class="mi">2</span><span class="w">   </span><span class="mi">3</span><span class="w">   </span><span class="mi">4</span><span class="w">   </span><span class="mi">5</span>

<span class="nc">Table</span><span class="w"> </span><span class="n">T</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="err">:</span>

<span class="n">i</span><span class="err">\</span><span class="n">j</span><span class="w"> </span><span class="o">|</span><span class="w">  </span><span class="mi">1</span><span class="w">      </span><span class="mi">2</span><span class="w">       </span><span class="mi">3</span><span class="w">       </span><span class="mi">4</span><span class="w">       </span><span class="mi">5</span>
<span class="c1">----+-------------------------------------------</span>
<span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="err">{</span><span class="n">B</span><span class="err">}</span><span class="w">   </span><span class="err">{</span><span class="n">S</span><span class="p">,</span><span class="n">A</span><span class="err">}</span><span class="w">  </span><span class="err">{</span><span class="n">B</span><span class="err">}</span><span class="w">     </span><span class="err">{</span><span class="n">S</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">C</span><span class="err">}</span><span class="w"> </span><span class="err">{</span><span class="n">B</span><span class="err">}</span>
<span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="o">|</span><span class="w">        </span><span class="err">{</span><span class="n">A</span><span class="p">,</span><span class="n">C</span><span class="err">}</span><span class="w">  </span><span class="err">{</span><span class="n">S</span><span class="p">,</span><span class="n">C</span><span class="err">}</span><span class="w">   </span><span class="err">{</span><span class="n">B</span><span class="err">}</span><span class="w">    </span><span class="err">{</span><span class="n">S</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">C</span><span class="err">}</span>
<span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="o">|</span><span class="w">               </span><span class="err">{</span><span class="n">A</span><span class="p">,</span><span class="n">C</span><span class="err">}</span><span class="w">   </span><span class="err">{</span><span class="n">S</span><span class="p">,</span><span class="n">A</span><span class="err">}</span><span class="w">  </span><span class="err">{</span><span class="n">B</span><span class="err">}</span>
<span class="w"> </span><span class="mi">4</span><span class="w">  </span><span class="o">|</span><span class="w">                        </span><span class="err">{</span><span class="n">B</span><span class="err">}</span><span class="w">   </span><span class="err">{</span><span class="n">S</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">C</span><span class="err">}</span>
<span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="o">|</span><span class="w">                               </span><span class="err">{</span><span class="n">A</span><span class="p">,</span><span class="n">C</span><span class="err">}</span>
</code></pre></div>

<p>Step-by-step:</p>
<p><strong>Length 1</strong> (diagonal):
- $T[1][1]$: $b$ matched by $B \rightarrow b$, so $\{B\}$
- $T[2][2]$: $a$ matched by $A \rightarrow a$ and $C \rightarrow a$, so $\{A, C\}$
- Similarly for positions 3, 4, 5</p>
<p><strong>Length 2</strong>:
- $T[1][2]$: split at $k=1$: $T[1][1] \times T[2][2] = \{B\} \times \{A,C\}$
  - $B, A$: Check $? \rightarrow BA$: $A \rightarrow BA$ and $S \rightarrow BC$... Actually $A \rightarrow BA$ gives $A$, and any production giving $BA$? Let's check: $S \rightarrow AB$ needs $(A,B)$, $S \rightarrow BC$ needs $(B,C)$: $B \in T[1][1]$ and $C \in T[2][2]$, so $S$.
  - $A \rightarrow BA$: $B \in T[1][1]$ and $A \in T[2][2]$, so $A$.
  - Result: $\{S, A\}$</p>
<p>(Continuing similarly for all cells...)</p>
<p>Since $S \in T[1][5]$, the string <code>"baaba"</code> is in the language.</p>
<h3 id="python-implementation_4">Python Implementation<a class="header-link" href="#python-implementation_4" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cyk_parse</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CYK parsing algorithm.</span>
<span class="sd">    Grammar must be in Chomsky Normal Form.</span>
<span class="sd">    word is a space-separated string of terminals.</span>

<span class="sd">    Returns (accepted, table) where table[i][j] is the set of</span>
<span class="sd">    variables that can derive word[i..j].</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">symbols</span> <span class="o">=</span> <span class="n">word</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="c1"># Check if S -&gt; Œµ exists</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">prod_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="p">[])</span>

    <span class="c1"># Initialize table: T[i][j] = set of variables</span>
    <span class="c1"># Using 0-indexed</span>
    <span class="n">T</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># Also store back-pointers for parse tree construction</span>
    <span class="c1"># back[i][j][A] = (B, C, k) meaning A -&gt; BC, B derives [i..k], C derives [k+1..j]</span>
    <span class="n">back</span> <span class="o">=</span> <span class="p">[[{}</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># Step 1: Base case (length 1)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">)</span>
                <span class="n">back</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">i</span><span class="p">][</span><span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;terminal&#39;</span><span class="p">,</span> <span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="c1"># Step 2: Fill table for increasing lengths</span>
    <span class="k">for</span> <span class="n">length</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">length</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
                <span class="c1"># Try all productions A -&gt; BC</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">B</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span>
                        <span class="k">if</span> <span class="n">B</span> <span class="ow">in</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="ow">and</span> <span class="n">C</span> <span class="ow">in</span> <span class="n">T</span><span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                            <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">head</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">back</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]:</span>
                                <span class="n">back</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">][</span><span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;split&#39;</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="n">accepted</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">start</span> <span class="ow">in</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Print table</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CYK Table for &#39;</span><span class="si">{</span><span class="n">word</span><span class="si">}</span><span class="s2">&#39;:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">col_width</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;i</span><span class="se">\\</span><span class="s2">j |&quot;</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">j</span><span class="si">:</span><span class="s2">^</span><span class="si">{</span><span class="n">col_width</span><span class="si">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">cells</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">:</span>
                <span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="n">col_width</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="s2">&quot;{&quot;</span> <span class="o">+</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]))</span> <span class="o">+</span> <span class="s2">&quot;}&quot;</span> <span class="k">if</span> <span class="n">T</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;‚àÖ&quot;</span>
                <span class="n">cells</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cell</span><span class="si">:</span><span class="s2">^</span><span class="si">{</span><span class="n">col_width</span><span class="si">}}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">  |&quot;</span> <span class="o">+</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cells</span><span class="p">))</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Accepted: </span><span class="si">{</span><span class="n">accepted</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Build parse tree</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">build_tree</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">):</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">back</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="p">[</span><span class="n">ParseTreeNode</span><span class="p">(</span><span class="s2">&quot;?&quot;</span><span class="p">,</span> <span class="n">is_terminal</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;terminal&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="p">[</span><span class="n">ParseTreeNode</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">is_terminal</span><span class="o">=</span><span class="kc">True</span><span class="p">)])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">info</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">build_tree</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">build_tree</span><span class="p">(</span><span class="n">C</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ParseTreeNode</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">accepted</span><span class="p">:</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="n">build_tree</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Parse tree:&quot;</span><span class="p">)</span>
        <span class="n">tree</span><span class="o">.</span><span class="n">pretty_print</span><span class="p">()</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">accepted</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>


<span class="c1"># Example: CYK parsing</span>
<span class="n">cnf_grammar</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">S -&gt; A B | B C</span>
<span class="s2">A -&gt; B A | a</span>
<span class="s2">B -&gt; C C | b</span>
<span class="s2">C -&gt; A B | a</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== CYK Parsing ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Grammar:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">cnf_grammar</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="n">cyk_parse</span><span class="p">(</span><span class="n">cnf_grammar</span><span class="p">,</span> <span class="s2">&quot;b a a b a&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="n">cyk_parse</span><span class="p">(</span><span class="n">cnf_grammar</span><span class="p">,</span> <span class="s2">&quot;a b&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>
<span class="n">cyk_parse</span><span class="p">(</span><span class="n">cnf_grammar</span><span class="p">,</span> <span class="s2">&quot;b b b&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="10-pushdown-automata-overview">10. Pushdown Automata (Overview)<a class="header-link" href="#10-pushdown-automata-overview" title="Permanent link">&para;</a></h2>
<p>A <strong>pushdown automaton (PDA)</strong> is a finite automaton augmented with a <strong>stack</strong>. PDAs recognize exactly the context-free languages.</p>
<h3 id="formal-definition">Formal Definition<a class="header-link" href="#formal-definition" title="Permanent link">&para;</a></h3>
<p>A PDA is a 7-tuple:</p>
<p>$$M = (Q, \Sigma, \Gamma, \delta, q_0, Z_0, F)$$</p>
<p>where:</p>
<ul>
<li>$Q$ is a finite set of states</li>
<li>$\Sigma$ is the input alphabet</li>
<li>$\Gamma$ is the <strong>stack alphabet</strong></li>
<li>$\delta: Q \times (\Sigma \cup \{\epsilon\}) \times \Gamma \rightarrow \mathcal{P}(Q \times \Gamma^*)$ is the transition function</li>
<li>$q_0 \in Q$ is the start state</li>
<li>$Z_0 \in \Gamma$ is the initial stack symbol</li>
<li>$F \subseteq Q$ is the set of accepting states</li>
</ul>
<h3 id="how-a-pda-works">How a PDA Works<a class="header-link" href="#how-a-pda-works" title="Permanent link">&para;</a></h3>
<p>At each step, based on:
1. The current state
2. The current input symbol (or $\epsilon$ for no input)
3. The top of the stack</p>
<p>The PDA:
1. Moves to a new state
2. Optionally consumes an input symbol
3. Replaces the top of the stack with zero or more symbols</p>
<h3 id="equivalence-with-cfgs">Equivalence with CFGs<a class="header-link" href="#equivalence-with-cfgs" title="Permanent link">&para;</a></h3>
<p><strong>Theorem</strong>: A language is context-free if and only if it is recognized by some PDA.</p>
<p><strong>CFG $\rightarrow$ PDA</strong>: For every CFG, we can construct a PDA that simulates leftmost derivations. The PDA uses the stack to track the remaining symbols to be derived.</p>
<p><strong>PDA $\rightarrow$ CFG</strong>: For every PDA, we can construct a CFG. The construction creates variables $[q_i, A, q_j]$ representing "the PDA goes from state $q_i$ to state $q_j$ while popping $A$ off the stack."</p>
<h3 id="python-simple-pda-simulation">Python: Simple PDA Simulation<a class="header-link" href="#python-simple-pda-simulation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">PDA</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple Pushdown Automaton simulation.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transitions</span><span class="p">,</span> <span class="n">start_state</span><span class="p">,</span> <span class="n">start_stack</span><span class="p">,</span> <span class="n">accept_states</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        transitions: dict mapping (state, input_or_eps, stack_top) -&gt;</span>
<span class="sd">                     list of (new_state, stack_push)</span>
<span class="sd">        stack_push is a tuple: () means pop, (&#39;A&#39;,) means replace with A,</span>
<span class="sd">                                (&#39;A&#39;, &#39;B&#39;) means replace top with A then push B</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span> <span class="o">=</span> <span class="n">transitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_state</span> <span class="o">=</span> <span class="n">start_state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start_stack</span> <span class="o">=</span> <span class="n">start_stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">accept_states</span> <span class="o">=</span> <span class="n">accept_states</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">accepts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if the PDA accepts the word (by final state).&quot;&quot;&quot;</span>
        <span class="c1"># Configuration: (state, remaining_input_pos, stack)</span>
        <span class="c1"># Use BFS to explore all nondeterministic choices</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>

        <span class="n">initial</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start_stack</span><span class="p">,))</span>
        <span class="n">queue</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">initial</span><span class="p">])</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">symbols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="k">if</span> <span class="n">word</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
            <span class="n">state</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">stack</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>

            <span class="n">config</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">stack</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">config</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>

            <span class="c1"># Check acceptance</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)</span> <span class="ow">and</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">accept_states</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">stack</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">rest</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Try epsilon transitions</span>
            <span class="k">for</span> <span class="n">new_state</span><span class="p">,</span> <span class="n">push</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="n">top</span><span class="p">),</span> <span class="p">[]</span>
            <span class="p">):</span>
                <span class="n">new_stack</span> <span class="o">=</span> <span class="n">rest</span> <span class="o">+</span> <span class="n">push</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_stack</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>  <span class="c1"># Bound stack size</span>
                    <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_state</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">new_stack</span><span class="p">))</span>

            <span class="c1"># Try input transitions</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">symbols</span><span class="p">[</span><span class="n">pos</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">new_state</span><span class="p">,</span> <span class="n">push</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">transitions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="n">top</span><span class="p">),</span> <span class="p">[]</span>
                <span class="p">):</span>
                    <span class="n">new_stack</span> <span class="o">=</span> <span class="n">rest</span> <span class="o">+</span> <span class="n">push</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_stack</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">:</span>
                        <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">new_state</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">new_stack</span><span class="p">))</span>

        <span class="k">return</span> <span class="kc">False</span>


<span class="c1"># PDA for {a^n b^n | n &gt;= 0}</span>
<span class="c1"># States: q0 (push a&#39;s), q1 (pop a&#39;s matching b&#39;s), q_accept</span>
<span class="n">pda_anbn</span> <span class="o">=</span> <span class="n">PDA</span><span class="p">(</span>
    <span class="n">transitions</span><span class="o">=</span><span class="p">{</span>
        <span class="c1"># In q0, push a&#39;s onto stack</span>
        <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">):</span> <span class="p">[(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">))],</span>    <span class="c1"># Push A, keep Z</span>
        <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">):</span> <span class="p">[(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">))],</span>    <span class="c1"># Push A</span>
        <span class="c1"># Switch to q1 when seeing b</span>
        <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">):</span> <span class="p">[(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="p">())],</span>             <span class="c1"># Pop A</span>
        <span class="c1"># In q0, accept empty string</span>
        <span class="p">(</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span> <span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">):</span> <span class="p">[(</span><span class="s1">&#39;q_accept&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,))],</span>
        <span class="c1"># In q1, pop a&#39;s matching b&#39;s</span>
        <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;A&#39;</span><span class="p">):</span> <span class="p">[(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="p">())],</span>             <span class="c1"># Pop A</span>
        <span class="c1"># Accept when stack has only Z</span>
        <span class="p">(</span><span class="s1">&#39;q1&#39;</span><span class="p">,</span> <span class="s1">&#39;Œµ&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">):</span> <span class="p">[(</span><span class="s1">&#39;q_accept&#39;</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;Z&#39;</span><span class="p">,))],</span>
    <span class="p">},</span>
    <span class="n">start_state</span><span class="o">=</span><span class="s1">&#39;q0&#39;</span><span class="p">,</span>
    <span class="n">start_stack</span><span class="o">=</span><span class="s1">&#39;Z&#39;</span><span class="p">,</span>
    <span class="n">accept_states</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;q_accept&#39;</span><span class="p">}</span>
<span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== PDA for {a^n b^n | n &gt;= 0} ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;ab&quot;</span><span class="p">,</span> <span class="s2">&quot;aabb&quot;</span><span class="p">,</span> <span class="s2">&quot;aaabbb&quot;</span><span class="p">,</span> <span class="s2">&quot;aab&quot;</span><span class="p">,</span> <span class="s2">&quot;abb&quot;</span><span class="p">,</span> <span class="s2">&quot;ba&quot;</span><span class="p">,</span> <span class="s2">&quot;abab&quot;</span><span class="p">]:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s2">&quot;accept&quot;</span> <span class="k">if</span> <span class="n">pda_anbn</span><span class="o">.</span><span class="n">accepts</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;reject&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &#39;</span><span class="si">{</span><span class="n">w</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="11-the-pumping-lemma-for-context-free-languages">11. The Pumping Lemma for Context-Free Languages<a class="header-link" href="#11-the-pumping-lemma-for-context-free-languages" title="Permanent link">&para;</a></h2>
<h3 id="statement">Statement<a class="header-link" href="#statement" title="Permanent link">&para;</a></h3>
<p>If $L$ is a context-free language, then there exists a constant $p \geq 1$ such that every string $w \in L$ with $|w| \geq p$ can be split into five parts:</p>
<p>$$w = uvxyz$$</p>
<p>satisfying:</p>
<ol>
<li>$|vy| > 0$ (at least one of $v$ and $y$ is nonempty)</li>
<li>$|vxy| \leq p$</li>
<li>$\forall i \geq 0: uv^ixy^iz \in L$ (pumping $v$ and $y$ together)</li>
</ol>
<h3 id="proof-idea">Proof Idea<a class="header-link" href="#proof-idea" title="Permanent link">&para;</a></h3>
<p>Any sufficiently long string must have a derivation tree of height greater than $|V|$ (the number of variables). By the pigeonhole principle, some variable $A$ must repeat on a path from root to leaf:</p>
<div class="highlight"><pre><span></span><code>        S
       / \
      /   \
     /     \
    A       &lt;-- first occurrence of A
   / \
  v   A    &lt;-- second occurrence of A
     / \
    x   y
</code></pre></div>

<p>The subtree rooted at the first $A$ generates $vxy$, and the subtree rooted at the second $A$ generates $x$. We can "pump" by repeating or removing the portion between the two $A$'s.</p>
<h3 id="using-the-cfl-pumping-lemma">Using the CFL Pumping Lemma<a class="header-link" href="#using-the-cfl-pumping-lemma" title="Permanent link">&para;</a></h3>
<p>To prove a language is NOT context-free:</p>
<ol>
<li>Assume $L$ is context-free</li>
<li>Let $p$ be the pumping length</li>
<li>Choose a specific $w \in L$ with $|w| \geq p$</li>
<li>Show that <strong>for all</strong> decompositions $w = uvxyz$ with $|vy| > 0$ and $|vxy| \leq p$, there exists some $i$ where $uv^ixy^iz \notin L$</li>
<li>Contradiction</li>
</ol>
<h3 id="example-latex201-is-not-context-free">Example: $L = \{a^n b^n c^n \mid n \geq 0\}$ Is Not Context-Free<a class="header-link" href="#example-latex201-is-not-context-free" title="Permanent link">&para;</a></h3>
<p><strong>Proof</strong>:</p>
<ol>
<li>Assume $L$ is context-free with pumping length $p$.</li>
<li>Choose $w = a^p b^p c^p \in L$, with $|w| = 3p \geq p$.</li>
<li>Let $w = uvxyz$ with $|vy| > 0$ and $|vxy| \leq p$.</li>
<li>Since $|vxy| \leq p$, the substring $vxy$ can span at most two of the three groups ($a$'s, $b$'s, $c$'s).</li>
<li>Case analysis:</li>
<li>$vxy$ is within $a^p$: pumping changes $a$ count but not $b$ or $c$.</li>
<li>$vxy$ is within $a^p b^p$: pumping changes $a$ and/or $b$ but not $c$.</li>
<li>$vxy$ is within $b^p$: pumping changes $b$ but not $a$ or $c$.</li>
<li>$vxy$ is within $b^p c^p$: pumping changes $b$ and/or $c$ but not $a$.</li>
<li>$vxy$ is within $c^p$: pumping changes $c$ but not $a$ or $b$.</li>
<li>In all cases, pumping ($i = 2$) produces a string where the three counts are unequal, so $uv^2xy^2z \notin L$.</li>
<li>Contradiction. $\blacksquare$</li>
</ol>
<h3 id="languages-beyond-context-free">Languages Beyond Context-Free<a class="header-link" href="#languages-beyond-context-free" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Language</th>
<th>Type</th>
<th>Why Not CF</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\{a^n b^n c^n \mid n \geq 0\}$</td>
<td>Context-sensitive</td>
<td>Needs three-way matching</td>
</tr>
<tr>
<td>$\{ww \mid w \in \{a,b\}^*\}$</td>
<td>Context-sensitive</td>
<td>Copy language</td>
</tr>
<tr>
<td>$\{a^{2^n} \mid n \geq 0\}$</td>
<td>Context-sensitive</td>
<td>Exponential growth</td>
</tr>
<tr>
<td>Any decidable language</td>
<td>Type 0 or below</td>
<td>Turing machine required</td>
</tr>
</tbody>
</table>
<p>Note: $\{a^n b^n \mid n \geq 0\}$ IS context-free. The limitation is three or more matched groups.</p>
<hr />
<h2 id="12-the-chomsky-hierarchy">12. The Chomsky Hierarchy<a class="header-link" href="#12-the-chomsky-hierarchy" title="Permanent link">&para;</a></h2>
<p>The <strong>Chomsky hierarchy</strong> classifies formal languages into four levels:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>Grammar restriction</th>
<th>Automaton</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>Regular</td>
<td>$A \rightarrow aB$ or $A \rightarrow a$</td>
<td>Finite automaton (DFA/NFA)</td>
<td>$a^*b^*$</td>
</tr>
<tr>
<td>2</td>
<td>Context-free</td>
<td>$A \rightarrow \alpha$ ($\alpha \in (V \cup \Sigma)^*$)</td>
<td>Pushdown automaton</td>
<td>$a^nb^n$</td>
</tr>
<tr>
<td>1</td>
<td>Context-sensitive</td>
<td>$\alpha A \beta \rightarrow \alpha \gamma \beta$ ($|\gamma| \geq 1$)</td>
<td>Linear-bounded automaton</td>
<td>$a^nb^nc^n$</td>
</tr>
<tr>
<td>0</td>
<td>Recursively enumerable</td>
<td>No restriction</td>
<td>Turing machine</td>
<td>Halting problem complement</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code>Hierarchy (proper inclusions):

Regular  ‚äÇ  Context-Free  ‚äÇ  Context-Sensitive  ‚äÇ  Recursively Enumerable
  (Type 3)    (Type 2)         (Type 1)              (Type 0)
</code></pre></div>

<h3 id="relevance-to-compiler-design">Relevance to Compiler Design<a class="header-link" href="#relevance-to-compiler-design" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Phase</th>
<th>Language Type</th>
<th>Formalism</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lexical analysis</td>
<td>Regular (Type 3)</td>
<td>DFA, regular expressions</td>
</tr>
<tr>
<td>Syntax analysis</td>
<td>Context-free (Type 2)</td>
<td>CFG, pushdown automata</td>
</tr>
<tr>
<td>Semantic analysis</td>
<td>Context-sensitive (Type 1)</td>
<td>Attribute grammars, type systems</td>
</tr>
<tr>
<td>Full language semantics</td>
<td>Beyond CF</td>
<td>Turing machines (undecidable in general)</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="13-grammar-transformations">13. Grammar Transformations<a class="header-link" href="#13-grammar-transformations" title="Permanent link">&para;</a></h2>
<h3 id="eliminating-left-recursion">Eliminating Left Recursion<a class="header-link" href="#eliminating-left-recursion" title="Permanent link">&para;</a></h3>
<p>A grammar has <strong>left recursion</strong> if there exists a derivation $A \xRightarrow{+} A\alpha$ for some $\alpha$. Left recursion causes problems for top-down parsers (infinite loop).</p>
<p><strong>Direct left recursion</strong> ($A \rightarrow A\alpha \mid \beta$):</p>
<p>Replace with:
$$A \rightarrow \beta A'$$
$$A' \rightarrow \alpha A' \mid \epsilon$$</p>
<p><strong>Example</strong>:
$$E \rightarrow E + T \mid T$$</p>
<p>becomes:
$$E \rightarrow T E'$$
$$E' \rightarrow + T E' \mid \epsilon$$</p>
<h3 id="left-factoring">Left Factoring<a class="header-link" href="#left-factoring" title="Permanent link">&para;</a></h3>
<p>When two productions for the same nonterminal share a common prefix:</p>
<p>$$A \rightarrow \alpha \beta_1 \mid \alpha \beta_2$$</p>
<p>Replace with:
$$A \rightarrow \alpha A'$$
$$A' \rightarrow \beta_1 \mid \beta_2$$</p>
<h3 id="python-implementation_5">Python Implementation<a class="header-link" href="#python-implementation_5" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">eliminate_left_recursion</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Grammar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Eliminate immediate left recursion from all productions.</span>
<span class="sd">    (Does not handle indirect left recursion.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_productions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">new_variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">variables</span><span class="p">):</span>
        <span class="n">prods</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">prod_index</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="p">[])</span>

        <span class="c1"># Separate left-recursive and non-left-recursive productions</span>
        <span class="n">left_recursive</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># A -&gt; A Œ±</span>
        <span class="n">non_recursive</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># A -&gt; Œ≤</span>

        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span> <span class="ow">and</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">var</span><span class="p">:</span>
                <span class="n">left_recursive</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># Œ± (without leading A)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">non_recursive</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">left_recursive</span><span class="p">:</span>
            <span class="c1"># No left recursion for this variable</span>
            <span class="n">new_productions</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">prods</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># Eliminate left recursion</span>
        <span class="c1"># A -&gt; Œ≤1 | Œ≤2 | ... | A Œ±1 | A Œ±2 | ...</span>
        <span class="c1"># becomes:</span>
        <span class="c1"># A  -&gt; Œ≤1 A&#39; | Œ≤2 A&#39; | ...</span>
        <span class="c1"># A&#39; -&gt; Œ±1 A&#39; | Œ±2 A&#39; | ... | Œµ</span>

        <span class="n">new_var</span> <span class="o">=</span> <span class="n">var</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
        <span class="k">while</span> <span class="n">new_var</span> <span class="ow">in</span> <span class="n">new_variables</span><span class="p">:</span>
            <span class="n">new_var</span> <span class="o">+=</span> <span class="s2">&quot;&#39;&quot;</span>
        <span class="n">new_variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_var</span><span class="p">)</span>

        <span class="c1"># A -&gt; Œ≤i A&#39;</span>
        <span class="k">for</span> <span class="n">beta</span> <span class="ow">in</span> <span class="n">non_recursive</span><span class="p">:</span>
            <span class="n">new_body</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_var</span><span class="p">,)</span> <span class="k">if</span> <span class="n">beta</span> <span class="k">else</span> <span class="p">(</span><span class="n">new_var</span><span class="p">,)</span>
            <span class="n">new_productions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">new_body</span><span class="p">))</span>

        <span class="c1"># A&#39; -&gt; Œ±i A&#39;</span>
        <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">left_recursive</span><span class="p">:</span>
            <span class="n">new_body</span> <span class="o">=</span> <span class="n">alpha</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_var</span><span class="p">,)</span>
            <span class="n">new_productions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">new_var</span><span class="p">,</span> <span class="n">new_body</span><span class="p">))</span>

        <span class="c1"># A&#39; -&gt; Œµ</span>
        <span class="n">new_productions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">new_var</span><span class="p">,</span> <span class="p">()))</span>

    <span class="k">return</span> <span class="n">Grammar</span><span class="p">(</span>
        <span class="n">new_variables</span><span class="p">,</span> <span class="n">grammar</span><span class="o">.</span><span class="n">terminals</span><span class="p">,</span>
        <span class="n">new_productions</span><span class="p">,</span> <span class="n">grammar</span><span class="o">.</span><span class="n">start</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">left_factor</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Grammar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply left factoring to a grammar.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_productions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="p">)</span>
    <span class="n">new_variables</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">variables</span><span class="p">)</span>
    <span class="n">aux_counter</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Index by head</span>
        <span class="n">prod_index</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">new_productions</span><span class="p">:</span>
            <span class="n">prod_index</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">head</span><span class="p">,</span> <span class="p">[])</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="n">next_prods</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">processed_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">prod_index</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">processed_vars</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">prods</span> <span class="o">=</span> <span class="n">prod_index</span><span class="p">[</span><span class="n">var</span><span class="p">]</span>

            <span class="c1"># Find longest common prefix among any two productions</span>
            <span class="n">best_prefix</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">best_group</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prods</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">prods</span><span class="p">)):</span>
                    <span class="c1"># Find common prefix</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">prods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">body</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">prods</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">body</span><span class="p">))):</span>
                        <span class="k">if</span> <span class="n">prods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="n">prods</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                            <span class="n">prefix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prods</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">break</span>

                    <span class="k">if</span> <span class="n">prefix</span> <span class="ow">and</span> <span class="p">(</span><span class="n">best_prefix</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_prefix</span><span class="p">)):</span>
                        <span class="n">best_prefix</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">prefix</span><span class="p">)</span>
                        <span class="c1"># Find all productions sharing this prefix</span>
                        <span class="n">group</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prods</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">)]</span> <span class="o">==</span> <span class="n">best_prefix</span><span class="p">]</span>
                        <span class="n">best_group</span> <span class="o">=</span> <span class="n">group</span>

            <span class="k">if</span> <span class="n">best_prefix</span> <span class="ow">and</span> <span class="n">best_group</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">best_group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">processed_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">var</span><span class="p">)</span>

                <span class="c1"># Create new variable</span>
                <span class="n">aux_counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">new_var</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">_LF</span><span class="si">{</span><span class="n">aux_counter</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="n">new_variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_var</span><span class="p">)</span>

                <span class="c1"># A -&gt; prefix A_LF</span>
                <span class="n">next_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">best_prefix</span> <span class="o">+</span> <span class="p">(</span><span class="n">new_var</span><span class="p">,)))</span>

                <span class="c1"># A_LF -&gt; remaining1 | remaining2 | ...</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">best_group</span><span class="p">:</span>
                    <span class="n">remaining</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">best_prefix</span><span class="p">):]</span>
                    <span class="n">next_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Production</span><span class="p">(</span><span class="n">new_var</span><span class="p">,</span> <span class="n">remaining</span> <span class="k">if</span> <span class="n">remaining</span> <span class="k">else</span> <span class="p">()))</span>

                <span class="c1"># Keep non-matching productions</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">best_group</span><span class="p">:</span>
                        <span class="n">next_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">next_prods</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">prods</span><span class="p">)</span>

        <span class="n">new_productions</span> <span class="o">=</span> <span class="n">next_prods</span>

    <span class="k">return</span> <span class="n">Grammar</span><span class="p">(</span>
        <span class="n">new_variables</span><span class="p">,</span> <span class="n">grammar</span><span class="o">.</span><span class="n">terminals</span><span class="p">,</span>
        <span class="n">new_productions</span><span class="p">,</span> <span class="n">grammar</span><span class="o">.</span><span class="n">start</span>
    <span class="p">)</span>


<span class="c1"># Example: Eliminate left recursion</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Eliminating Left Recursion ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">expr_grammar</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="n">no_lr</span> <span class="o">=</span> <span class="n">eliminate_left_recursion</span><span class="p">(</span><span class="n">expr_grammar</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After eliminating left recursion:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">no_lr</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="c1"># Example: Left factoring</span>
<span class="n">lf_grammar</span> <span class="o">=</span> <span class="n">Grammar</span><span class="o">.</span><span class="n">from_string</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">S -&gt; if E then S else S | if E then S | other</span>
<span class="s2">E -&gt; id</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Left Factoring ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">lf_grammar</span><span class="p">)</span>
<span class="nb">print</span><span class="p">()</span>

<span class="n">factored</span> <span class="o">=</span> <span class="n">left_factor</span><span class="p">(</span><span class="n">lf_grammar</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After left factoring:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">factored</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="summary">Summary<a class="header-link" href="#summary" title="Permanent link">&para;</a></h2>
<ul>
<li>A <strong>context-free grammar</strong> $G = (V, \Sigma, P, S)$ generates a language through derivations</li>
<li><strong>BNF</strong> and <strong>EBNF</strong> are standard notations for writing grammars</li>
<li><strong>Leftmost</strong> and <strong>rightmost</strong> derivations correspond to different parsing strategies</li>
<li><strong>Parse trees</strong> are the structural representation of derivations</li>
<li>A grammar is <strong>ambiguous</strong> if some string has multiple parse trees; ambiguity is undecidable in general</li>
<li>Ambiguity is resolved through <strong>precedence</strong>, <strong>associativity</strong>, and grammar restructuring</li>
<li><strong>Chomsky Normal Form</strong> (binary productions) enables the <strong>CYK algorithm</strong> for parsing in $O(n^3)$</li>
<li><strong>Greibach Normal Form</strong> (terminal-first productions) is useful for PDA construction</li>
<li><strong>Pushdown automata</strong> recognize exactly the context-free languages</li>
<li>The <strong>CFL pumping lemma</strong> proves that languages like $\{a^n b^n c^n\}$ are not context-free</li>
<li>The <strong>Chomsky hierarchy</strong> classifies languages into four types: regular, context-free, context-sensitive, and recursively enumerable</li>
<li><strong>Left recursion elimination</strong> and <strong>left factoring</strong> prepare grammars for top-down parsing</li>
</ul>
<hr />
<h2 id="exercises">Exercises<a class="header-link" href="#exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-grammar-writing">Exercise 1: Grammar Writing<a class="header-link" href="#exercise-1-grammar-writing" title="Permanent link">&para;</a></h3>
<p>Write a context-free grammar for each of the following languages:</p>
<ol>
<li>Palindromes over $\{a, b\}$</li>
<li>Balanced parentheses (possibly nested)</li>
<li>$\{a^i b^j c^k \mid i = j \text{ or } j = k\}$</li>
<li>A simplified subset of Python <code>if</code>/<code>elif</code>/<code>else</code> statements</li>
<li>Arithmetic expressions with <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, unary <code>-</code>, and parentheses, respecting standard precedence and left-associativity</li>
</ol>
<h3 id="exercise-2-derivations-and-parse-trees">Exercise 2: Derivations and Parse Trees<a class="header-link" href="#exercise-2-derivations-and-parse-trees" title="Permanent link">&para;</a></h3>
<p>Using the grammar $E \rightarrow E + T \mid T$, $T \rightarrow T * F \mid F$, $F \rightarrow (E) \mid \texttt{id} \mid \texttt{num}$:</p>
<ol>
<li>Find the leftmost derivation for <code>id * (num + id)</code></li>
<li>Find the rightmost derivation for the same string</li>
<li>Draw the parse tree</li>
<li>Verify that both derivations correspond to the same parse tree</li>
</ol>
<h3 id="exercise-3-ambiguity-analysis">Exercise 3: Ambiguity Analysis<a class="header-link" href="#exercise-3-ambiguity-analysis" title="Permanent link">&para;</a></h3>
<p>Consider the grammar:</p>
<p>$$S \rightarrow aSb \mid aSbb \mid \epsilon$$</p>
<ol>
<li>What language does this grammar generate?</li>
<li>Is the grammar ambiguous? If so, find a string with two parse trees.</li>
<li>Can you find an unambiguous grammar for the same language?</li>
</ol>
<h3 id="exercise-4-cnf-conversion">Exercise 4: CNF Conversion<a class="header-link" href="#exercise-4-cnf-conversion" title="Permanent link">&para;</a></h3>
<p>Convert the following grammar to Chomsky Normal Form:</p>
<p>$$S \rightarrow ASA \mid aB$$
$$A \rightarrow B \mid S$$
$$B \rightarrow b \mid \epsilon$$</p>
<p>Show each step of the conversion process.</p>
<h3 id="exercise-5-cyk-algorithm">Exercise 5: CYK Algorithm<a class="header-link" href="#exercise-5-cyk-algorithm" title="Permanent link">&para;</a></h3>
<p>Using the CNF grammar from Exercise 4 (or the one provided in Section 9), run the CYK algorithm on the strings:
1. <code>"aabb"</code>
2. <code>"abab"</code>
3. <code>"baba"</code></p>
<p>Show the complete table for each string.</p>
<h3 id="exercise-6-pumping-lemma">Exercise 6: Pumping Lemma<a class="header-link" href="#exercise-6-pumping-lemma" title="Permanent link">&para;</a></h3>
<p>Use the pumping lemma for CFLs to prove that the following languages are NOT context-free:</p>
<ol>
<li>$L_1 = \{a^n b^n c^n d^n \mid n \geq 0\}$</li>
<li>$L_2 = \{a^i b^j c^k \mid 0 \leq i \leq j \leq k\}$</li>
<li>$L_3 = \{ww \mid w \in \{a, b\}^*\}$ (the copy language)</li>
</ol>
<hr />
<p><a href="./03_Finite_Automata.md">Previous: Finite Automata</a> | <a href="./05_Top_Down_Parsing.md">Next: Top-Down Parsing</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/03_Finite_Automata.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 3: Finite Automata</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/05_Top_Down_Parsing.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 5: Top-Down Parsing</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}