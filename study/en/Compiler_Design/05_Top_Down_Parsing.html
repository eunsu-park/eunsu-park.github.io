{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 5: Top-Down Parsing - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Lesson 5: Top-Down Parsing</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 5: Top-Down Parsing</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/04_Context_Free_Grammars.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 4: Context-Free Grammars</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/06_Bottom_Up_Parsing.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 6: Bottom-Up Parsing</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#learning-objectives">Learning Objectives</a></li>
<li><a href="#1-introduction-to-top-down-parsing">1. Introduction to Top-Down Parsing</a></li>
<li><a href="#2-recursive-descent-parsing">2. Recursive Descent Parsing</a><ul>
<li><a href="#21-basic-concept">2.1 Basic Concept</a></li>
<li><a href="#22-implementation">2.2 Implementation</a></li>
<li><a href="#23-advantages-and-limitations">2.3 Advantages and Limitations</a></li>
</ul>
</li>
<li><a href="#3-first-and-follow-sets">3. FIRST and FOLLOW Sets</a><ul>
<li><a href="#31-first-sets">3.1 FIRST Sets</a></li>
<li><a href="#32-follow-sets">3.2 FOLLOW Sets</a></li>
<li><a href="#42-python-implementation">4.2 Python Implementation</a></li>
<li><a href="#43-the-expression-grammar-table">4.3 The Expression Grammar Table</a></li>
</ul>
</li>
<li><a href="#5-table-driven-ll1-parser">5. Table-Driven LL(1) Parser</a><ul>
<li><a href="#51-the-parsing-algorithm">5.1 The Parsing Algorithm</a></li>
<li><a href="#52-complete-implementation">5.2 Complete Implementation</a></li>
</ul>
</li>
<li><a href="#6-left-recursion-elimination">6. Left Recursion Elimination</a><ul>
<li><a href="#61-the-problem">6.1 The Problem</a></li>
<li><a href="#62-eliminating-immediate-left-recursion">6.2 Eliminating Immediate Left Recursion</a></li>
<li><a href="#63-eliminating-indirect-left-recursion">6.3 Eliminating Indirect Left Recursion</a></li>
<li><a href="#64-python-implementation">6.4 Python Implementation</a></li>
</ul>
</li>
<li><a href="#7-left-factoring">7. Left Factoring</a><ul>
<li><a href="#71-the-problem">7.1 The Problem</a></li>
<li><a href="#72-the-transformation">7.2 The Transformation</a></li>
<li><a href="#73-implementation">7.3 Implementation</a></li>
</ul>
</li>
<li><a href="#8-ll1-conflicts-and-resolution">8. LL(1) Conflicts and Resolution</a><ul>
<li><a href="#81-types-of-conflicts">8.1 Types of Conflicts</a></li>
<li><a href="#82-resolution-strategies">8.2 Resolution Strategies</a></li>
<li><a href="#83-the-classic-dangling-else">8.3 The Classic Dangling Else</a></li>
</ul>
</li>
<li><a href="#9-error-recovery">9. Error Recovery</a><ul>
<li><a href="#91-panic-mode-recovery">9.1 Panic Mode Recovery</a></li>
<li><a href="#92-phrase-level-recovery">9.2 Phrase-Level Recovery</a></li>
<li><a href="#93-error-productions">9.3 Error Productions</a></li>
</ul>
</li>
<li><a href="#10-llk-and-all-parsing">10. LL(k) and ALL(*) Parsing</a><ul>
<li><a href="#101-llk-parsing">10.1 LL(k) Parsing</a></li>
<li><a href="#102-all-parsing">10.2 ALL(*) Parsing</a></li>
<li><a href="#103-comparison-of-top-down-parsing-strategies">10.3 Comparison of Top-Down Parsing Strategies</a></li>
</ul>
</li>
<li><a href="#11-putting-it-all-together">11. Putting It All Together</a></li>
<li><a href="#12-summary">12. Summary</a></li>
<li><a href="#exercises">Exercises</a><ul>
<li><a href="#exercise-1-first-and-follow-computation">Exercise 1: FIRST and FOLLOW Computation</a></li>
<li><a href="#exercise-2-ll1-table-construction">Exercise 2: LL(1) Table Construction</a></li>
<li><a href="#exercise-3-left-recursion-elimination">Exercise 3: Left Recursion Elimination</a></li>
<li><a href="#exercise-4-recursive-descent-parser-extension">Exercise 4: Recursive Descent Parser Extension</a></li>
<li><a href="#exercise-5-error-recovery">Exercise 5: Error Recovery</a></li>
<li><a href="#exercise-6-grammar-design-challenge">Exercise 6: Grammar Design Challenge</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-5-top-down-parsing">Lesson 5: Top-Down Parsing<a class="header-link" href="#lesson-5-top-down-parsing" title="Permanent link">&para;</a></h1>
<h2 id="learning-objectives">Learning Objectives<a class="header-link" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<p>After completing this lesson, you will be able to:</p>
<ol>
<li><strong>Understand</strong> the principles of top-down parsing and how it constructs parse trees from the root downward</li>
<li><strong>Compute</strong> FIRST and FOLLOW sets for any context-free grammar</li>
<li><strong>Construct</strong> LL(1) parsing tables and identify LL(1) grammars</li>
<li><strong>Implement</strong> recursive descent parsers by hand for small languages</li>
<li><strong>Implement</strong> table-driven LL(1) parsers from constructed parsing tables</li>
<li><strong>Eliminate</strong> left recursion and apply left factoring to make grammars LL(1)-compatible</li>
<li><strong>Resolve</strong> LL(1) conflicts and apply error recovery strategies</li>
<li><strong>Explain</strong> the extensions LL(k) and ALL(*) parsing provide beyond LL(1)</li>
</ol>
<hr />
<h2 id="1-introduction-to-top-down-parsing">1. Introduction to Top-Down Parsing<a class="header-link" href="#1-introduction-to-top-down-parsing" title="Permanent link">&para;</a></h2>
<p>Top-down parsing is a parsing strategy that builds the parse tree starting from the <strong>root</strong> (the start symbol) and works its way down toward the <strong>leaves</strong> (the terminal symbols). At each step, the parser attempts to predict which production to apply based on the current input token.</p>
<p>The fundamental question in top-down parsing is:</p>
<blockquote>
<p>Given a nonterminal $A$ on top of the parsing stack and the current lookahead token $a$, which production $A \to \alpha$ should the parser apply?</p>
</blockquote>
<p>Top-down parsers come in two main forms:</p>
<ol>
<li><strong>Recursive descent parsers</strong> -- a collection of mutually recursive procedures, one per nonterminal</li>
<li><strong>Table-driven predictive parsers</strong> -- driven by an LL(1) parsing table and an explicit stack</li>
</ol>
<p>Both forms require the grammar to be <strong>LL(1)</strong> (or close to it). The name LL(1) stands for:</p>
<ul>
<li><strong>L</strong>: scan input <strong>L</strong>eft to right</li>
<li><strong>L</strong>: produce a <strong>L</strong>eftmost derivation</li>
<li><strong>1</strong>: use <strong>1</strong> token of lookahead</li>
</ul>
<div class="highlight"><pre><span></span><code>Top-Down Parse Tree Construction (for input &quot;a + b * c&quot;):

Step 1:         E              Step 2:         E
               /|\                            /|\
              ? ? ?                          T  E&#39;
                                            /
                                           ?

Step 3:         E              Step 4:         E
               /|\                            /|\
              T  E&#39;                          T  E&#39;
             /   |                          /|  |\
            F    T&#39;                        F T&#39; + T E&#39;
            |                              |  |
            a    ...                       a  Œµ  ...
</code></pre></div>

<p>The parser proceeds in a <strong>leftmost derivation</strong>: at every step, it expands the leftmost nonterminal.</p>
<hr />
<h2 id="2-recursive-descent-parsing">2. Recursive Descent Parsing<a class="header-link" href="#2-recursive-descent-parsing" title="Permanent link">&para;</a></h2>
<h3 id="21-basic-concept">2.1 Basic Concept<a class="header-link" href="#21-basic-concept" title="Permanent link">&para;</a></h3>
<p>In a recursive descent parser, each nonterminal in the grammar corresponds to a function. The function for nonterminal $A$ examines the current lookahead token and decides which production to use, then calls functions for each symbol in the chosen production's right-hand side.</p>
<p>Consider the classic expression grammar (after eliminating left recursion):</p>
<p>$$
\begin{aligned}
E &\to T \; E' \\
E' &\to + \; T \; E' \;\mid\; \varepsilon \\
T &\to F \; T' \\
T' &\to * \; F \; T' \;\mid\; \varepsilon \\
F &\to ( \; E \; ) \;\mid\; \textbf{id}
\end{aligned}
$$</p>
<h3 id="22-implementation">2.2 Implementation<a class="header-link" href="#22-implementation" title="Permanent link">&para;</a></h3>
<p>Here is a complete recursive descent parser for arithmetic expressions:</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Recursive Descent Parser for Arithmetic Expressions</span>

<span class="sd">Grammar (LL(1)-compatible):</span>
<span class="sd">    E  -&gt; T E&#39;</span>
<span class="sd">    E&#39; -&gt; + T E&#39; | Œµ</span>
<span class="sd">    T  -&gt; F T&#39;</span>
<span class="sd">    T&#39; -&gt; * F T&#39; | Œµ</span>
<span class="sd">    F  -&gt; ( E ) | id | num</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Token Types ‚îÄ‚îÄ‚îÄ</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TokenType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">PLUS</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">STAR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">LPAREN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">RPAREN</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">ID</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">NUM</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">EOF</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Token</span><span class="p">:</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">TokenType</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">pos</span><span class="p">:</span> <span class="nb">int</span>  <span class="c1"># position in input for error reporting</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Lexer ‚îÄ‚îÄ‚îÄ</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Lexer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Simple tokenizer for arithmetic expressions.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">text</span> <span class="o">=</span> <span class="n">text</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_skip_whitespace</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">isspace</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">next_token</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Token</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_skip_whitespace</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Token</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">EOF</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">)</span>

        <span class="n">ch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span>

        <span class="k">if</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">Token</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">PLUS</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">Token</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">STAR</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">Token</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">LPAREN</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">Token</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">RPAREN</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ch</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">isdigit</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">Token</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">NUM</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">],</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ch</span><span class="o">.</span><span class="n">isalpha</span><span class="p">()</span> <span class="ow">or</span> <span class="n">ch</span> <span class="o">==</span> <span class="s1">&#39;_&#39;</span><span class="p">:</span>
            <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span><span class="o">.</span><span class="n">isalnum</span><span class="p">()</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;_&#39;</span>
            <span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">Token</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">ID</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">],</span> <span class="n">start</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected character &#39;</span><span class="si">{</span><span class="n">ch</span><span class="si">}</span><span class="s2">&#39; at position </span><span class="si">{</span><span class="n">start</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tokenize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Token</span><span class="p">]:</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_token</span><span class="p">()</span>
            <span class="n">tokens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TokenType</span><span class="o">.</span><span class="n">EOF</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">tokens</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ AST Nodes ‚îÄ‚îÄ‚îÄ</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ASTNode</span><span class="p">:</span>
    <span class="k">pass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NumLit</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Ident</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BinOp</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">ASTNode</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">ASTNode</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Recursive Descent Parser ‚îÄ‚îÄ‚îÄ</span>

<span class="k">class</span><span class="w"> </span><span class="nc">RecursiveDescentParser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parses arithmetic expressions using recursive descent.</span>

<span class="sd">    Each nonterminal in the grammar has a corresponding method:</span>
<span class="sd">        E  -&gt; T E&#39;        =&gt;  parse_E()</span>
<span class="sd">        E&#39; -&gt; + T E&#39; | Œµ  =&gt;  parse_E_prime(left)</span>
<span class="sd">        T  -&gt; F T&#39;        =&gt;  parse_T()</span>
<span class="sd">        T&#39; -&gt; * F T&#39; | Œµ  =&gt;  parse_T_prime(left)</span>
<span class="sd">        F  -&gt; ( E ) | id  =&gt;  parse_F()</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Token</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span> <span class="o">=</span> <span class="n">tokens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">current</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Token</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tokens</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pos</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">eat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expected</span><span class="p">:</span> <span class="n">TokenType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Token</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Consume the current token if it matches the expected type.&quot;&quot;&quot;</span>
        <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span>
        <span class="k">if</span> <span class="n">tok</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">expected</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Expected </span><span class="si">{</span><span class="n">expected</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> but found </span><span class="si">{</span><span class="n">tok</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(&#39;</span><span class="si">{</span><span class="n">tok</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;) at position </span><span class="si">{</span><span class="n">tok</span><span class="o">.</span><span class="n">pos</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pos</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">tok</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Entry point: parse the entire expression.&quot;&quot;&quot;</span>
        <span class="n">tree</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_E</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">EOF</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tree</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_E</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;E -&gt; T E&#39;&quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_T</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_E_prime</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_E_prime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;E&#39; -&gt; + T E&#39; | Œµ&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TokenType</span><span class="o">.</span><span class="n">PLUS</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">PLUS</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_T</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">BinOp</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_E_prime</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>  <span class="c1"># left-associate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Œµ-production: return what we have</span>
            <span class="k">return</span> <span class="n">left</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_T</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;T -&gt; F T&#39;&quot;&quot;&quot;</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_F</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_T_prime</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_T_prime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;T&#39; -&gt; * F T&#39; | Œµ&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TokenType</span><span class="o">.</span><span class="n">STAR</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">STAR</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_F</span><span class="p">()</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">BinOp</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_T_prime</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>  <span class="c1"># left-associate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_F</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;F -&gt; ( E ) | id | num&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TokenType</span><span class="o">.</span><span class="n">LPAREN</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">LPAREN</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_E</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">RPAREN</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">node</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TokenType</span><span class="o">.</span><span class="n">NUM</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">NUM</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">NumLit</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">value</span><span class="p">))</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">TokenType</span><span class="o">.</span><span class="n">ID</span><span class="p">:</span>
            <span class="n">tok</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eat</span><span class="p">(</span><span class="n">TokenType</span><span class="o">.</span><span class="n">ID</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Ident</span><span class="p">(</span><span class="n">tok</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">tok</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="n">tok</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">SyntaxError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unexpected token </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;) at position </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current</span><span class="o">.</span><span class="n">pos</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Pretty Printer ‚îÄ‚îÄ‚îÄ</span>

<span class="k">def</span><span class="w"> </span><span class="nf">pretty_print</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Produce a human-readable representation of the AST.&quot;&quot;&quot;</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;  &quot;</span> <span class="o">*</span> <span class="n">indent</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">NumLit</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">NumLit(</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">)&quot;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Ident</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">Ident(</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">)&quot;</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">):</span>
        <span class="n">left_str</span> <span class="o">=</span> <span class="n">pretty_print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">right_str</span> <span class="o">=</span> <span class="n">pretty_print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">BinOp(</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">)</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">left_str</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">right_str</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">Unknown(</span><span class="si">{</span><span class="n">node</span><span class="si">}</span><span class="s2">)&quot;</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Demo ‚îÄ‚îÄ‚îÄ</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">examples</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;3 + 4 * 5&quot;</span><span class="p">,</span>
        <span class="s2">&quot;(a + b) * c&quot;</span><span class="p">,</span>
        <span class="s2">&quot;x + y + z&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2 * (3 + 4)&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Input: </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">tokens</span> <span class="o">=</span> <span class="n">Lexer</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="n">tokenize</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tokens: </span><span class="si">{</span><span class="p">[(</span><span class="n">t</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">tokens</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">ast</span> <span class="o">=</span> <span class="n">RecursiveDescentParser</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="o">.</span><span class="n">parse</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;AST:</span><span class="se">\n</span><span class="si">{</span><span class="n">pretty_print</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p><strong>Output for "3 + 4 * 5":</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">Input</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5</span>
<span class="n">Tokens</span><span class="o">:</span><span class="w"> </span><span class="o">[(</span><span class="s1">&#39;NUM&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;3&#39;</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="s1">&#39;PLUS&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;+&#39;</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="s1">&#39;NUM&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;4&#39;</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="s1">&#39;STAR&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;*&#39;</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="s1">&#39;NUM&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;5&#39;</span><span class="o">),</span><span class="w"> </span><span class="o">(</span><span class="s1">&#39;EOF&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="o">)]</span>
<span class="n">AST</span><span class="o">:</span>
<span class="n">BinOp</span><span class="o">(+)</span>
<span class="w">  </span><span class="n">NumLit</span><span class="o">(</span><span class="mi">3</span><span class="o">)</span>
<span class="w">  </span><span class="n">BinOp</span><span class="o">(*)</span>
<span class="w">    </span><span class="n">NumLit</span><span class="o">(</span><span class="mi">4</span><span class="o">)</span>
<span class="w">    </span><span class="n">NumLit</span><span class="o">(</span><span class="mi">5</span><span class="o">)</span>
</code></pre></div>

<h3 id="23-advantages-and-limitations">2.3 Advantages and Limitations<a class="header-link" href="#23-advantages-and-limitations" title="Permanent link">&para;</a></h3>
<p><strong>Advantages:</strong></p>
<ul>
<li>Simple to understand and implement by hand</li>
<li>Natural error messages (each function knows what it expects)</li>
<li>Easy to embed semantic actions (AST construction, type checking)</li>
<li>Can handle some non-LL(1) constructs with manual backtracking</li>
</ul>
<p><strong>Limitations:</strong></p>
<ul>
<li>Requires the grammar to be (approximately) LL(1)</li>
<li>Cannot handle left-recursive grammars directly</li>
<li>Performance may degrade with excessive backtracking</li>
<li>Maintaining large parsers by hand is error-prone</li>
</ul>
<hr />
<h2 id="3-first-and-follow-sets">3. FIRST and FOLLOW Sets<a class="header-link" href="#3-first-and-follow-sets" title="Permanent link">&para;</a></h2>
<p>The FIRST and FOLLOW sets are the key data structures that make predictive parsing possible. They answer two essential questions:</p>
<ul>
<li><strong>FIRST($\alpha$)</strong>: What terminals can appear as the first symbol of a string derived from $\alpha$?</li>
<li><strong>FOLLOW($A$)</strong>: What terminals can appear immediately after nonterminal $A$ in some sentential form?</li>
</ul>
<h3 id="31-first-sets">3.1 FIRST Sets<a class="header-link" href="#31-first-sets" title="Permanent link">&para;</a></h3>
<p><strong>Definition.</strong> For a string of grammar symbols $\alpha$, $\text{FIRST}(\alpha)$ is the set of terminals that can begin strings derived from $\alpha$. If $\alpha \Rightarrow^* \varepsilon$, then $\varepsilon \in \text{FIRST}(\alpha)$.</p>
<p><strong>Algorithm to compute FIRST sets:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">Algorithm</span><span class="o">:</span><span class="w"> </span><span class="n">Compute</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">grammar</span><span class="w"> </span><span class="n">symbols</span><span class="w"> </span><span class="n">X</span>

<span class="mi">1</span><span class="o">.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">terminal</span><span class="o">:</span>
<span class="w">       </span><span class="n">FIRST</span><span class="o">(</span><span class="n">X</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">X</span><span class="o">}</span>

<span class="mi">2</span><span class="o">.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">nonterminal</span><span class="o">:</span>
<span class="w">       </span><span class="n">For</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">production</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Y1</span><span class="w"> </span><span class="n">Y2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">Yk</span><span class="o">:</span>
<span class="w">           </span><span class="n">Add</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">Y1</span><span class="o">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">{</span><span class="err">Œµ</span><span class="o">}</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">X</span><span class="o">)</span>
<span class="w">           </span><span class="n">If</span><span class="w"> </span><span class="err">Œµ</span><span class="w"> </span><span class="err">‚àà</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">Y1</span><span class="o">):</span>
<span class="w">               </span><span class="n">Add</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">Y2</span><span class="o">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">{</span><span class="err">Œµ</span><span class="o">}</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">X</span><span class="o">)</span>
<span class="w">               </span><span class="n">If</span><span class="w"> </span><span class="err">Œµ</span><span class="w"> </span><span class="err">‚àà</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">Y2</span><span class="o">):</span>
<span class="w">                   </span><span class="n">Add</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">Y3</span><span class="o">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">{</span><span class="err">Œµ</span><span class="o">}</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">X</span><span class="o">)</span>
<span class="w">                   </span><span class="o">...</span><span class="k">continue</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">Yi</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="err">Œµ</span><span class="w"> </span><span class="err">‚àâ</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">Yi</span><span class="o">)</span>
<span class="w">           </span><span class="n">If</span><span class="w"> </span><span class="err">Œµ</span><span class="w"> </span><span class="err">‚àà</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">Yi</span><span class="o">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">..</span><span class="n">k</span><span class="o">:</span>
<span class="w">               </span><span class="n">Add</span><span class="w"> </span><span class="err">Œµ</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">X</span><span class="o">)</span>

<span class="mi">3</span><span class="o">.</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œµ</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">production</span><span class="o">:</span>
<span class="w">       </span><span class="n">Add</span><span class="w"> </span><span class="err">Œµ</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">FIRST</span><span class="o">(</span><span class="n">X</span><span class="o">)</span>

<span class="n">Repeat</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">FIRST</span><span class="w"> </span><span class="kd">set</span><span class="w"> </span><span class="n">changes</span><span class="o">.</span>
</code></pre></div>

<p><strong>Extending FIRST to strings:</strong></p>
<p>For a string $\alpha = X_1 X_2 \cdots X_n$:</p>
<p>$$
\text{FIRST}(X_1 X_2 \cdots X_n) = \begin{cases}
\text{FIRST}(X_1) & \text{if } \varepsilon \notin \text{FIRST}(X_1) \\
(\text{FIRST}(X_1) - \{\varepsilon\}) \cup \text{FIRST}(X_2 \cdots X_n) & \text{if } \varepsilon \in \text{FIRST}(X_1)
\end{cases}
$$</p>
<h3 id="32-follow-sets">3.2 FOLLOW Sets<a class="header-link" href="#32-follow-sets" title="Permanent link">&para;</a></h3>
<p><strong>Definition.</strong> For a nonterminal $A$, $\text{FOLLOW}(A)$ is the set of terminals that can appear immediately to the right of $A$ in some sentential form. The end-of-input marker $\ LATEX2  (columns). Each entry $M[A, a]$ contains a production to apply.</p>
<p><strong>Algorithm: LL(1) Table Construction</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">production</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">grammar</span><span class="o">:</span>
<span class="w">    </span><span class="mf">1.</span><span class="w"> </span><span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">terminal</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="kr">FIRST</span><span class="p">(</span><span class="err">Œ±</span><span class="p">)</span><span class="o">:</span>
<span class="w">           </span><span class="n">Add</span><span class="w"> </span><span class="s">&quot;A -&gt; Œ±&quot;</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">]</span>

<span class="w">    </span><span class="mf">2.</span><span class="w"> </span><span class="nf">If</span><span class="w"> </span><span class="err">Œµ</span><span class="w"> </span><span class="err">‚àà</span><span class="w"> </span><span class="kr">FIRST</span><span class="p">(</span><span class="err">Œ±</span><span class="p">)</span><span class="o">:</span>
<span class="w">           </span><span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">terminal</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">FOLLOW</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">:</span>
<span class="w">               </span><span class="n">Add</span><span class="w"> </span><span class="s">&quot;A -&gt; Œ±&quot;</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">]</span>
<span class="w">           </span><span class="nf">If</span><span class="w"> </span><span class="err">$</span><span class="w"> </span><span class="err">‚àà</span><span class="w"> </span><span class="n">FOLLOW</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">:</span>
<span class="w">               </span><span class="n">Add</span><span class="w"> </span><span class="s">&quot;A -&gt; Œ±&quot;</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">M</span><span class="p">[</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="err">$</span><span class="p">]</span>
</code></pre></div>

<p><strong>Definition.</strong> A grammar is <strong>LL(1)</strong> if and only if every entry in the parsing table $M$ contains at most one production.</p>
<h3 id="42-python-implementation">4.2 Python Implementation<a class="header-link" href="#42-python-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">build_ll1_table</span><span class="p">(</span>
    <span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span>
    <span class="n">first</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">follow</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build the LL(1) parsing table.</span>

<span class="sd">    Returns:</span>
<span class="sd">        (table, conflicts) where:</span>
<span class="sd">        - table: dict mapping (nonterminal, terminal) -&gt; production RHS</span>
<span class="sd">        - conflicts: list of conflict descriptions (empty if grammar is LL(1))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">table</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">conflicts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_list</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhs_list</span><span class="p">:</span>
            <span class="c1"># Compute FIRST of the RHS</span>
            <span class="n">rhs_first</span> <span class="o">=</span> <span class="n">first_of_string</span><span class="p">(</span><span class="n">rhs</span><span class="p">,</span> <span class="n">first</span><span class="p">)</span>

            <span class="c1"># Rule 1: For each terminal a in FIRST(rhs)</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">rhs_first</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">EPSILON</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
                    <span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

            <span class="c1"># Rule 2: If Œµ in FIRST(rhs), for each b in FOLLOW(lhs)</span>
            <span class="k">if</span> <span class="n">EPSILON</span> <span class="ow">in</span> <span class="n">rhs_first</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">follow</span><span class="p">[</span><span class="n">lhs</span><span class="p">]:</span>
                    <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
                        <span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

    <span class="c1"># Check for conflicts</span>
    <span class="n">final_table</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">prods</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">prods</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">conflict_strs</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">prods</span><span class="p">]</span>
            <span class="n">conflicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Conflict at M[</span><span class="si">{</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">]: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39; vs &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conflict_strs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">final_table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">prods</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">final_table</span><span class="p">,</span> <span class="n">conflicts</span>


<span class="k">def</span><span class="w"> </span><span class="nf">print_ll1_table</span><span class="p">(</span>
    <span class="n">table</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pretty-print the LL(1) parsing table.&quot;&quot;&quot;</span>
    <span class="n">terminals_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">terminals</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">EOF</span><span class="p">]</span>
    <span class="n">nonterminals_list</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">nonterminals</span><span class="p">)</span>

    <span class="c1"># Compute column widths</span>
    <span class="n">col_width</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
        <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terminals_list</span><span class="p">),</span>
        <span class="nb">max</span><span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span> <span class="n">t</span><span class="p">),</span> <span class="p">[])))</span>
            <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="n">nonterminals_list</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terminals_list</span>
        <span class="p">),</span>
        <span class="mi">8</span>
    <span class="p">)</span> <span class="o">+</span> <span class="mi">2</span>

    <span class="c1"># Header</span>
    <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;&#39;</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t</span><span class="si">:</span><span class="s2">&gt;</span><span class="si">{</span><span class="n">col_width</span><span class="si">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terminals_list</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">))</span>

    <span class="c1"># Rows</span>
    <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="n">nonterminals_list</span><span class="p">:</span>
        <span class="n">row</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nt</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terminals_list</span><span class="p">:</span>
            <span class="n">entry</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">nt</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">:</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nt</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="n">row</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cell</span><span class="si">:</span><span class="s2">&gt;</span><span class="si">{</span><span class="n">col_width</span><span class="si">}}</span><span class="s2">&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="n">build_expression_grammar</span><span class="p">()</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">compute_first</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
    <span class="n">follow</span> <span class="o">=</span> <span class="n">compute_follow</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">first</span><span class="p">)</span>
    <span class="n">table</span><span class="p">,</span> <span class="n">conflicts</span> <span class="o">=</span> <span class="n">build_ll1_table</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">follow</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">conflicts</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LL(1) conflicts found:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">conflicts</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Grammar is LL(1)!&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">LL(1) Parsing Table:&quot;</span><span class="p">)</span>
    <span class="n">print_ll1_table</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">grammar</span><span class="p">)</span>
</code></pre></div>

<h3 id="43-the-expression-grammar-table">4.3 The Expression Grammar Table<a class="header-link" href="#43-the-expression-grammar-table" title="Permanent link">&para;</a></h3>
<p>For the expression grammar, the LL(1) table is:</p>
<div class="highlight"><pre><span></span><code><span class="w">             </span><span class="p">(</span><span class="w">          </span><span class="p">)</span><span class="w">          </span><span class="o">*</span><span class="w">          </span><span class="o">+</span><span class="w">         </span><span class="nv">id</span><span class="w">          </span><span class="p">$</span>
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
<span class="w">   </span><span class="nv">E</span><span class="w">     </span><span class="nv">E</span><span class="o">-&gt;</span><span class="nv">T</span><span class="w"> </span><span class="nv">E</span><span class="o">&#39;</span><span class="w">                                    </span><span class="nv">E</span><span class="o">-&gt;</span><span class="nv">T</span><span class="w"> </span><span class="nv">E</span><span class="o">&#39;</span>
<span class="w">   </span><span class="nv">E</span><span class="o">&#39;</span><span class="w">               </span><span class="nv">E</span><span class="o">&#39;-&gt;</span>Œµ<span class="w">                </span><span class="nv">E</span><span class="o">&#39;-&gt;+</span><span class="nv">T</span><span class="w"> </span><span class="nv">E</span><span class="o">&#39;</span><span class="w">              </span><span class="nv">E</span><span class="o">&#39;-&gt;</span>Œµ
<span class="w">   </span><span class="nv">F</span><span class="w">     </span><span class="nv">F</span><span class="o">-&gt;</span><span class="p">(</span><span class="nv">E</span><span class="p">)</span><span class="w">                                     </span><span class="nv">F</span><span class="o">-&gt;</span><span class="nv">id</span>
<span class="w">   </span><span class="nv">T</span><span class="w">     </span><span class="nv">T</span><span class="o">-&gt;</span><span class="nv">F</span><span class="w"> </span><span class="nv">T</span><span class="o">&#39;</span><span class="w">                                    </span><span class="nv">T</span><span class="o">-&gt;</span><span class="nv">F</span><span class="w"> </span><span class="nv">T</span><span class="o">&#39;</span>
<span class="w">   </span><span class="nv">T</span><span class="o">&#39;</span><span class="w">               </span><span class="nv">T</span><span class="o">&#39;-&gt;</span>Œµ<span class="w">     </span><span class="nv">T</span><span class="o">&#39;-&gt;*</span><span class="nv">F</span><span class="w"> </span><span class="nv">T</span><span class="o">&#39;</span><span class="w">   </span><span class="nv">T</span><span class="o">&#39;-&gt;</span>Œµ<span class="w">                 </span><span class="nv">T</span><span class="o">&#39;-&gt;</span>Œµ
</code></pre></div>

<p><strong>Reading the table:</strong> If the parser sees nonterminal $E$ on top of the stack and the lookahead is <code>id</code>, it applies the production $E \to T\ E'$.</p>
<hr />
<h2 id="5-table-driven-ll1-parser">5. Table-Driven LL(1) Parser<a class="header-link" href="#5-table-driven-ll1-parser" title="Permanent link">&para;</a></h2>
<h3 id="51-the-parsing-algorithm">5.1 The Parsing Algorithm<a class="header-link" href="#51-the-parsing-algorithm" title="Permanent link">&para;</a></h3>
<p>The table-driven LL(1) parser uses an explicit stack and the parsing table to simulate a leftmost derivation.</p>
<div class="highlight"><pre><span></span><code><span class="n">Algorithm</span><span class="o">:</span><span class="w"> </span><span class="n">Table</span><span class="o">-</span><span class="n">Driven</span><span class="w"> </span><span class="n">LL</span><span class="o">(</span><span class="mi">1</span><span class="o">)</span><span class="w"> </span><span class="n">Parsing</span>

<span class="n">Input</span><span class="o">:</span><span class="w">  </span><span class="n">string</span><span class="w"> </span><span class="n">w$</span><span class="o">,</span><span class="w"> </span><span class="n">parsing</span><span class="w"> </span><span class="n">table</span><span class="w"> </span><span class="n">M</span>
<span class="n">Output</span><span class="o">:</span><span class="w"> </span><span class="n">leftmost</span><span class="w"> </span><span class="n">derivation</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">error</span>

<span class="n">Initialize</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">S</span><span class="o">,</span><span class="w"> </span><span class="n">$</span><span class="o">]</span><span class="w">  </span><span class="o">(</span><span class="n">start</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">top</span><span class="o">)</span>
<span class="n">Set</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">w$</span>

<span class="n">repeat</span><span class="o">:</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">stack</span><span class="o">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="n">symbol</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">terminal</span><span class="o">:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">a</span><span class="o">:</span>
<span class="w">            </span><span class="n">pop</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">stack</span>
<span class="w">            </span><span class="n">advance</span><span class="w"> </span><span class="n">ip</span><span class="w">          </span><span class="o">(</span><span class="s2">&quot;match&quot;</span><span class="o">)</span>
<span class="w">        </span><span class="k">else</span><span class="o">:</span>
<span class="w">            </span><span class="n">error</span><span class="o">()</span>

<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">$</span><span class="o">:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">$</span><span class="o">:</span>
<span class="w">            </span><span class="n">accept</span><span class="o">()</span><span class="w">            </span><span class="o">(</span><span class="s2">&quot;success&quot;</span><span class="o">)</span>
<span class="w">        </span><span class="k">else</span><span class="o">:</span>
<span class="w">            </span><span class="n">error</span><span class="o">()</span>

<span class="w">    </span><span class="k">else</span><span class="o">:</span><span class="w">  </span><span class="o">(</span><span class="n">X</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">nonterminal</span><span class="o">)</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">M</span><span class="o">[</span><span class="n">X</span><span class="o">,</span><span class="w"> </span><span class="n">a</span><span class="o">]</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">defined</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Y1</span><span class="w"> </span><span class="n">Y2</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="n">Yk</span><span class="o">:</span>
<span class="w">            </span><span class="n">pop</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">stack</span>
<span class="w">            </span><span class="n">push</span><span class="w"> </span><span class="n">Yk</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">Y2</span><span class="o">,</span><span class="w"> </span><span class="n">Y1</span><span class="w"> </span><span class="n">onto</span><span class="w"> </span><span class="n">stack</span><span class="w">  </span><span class="o">(</span><span class="n">Y1</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">top</span><span class="o">)</span>
<span class="w">            </span><span class="n">output</span><span class="w"> </span><span class="s2">&quot;X -&gt; Y1 Y2 ... Yk&quot;</span>
<span class="w">        </span><span class="k">else</span><span class="o">:</span>
<span class="w">            </span><span class="n">error</span><span class="o">()</span>
</code></pre></div>

<h3 id="52-complete-implementation">5.2 Complete Implementation<a class="header-link" href="#52-complete-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Table-Driven LL(1) Parser</span>

<span class="sd">Implements a complete LL(1) parser using the parsing table constructed</span>
<span class="sd">from FIRST and FOLLOW sets.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LL1Parser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A table-driven LL(1) parser.</span>

<span class="sd">    Uses an explicit stack and a parsing table to parse input strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span>
        <span class="n">table</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span> <span class="o">=</span> <span class="n">table</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse a list of terminal symbols.</span>

<span class="sd">        Args:</span>
<span class="sd">            tokens: list of terminal symbols (without $)</span>
<span class="sd">            verbose: if True, print each step</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if the input is accepted, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Add end marker</span>
        <span class="n">input_symbols</span> <span class="o">=</span> <span class="n">tokens</span> <span class="o">+</span> <span class="p">[</span><span class="n">EOF</span><span class="p">]</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># input pointer</span>

        <span class="c1"># Initialize stack with $ and start symbol</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">EOF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">]</span>

        <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;Step&#39;</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="s1">&#39;Stack&#39;</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Input&#39;</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Action&#39;</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">90</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">top</span> <span class="o">=</span> <span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">input_symbols</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span>
            <span class="n">remaining</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_symbols</span><span class="p">[</span><span class="n">ip</span><span class="p">:])</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">stack_str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">stack</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">step</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">stack_str</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">remaining</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="c1"># Case 1: Top is $ (end marker)</span>
            <span class="k">if</span> <span class="n">top</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">current</span> <span class="o">==</span> <span class="n">EOF</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ACCEPT&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR: unexpected input after stack empty&quot;</span><span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># Case 2: Top is a terminal</span>
            <span class="k">if</span> <span class="n">top</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">terminals</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">top</span> <span class="o">==</span> <span class="n">current</span><span class="p">:</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">ip</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Match &#39;</span><span class="si">{</span><span class="n">top</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;ERROR: expected &#39;</span><span class="si">{</span><span class="n">top</span><span class="si">}</span><span class="s2">&#39;, found &#39;</span><span class="si">{</span><span class="n">current</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                        <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="c1"># Case 3: Top is a nonterminal</span>
            <span class="k">elif</span> <span class="n">top</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">nonterminals</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">top</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">:</span>
                    <span class="n">production</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

                    <span class="c1"># Push RHS in reverse order (so first symbol is on top)</span>
                    <span class="k">if</span> <span class="n">production</span> <span class="o">!=</span> <span class="p">[</span><span class="n">EPSILON</span><span class="p">]:</span>
                        <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">production</span><span class="p">):</span>
                            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>

                    <span class="n">prod_str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">production</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Apply </span><span class="si">{</span><span class="n">top</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">prod_str</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;ERROR: no entry for M[</span><span class="si">{</span><span class="n">top</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">current</span><span class="si">}</span><span class="s2">]&quot;</span>
                        <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR: unknown symbol &#39;</span><span class="si">{</span><span class="n">top</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Safety: prevent infinite loops</span>
            <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">10000</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR: too many steps, possible infinite loop&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Demo ‚îÄ‚îÄ‚îÄ</span>

<span class="k">def</span><span class="w"> </span><span class="nf">demo_ll1_parser</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate the LL(1) parser on the expression grammar.&quot;&quot;&quot;</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="n">build_expression_grammar</span><span class="p">()</span>
    <span class="n">first</span> <span class="o">=</span> <span class="n">compute_first</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
    <span class="n">follow</span> <span class="o">=</span> <span class="n">compute_follow</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">first</span><span class="p">)</span>
    <span class="n">table</span><span class="p">,</span> <span class="n">conflicts</span> <span class="o">=</span> <span class="n">build_ll1_table</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">follow</span><span class="p">)</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">LL1Parser</span><span class="p">(</span><span class="n">grammar</span><span class="p">,</span> <span class="n">table</span><span class="p">)</span>

    <span class="c1"># Test inputs</span>
    <span class="n">tests</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">([</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span>
        <span class="p">([</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span>
        <span class="p">([</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">],</span> <span class="kc">False</span><span class="p">),</span>
        <span class="p">([</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="kc">False</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">expected</span> <span class="ow">in</span> <span class="n">tests</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">90</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input: </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">90</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;ACCEPTED&quot;</span> <span class="k">if</span> <span class="n">result</span> <span class="k">else</span> <span class="s2">&quot;REJECTED&quot;</span>
        <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="n">expected</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Expected </span><span class="si">{</span><span class="n">expected</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Result: </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo_ll1_parser</span><span class="p">()</span>
</code></pre></div>

<p><strong>Example trace for "id + id * id":</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">Step</span><span class="w">  </span><span class="n">Stack</span><span class="w">                          </span><span class="n">Input</span><span class="w">                          </span><span class="n">Action</span>
<span class="o">------------------------------------------------------------------------------------------</span>
<span class="w">   </span><span class="mi">0</span><span class="w">  </span><span class="n">E</span><span class="w"> </span><span class="err">$</span><span class="w">                            </span><span class="n">id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">                 </span><span class="kr">Apply</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">E</span><span class="s">&#39;</span>
<span class="s">   1  T E&#39;</span><span class="w"> </span><span class="err">$</span><span class="w">                         </span><span class="n">id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">                 </span><span class="kr">Apply</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">T</span><span class="s">&#39;</span>
<span class="s">   2  F T&#39;</span><span class="w"> </span><span class="n">E</span><span class="s">&#39; $                      id + id * id $                 Apply F -&gt; id</span>
<span class="s">   3  id T&#39;</span><span class="w"> </span><span class="n">E</span><span class="s">&#39; $                     id + id * id $                 Match &#39;</span><span class="n">id</span><span class="s">&#39;</span>
<span class="s">   4  T&#39;</span><span class="w"> </span><span class="n">E</span><span class="s">&#39; $                        + id * id $                    Apply T&#39;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œµ</span>
<span class="w">   </span><span class="mi">5</span><span class="w">  </span><span class="n">E</span><span class="s">&#39; $                           + id * id $                    Apply E&#39;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="n">E</span><span class="s">&#39;</span>
<span class="s">   6  + T E&#39;</span><span class="w"> </span><span class="err">$</span><span class="w">                       </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">                    </span><span class="n">Match</span><span class="w"> </span><span class="s">&#39;+&#39;</span>
<span class="w">   </span><span class="mi">7</span><span class="w">  </span><span class="n">T</span><span class="w"> </span><span class="n">E</span><span class="s">&#39; $                         id * id $                      Apply T -&gt; F T&#39;</span>
<span class="w">   </span><span class="mi">8</span><span class="w">  </span><span class="n">F</span><span class="w"> </span><span class="n">T</span><span class="s">&#39; E&#39;</span><span class="w"> </span><span class="err">$</span><span class="w">                      </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">                      </span><span class="kr">Apply</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">id</span>
<span class="w">   </span><span class="mi">9</span><span class="w">  </span><span class="n">id</span><span class="w"> </span><span class="n">T</span><span class="s">&#39; E&#39;</span><span class="w"> </span><span class="err">$</span><span class="w">                     </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">                      </span><span class="n">Match</span><span class="w"> </span><span class="s">&#39;id&#39;</span>
<span class="w">  </span><span class="mi">10</span><span class="w">  </span><span class="n">T</span><span class="s">&#39; E&#39;</span><span class="w"> </span><span class="err">$</span><span class="w">                        </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">                         </span><span class="kr">Apply</span><span class="w"> </span><span class="n">T</span><span class="s">&#39; -&gt; * F T&#39;</span>
<span class="w">  </span><span class="mi">11</span><span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">T</span><span class="s">&#39; E&#39;</span><span class="w"> </span><span class="err">$</span><span class="w">                    </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">                         </span><span class="n">Match</span><span class="w"> </span><span class="s">&#39;*&#39;</span>
<span class="w">  </span><span class="mi">12</span><span class="w">  </span><span class="n">F</span><span class="w"> </span><span class="n">T</span><span class="s">&#39; E&#39;</span><span class="w"> </span><span class="err">$</span><span class="w">                      </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">                           </span><span class="kr">Apply</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">id</span>
<span class="w">  </span><span class="mi">13</span><span class="w">  </span><span class="n">id</span><span class="w"> </span><span class="n">T</span><span class="s">&#39; E&#39;</span><span class="w"> </span><span class="err">$</span><span class="w">                     </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">                           </span><span class="n">Match</span><span class="w"> </span><span class="s">&#39;id&#39;</span>
<span class="w">  </span><span class="mi">14</span><span class="w">  </span><span class="n">T</span><span class="s">&#39; E&#39;</span><span class="w"> </span><span class="err">$</span><span class="w">                        </span><span class="err">$</span><span class="w">                              </span><span class="kr">Apply</span><span class="w"> </span><span class="n">T</span><span class="s">&#39; -&gt; Œµ</span>
<span class="s">  15  E&#39;</span><span class="w"> </span><span class="err">$</span><span class="w">                           </span><span class="err">$</span><span class="w">                              </span><span class="kr">Apply</span><span class="w"> </span><span class="n">E</span><span class="s">&#39; -&gt; Œµ</span>
<span class="s">  16  $                              $                              ACCEPT</span>
</code></pre></div>

<hr />
<h2 id="6-left-recursion-elimination">6. Left Recursion Elimination<a class="header-link" href="#6-left-recursion-elimination" title="Permanent link">&para;</a></h2>
<h3 id="61-the-problem">6.1 The Problem<a class="header-link" href="#61-the-problem" title="Permanent link">&para;</a></h3>
<p>A grammar is <strong>left-recursive</strong> if there exists a nonterminal $A$ such that $A \Rightarrow^+ A\alpha$ for some string $\alpha$. Top-down parsers cannot handle left recursion because parsing $A$ would immediately require parsing $A$ again, leading to infinite recursion.</p>
<p><strong>Immediate left recursion</strong> has the form:</p>
<p>$$A \to A\alpha_1 \mid A\alpha_2 \mid \cdots \mid A\alpha_m \mid \beta_1 \mid \beta_2 \mid \cdots \mid \beta_n$$</p>
<p>where none of the $\beta_i$ starts with $A$.</p>
<h3 id="62-eliminating-immediate-left-recursion">6.2 Eliminating Immediate Left Recursion<a class="header-link" href="#62-eliminating-immediate-left-recursion" title="Permanent link">&para;</a></h3>
<p><strong>Transformation rule:</strong></p>
<p>Replace:
$$A \to A\alpha_1 \mid A\alpha_2 \mid \cdots \mid \beta_1 \mid \beta_2 \mid \cdots$$</p>
<p>With:
$$
\begin{aligned}
A &\to \beta_1 A' \mid \beta_2 A' \mid \cdots \\
A' &\to \alpha_1 A' \mid \alpha_2 A' \mid \cdots \mid \varepsilon
\end{aligned}
$$</p>
<p><strong>Example:</strong> The left-recursive expression grammar:</p>
<p>$$E \to E + T \mid T$$</p>
<p>Becomes:</p>
<p>$$
\begin{aligned}
E &\to T\ E' \\
E' &\to +\ T\ E' \mid \varepsilon
\end{aligned}
$$</p>
<h3 id="63-eliminating-indirect-left-recursion">6.3 Eliminating Indirect Left Recursion<a class="header-link" href="#63-eliminating-indirect-left-recursion" title="Permanent link">&para;</a></h3>
<p>Indirect (or hidden) left recursion occurs when the cycle involves multiple nonterminals:</p>
<p>$$
\begin{aligned}
A &\to B\alpha \\
B &\to A\beta
\end{aligned}
$$</p>
<p>Here $A \Rightarrow B\alpha \Rightarrow A\beta\alpha$, so $A$ is indirectly left-recursive.</p>
<p><strong>Algorithm: Eliminate All Left Recursion</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">Input</span><span class="o">:</span><span class="w"> </span><span class="n">Grammar</span><span class="w"> </span><span class="n">G</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">cycles</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="err">Œµ</span><span class="o">-</span><span class="n">productions</span>
<span class="w">       </span><span class="o">(</span><span class="n">except</span><span class="w"> </span><span class="err">Œµ</span><span class="o">-</span><span class="n">productions</span><span class="w"> </span><span class="n">introduced</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">algorithm</span><span class="o">)</span>

<span class="mi">1</span><span class="o">.</span><span class="w"> </span><span class="n">Order</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">nonterminals</span><span class="o">:</span><span class="w"> </span><span class="n">A1</span><span class="o">,</span><span class="w"> </span><span class="n">A2</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">An</span>

<span class="mi">2</span><span class="o">.</span><span class="w"> </span><span class="n">For</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">n</span><span class="o">:</span>
<span class="w">       </span><span class="n">For</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="o">:</span>
<span class="w">           </span><span class="n">Replace</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">production</span><span class="w"> </span><span class="n">Ai</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Aj</span><span class="w"> </span><span class="err">Œ≥</span><span class="w"> </span><span class="k">with</span><span class="o">:</span>
<span class="w">               </span><span class="n">Ai</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ¥</span><span class="mi">1</span><span class="w"> </span><span class="err">Œ≥</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="err">Œ¥</span><span class="mi">2</span><span class="w"> </span><span class="err">Œ≥</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="err">Œ¥</span><span class="n">k</span><span class="w"> </span><span class="err">Œ≥</span>
<span class="w">           </span><span class="n">where</span><span class="w"> </span><span class="n">Aj</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ¥</span><span class="mi">1</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="err">Œ¥</span><span class="mi">2</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">...</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="err">Œ¥</span><span class="n">k</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">Aj</span><span class="o">-</span><span class="n">productions</span>

<span class="w">       </span><span class="n">Eliminate</span><span class="w"> </span><span class="n">immediate</span><span class="w"> </span><span class="n">left</span><span class="w"> </span><span class="n">recursion</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">Ai</span><span class="w"> </span><span class="n">productions</span>
</code></pre></div>

<h3 id="64-python-implementation">6.4 Python Implementation<a class="header-link" href="#64-python-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">eliminate_immediate_left_recursion</span><span class="p">(</span>
    <span class="n">lhs</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">productions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Eliminate immediate left recursion from productions of a nonterminal.</span>

<span class="sd">    Args:</span>
<span class="sd">        lhs: the nonterminal</span>
<span class="sd">        productions: list of RHS alternatives</span>

<span class="sd">    Returns:</span>
<span class="sd">        (new_nonterminal, new_productions_for_lhs, productions_for_new)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">left_recursive</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">non_recursive</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">productions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">lhs</span><span class="p">:</span>
            <span class="c1"># A -&gt; A Œ±  =&gt;  Œ± part</span>
            <span class="n">left_recursive</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rhs</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">non_recursive</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">left_recursive</span><span class="p">:</span>
        <span class="c1"># No left recursion to eliminate</span>
        <span class="k">return</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">productions</span><span class="p">,</span> <span class="p">[]</span>

    <span class="c1"># Create new nonterminal A&#39;</span>
    <span class="n">new_nt</span> <span class="o">=</span> <span class="n">lhs</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>

    <span class="c1"># A -&gt; Œ≤1 A&#39; | Œ≤2 A&#39; | ...</span>
    <span class="n">new_lhs_prods</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">beta</span> <span class="ow">in</span> <span class="n">non_recursive</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">beta</span> <span class="o">==</span> <span class="p">[</span><span class="n">EPSILON</span><span class="p">]:</span>
            <span class="n">new_lhs_prods</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">new_nt</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_lhs_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">beta</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_nt</span><span class="p">])</span>

    <span class="c1"># A&#39; -&gt; Œ±1 A&#39; | Œ±2 A&#39; | ... | Œµ</span>
    <span class="n">new_nt_prods</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">alpha</span> <span class="ow">in</span> <span class="n">left_recursive</span><span class="p">:</span>
        <span class="n">new_nt_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">alpha</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_nt</span><span class="p">])</span>
    <span class="n">new_nt_prods</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">EPSILON</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">new_nt</span><span class="p">,</span> <span class="n">new_lhs_prods</span><span class="p">,</span> <span class="n">new_nt_prods</span>


<span class="k">def</span><span class="w"> </span><span class="nf">eliminate_all_left_recursion</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Grammar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Eliminate all left recursion (immediate and indirect) from a grammar.</span>

<span class="sd">    Returns a new grammar with no left recursion.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_grammar</span> <span class="o">=</span> <span class="n">Grammar</span><span class="p">()</span>
    <span class="n">nonterminals</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">grammar</span><span class="o">.</span><span class="n">nonterminals</span><span class="p">)</span>

    <span class="c1"># Working copy of productions</span>
    <span class="n">current_prods</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">nt</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">rhs_list</span><span class="p">)</span> <span class="k">for</span> <span class="n">nt</span><span class="p">,</span> <span class="n">rhs_list</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ai</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nonterminals</span><span class="p">):</span>
        <span class="c1"># Step 1: Replace Ai -&gt; Aj Œ≥ for j &lt; i</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
            <span class="n">aj</span> <span class="o">=</span> <span class="n">nonterminals</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">new_prods</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">current_prods</span><span class="p">[</span><span class="n">ai</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">aj</span><span class="p">:</span>
                    <span class="c1"># Substitute: Ai -&gt; Aj Œ≥ becomes Ai -&gt; Œ¥k Œ≥</span>
                    <span class="n">gamma</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="k">for</span> <span class="n">delta</span> <span class="ow">in</span> <span class="n">current_prods</span><span class="p">[</span><span class="n">aj</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">delta</span> <span class="o">==</span> <span class="p">[</span><span class="n">EPSILON</span><span class="p">]:</span>
                            <span class="n">new_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gamma</span> <span class="k">if</span> <span class="n">gamma</span> <span class="k">else</span> <span class="p">[</span><span class="n">EPSILON</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">delta</span> <span class="o">+</span> <span class="n">gamma</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_prods</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
            <span class="n">current_prods</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_prods</span>

        <span class="c1"># Step 2: Eliminate immediate left recursion</span>
        <span class="n">new_nt</span><span class="p">,</span> <span class="n">lhs_prods</span><span class="p">,</span> <span class="n">nt_prods</span> <span class="o">=</span> <span class="n">eliminate_immediate_left_recursion</span><span class="p">(</span>
            <span class="n">ai</span><span class="p">,</span> <span class="n">current_prods</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">current_prods</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span> <span class="o">=</span> <span class="n">lhs_prods</span>
        <span class="k">if</span> <span class="n">nt_prods</span><span class="p">:</span>
            <span class="n">current_prods</span><span class="p">[</span><span class="n">new_nt</span><span class="p">]</span> <span class="o">=</span> <span class="n">nt_prods</span>

    <span class="c1"># Build new grammar</span>
    <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_list</span> <span class="ow">in</span> <span class="n">current_prods</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhs_list</span><span class="p">:</span>
            <span class="n">new_grammar</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>

    <span class="n">new_grammar</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">start</span>
    <span class="n">new_grammar</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">new_grammar</span>


<span class="c1"># Example:</span>
<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Grammar</span><span class="p">()</span>
    <span class="c1"># Left-recursive expression grammar</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original grammar:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="n">g2</span> <span class="o">=</span> <span class="n">eliminate_all_left_recursion</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After left-recursion elimination:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">g2</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="7-left-factoring">7. Left Factoring<a class="header-link" href="#7-left-factoring" title="Permanent link">&para;</a></h2>
<h3 id="71-the-problem">7.1 The Problem<a class="header-link" href="#71-the-problem" title="Permanent link">&para;</a></h3>
<p>Left factoring is needed when two or more productions for a nonterminal share a common prefix, causing the parser to be unable to decide which production to use.</p>
<p><strong>Example:</strong></p>
<p>$$
\text{Stmt} \to \textbf{if}\ E\ \textbf{then}\ S\ \textbf{else}\ S \mid \textbf{if}\ E\ \textbf{then}\ S
$$</p>
<p>Both alternatives start with <code>if E then S</code>, so with a single lookahead token the parser cannot choose.</p>
<h3 id="72-the-transformation">7.2 The Transformation<a class="header-link" href="#72-the-transformation" title="Permanent link">&para;</a></h3>
<p>For productions $A \to \alpha\beta_1 \mid \alpha\beta_2$, replace with:</p>
<p>$$
\begin{aligned}
A &\to \alpha\ A' \\
A' &\to \beta_1 \mid \beta_2
\end{aligned}
$$</p>
<p><strong>After left factoring the if-then-else:</strong></p>
<p>$$
\begin{aligned}
\text{Stmt} &\to \textbf{if}\ E\ \textbf{then}\ S\ \text{Stmt'} \\
\text{Stmt'} &\to \textbf{else}\ S \mid \varepsilon
\end{aligned}
$$</p>
<h3 id="73-implementation">7.3 Implementation<a class="header-link" href="#73-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">left_factor</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Grammar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply left factoring to the grammar.</span>

<span class="sd">    Returns a new grammar with common prefixes factored out.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">new_grammar</span> <span class="o">=</span> <span class="n">Grammar</span><span class="p">()</span>
    <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_list</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">remaining</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">rhs_list</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">remaining</span><span class="p">:</span>
            <span class="c1"># Find the longest common prefix among remaining productions</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">remaining</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">new_grammar</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">remaining</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">remaining</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">continue</span>

            <span class="c1"># Group by first symbol</span>
            <span class="n">groups</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">remaining</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="n">rhs</span> <span class="k">else</span> <span class="n">EPSILON</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">groups</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>

            <span class="n">new_remaining</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">first_sym</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">new_grammar</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Find longest common prefix</span>
                    <span class="n">prefix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">group</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="n">new_prefix</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">rhs</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">:</span>
                                <span class="n">new_prefix</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="k">break</span>
                        <span class="n">prefix</span> <span class="o">=</span> <span class="n">new_prefix</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">prefix</span><span class="p">:</span>
                        <span class="c1"># No common prefix; just add all</span>
                        <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                            <span class="n">new_grammar</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># Factor out the prefix</span>
                        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">new_nt</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lhs</span><span class="si">}</span><span class="s2">_F</span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">&quot;</span>
                        <span class="n">new_grammar</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span>
                            <span class="n">lhs</span><span class="p">,</span> <span class="n">prefix</span> <span class="o">+</span> <span class="p">[</span><span class="n">new_nt</span><span class="p">]</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                            <span class="n">suffix</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">):]</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">suffix</span><span class="p">:</span>
                                <span class="n">suffix</span> <span class="o">=</span> <span class="p">[</span><span class="n">EPSILON</span><span class="p">]</span>
                            <span class="n">new_grammar</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="n">new_nt</span><span class="p">,</span> <span class="n">suffix</span><span class="p">)</span>

            <span class="n">remaining</span> <span class="o">=</span> <span class="n">new_remaining</span>

    <span class="n">new_grammar</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">start</span>
    <span class="n">new_grammar</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">new_grammar</span>
</code></pre></div>

<hr />
<h2 id="8-ll1-conflicts-and-resolution">8. LL(1) Conflicts and Resolution<a class="header-link" href="#8-ll1-conflicts-and-resolution" title="Permanent link">&para;</a></h2>
<h3 id="81-types-of-conflicts">8.1 Types of Conflicts<a class="header-link" href="#81-types-of-conflicts" title="Permanent link">&para;</a></h3>
<p>An LL(1) conflict occurs when a parsing table entry $M[A, a]$ has multiple productions. This can happen for two reasons:</p>
<p><strong>FIRST-FIRST Conflict:</strong> Two productions for $A$ have overlapping FIRST sets.</p>
<p>$$A \to \alpha \mid \beta \quad \text{where } \text{FIRST}(\alpha) \cap \text{FIRST}(\beta) \neq \emptyset$$</p>
<p><strong>FIRST-FOLLOW Conflict:</strong> A nullable production's FIRST set overlaps with the nonterminal's FOLLOW set.</p>
<p>$$A \to \alpha \mid \varepsilon \quad \text{where } \text{FIRST}(\alpha) \cap \text{FOLLOW}(A) \neq \emptyset$$</p>
<h3 id="82-resolution-strategies">8.2 Resolution Strategies<a class="header-link" href="#82-resolution-strategies" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Conflict Type</th>
<th>Resolution Strategy</th>
</tr>
</thead>
<tbody>
<tr>
<td>FIRST-FIRST</td>
<td>Left factoring, grammar rewriting</td>
</tr>
<tr>
<td>FIRST-FOLLOW</td>
<td>Grammar restructuring, or use LL(k)/ALL(*)</td>
</tr>
<tr>
<td>Dangling else</td>
<td>Convention: match with nearest unmatched <code>if</code></td>
</tr>
<tr>
<td>Inherent ambiguity</td>
<td>Rewrite grammar to remove ambiguity</td>
</tr>
</tbody>
</table>
<h3 id="83-the-classic-dangling-else">8.3 The Classic Dangling Else<a class="header-link" href="#83-the-classic-dangling-else" title="Permanent link">&para;</a></h3>
<p>The dangling else problem is perhaps the most famous LL(1) conflict:</p>
<div class="highlight"><pre><span></span><code><span class="n">Stmt</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="n">Expr</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Stmt</span><span class="w"> </span><span class="n">else</span><span class="w"> </span><span class="n">Stmt</span>
<span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="n">Expr</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Stmt</span>
<span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="n">other</span>
</code></pre></div>

<p>After left factoring:</p>
<div class="highlight"><pre><span></span><code><span class="n">Stmt</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="nf">if</span><span class="w"> </span><span class="n">Expr</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">Stmt</span><span class="w"> </span><span class="n">Else</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">other</span>
<span class="n">Else</span><span class="w">  </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">else</span><span class="w"> </span><span class="n">Stmt</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="err">Œµ</span>
</code></pre></div>

<p>This still has a FIRST-FOLLOW conflict for $\text{Else}$ when the lookahead is <code>else</code>: both $\text{Else} \to \textbf{else}\ \text{Stmt}$ and $\text{Else} \to \varepsilon$ apply.</p>
<p><strong>Resolution:</strong> By convention, always choose the non-epsilon production (match <code>else</code> with the nearest <code>if</code>). In the parsing table, simply prefer the <code>else Stmt</code> production.</p>
<hr />
<h2 id="9-error-recovery">9. Error Recovery<a class="header-link" href="#9-error-recovery" title="Permanent link">&para;</a></h2>
<p>When the parser encounters an error (no entry in the parsing table, or a terminal mismatch), it must recover gracefully rather than simply halting.</p>
<h3 id="91-panic-mode-recovery">9.1 Panic Mode Recovery<a class="header-link" href="#91-panic-mode-recovery" title="Permanent link">&para;</a></h3>
<p>Panic mode is the simplest and most commonly used error recovery strategy. When an error occurs, the parser discards input symbols until it finds a <strong>synchronization token</strong> -- typically a member of the FOLLOW set of the nonterminal being expanded.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">panic_mode_recovery</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">nonterminal</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">input_symbols</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">ip</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">follow</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Panic mode error recovery.</span>

<span class="sd">    Skip input tokens until we find one in FOLLOW(nonterminal),</span>
<span class="sd">    then pop the nonterminal from the stack and continue.</span>

<span class="sd">    Returns the new input pointer position.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sync_set</span> <span class="o">=</span> <span class="n">follow</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nonterminal</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;  Error: skipping input, looking for sync tokens &quot;</span>
        <span class="sa">f</span><span class="s2">&quot;in FOLLOW(</span><span class="si">{</span><span class="n">nonterminal</span><span class="si">}</span><span class="s2">) = </span><span class="si">{</span><span class="n">sync_set</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>

    <span class="k">while</span> <span class="n">ip</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_symbols</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">input_symbols</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="ow">in</span> <span class="n">sync_set</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Synchronized on &#39;</span><span class="si">{</span><span class="n">input_symbols</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ip</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Skipping &#39;</span><span class="si">{</span><span class="n">input_symbols</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="n">ip</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">ip</span>
</code></pre></div>

<h3 id="92-phrase-level-recovery">9.2 Phrase-Level Recovery<a class="header-link" href="#92-phrase-level-recovery" title="Permanent link">&para;</a></h3>
<p>Phrase-level recovery fills in error entries in the parsing table with specific error-handling routines. For example:</p>
<table>
<thead>
<tr>
<th>Situation</th>
<th>Recovery Action</th>
</tr>
</thead>
<tbody>
<tr>
<td>Missing operand (<code>+ * x</code>)</td>
<td>Insert a dummy operand</td>
</tr>
<tr>
<td>Missing operator (<code>x y</code>)</td>
<td>Insert a dummy operator</td>
</tr>
<tr>
<td>Unbalanced parenthesis</td>
<td>Insert missing <code>)</code> or discard extra <code>(</code></td>
</tr>
<tr>
<td>Missing semicolon</td>
<td>Insert <code>;</code> and continue</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code><span class="c1"># Phrase-level error recovery entries for expression grammar</span>
<span class="n">ERROR_ACTIONS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># M[E, +]: missing operand before +</span>
    <span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">):</span> <span class="p">(</span><span class="s2">&quot;insert_id&quot;</span><span class="p">,</span> <span class="s2">&quot;Missing operand before &#39;+&#39;&quot;</span><span class="p">),</span>
    <span class="c1"># M[F, +]: missing operand</span>
    <span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">):</span> <span class="p">(</span><span class="s2">&quot;insert_id&quot;</span><span class="p">,</span> <span class="s2">&quot;Missing operand&quot;</span><span class="p">),</span>
    <span class="c1"># M[F, *]: missing operand</span>
    <span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">):</span> <span class="p">(</span><span class="s2">&quot;insert_id&quot;</span><span class="p">,</span> <span class="s2">&quot;Missing operand&quot;</span><span class="p">),</span>
    <span class="c1"># M[E, )]: extra closing paren</span>
    <span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">):</span> <span class="p">(</span><span class="s2">&quot;skip&quot;</span><span class="p">,</span> <span class="s2">&quot;Unexpected &#39;)&#39;&quot;</span><span class="p">),</span>
    <span class="c1"># M[F, )]: missing operand before )</span>
    <span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">):</span> <span class="p">(</span><span class="s2">&quot;insert_id&quot;</span><span class="p">,</span> <span class="s2">&quot;Missing operand before &#39;)&#39;&quot;</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="93-error-productions">9.3 Error Productions<a class="header-link" href="#93-error-productions" title="Permanent link">&para;</a></h3>
<p>Some parser generators allow adding <strong>error productions</strong> to the grammar:</p>
<div class="highlight"><pre><span></span><code><span class="n">Stmt</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nf">error</span><span class="w"> </span><span class="p">;</span><span class="w">    </span><span class="c1">// skip everything until &#39;;&#39;</span>
</code></pre></div>

<p>When the parser cannot match any normal production, the <code>error</code> token matches and consumes input until the synchronizing token (<code>;</code> in this case).</p>
<hr />
<h2 id="10-llk-and-all-parsing">10. LL(k) and ALL(*) Parsing<a class="header-link" href="#10-llk-and-all-parsing" title="Permanent link">&para;</a></h2>
<h3 id="101-llk-parsing">10.1 LL(k) Parsing<a class="header-link" href="#101-llk-parsing" title="Permanent link">&para;</a></h3>
<p>LL(1) uses a single lookahead token. <strong>LL(k)</strong> extends this to $k$ tokens of lookahead. The parsing table becomes indexed by a nonterminal and a $k$-length prefix of the remaining input.</p>
<p><strong>Definition.</strong> A grammar is LL(k) if for any two leftmost derivations:</p>
<p>$$
\begin{aligned}
S &\Rightarrow^*_{lm} wA\alpha \Rightarrow_{lm} w\beta\alpha \Rightarrow^*_{lm} wx \\
S &\Rightarrow^*_{lm} wA\alpha \Rightarrow_{lm} w\gamma\alpha \Rightarrow^*_{lm} wy
\end{aligned}
$$</p>
<p>If $\text{FIRST}_k(x) = \text{FIRST}_k(y)$, then $\beta = \gamma$ (the same production was used).</p>
<p><strong>Practical impact:</strong> As $k$ increases, the parsing table grows exponentially ($O(|\Sigma|^k)$ columns). In practice, $k > 2$ is rare for hand-built LL parsers.</p>
<h3 id="102-all-parsing">10.2 ALL(*) Parsing<a class="header-link" href="#102-all-parsing" title="Permanent link">&para;</a></h3>
<p><strong>ALL(*)</strong> (Adaptive LL) is the parsing algorithm used by ANTLR 4. It provides the power of unlimited lookahead without the exponential table size.</p>
<p><strong>Key ideas:</strong></p>
<ol>
<li><strong>Arbitrary lookahead</strong>: Instead of a fixed $k$, ALL(*) examines as many tokens as needed to resolve the prediction</li>
<li><strong>Augmented Transition Networks (ATNs)</strong>: The grammar is represented as a set of recursive state machines</li>
<li><strong>Dynamic analysis</strong>: At runtime, if the ATN simulation encounters a prediction that requires more context, it performs a <strong>lookahead DFA</strong> construction</li>
<li><strong>Caching</strong>: Once a prediction is resolved for a given lookahead context, the result is cached as a DFA for future reuse</li>
</ol>
<div class="highlight"><pre><span></span><code>ALL(*) Decision Process:

    Regular LL(1)                     ALL(*) Adaptive
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ Single  ‚îÇ                       ‚îÇ  ATN        ‚îÇ
    ‚îÇ token   ‚îÇ ‚îÄ‚îÄresolve‚îÄ‚îÄ‚ñ∂ prod     ‚îÇ  simulation ‚îÇ
    ‚îÇ lookup  ‚îÇ                       ‚îÇ             ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                       ‚îÇ If ambig:   ‚îÇ
                                      ‚îÇ  build DFA  ‚îÇ‚îÄ‚îÄ‚ñ∂ prod
                                      ‚îÇ  cache it   ‚îÇ
                                      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></div>

<p><strong>Advantages of ALL(*):</strong></p>
<ul>
<li>Handles any deterministic context-free language</li>
<li>No manual left-factoring or left-recursion elimination needed (ANTLR 4 handles these automatically for direct left recursion)</li>
<li>Error messages can be very precise</li>
<li>Practical performance is often near-linear</li>
</ul>
<p><strong>Example in ANTLR 4:</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">// ANTLR 4 grammar -- no left factoring needed</span>
<span class="n">expr</span><span class="w"> </span><span class="p">:</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="s">&#39;*&#39;</span><span class="w"> </span><span class="n">expr</span><span class="w">    </span><span class="c1">// direct left recursion is OK</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="s">&#39;+&#39;</span><span class="w"> </span><span class="n">expr</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="s">&#39;(&#39;</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="s">&#39;)&#39;</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">ID</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">NUM</span>
<span class="w">     </span><span class="p">;</span>
</code></pre></div>

<h3 id="103-comparison-of-top-down-parsing-strategies">10.3 Comparison of Top-Down Parsing Strategies<a class="header-link" href="#103-comparison-of-top-down-parsing-strategies" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>LL(1)</th>
<th>LL(k)</th>
<th>ALL(*)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lookahead</td>
<td>1 token</td>
<td>$k$ tokens</td>
<td>Unbounded</td>
</tr>
<tr>
<td>Table size</td>
<td>$O(|\Sigma|)$</td>
<td>$O(|\Sigma|^k)$</td>
<td>Dynamic DFA</td>
</tr>
<tr>
<td>Left recursion</td>
<td>Must eliminate</td>
<td>Must eliminate</td>
<td>Direct LR auto-handled</td>
</tr>
<tr>
<td>Left factoring</td>
<td>Required</td>
<td>Sometimes</td>
<td>Not needed</td>
</tr>
<tr>
<td>Parser generator</td>
<td>Hand-written / simple</td>
<td>Uncommon</td>
<td>ANTLR 4</td>
</tr>
<tr>
<td>Error recovery</td>
<td>Manual</td>
<td>Manual</td>
<td>Automatic (ANTLR)</td>
</tr>
<tr>
<td>Performance</td>
<td>$O(n)$</td>
<td>$O(n)$</td>
<td>$O(n)$ typical, $O(n^2)$ worst</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="11-putting-it-all-together">11. Putting It All Together<a class="header-link" href="#11-putting-it-all-together" title="Permanent link">&para;</a></h2>
<p>Let us build a complete mini-language parser that demonstrates the full pipeline from grammar to parsed output.</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Complete LL(1) Parser for a Mini-Language</span>

<span class="sd">Language syntax:</span>
<span class="sd">    Program   -&gt; StmtList</span>
<span class="sd">    StmtList  -&gt; Stmt StmtList | Œµ</span>
<span class="sd">    Stmt      -&gt; id = Expr ;</span>
<span class="sd">               | print ( Expr ) ;</span>
<span class="sd">    Expr      -&gt; Term Expr&#39;</span>
<span class="sd">    Expr&#39;     -&gt; + Term Expr&#39; | Œµ</span>
<span class="sd">    Term      -&gt; Factor Term&#39;</span>
<span class="sd">    Term&#39;     -&gt; * Factor Term&#39; | Œµ</span>
<span class="sd">    Factor    -&gt; ( Expr ) | id | num</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MiniLangParser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;LL(1) parser for a mini-language with assignments and print.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="n">Grammar</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_grammar</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">compute_first</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">follow</span> <span class="o">=</span> <span class="n">compute_follow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">,</span> <span class="n">conflicts</span> <span class="o">=</span> <span class="n">build_ll1_table</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">follow</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">conflicts</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grammar is not LL(1): </span><span class="si">{</span><span class="n">conflicts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build_grammar</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Program&quot;</span><span class="p">,</span>   <span class="p">[</span><span class="s2">&quot;StmtList&quot;</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;StmtList&quot;</span><span class="p">,</span>  <span class="p">[</span><span class="s2">&quot;Stmt&quot;</span><span class="p">,</span> <span class="s2">&quot;StmtList&quot;</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;StmtList&quot;</span><span class="p">,</span>  <span class="p">[</span><span class="n">EPSILON</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Stmt&quot;</span><span class="p">,</span>      <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="s2">&quot;Expr&quot;</span><span class="p">,</span> <span class="s2">&quot;;&quot;</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Stmt&quot;</span><span class="p">,</span>      <span class="p">[</span><span class="s2">&quot;print&quot;</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;Expr&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;;&quot;</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Expr&quot;</span><span class="p">,</span>      <span class="p">[</span><span class="s2">&quot;Term&quot;</span><span class="p">,</span> <span class="s2">&quot;Expr&#39;&quot;</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Expr&#39;&quot;</span><span class="p">,</span>     <span class="p">[</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;Term&quot;</span><span class="p">,</span> <span class="s2">&quot;Expr&#39;&quot;</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Expr&#39;&quot;</span><span class="p">,</span>     <span class="p">[</span><span class="n">EPSILON</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Term&quot;</span><span class="p">,</span>      <span class="p">[</span><span class="s2">&quot;Factor&quot;</span><span class="p">,</span> <span class="s2">&quot;Term&#39;&quot;</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Term&#39;&quot;</span><span class="p">,</span>     <span class="p">[</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;Factor&quot;</span><span class="p">,</span> <span class="s2">&quot;Term&#39;&quot;</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Term&#39;&quot;</span><span class="p">,</span>     <span class="p">[</span><span class="n">EPSILON</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Factor&quot;</span><span class="p">,</span>    <span class="p">[</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;Expr&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Factor&quot;</span><span class="p">,</span>    <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
        <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;Factor&quot;</span><span class="p">,</span>    <span class="p">[</span><span class="s2">&quot;num&quot;</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse input tokens and return the list of productions applied.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">parser</span> <span class="o">=</span> <span class="n">LL1Parser</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">table</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">mini</span> <span class="o">=</span> <span class="n">MiniLangParser</span><span class="p">()</span>

    <span class="c1"># Parse: x = 3 + 4 * 5 ; print ( x ) ;</span>
    <span class="n">tokens</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="s2">&quot;num&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;num&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;num&quot;</span><span class="p">,</span> <span class="s2">&quot;;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;print&quot;</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;;&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Parsing: x = 3 + 4 * 5 ; print ( x ) ;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">90</span><span class="p">)</span>
    <span class="n">mini</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="12-summary">12. Summary<a class="header-link" href="#12-summary" title="Permanent link">&para;</a></h2>
<p>Top-down parsing builds parse trees from the root to the leaves, guided by lookahead tokens and prediction tables.</p>
<p><strong>Key concepts:</strong></p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Recursive descent</strong></td>
<td>One function per nonterminal; the most intuitive parsing method</td>
</tr>
<tr>
<td><strong>FIRST sets</strong></td>
<td>Terminals that can begin strings derived from a grammar symbol</td>
</tr>
<tr>
<td><strong>FOLLOW sets</strong></td>
<td>Terminals that can appear after a nonterminal in any derivation</td>
</tr>
<tr>
<td><strong>LL(1) table</strong></td>
<td>Maps (nonterminal, terminal) pairs to productions</td>
</tr>
<tr>
<td><strong>Left recursion elimination</strong></td>
<td>Required for top-down parsing; transforms $A \to A\alpha$ patterns</td>
</tr>
<tr>
<td><strong>Left factoring</strong></td>
<td>Factors out common prefixes to resolve FIRST-FIRST conflicts</td>
</tr>
<tr>
<td><strong>Panic mode</strong></td>
<td>Error recovery by skipping to synchronization tokens</td>
</tr>
<tr>
<td><strong>ALL(*)</strong></td>
<td>Adaptive LL parsing with unbounded lookahead (ANTLR 4)</td>
</tr>
</tbody>
</table>
<p><strong>When to use top-down parsing:</strong></p>
<ul>
<li>When the grammar is naturally LL(1) or close to it</li>
<li>When you want to write a parser by hand (recursive descent)</li>
<li>When you need fine-grained control over error messages</li>
<li>When using ANTLR 4 (which uses ALL(*) internally)</li>
</ul>
<p><strong>When NOT to use top-down parsing:</strong></p>
<ul>
<li>Grammars with inherent left recursion that is hard to eliminate</li>
<li>Operator-heavy languages where precedence climbing or Pratt parsing is simpler</li>
<li>When a parser generator like Yacc/Bison (LR-based) is already in your toolchain</li>
</ul>
<hr />
<h2 id="exercises">Exercises<a class="header-link" href="#exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-first-and-follow-computation">Exercise 1: FIRST and FOLLOW Computation<a class="header-link" href="#exercise-1-first-and-follow-computation" title="Permanent link">&para;</a></h3>
<p>Compute the FIRST and FOLLOW sets for the following grammar:</p>
<p>$$
\begin{aligned}
S &\to A\ B \\
A &\to a\ A \mid \varepsilon \\
B &\to b\ B \mid c
\end{aligned}
$$</p>
<p>Verify your answer by implementing the grammar in the Python code provided and running the computation.</p>
<h3 id="exercise-2-ll1-table-construction">Exercise 2: LL(1) Table Construction<a class="header-link" href="#exercise-2-ll1-table-construction" title="Permanent link">&para;</a></h3>
<p>Given the grammar:</p>
<p>$$
\begin{aligned}
S &\to i\ E\ t\ S\ S' \mid a \\
S' &\to e\ S \mid \varepsilon \\
E &\to b
\end{aligned}
$$</p>
<p>(where $i$ = <code>if</code>, $t$ = <code>then</code>, $e$ = <code>else</code>, $a$ = assignment, $b$ = boolean expression)</p>
<ol>
<li>Compute FIRST and FOLLOW sets.</li>
<li>Construct the LL(1) parsing table.</li>
<li>Identify any conflicts. How would you resolve the dangling else?</li>
</ol>
<h3 id="exercise-3-left-recursion-elimination">Exercise 3: Left Recursion Elimination<a class="header-link" href="#exercise-3-left-recursion-elimination" title="Permanent link">&para;</a></h3>
<p>Eliminate all left recursion from the following grammar:</p>
<p>$$
\begin{aligned}
S &\to A\ a \mid b \\
A &\to A\ c \mid S\ d \mid e
\end{aligned}
$$</p>
<p>Note that $A \to S\ d$ creates indirect left recursion. Show each step of the algorithm.</p>
<h3 id="exercise-4-recursive-descent-parser-extension">Exercise 4: Recursive Descent Parser Extension<a class="header-link" href="#exercise-4-recursive-descent-parser-extension" title="Permanent link">&para;</a></h3>
<p>Extend the recursive descent parser provided in Section 2.2 to support:</p>
<ol>
<li>Subtraction (<code>-</code>) with the same precedence as addition</li>
<li>Division (<code>/</code>) with the same precedence as multiplication</li>
<li>Unary negation (<code>-x</code>)</li>
<li>Integer literals and variable names</li>
</ol>
<p>Write the modified grammar and the corresponding Python code.</p>
<h3 id="exercise-5-error-recovery">Exercise 5: Error Recovery<a class="header-link" href="#exercise-5-error-recovery" title="Permanent link">&para;</a></h3>
<p>Implement panic-mode error recovery in the table-driven LL(1) parser. Your implementation should:</p>
<ol>
<li>When $M[A, a]$ is empty, report the error with the position</li>
<li>Skip input tokens until finding one in $\text{FOLLOW}(A)$</li>
<li>Pop $A$ from the stack and continue parsing</li>
<li>Report all errors found (not just the first one)</li>
</ol>
<p>Test with the input <code>"id + * id"</code> (missing operand between <code>+</code> and <code>*</code>).</p>
<h3 id="exercise-6-grammar-design-challenge">Exercise 6: Grammar Design Challenge<a class="header-link" href="#exercise-6-grammar-design-challenge" title="Permanent link">&para;</a></h3>
<p>Design an LL(1) grammar for the following language features:</p>
<ul>
<li>Variable declarations: <code>let x = expr;</code></li>
<li>Assignment: <code>x = expr;</code></li>
<li>If-else statements: <code>if (expr) { stmts } else { stmts }</code></li>
<li>While loops: <code>while (expr) { stmts }</code></li>
<li>Print statements: <code>print(expr);</code></li>
<li>
<p>Arithmetic expressions with <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code></p>
</li>
<li>
<p>Write the grammar.</p>
</li>
<li>Verify it is LL(1) by computing FIRST and FOLLOW sets.</li>
<li>If not LL(1), apply left factoring and/or left recursion elimination.</li>
</ul>
<hr />
<p><a href="./04_Context_Free_Grammars.md">Previous: 04_Context_Free_Grammars.md</a> | <a href="./06_Bottom_Up_Parsing.md">Next: 06_Bottom_Up_Parsing.md</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/04_Context_Free_Grammars.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 4: Context-Free Grammars</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/06_Bottom_Up_Parsing.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 6: Bottom-Up Parsing</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}