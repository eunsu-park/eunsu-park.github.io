{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 6: Bottom-Up Parsing - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Lesson 6: Bottom-Up Parsing</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 6: Bottom-Up Parsing</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/05_Top_Down_Parsing.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 5: Top-Down Parsing</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/07_Abstract_Syntax_Trees.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 7: Abstract Syntax Trees</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#learning-objectives">Learning Objectives</a></li>
<li><a href="#1-introduction-to-bottom-up-parsing">1. Introduction to Bottom-Up Parsing</a><ul>
<li><a href="#11-why-bottom-up">1.1 Why Bottom-Up?</a></li>
</ul>
</li>
<li><a href="#2-shift-reduce-parsing">2. Shift-Reduce Parsing</a><ul>
<li><a href="#21-the-four-actions">2.1 The Four Actions</a></li>
<li><a href="#22-handles">2.2 Handles</a></li>
<li><a href="#23-viable-prefixes">2.3 Viable Prefixes</a></li>
</ul>
</li>
<li><a href="#3-lr0-items-and-the-lr0-automaton">3. LR(0) Items and the LR(0) Automaton</a><ul>
<li><a href="#31-lr0-items">3.1 LR(0) Items</a></li>
<li><a href="#32-closure-operation">3.2 Closure Operation</a></li>
<li><a href="#33-goto-operation">3.3 GOTO Operation</a></li>
<li><a href="#34-constructing-the-lr0-automaton">3.4 Constructing the LR(0) Automaton</a></li>
<li><a href="#35-python-implementation">3.5 Python Implementation</a></li>
</ul>
</li>
<li><a href="#4-slr1-parsing">4. SLR(1) Parsing</a><ul>
<li><a href="#41-slr1-table-construction">4.1 SLR(1) Table Construction</a></li>
<li><a href="#42-slr1-parser-implementation">4.2 SLR(1) Parser Implementation</a></li>
</ul>
</li>
<li><a href="#5-canonical-lr1-parsing">5. Canonical LR(1) Parsing</a><ul>
<li><a href="#51-lr1-items">5.1 LR(1) Items</a></li>
<li><a href="#52-lr1-closure">5.2 LR(1) Closure</a></li>
<li><a href="#53-lr1-table-construction">5.3 LR(1) Table Construction</a></li>
<li><a href="#54-lr1-vs-slr1">5.4 LR(1) vs SLR(1)</a></li>
<li><a href="#72-ply-python-lex-yacc">7.2 PLY (Python Lex-Yacc)</a></li>
<li><a href="#73-other-parser-generator-tools">7.3 Other Parser Generator Tools</a></li>
</ul>
</li>
<li><a href="#8-conflict-resolution">8. Conflict Resolution</a><ul>
<li><a href="#81-shift-reduce-conflicts">8.1 Shift-Reduce Conflicts</a></li>
<li><a href="#82-reduce-reduce-conflicts">8.2 Reduce-Reduce Conflicts</a></li>
<li><a href="#83-precedence-and-associativity-declarations">8.3 Precedence and Associativity Declarations</a></li>
<li><a href="#84-the-prec-directive">8.4 The %prec Directive</a></li>
</ul>
</li>
<li><a href="#9-error-recovery-in-lr-parsers">9. Error Recovery in LR Parsers</a><ul>
<li><a href="#91-panic-mode">9.1 Panic Mode</a></li>
<li><a href="#92-error-productions">9.2 Error Productions</a></li>
<li><a href="#93-implementation">9.3 Implementation</a></li>
</ul>
</li>
<li><a href="#10-advanced-topics">10. Advanced Topics</a><ul>
<li><a href="#101-glr-parsing">10.1 GLR Parsing</a></li>
<li><a href="#102-incremental-parsing">10.2 Incremental Parsing</a></li>
<li><a href="#103-operator-precedence-parsing">10.3 Operator Precedence Parsing</a></li>
</ul>
</li>
<li><a href="#11-summary">11. Summary</a></li>
<li><a href="#exercises">Exercises</a><ul>
<li><a href="#exercise-1-lr0-automaton-construction">Exercise 1: LR(0) Automaton Construction</a></li>
<li><a href="#exercise-2-slr1-table-construction">Exercise 2: SLR(1) Table Construction</a></li>
<li><a href="#exercise-3-slr-vs-lr1">Exercise 3: SLR vs LR(1)</a></li>
<li><a href="#exercise-4-ply-parser">Exercise 4: PLY Parser</a></li>
<li><a href="#exercise-5-conflict-analysis">Exercise 5: Conflict Analysis</a></li>
<li><a href="#exercise-6-error-recovery">Exercise 6: Error Recovery</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-6-bottom-up-parsing">Lesson 6: Bottom-Up Parsing<a class="header-link" href="#lesson-6-bottom-up-parsing" title="Permanent link">&para;</a></h1>
<h2 id="learning-objectives">Learning Objectives<a class="header-link" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<p>After completing this lesson, you will be able to:</p>
<ol>
<li><strong>Understand</strong> the principles of shift-reduce parsing and how it constructs parse trees from the leaves upward</li>
<li><strong>Define</strong> handles and explain how they guide reduction decisions</li>
<li><strong>Construct</strong> LR(0) item sets and the corresponding automaton</li>
<li><strong>Build</strong> SLR(1), canonical LR(1), and LALR(1) parsing tables</li>
<li><strong>Compare</strong> the strengths and limitations of each LR variant</li>
<li><strong>Use</strong> parser generator tools (Yacc, Bison, PLY) effectively</li>
<li><strong>Resolve</strong> shift-reduce and reduce-reduce conflicts using precedence and associativity</li>
<li><strong>Implement</strong> error recovery strategies in LR parsers</li>
</ol>
<hr />
<h2 id="1-introduction-to-bottom-up-parsing">1. Introduction to Bottom-Up Parsing<a class="header-link" href="#1-introduction-to-bottom-up-parsing" title="Permanent link">&para;</a></h2>
<p>Bottom-up parsing builds the parse tree from the <strong>leaves</strong> (terminal symbols) up to the <strong>root</strong> (start symbol). It works by repeatedly finding and reducing <strong>handles</strong> -- substrings of the sentential form that match the right-hand side of a production.</p>
<p>The most common form of bottom-up parsing is <strong>LR parsing</strong>, which stands for:</p>
<ul>
<li><strong>L</strong>: scan input <strong>L</strong>eft to right</li>
<li><strong>R</strong>: produce a <strong>R</strong>ightmost derivation (in reverse)</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">Bottom</span><span class="o">-</span><span class="n">Up</span><span class="w"> </span><span class="nf">Parse</span><span class="w"> </span><span class="n">Construction</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="s">&quot;id + id * id&quot;</span><span class="o">:</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w">     </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n">F</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w">     </span><span class="p">(</span><span class="n">reduce</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w"> </span><span class="n">T</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w">     </span><span class="p">(</span><span class="n">reduce</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">F</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="o">:</span><span class="w"> </span><span class="n">E</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w">     </span><span class="p">(</span><span class="n">reduce</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">5</span><span class="o">:</span><span class="w"> </span><span class="n">E</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w">     </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="o">+</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">6</span><span class="o">:</span><span class="w"> </span><span class="n">E</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w">     </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">7</span><span class="o">:</span><span class="w"> </span><span class="n">E</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">F</span><span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w">     </span><span class="p">(</span><span class="n">reduce</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">8</span><span class="o">:</span><span class="w"> </span><span class="n">E</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w">     </span><span class="p">(</span><span class="n">reduce</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">F</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">9</span><span class="o">:</span><span class="w"> </span><span class="n">E</span><span class="w">  </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w">     </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="o">*</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">10</span><span class="o">:</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w">     </span><span class="p">(</span><span class="n">shift</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">11</span><span class="o">:</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w">  </span><span class="o">*</span><span class="w"> </span><span class="n">F</span><span class="w">      </span><span class="p">(</span><span class="n">reduce</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">id</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">12</span><span class="o">:</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w">           </span><span class="p">(</span><span class="n">reduce</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">F</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">13</span><span class="o">:</span><span class="w"> </span><span class="n">E</span><span class="w">               </span><span class="p">(</span><span class="n">reduce</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="p">)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">14</span><span class="o">:</span><span class="w"> </span><span class="n">ACCEPT</span>
</code></pre></div>

<h3 id="11-why-bottom-up">1.1 Why Bottom-Up?<a class="header-link" href="#11-why-bottom-up" title="Permanent link">&para;</a></h3>
<p>Bottom-up parsers have significant advantages over top-down parsers:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Top-Down (LL)</th>
<th>Bottom-Up (LR)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Grammar class</td>
<td>LL(1) subset</td>
<td>Virtually all practical CFGs</td>
</tr>
<tr>
<td>Left recursion</td>
<td>Must be eliminated</td>
<td>Handled naturally</td>
</tr>
<tr>
<td>Lookahead decisions</td>
<td>Predict which production</td>
<td>Decide when to reduce</td>
</tr>
<tr>
<td>Ambiguity</td>
<td>Difficult to handle</td>
<td>Resolved by precedence rules</td>
</tr>
<tr>
<td>Tool support</td>
<td>ANTLR</td>
<td>Yacc, Bison, PLY, tree-sitter</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="2-shift-reduce-parsing">2. Shift-Reduce Parsing<a class="header-link" href="#2-shift-reduce-parsing" title="Permanent link">&para;</a></h2>
<h3 id="21-the-four-actions">2.1 The Four Actions<a class="header-link" href="#21-the-four-actions" title="Permanent link">&para;</a></h3>
<p>A shift-reduce parser maintains a <strong>stack</strong> of grammar symbols and an <strong>input buffer</strong>. At each step, it performs one of four actions:</p>
<ol>
<li><strong>Shift</strong>: Push the next input symbol onto the stack</li>
<li><strong>Reduce</strong>: Pop a handle from the stack and push the corresponding nonterminal</li>
<li><strong>Accept</strong>: Parsing is complete -- the stack contains the start symbol and the input is empty</li>
<li><strong>Error</strong>: No valid action exists</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="n">Shift</span><span class="o">-</span><span class="n">Reduce</span><span class="w"> </span><span class="n">Parsing</span><span class="w"> </span><span class="n">Visualization</span><span class="o">:</span>

<span class="w">    </span><span class="n">STACK</span><span class="w">                     </span><span class="n">INPUT</span><span class="w">                </span><span class="n">ACTION</span>
<span class="w">    </span><span class="err">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span><span class="w">                     </span><span class="err">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span><span class="w">                </span><span class="err">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>
<span class="w">    </span><span class="err">$</span><span class="w">                         </span><span class="n">id</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">       </span><span class="n">Shift</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">id</span><span class="w">                      </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">          </span><span class="n">Reduce</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">id</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">F</span><span class="w">                       </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">          </span><span class="n">Reduce</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">F</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">T</span><span class="w">                       </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">          </span><span class="n">Reduce</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">E</span><span class="w">                       </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">          </span><span class="n">Shift</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w">                     </span><span class="n">id</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">            </span><span class="n">Shift</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">id</span><span class="w">                  </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">               </span><span class="n">Reduce</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">id</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">F</span><span class="w">                   </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">               </span><span class="n">Reduce</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">F</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w">                   </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">               </span><span class="n">Shift</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w">                 </span><span class="n">id</span><span class="w"> </span><span class="err">$</span><span class="w">                 </span><span class="n">Shift</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">id</span><span class="w">              </span><span class="err">$</span><span class="w">                    </span><span class="n">Reduce</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">id</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">F</span><span class="w">               </span><span class="err">$</span><span class="w">                    </span><span class="n">Reduce</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">F</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w">                   </span><span class="err">$</span><span class="w">                    </span><span class="n">Reduce</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span>
<span class="w">    </span><span class="err">$</span><span class="w"> </span><span class="n">E</span><span class="w">                       </span><span class="err">$</span><span class="w">                    </span><span class="n">Accept</span>
</code></pre></div>

<h3 id="22-handles">2.2 Handles<a class="header-link" href="#22-handles" title="Permanent link">&para;</a></h3>
<p>A <strong>handle</strong> of a right-sentential form $\gamma$ is a production $A \to \beta$ and a position in $\gamma$ where $\beta$ may be found, such that replacing $\beta$ by $A$ produces the previous right-sentential form in a rightmost derivation.</p>
<p><strong>Formally:</strong> If $S \Rightarrow^*_{rm} \alpha A w \Rightarrow_{rm} \alpha \beta w$, then $A \to \beta$ in the position following $\alpha$ is a handle of $\alpha \beta w$.</p>
<p><strong>Key insight:</strong> The handle always appears at the top of the stack. This is what makes bottom-up parsing work with a stack -- we never need to look deep into the stack to find the handle.</p>
<h3 id="23-viable-prefixes">2.3 Viable Prefixes<a class="header-link" href="#23-viable-prefixes" title="Permanent link">&para;</a></h3>
<p>A <strong>viable prefix</strong> is any prefix of a right-sentential form that can appear on the parsing stack. Equivalently, it is a prefix that does not extend past the right end of the rightmost handle.</p>
<p>The set of viable prefixes is a regular language, which means it can be recognized by a finite automaton. This automaton is exactly the LR(0) automaton we will construct next.</p>
<hr />
<h2 id="3-lr0-items-and-the-lr0-automaton">3. LR(0) Items and the LR(0) Automaton<a class="header-link" href="#3-lr0-items-and-the-lr0-automaton" title="Permanent link">&para;</a></h2>
<h3 id="31-lr0-items">3.1 LR(0) Items<a class="header-link" href="#31-lr0-items" title="Permanent link">&para;</a></h3>
<p>An <strong>LR(0) item</strong> (or simply "item") is a production with a dot (.) at some position in the right-hand side:</p>
<p>$$A \to \alpha \cdot \beta$$</p>
<p>The dot indicates how much of the production has been seen so far:</p>
<ul>
<li>$A \to \cdot \alpha\beta$: nothing has been matched yet</li>
<li>$A \to \alpha \cdot \beta$: $\alpha$ has been matched, $\beta$ is expected</li>
<li>$A \to \alpha\beta \cdot$: the entire right-hand side has been matched (ready to reduce)</li>
</ul>
<p><strong>Example:</strong> The production $E \to E + T$ generates four items:</p>
<p>$$E \to \cdot E + T \qquad E \to E \cdot + T \qquad E \to E + \cdot T \qquad E \to E + T \cdot$$</p>
<h3 id="32-closure-operation">3.2 Closure Operation<a class="header-link" href="#32-closure-operation" title="Permanent link">&para;</a></h3>
<p>The <strong>closure</strong> of a set of items adds all items implied by having a dot before a nonterminal.</p>
<p><strong>Algorithm:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">CLOSURE</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">:</span>
<span class="w">    </span><span class="kr">repeat</span><span class="o">:</span>
<span class="w">        </span><span class="n">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">[</span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="err">Œ≤</span><span class="p">]</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">I</span><span class="o">:</span>
<span class="w">            </span><span class="n">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">production</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ≥</span><span class="o">:</span>
<span class="w">                </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">B</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="err">Œ≥</span><span class="p">]</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">I</span>
<span class="w">    </span><span class="n">until</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">added</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="n">I</span>
</code></pre></div>

<p><strong>Intuition:</strong> If we expect to see $B$ next (dot is before $B$), then we must also be prepared to see anything that $B$ can begin with.</p>
<h3 id="33-goto-operation">3.3 GOTO Operation<a class="header-link" href="#33-goto-operation" title="Permanent link">&para;</a></h3>
<p>The <strong>GOTO</strong> function defines transitions between item sets.</p>
<p>$$\text{GOTO}(I, X) = \text{CLOSURE}(\{[A \to \alpha X \cdot \beta] \mid [A \to \alpha \cdot X \beta] \in I\})$$</p>
<p>In words: take all items in $I$ where the dot is before symbol $X$, advance the dot past $X$, then take the closure.</p>
<h3 id="34-constructing-the-lr0-automaton">3.4 Constructing the LR(0) Automaton<a class="header-link" href="#34-constructing-the-lr0-automaton" title="Permanent link">&para;</a></h3>
<p>The canonical collection of LR(0) item sets forms the states of a finite automaton that recognizes viable prefixes.</p>
<p><strong>Algorithm:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">ITEMS</span><span class="p">(</span><span class="n">G</span><span class="s">&#39;):</span>
<span class="s">    C = { CLOSURE({[S&#39;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="n">S</span><span class="p">]})</span><span class="w"> </span><span class="p">}</span><span class="w">    </span><span class="c1">// initial state</span>
<span class="w">    </span><span class="kr">repeat</span><span class="o">:</span>
<span class="w">        </span><span class="n">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="kt">set of</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">C</span><span class="o">:</span>
<span class="w">            </span><span class="n">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">grammar</span><span class="w"> </span><span class="n">symbol</span><span class="w"> </span><span class="n">X</span><span class="o">:</span>
<span class="w">                </span><span class="nf">if</span><span class="w"> </span><span class="n">GOTO</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">)</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="kr">not</span><span class="w"> </span><span class="n">empty</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="kr">not</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">C</span><span class="o">:</span>
<span class="w">                    </span><span class="n">add</span><span class="w"> </span><span class="n">GOTO</span><span class="p">(</span><span class="n">I</span><span class="p">,</span><span class="w"> </span><span class="n">X</span><span class="p">)</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">C</span>
<span class="w">    </span><span class="n">until</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">sets</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">added</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="n">C</span>
</code></pre></div>

<h3 id="35-python-implementation">3.5 Python Implementation<a class="header-link" href="#35-python-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">LR(0) Automaton Construction</span>

<span class="sd">Builds the canonical collection of LR(0) item sets, which forms</span>
<span class="sd">the basis for SLR, canonical LR, and LALR parsing table construction.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">FrozenSet</span>


<span class="n">EPSILON</span> <span class="o">=</span> <span class="s2">&quot;Œµ&quot;</span>
<span class="n">EOF</span> <span class="o">=</span> <span class="s2">&quot;$&quot;</span>
<span class="n">DOT</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Item</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An LR(0) item: a production with a dot position.</span>

<span class="sd">    Example: Item(&quot;E&quot;, (&quot;E&quot;, &quot;+&quot;, &quot;T&quot;), 1) represents E -&gt; E . + T</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lhs</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">rhs</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="n">dot</span><span class="p">:</span> <span class="nb">int</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">next_symbol</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Symbol immediately after the dot, or None if dot is at end.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">):</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">]</span>
            <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">sym</span> <span class="o">==</span> <span class="n">EPSILON</span> <span class="k">else</span> <span class="n">sym</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;True if the dot is at the end (ready to reduce).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">EPSILON</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">advance</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Item&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new item with the dot advanced by one position.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Item</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rhs_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rhs_list</span> <span class="o">==</span> <span class="p">[</span><span class="n">EPSILON</span><span class="p">]:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">DOT</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="n">rhs_list</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dot</span><span class="p">,</span> <span class="n">DOT</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rhs_list</span><span class="p">)</span><span class="si">}</span><span class="s2">]&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LRAutomaton</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs the canonical collection of LR(0) item sets.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">:</span> <span class="s2">&quot;Grammar&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize with an augmented grammar.</span>

<span class="sd">        The grammar should already have an augmented start production</span>
<span class="sd">        S&#39; -&gt; S added.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">frozenset</span><span class="p">[</span><span class="n">Item</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">goto_table</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_productions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nonterminal</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get all productions for a nonterminal as tuples.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">nonterminal</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">rhs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">closure</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="n">Item</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">frozenset</span><span class="p">[</span><span class="n">Item</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the closure of a set of items.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
        <span class="n">worklist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">next_sym</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">next_symbol</span>

            <span class="k">if</span> <span class="n">next_sym</span> <span class="ow">and</span> <span class="n">next_sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">nonterminals</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_productions</span><span class="p">(</span><span class="n">next_sym</span><span class="p">):</span>
                    <span class="n">new_item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">(</span><span class="n">next_sym</span><span class="p">,</span> <span class="n">rhs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">new_item</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                        <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_item</span><span class="p">)</span>
                        <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_item</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">frozenset</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">goto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">items</span><span class="p">:</span> <span class="nb">frozenset</span><span class="p">[</span><span class="n">Item</span><span class="p">],</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">frozenset</span><span class="p">[</span><span class="n">Item</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute GOTO(items, symbol).&quot;&quot;&quot;</span>
        <span class="n">moved</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">next_symbol</span> <span class="o">==</span> <span class="n">symbol</span><span class="p">:</span>
                <span class="n">moved</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">advance</span><span class="p">())</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">moved</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">frozenset</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">closure</span><span class="p">(</span><span class="n">moved</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the canonical collection of LR(0) item sets.&quot;&quot;&quot;</span>
        <span class="c1"># Find the augmented start production S&#39; -&gt; S</span>
        <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span>
        <span class="n">start_rhs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_productions</span><span class="p">(</span><span class="n">start</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">initial_item</span> <span class="o">=</span> <span class="n">Item</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">start_rhs</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">initial_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">closure</span><span class="p">({</span><span class="n">initial_item</span><span class="p">})</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">states</span> <span class="o">=</span> <span class="p">[</span><span class="n">initial_state</span><span class="p">]</span>
        <span class="n">state_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">initial_state</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>

        <span class="n">worklist</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">all_symbols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">terminals</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">grammar</span><span class="o">.</span><span class="n">nonterminals</span>

        <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
            <span class="n">state_idx</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">[</span><span class="n">state_idx</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">symbol</span> <span class="ow">in</span> <span class="n">all_symbols</span><span class="p">:</span>
                <span class="n">next_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">goto</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">next_state</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">next_state</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">state_map</span><span class="p">:</span>
                    <span class="n">state_map</span><span class="p">[</span><span class="n">next_state</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_state</span><span class="p">)</span>
                    <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">state_map</span><span class="p">[</span><span class="n">next_state</span><span class="p">])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">goto_table</span><span class="p">[(</span><span class="n">state_idx</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)]</span> <span class="o">=</span> <span class="n">state_map</span><span class="p">[</span><span class="n">next_state</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_states</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pretty-print all states of the automaton.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">State </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="nb">repr</span><span class="p">):</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_transitions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print all transitions.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Transitions:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">),</span> <span class="n">target</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">goto_table</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  State </span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2"> --</span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">--&gt; State </span><span class="si">{</span><span class="n">target</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Grammar Helper ‚îÄ‚îÄ‚îÄ</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Grammar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Grammar representation (same as Lesson 5, augmented).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">productions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonterminals</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_production</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">lhs</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">productions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">productions</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">productions</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nonterminals</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lhs</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">lhs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">all_symbols</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">productions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhs_list</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">rhs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sym</span> <span class="o">!=</span> <span class="n">EPSILON</span><span class="p">:</span>
                        <span class="n">all_symbols</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sym</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">terminals</span> <span class="o">=</span> <span class="n">all_symbols</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonterminals</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">augment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Grammar&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an augmented grammar with S&#39; -&gt; S.&quot;&quot;&quot;</span>
        <span class="n">aug</span> <span class="o">=</span> <span class="n">Grammar</span><span class="p">()</span>
        <span class="n">new_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="s2">&quot;&#39;&quot;</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="n">new_start</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">productions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhs_list</span><span class="p">:</span>
                <span class="n">aug</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span>
        <span class="n">aug</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">aug</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Demo ‚îÄ‚îÄ‚îÄ</span>

<span class="k">def</span><span class="w"> </span><span class="nf">build_expression_grammar</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Grammar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Expression grammar:</span>
<span class="sd">        E -&gt; E + T | T</span>
<span class="sd">        T -&gt; T * F | F</span>
<span class="sd">        F -&gt; ( E ) | id</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">Grammar</span><span class="p">()</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;T&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;F&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;F&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">add_production</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
    <span class="n">g</span><span class="o">.</span><span class="n">finalize</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">g</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="n">build_expression_grammar</span><span class="p">()</span>
    <span class="n">augmented</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">augment</span><span class="p">()</span>
    <span class="n">automaton</span> <span class="o">=</span> <span class="n">LRAutomaton</span><span class="p">(</span><span class="n">augmented</span><span class="p">)</span>
    <span class="n">automaton</span><span class="o">.</span><span class="n">print_states</span><span class="p">()</span>
    <span class="n">automaton</span><span class="o">.</span><span class="n">print_transitions</span><span class="p">()</span>
</code></pre></div>

<p><strong>Example output (partial):</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">State</span><span class="w"> </span><span class="mi">0</span><span class="o">:</span>
<span class="w">  </span><span class="p">[</span><span class="n">E</span><span class="s">&#39; -&gt; . E]</span>
<span class="s">  [E -&gt; . E + T]</span>
<span class="s">  [E -&gt; . T]</span>
<span class="s">  [F -&gt; . ( E )]</span>
<span class="s">  [F -&gt; . id]</span>
<span class="s">  [T -&gt; . F]</span>
<span class="s">  [T -&gt; . T * F]</span>

<span class="s">State 1:</span>
<span class="s">  [E&#39;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="p">.]</span>
<span class="w">  </span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="p">]</span>

<span class="n">State</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span>
<span class="w">  </span><span class="p">[</span><span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">.]</span>
<span class="w">  </span><span class="p">[</span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">T</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">F</span><span class="p">]</span>

<span class="n">State</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span>
<span class="w">  </span><span class="p">[</span><span class="n">T</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="p">.]</span>

<span class="p">...</span>
</code></pre></div>

<hr />
<h2 id="4-slr1-parsing">4. SLR(1) Parsing<a class="header-link" href="#4-slr1-parsing" title="Permanent link">&para;</a></h2>
<h3 id="41-slr1-table-construction">4.1 SLR(1) Table Construction<a class="header-link" href="#41-slr1-table-construction" title="Permanent link">&para;</a></h3>
<p><strong>Simple LR (SLR)</strong> parsing uses the LR(0) automaton and the FOLLOW sets to construct the parsing table. It is the simplest LR variant.</p>
<p><strong>Algorithm:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">Construct</span><span class="w"> </span><span class="n">SLR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="nf">Table</span><span class="o">:</span>

<span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">I_i</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">canonical</span><span class="w"> </span><span class="n">collection</span><span class="o">:</span>

<span class="w">  </span><span class="mf">1.</span><span class="w"> </span><span class="n">SHIFT</span><span class="o">:</span><span class="w"> </span><span class="nf">If</span><span class="w"> </span><span class="p">[</span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="err">Œ≤</span><span class="p">]</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">I_i</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">GOTO</span><span class="p">(</span><span class="n">I_i</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I_j</span><span class="o">:</span>
<span class="w">       </span><span class="nf">Set</span><span class="w"> </span><span class="n">ACTION</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;shift j&quot;</span>

<span class="w">  </span><span class="mf">2.</span><span class="w"> </span><span class="n">REDUCE</span><span class="o">:</span><span class="w"> </span><span class="nf">If</span><span class="w"> </span><span class="p">[</span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="w"> </span><span class="p">.]</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">I_i</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="err">‚â†</span><span class="w"> </span><span class="n">S</span><span class="s">&#39;):</span>
<span class="s">       For each terminal a in FOLLOW(A):</span>
<span class="s">           Set ACTION[i, a] = &quot;</span><span class="n">reduce</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="s">&quot;</span>

<span class="s">  3. ACCEPT: If [S&#39;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="p">.]</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">I_i</span><span class="o">:</span>
<span class="w">       </span><span class="nf">Set</span><span class="w"> </span><span class="n">ACTION</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="err">$</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;accept&quot;</span>

<span class="w">  </span><span class="mf">4.</span><span class="w"> </span><span class="n">GOTO</span><span class="o">:</span><span class="w"> </span><span class="nf">If</span><span class="w"> </span><span class="n">GOTO</span><span class="p">(</span><span class="n">I_i</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I_j</span><span class="w"> </span><span class="n">for</span><span class="w"> </span><span class="n">nonterminal</span><span class="w"> </span><span class="n">A</span><span class="o">:</span>
<span class="w">       </span><span class="nf">Set</span><span class="w"> </span><span class="n">GOTO</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">j</span>

<span class="nf">If</span><span class="w"> </span><span class="kr">any</span><span class="w"> </span><span class="n">entry</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">multiply</span><span class="w"> </span><span class="n">defined</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">grammar</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="kr">not</span><span class="w"> </span><span class="n">SLR</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span>
</code></pre></div>

<h3 id="42-slr1-parser-implementation">4.2 SLR(1) Parser Implementation<a class="header-link" href="#42-slr1-parser-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">SLR(1) Parser Implementation</span>

<span class="sd">Constructs an SLR(1) parsing table from the LR(0) automaton</span>
<span class="sd">and FOLLOW sets, then uses it to parse input strings.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="c1"># Reuse FIRST/FOLLOW from Lesson 5 (imported or redefined)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">compute_first</span><span class="p">(</span><span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute FIRST sets (same algorithm as Lesson 5).&quot;&quot;&quot;</span>
    <span class="n">first</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">terminals</span><span class="p">:</span>
        <span class="n">first</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">t</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">nonterminals</span><span class="p">:</span>
        <span class="n">first</span><span class="p">[</span><span class="n">nt</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_list</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhs_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rhs</span> <span class="o">==</span> <span class="p">[</span><span class="n">EPSILON</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">EPSILON</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">first</span><span class="p">[</span><span class="n">lhs</span><span class="p">]:</span>
                        <span class="n">first</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">EPSILON</span><span class="p">)</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
                <span class="n">all_eps</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">rhs</span><span class="p">:</span>
                    <span class="n">sf</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">sym</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
                    <span class="n">additions</span> <span class="o">=</span> <span class="n">sf</span> <span class="o">-</span> <span class="p">{</span><span class="n">EPSILON</span><span class="p">}</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">additions</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">first</span><span class="p">[</span><span class="n">lhs</span><span class="p">]):</span>
                        <span class="n">first</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span> <span class="o">|=</span> <span class="n">additions</span>
                        <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">if</span> <span class="n">EPSILON</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sf</span><span class="p">:</span>
                        <span class="n">all_eps</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">all_eps</span> <span class="ow">and</span> <span class="n">EPSILON</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">first</span><span class="p">[</span><span class="n">lhs</span><span class="p">]:</span>
                    <span class="n">first</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">EPSILON</span><span class="p">)</span>
                    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">first</span>


<span class="k">def</span><span class="w"> </span><span class="nf">compute_follow</span><span class="p">(</span>
    <span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">first</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute FOLLOW sets (same algorithm as Lesson 5).&quot;&quot;&quot;</span>
    <span class="n">follow</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{</span><span class="n">nt</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">nonterminals</span><span class="p">}</span>
    <span class="n">follow</span><span class="p">[</span><span class="n">grammar</span><span class="o">.</span><span class="n">start</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">EOF</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">first_of_seq</span><span class="p">(</span><span class="n">symbols</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">symbols</span><span class="p">:</span>
            <span class="n">sf</span> <span class="o">=</span> <span class="n">first</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">{</span><span class="n">s</span><span class="p">})</span>
            <span class="n">result</span> <span class="o">|=</span> <span class="p">(</span><span class="n">sf</span> <span class="o">-</span> <span class="p">{</span><span class="n">EPSILON</span><span class="p">})</span>
            <span class="k">if</span> <span class="n">EPSILON</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sf</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">result</span>
        <span class="n">result</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">EPSILON</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_list</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhs_list</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">rhs</span> <span class="o">==</span> <span class="p">[</span><span class="n">EPSILON</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rhs</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">sym</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">nonterminals</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">beta</span> <span class="o">=</span> <span class="n">rhs</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]</span>
                    <span class="k">if</span> <span class="n">beta</span><span class="p">:</span>
                        <span class="n">fb</span> <span class="o">=</span> <span class="n">first_of_seq</span><span class="p">(</span><span class="n">beta</span><span class="p">)</span>
                        <span class="n">add</span> <span class="o">=</span> <span class="n">fb</span> <span class="o">-</span> <span class="p">{</span><span class="n">EPSILON</span><span class="p">}</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">add</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">follow</span><span class="p">[</span><span class="n">sym</span><span class="p">]):</span>
                            <span class="n">follow</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">|=</span> <span class="n">add</span>
                            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">if</span> <span class="n">EPSILON</span> <span class="ow">in</span> <span class="n">fb</span><span class="p">:</span>
                            <span class="k">if</span> <span class="ow">not</span> <span class="n">follow</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">follow</span><span class="p">[</span><span class="n">sym</span><span class="p">]):</span>
                                <span class="n">follow</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">|=</span> <span class="n">follow</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span>
                                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">follow</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">follow</span><span class="p">[</span><span class="n">sym</span><span class="p">]):</span>
                            <span class="n">follow</span><span class="p">[</span><span class="n">sym</span><span class="p">]</span> <span class="o">|=</span> <span class="n">follow</span><span class="p">[</span><span class="n">lhs</span><span class="p">]</span>
                            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="n">follow</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Action</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a parsing action.&quot;&quot;&quot;</span>
    <span class="n">kind</span><span class="p">:</span> <span class="nb">str</span>          <span class="c1"># &quot;shift&quot;, &quot;reduce&quot;, &quot;accept&quot;</span>
    <span class="n">state</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>    <span class="c1"># target state for shift</span>
    <span class="n">lhs</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>      <span class="c1"># LHS for reduce</span>
    <span class="n">rhs</span><span class="p">:</span> <span class="nb">tuple</span> <span class="o">=</span> <span class="p">()</span>    <span class="c1"># RHS for reduce</span>
    <span class="n">prod_num</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1"># production number for reduce</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;shift&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;s</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;reduce&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;r(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">lhs</span><span class="si">}</span><span class="s2">-&gt;</span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;accept&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;acc&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;?</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">SLRParser</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Complete SLR(1) parser.</span>

<span class="sd">    Constructs the SLR(1) table from a grammar and uses it</span>
<span class="sd">    to parse input token streams.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original</span> <span class="o">=</span> <span class="n">grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">augmented</span> <span class="o">=</span> <span class="n">grammar</span><span class="o">.</span><span class="n">augment</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">automaton</span> <span class="o">=</span> <span class="n">LRAutomaton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">augmented</span><span class="p">)</span>

        <span class="c1"># Compute FIRST and FOLLOW on the augmented grammar</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">compute_first</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">augmented</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">follow</span> <span class="o">=</span> <span class="n">compute_follow</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">augmented</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">first</span><span class="p">)</span>

        <span class="c1"># Number productions for reduce actions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">prod_list</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_list</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">augmented</span><span class="o">.</span><span class="n">productions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhs_list</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">prod_list</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">lhs</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rhs</span><span class="p">)))</span>

        <span class="c1"># Build the ACTION and GOTO tables</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">action_table</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="n">Action</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">goto_table</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conflicts</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_build_tables</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_find_prod_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lhs</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">rhs</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the production number for a given production.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">prod_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="n">lhs</span> <span class="ow">and</span> <span class="n">r</span> <span class="o">==</span> <span class="n">rhs</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_set_action</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">action</span><span class="p">:</span> <span class="n">Action</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set an action, detecting conflicts.&quot;&quot;&quot;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">symbol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">action_table</span><span class="p">:</span>
            <span class="n">existing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">action_table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">repr</span><span class="p">(</span><span class="n">existing</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">action</span><span class="p">):</span>
                <span class="n">conflict_type</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;shift-reduce&quot;</span>
                    <span class="k">if</span> <span class="p">{</span><span class="n">existing</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">action</span><span class="o">.</span><span class="n">kind</span><span class="p">}</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;shift&quot;</span><span class="p">,</span> <span class="s2">&quot;reduce&quot;</span><span class="p">}</span>
                    <span class="k">else</span> <span class="s2">&quot;reduce-reduce&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conflicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">conflict_type</span><span class="si">}</span><span class="s2"> conflict in state </span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;on &#39;</span><span class="si">{</span><span class="n">symbol</span><span class="si">}</span><span class="s2">&#39;: </span><span class="si">{</span><span class="n">existing</span><span class="si">}</span><span class="s2"> vs </span><span class="si">{</span><span class="n">action</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="c1"># Default resolution: prefer shift over reduce</span>
                <span class="k">if</span> <span class="n">action</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;shift&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">action_table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">action</span>
                <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">action_table</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">action</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Build the SLR(1) ACTION and GOTO tables.&quot;&quot;&quot;</span>
        <span class="n">start_nt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">augmented</span><span class="o">.</span><span class="n">start</span>  <span class="c1"># S&#39;</span>
        <span class="n">original_start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original</span><span class="o">.</span><span class="n">start</span>  <span class="c1"># S</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">state</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">states</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">state</span><span class="p">:</span>
                <span class="n">next_sym</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">next_symbol</span>

                <span class="k">if</span> <span class="n">next_sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># Dot is before a symbol</span>
                    <span class="k">if</span> <span class="n">next_sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">augmented</span><span class="o">.</span><span class="n">terminals</span><span class="p">:</span>
                        <span class="c1"># SHIFT</span>
                        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">goto_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">next_sym</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_set_action</span><span class="p">(</span>
                                <span class="n">i</span><span class="p">,</span> <span class="n">next_sym</span><span class="p">,</span>
                                <span class="n">Action</span><span class="p">(</span><span class="s2">&quot;shift&quot;</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
                            <span class="p">)</span>
                    <span class="k">elif</span> <span class="n">next_sym</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">augmented</span><span class="o">.</span><span class="n">nonterminals</span><span class="p">:</span>
                        <span class="c1"># GOTO</span>
                        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">goto_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">next_sym</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">if</span> <span class="n">target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">goto_table</span><span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">next_sym</span><span class="p">)]</span> <span class="o">=</span> <span class="n">target</span>

                <span class="k">elif</span> <span class="n">item</span><span class="o">.</span><span class="n">is_reduce</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">item</span><span class="o">.</span><span class="n">lhs</span> <span class="o">==</span> <span class="n">start_nt</span><span class="p">:</span>
                        <span class="c1"># ACCEPT: S&#39; -&gt; S .</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_set_action</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">EOF</span><span class="p">,</span> <span class="n">Action</span><span class="p">(</span><span class="s2">&quot;accept&quot;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># REDUCE: A -&gt; Œ± .</span>
                        <span class="n">prod_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_find_prod_num</span><span class="p">(</span>
                            <span class="n">item</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="n">item</span><span class="o">.</span><span class="n">rhs</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">terminal</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">follow</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">item</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span> <span class="nb">set</span><span class="p">()):</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">_set_action</span><span class="p">(</span>
                                <span class="n">i</span><span class="p">,</span> <span class="n">terminal</span><span class="p">,</span>
                                <span class="n">Action</span><span class="p">(</span>
                                    <span class="s2">&quot;reduce&quot;</span><span class="p">,</span>
                                    <span class="n">lhs</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="n">lhs</span><span class="p">,</span>
                                    <span class="n">rhs</span><span class="o">=</span><span class="n">item</span><span class="o">.</span><span class="n">rhs</span><span class="p">,</span>
                                    <span class="n">prod_num</span><span class="o">=</span><span class="n">prod_num</span><span class="p">,</span>
                                <span class="p">)</span>
                            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse a list of terminal symbols.</span>

<span class="sd">        Args:</span>
<span class="sd">            tokens: list of terminal symbols (without $)</span>
<span class="sd">            verbose: if True, print each step</span>

<span class="sd">        Returns:</span>
<span class="sd">            True if accepted, False otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">input_syms</span> <span class="o">=</span> <span class="n">tokens</span> <span class="o">+</span> <span class="p">[</span><span class="n">EOF</span><span class="p">]</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Stack holds alternating states and symbols:</span>
        <span class="c1"># [state0, sym1, state1, sym2, state2, ...]</span>
        <span class="c1"># We use a simpler model: stack of states, separate symbol stack</span>
        <span class="n">state_stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">symbol_stack</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">step</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;Step&#39;</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="s1">&#39;Stack&#39;</span><span class="si">:</span><span class="s2">&lt;35</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;Input&#39;</span><span class="si">:</span><span class="s2">&lt;25</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Action&#39;</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">95</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">state_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">input_syms</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="n">stack_str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="n">symbol_stack</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">symbol_stack</span><span class="p">)</span> <span class="k">else</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">state_stack</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="n">input_str</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">input_syms</span><span class="p">[</span><span class="n">ip</span><span class="p">:])</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">step</span><span class="si">:</span><span class="s2">&gt;4</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">stack_str</span><span class="si">:</span><span class="s2">&lt;35</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">input_str</span><span class="si">:</span><span class="s2">&lt;25</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="n">end</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">action_table</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">action</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ERROR: no action for state </span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2">, &#39;</span><span class="si">{</span><span class="n">current</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">if</span> <span class="n">action</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;shift&quot;</span><span class="p">:</span>
                <span class="n">symbol_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
                <span class="n">state_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">action</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
                <span class="n">ip</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shift </span><span class="si">{</span><span class="n">action</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">action</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;reduce&quot;</span><span class="p">:</span>
                <span class="n">rhs_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">action</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">action</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="p">(</span><span class="n">EPSILON</span><span class="p">,):</span>
                    <span class="n">rhs_len</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="c1"># Pop |rhs| symbols and states</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rhs_len</span><span class="p">):</span>
                    <span class="n">state_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">symbol_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

                <span class="c1"># Push LHS</span>
                <span class="n">symbol_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">action</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
                <span class="n">goto_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">goto_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">state_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">action</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">goto_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;ERROR: no GOTO for state &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">state_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, &#39;</span><span class="si">{</span><span class="n">action</span><span class="o">.</span><span class="n">lhs</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                        <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">False</span>
                <span class="n">state_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">goto_state</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Reduce </span><span class="si">{</span><span class="n">action</span><span class="o">.</span><span class="n">lhs</span><span class="si">}</span><span class="s2"> -&gt; &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">action</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="n">action</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;accept&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ACCEPT&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">True</span>

            <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">step</span> <span class="o">&gt;</span> <span class="mi">100000</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR: too many steps&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_tables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pretty-print the ACTION and GOTO tables.&quot;&quot;&quot;</span>
        <span class="n">terminals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">augmented</span><span class="o">.</span><span class="n">terminals</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">EOF</span><span class="p">]</span>
        <span class="n">nonterminals</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">augmented</span><span class="o">.</span><span class="n">nonterminals</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">augmented</span><span class="o">.</span><span class="n">start</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="n">col_w</span> <span class="o">=</span> <span class="mi">12</span>
        <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;State&#39;</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t</span><span class="si">:</span><span class="s2">&gt;</span><span class="si">{</span><span class="n">col_w</span><span class="si">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terminals</span><span class="p">)</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="s2">&quot; |&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">nt</span><span class="si">:</span><span class="s2">&gt;</span><span class="si">{</span><span class="n">col_w</span><span class="si">}}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="n">nonterminals</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">automaton</span><span class="o">.</span><span class="n">states</span><span class="p">)):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">&gt;6</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">terminals</span><span class="p">:</span>
                <span class="n">action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">action_table</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">t</span><span class="p">))</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">action</span><span class="p">)</span> <span class="k">if</span> <span class="n">action</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="n">row</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cell</span><span class="si">:</span><span class="s2">&gt;</span><span class="si">{</span><span class="n">col_w</span><span class="si">}}</span><span class="s2">&quot;</span>
            <span class="n">row</span> <span class="o">+=</span> <span class="s2">&quot; |&quot;</span>
            <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="n">nonterminals</span><span class="p">:</span>
                <span class="n">goto</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">goto_table</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">nt</span><span class="p">))</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">goto</span><span class="p">)</span> <span class="k">if</span> <span class="n">goto</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="n">row</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">cell</span><span class="si">:</span><span class="s2">&gt;</span><span class="si">{</span><span class="n">col_w</span><span class="si">}}</span><span class="s2">&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Demo ‚îÄ‚îÄ‚îÄ</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">grammar</span> <span class="o">=</span> <span class="n">build_expression_grammar</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Original Grammar:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">rhs_list</span> <span class="ow">in</span> <span class="n">grammar</span><span class="o">.</span><span class="n">productions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">rhs</span> <span class="ow">in</span> <span class="n">rhs_list</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">lhs</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">rhs</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">SLRParser</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">parser</span><span class="o">.</span><span class="n">conflicts</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Conflicts found:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">parser</span><span class="o">.</span><span class="n">conflicts</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">c</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No conflicts -- grammar is SLR(1)!&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;SLR(1) Parsing Table:&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">print_tables</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Parse some inputs</span>
    <span class="n">test_cases</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">([</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span>
        <span class="p">([</span><span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span>
        <span class="p">([</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;(&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">],</span> <span class="kc">True</span><span class="p">),</span>
        <span class="p">([</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">],</span> <span class="kc">False</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">expected</span> <span class="ow">in</span> <span class="n">test_cases</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">95</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input: </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">95</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;ACCEPTED&quot;</span> <span class="k">if</span> <span class="n">result</span> <span class="k">else</span> <span class="s2">&quot;REJECTED&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Result: </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">result</span> <span class="o">==</span> <span class="n">expected</span>
</code></pre></div>

<hr />
<h2 id="5-canonical-lr1-parsing">5. Canonical LR(1) Parsing<a class="header-link" href="#5-canonical-lr1-parsing" title="Permanent link">&para;</a></h2>
<h3 id="51-lr1-items">5.1 LR(1) Items<a class="header-link" href="#51-lr1-items" title="Permanent link">&para;</a></h3>
<p>An <strong>LR(1) item</strong> augments the LR(0) item with a <strong>lookahead</strong> terminal:</p>
<p>$$[A \to \alpha \cdot \beta, a]$$</p>
<p>This means: "We are in the process of recognizing $A \to \alpha\beta$, have matched $\alpha$, and if we complete the reduction, the next input symbol should be $a$."</p>
<p>The lookahead is only used when the dot reaches the end (for reduce decisions); shift decisions are the same as LR(0).</p>
<h3 id="52-lr1-closure">5.2 LR(1) Closure<a class="header-link" href="#52-lr1-closure" title="Permanent link">&para;</a></h3>
<p>The LR(1) closure propagates lookaheads:</p>
<div class="highlight"><pre><span></span><code><span class="n">CLOSURE</span><span class="p">(</span><span class="n">I</span><span class="p">)</span><span class="o">:</span>
<span class="w">    </span><span class="kr">repeat</span><span class="o">:</span>
<span class="w">        </span><span class="n">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">item</span><span class="w"> </span><span class="p">[</span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="err">Œ≤</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">I</span><span class="o">:</span>
<span class="w">            </span><span class="n">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">production</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ≥</span><span class="o">:</span>
<span class="w">                </span><span class="n">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">terminal</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="kr">FIRST</span><span class="p">(</span><span class="err">Œ≤</span><span class="n">a</span><span class="p">)</span><span class="o">:</span>
<span class="w">                    </span><span class="n">add</span><span class="w"> </span><span class="p">[</span><span class="n">B</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="err">Œ≥</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">I</span>
<span class="w">    </span><span class="n">until</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">items</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">added</span>
<span class="w">    </span><span class="kr">return</span><span class="w"> </span><span class="n">I</span>
</code></pre></div>

<p>The critical difference from LR(0) closure is the computation of the lookahead set $\text{FIRST}(\beta a)$. This is how context flows through the parser.</p>
<h3 id="53-lr1-table-construction">5.3 LR(1) Table Construction<a class="header-link" href="#53-lr1-table-construction" title="Permanent link">&para;</a></h3>
<p>The table construction is similar to SLR(1) but uses item-specific lookaheads instead of FOLLOW sets for reduce actions:</p>
<div class="highlight"><pre><span></span><code><span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">I_i</span><span class="o">:</span>
<span class="w">  </span><span class="n">SHIFT</span><span class="o">:</span><span class="w">  </span><span class="nf">If</span><span class="w"> </span><span class="p">[</span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="w"> </span><span class="p">.</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="err">Œ≤</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">]</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">I_i</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">GOTO</span><span class="p">(</span><span class="n">I_i</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">I_j</span><span class="o">:</span>
<span class="w">              </span><span class="n">ACTION</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;shift j&quot;</span>

<span class="w">  </span><span class="n">REDUCE</span><span class="o">:</span><span class="w"> </span><span class="nf">If</span><span class="w"> </span><span class="p">[</span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="w"> </span><span class="p">.,</span><span class="w"> </span><span class="n">a</span><span class="p">]</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">I_i</span><span class="w"> </span><span class="p">(</span><span class="n">A</span><span class="w"> </span><span class="err">‚â†</span><span class="w"> </span><span class="n">S</span><span class="s">&#39;):</span>
<span class="s">              ACTION[i, a] = &quot;</span><span class="n">reduce</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="s">&quot;</span>
<span class="s">              (Only on lookahead &#39;</span><span class="n">a</span><span class="s">&#39;, NOT all of FOLLOW(A))</span>

<span class="s">  ACCEPT: If [S&#39;</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="p">.,</span><span class="w"> </span><span class="err">$</span><span class="p">]</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">I_i</span><span class="o">:</span>
<span class="w">              </span><span class="n">ACTION</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="err">$</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;accept&quot;</span>
</code></pre></div>

<h3 id="54-lr1-vs-slr1">5.4 LR(1) vs SLR(1)<a class="header-link" href="#54-lr1-vs-slr1" title="Permanent link">&para;</a></h3>
<p>The key advantage of LR(1) is precision in reduce actions:</p>
<div class="highlight"><pre><span></span><code><span class="n">SLR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="w">  </span><span class="n">Reduce</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="kr">ALL</span><span class="w"> </span><span class="n">terminals</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">FOLLOW</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
<span class="n">LR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">:</span><span class="w">   </span><span class="n">Reduce</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">Œ±</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="kr">ONLY</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">specific</span><span class="w"> </span><span class="n">lookahead</span><span class="w"> </span><span class="n">terminal</span>

<span class="n">This</span><span class="w"> </span><span class="n">means</span><span class="w"> </span><span class="n">LR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="n">grammars</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">SLR</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">cannot</span><span class="p">.</span>
</code></pre></div>

<p><strong>Example where SLR(1) fails but LR(1) works:</strong></p>
<p>$$
\begin{aligned}
S &\to L = R \mid R \\
L &\to * R \mid \textbf{id} \\
R &\to L
\end{aligned}
$$</p>
<p>In SLR(1), there is a shift-reduce conflict in the state containing $[R \to L \cdot]$ and $[S \to L \cdot = R]$ because $=$ is in $\text{FOLLOW}(R)$. In LR(1), the item $[R \to L \cdot, \$]$ has lookahead $\$$, not $=$, so there is no conflict.

### 5.5 Practical Consideration: Table Size

The main disadvantage of canonical LR(1) is the size of the automaton. The number of LR(1) states can be much larger than LR(0) states because items with different lookaheads are kept separate. For typical programming language grammars, LR(1) tables can have thousands of states, while LR(0)/SLR has hundreds.

---

## 6. LALR(1) Parsing

### 6.1 Motivation

**LALR(1)** (Look-Ahead LR) is a practical compromise between SLR(1) and canonical LR(1):

- **More powerful than SLR(1)**: Uses context-sensitive lookaheads
- **Same number of states as SLR(1)**: Merges LR(1) states with identical cores
- **Almost as powerful as LR(1)**: Very few practical grammars are LR(1) but not LALR(1)

### 6.2 Construction by Merging

LALR(1) states are created by merging LR(1) states that have the same **core** (same set of LR(0) items, ignoring lookaheads). The lookahead sets are merged (unioned).

 CODE11 

### 6.3 Potential New Conflicts

Merging can introduce **reduce-reduce conflicts** that were not present in the canonical LR(1) table. However, it **cannot** introduce new shift-reduce conflicts (because the core determines shift actions).

 CODE12 

In practice, this situation is extremely rare for real programming language grammars.

### 6.4 Comparison of LR Variants

 CODE13 

| Variant | Reduce decision | # States | Power | Tool |
|---------|----------------|----------|-------|------|
| LR(0) | Always reduce (no lookahead) | Minimal | Weakest | Theoretical |
| SLR(1) | FOLLOW sets | Same as LR(0) | Good | Simple generators |
| LALR(1) | Merged LR(1) lookaheads | Same as LR(0) | Very good | Yacc, Bison, PLY |
| LR(1) | Exact LR(1) lookaheads | Can be much larger | Best | Rarely used directly |

---

## 7. Parser Generator Tools

### 7.1 Yacc and Bison

**Yacc** (Yet Another Compiler Compiler) is the classic Unix parser generator. **Bison** is the GNU version. Both generate LALR(1) parsers from a grammar specification.

**Yacc/Bison grammar format:**

 CODE14 

Key features:
- **`%left`, `%right`, `%nonassoc`**: Declare operator precedence and associativity
- **`$$<code>**: Value of the LHS symbol (the result)
- **</code>$1`, `$2<code>,</code>$3<code>, ...**: Values of RHS symbols
- **</code>%prec`**: Override default precedence for a specific rule</p>
<h3 id="72-ply-python-lex-yacc">7.2 PLY (Python Lex-Yacc)<a class="header-link" href="#72-ply-python-lex-yacc" title="Permanent link">&para;</a></h3>
<p><strong>PLY</strong> is a Python implementation of Lex and Yacc. It generates LALR(1) parsers.</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">PLY Example: Expression Parser</span>

<span class="sd">PLY (Python Lex-Yacc) provides lex and yacc functionality for Python.</span>
<span class="sd">Install with: pip install ply</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="c1"># ‚îÄ‚îÄ‚îÄ Lexer ‚îÄ‚îÄ‚îÄ</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ply.lex</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">lex</span>

<span class="n">tokens</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;NUM&#39;</span><span class="p">,</span> <span class="s1">&#39;PLUS&#39;</span><span class="p">,</span> <span class="s1">&#39;TIMES&#39;</span><span class="p">,</span> <span class="s1">&#39;LPAREN&#39;</span><span class="p">,</span> <span class="s1">&#39;RPAREN&#39;</span><span class="p">,</span> <span class="s1">&#39;ID&#39;</span><span class="p">)</span>

<span class="n">t_PLUS</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\+&#39;</span>
<span class="n">t_TIMES</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\*&#39;</span>
<span class="n">t_LPAREN</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\(&#39;</span>
<span class="n">t_RPAREN</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;\)&#39;</span>
<span class="n">t_ID</span> <span class="o">=</span> <span class="sa">r</span><span class="s1">&#39;[a-zA-Z_][a-zA-Z0-9_]*&#39;</span>
<span class="n">t_ignore</span> <span class="o">=</span> <span class="s1">&#39; </span><span class="se">\t</span><span class="s1">&#39;</span>

<span class="k">def</span><span class="w"> </span><span class="nf">t_NUM</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="sa">r</span><span class="s1">&#39;\d+&#39;</span>
    <span class="n">t</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span>

<span class="k">def</span><span class="w"> </span><span class="nf">t_error</span><span class="p">(</span><span class="n">t</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Illegal character &#39;</span><span class="si">{</span><span class="n">t</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
    <span class="n">t</span><span class="o">.</span><span class="n">lexer</span><span class="o">.</span><span class="n">skip</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">lexer</span> <span class="o">=</span> <span class="n">lex</span><span class="o">.</span><span class="n">lex</span><span class="p">()</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Parser ‚îÄ‚îÄ‚îÄ</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">ply.yacc</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">yacc</span>

<span class="c1"># Precedence (lowest to highest)</span>
<span class="n">precedence</span> <span class="o">=</span> <span class="p">(</span>
    <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;PLUS&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="s1">&#39;TIMES&#39;</span><span class="p">),</span>
<span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">p_expr_binop</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;expr : expr PLUS expr</span>
<span class="sd">            | expr TIMES expr&#39;&#39;&#39;</span>
    <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
        <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;add&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;mul&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">p_expr_group</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;expr : LPAREN expr RPAREN&#39;&#39;&#39;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">p_expr_num</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;expr : NUM&#39;&#39;&#39;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;num&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">p_expr_id</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;expr : ID&#39;&#39;&#39;</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">p_error</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">p</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Syntax error at &#39;</span><span class="si">{</span><span class="n">p</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Syntax error at end of input&quot;</span><span class="p">)</span>

<span class="n">parser</span> <span class="o">=</span> <span class="n">yacc</span><span class="o">.</span><span class="n">yacc</span><span class="p">()</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Usage ‚îÄ‚îÄ‚îÄ</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">test_inputs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;3 + 4 * 5&quot;</span><span class="p">,</span>
        <span class="s2">&quot;(a + b) * c&quot;</span><span class="p">,</span>
        <span class="s2">&quot;x + y + z&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">text</span> <span class="ow">in</span> <span class="n">test_inputs</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">text</span><span class="si">:</span><span class="s2">20s</span><span class="si">}</span><span class="s2"> =&gt; </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p><strong>Output:</strong></p>
<div class="highlight"><pre><span></span><code><span class="mf">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mf">5</span><span class="w">            </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">add</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">num</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">3</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">mul</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">num</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">4</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">num</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="mf">5</span><span class="p">)))</span>
<span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span><span class="w">          </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">mul</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">add</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">id</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">a</span><span class="err">&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">id</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">b</span><span class="err">&#39;</span><span class="p">)),</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">id</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">c</span><span class="err">&#39;</span><span class="p">))</span>
<span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="w">            </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">add</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">add</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">id</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">x</span><span class="err">&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">id</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">y</span><span class="err">&#39;</span><span class="p">)),</span><span class="w"> </span><span class="p">(</span><span class="err">&#39;</span><span class="n">id</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="n">z</span><span class="err">&#39;</span><span class="p">))</span>
</code></pre></div>

<h3 id="73-other-parser-generator-tools">7.3 Other Parser Generator Tools<a class="header-link" href="#73-other-parser-generator-tools" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Tool</th>
<th>Language</th>
<th>Parser Type</th>
<th>Notable Feature</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Yacc/Bison</strong></td>
<td>C/C++</td>
<td>LALR(1)</td>
<td>Industry standard</td>
</tr>
<tr>
<td><strong>PLY</strong></td>
<td>Python</td>
<td>LALR(1)</td>
<td>Pythonic Yacc</td>
</tr>
<tr>
<td><strong>Lark</strong></td>
<td>Python</td>
<td>Earley/LALR</td>
<td>Elegant EBNF syntax</td>
</tr>
<tr>
<td><strong>ANTLR</strong></td>
<td>Java/Python/...</td>
<td>ALL(*)</td>
<td>Most powerful LL</td>
</tr>
<tr>
<td><strong>tree-sitter</strong></td>
<td>C (with bindings)</td>
<td>GLR</td>
<td>Incremental, error-tolerant</td>
</tr>
<tr>
<td><strong>Menhir</strong></td>
<td>OCaml</td>
<td>LR(1)</td>
<td>Full LR(1), not LALR</td>
</tr>
<tr>
<td><strong>Happy</strong></td>
<td>Haskell</td>
<td>LALR(1)</td>
<td>Monadic parser actions</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="8-conflict-resolution">8. Conflict Resolution<a class="header-link" href="#8-conflict-resolution" title="Permanent link">&para;</a></h2>
<h3 id="81-shift-reduce-conflicts">8.1 Shift-Reduce Conflicts<a class="header-link" href="#81-shift-reduce-conflicts" title="Permanent link">&para;</a></h3>
<p>A <strong>shift-reduce conflict</strong> occurs when the parser can either shift the next input symbol or reduce a handle on the stack.</p>
<p><strong>Classic example: the dangling else.</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">stmt</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">THEN</span><span class="w"> </span><span class="n">stmt</span><span class="w"> </span><span class="n">ELSE</span><span class="w"> </span><span class="n">stmt</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">THEN</span><span class="w"> </span><span class="n">stmt</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">other</span>
<span class="w">     </span><span class="o">;</span>
</code></pre></div>

<p>When the parser sees <code>IF expr THEN stmt</code> with lookahead <code>ELSE</code>, it can:
- <strong>Shift</strong> <code>ELSE</code> (associate <code>else</code> with this <code>if</code>)
- <strong>Reduce</strong> <code>stmt -&gt; IF expr THEN stmt</code> (associate <code>else</code> with an outer <code>if</code>)</p>
<p><strong>Resolution:</strong> Most parser generators default to <strong>shift</strong> (match <code>else</code> with the nearest <code>if</code>). This is the correct behavior for virtually all programming languages.</p>
<h3 id="82-reduce-reduce-conflicts">8.2 Reduce-Reduce Conflicts<a class="header-link" href="#82-reduce-reduce-conflicts" title="Permanent link">&para;</a></h3>
<p>A <strong>reduce-reduce conflict</strong> occurs when the parser can reduce by two different productions.</p>
<div class="highlight"><pre><span></span><code><span class="n">stmt</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="s1">&#39;(&#39;</span><span class="w"> </span><span class="n">expr_list</span><span class="w"> </span><span class="s1">&#39;)&#39;</span><span class="w">    </span><span class="c1">// function call</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">ID</span><span class="w"> </span><span class="s1">&#39;(&#39;</span><span class="w"> </span><span class="n">expr_list</span><span class="w"> </span><span class="s1">&#39;)&#39;</span><span class="w">    </span><span class="c1">// array subscript (hypothetical)</span>
<span class="w">     </span><span class="o">;</span>
</code></pre></div>

<p><strong>Resolution strategies:</strong>
- Rewrite the grammar to eliminate the ambiguity
- In Yacc/Bison, the production listed first wins
- Use semantic analysis to distinguish cases (not at the parsing level)</p>
<h3 id="83-precedence-and-associativity-declarations">8.3 Precedence and Associativity Declarations<a class="header-link" href="#83-precedence-and-associativity-declarations" title="Permanent link">&para;</a></h3>
<p>Parser generators provide <strong>precedence</strong> and <strong>associativity</strong> declarations to systematically resolve shift-reduce conflicts in expression grammars.</p>
<div class="highlight"><pre><span></span><code><span class="cm">/* Precedence: lowest first */</span>
<span class="nf">%right</span><span class="w"> </span><span class="sc">&#39;=&#39;</span><span class="w">                  </span><span class="cm">/* assignment: right-associative */</span>
<span class="nf">%left</span><span class="w"> </span><span class="n">OR</span><span class="w">                    </span><span class="cm">/* logical OR */</span>
<span class="nf">%left</span><span class="w"> </span><span class="n">AND</span><span class="w">                   </span><span class="cm">/* logical AND */</span>
<span class="nf">%left</span><span class="w"> </span><span class="n">EQ</span><span class="w"> </span><span class="n">NE</span><span class="w">                 </span><span class="cm">/* equality */</span>
<span class="nf">%left</span><span class="w"> </span><span class="sc">&#39;&lt;&#39;</span><span class="w"> </span><span class="sc">&#39;&gt;&#39;</span><span class="w"> </span><span class="n">LE</span><span class="w"> </span><span class="n">GE</span><span class="w">         </span><span class="cm">/* comparison */</span>
<span class="nf">%left</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="w"> </span><span class="sc">&#39;-&#39;</span><span class="w">               </span><span class="cm">/* additive */</span>
<span class="nf">%left</span><span class="w"> </span><span class="sc">&#39;*&#39;</span><span class="w"> </span><span class="sc">&#39;/&#39;</span><span class="w"> </span><span class="sc">&#39;%&#39;</span><span class="w">           </span><span class="cm">/* multiplicative */</span>
<span class="nf">%right</span><span class="w"> </span><span class="n">UMINUS</span><span class="w">               </span><span class="cm">/* unary minus (pseudo-token) */</span>
</code></pre></div>

<p><strong>How it works:</strong></p>
<ol>
<li>Each token gets a <strong>precedence level</strong> (from its declaration position)</li>
<li>Each production gets the precedence of its <strong>rightmost terminal</strong></li>
<li>On a shift-reduce conflict:</li>
<li>If the shift token has higher precedence than the reduce production: <strong>shift</strong></li>
<li>If the reduce production has higher precedence: <strong>reduce</strong></li>
<li>If equal precedence: use <strong>associativity</strong> (<code>%left</code> = reduce, <code>%right</code> = shift, <code>%nonassoc</code> = error)</li>
</ol>
<p><strong>Example:</strong> For the input <code>3 + 4 * 5</code>:</p>
<div class="highlight"><pre><span></span><code><span class="n">Stack</span><span class="o">:</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w">    </span><span class="n">Lookahead</span><span class="o">:</span><span class="w"> </span><span class="o">*</span>

<span class="n">Production</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">reduce</span><span class="o">:</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">expr</span><span class="w">  </span><span class="p">(</span><span class="n">precedence</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="s">&#39;+&#39;</span><span class="p">)</span>
<span class="kt">Token</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">shift</span><span class="o">:</span><span class="w"> </span><span class="s">&#39;*&#39;</span><span class="w">                        </span><span class="p">(</span><span class="n">precedence</span><span class="w"> </span><span class="kr">of</span><span class="w"> </span><span class="s">&#39;*&#39;</span><span class="p">)</span>

<span class="n">Since</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kr">in</span><span class="w"> </span><span class="n">precedence</span><span class="o">:</span><span class="w"> </span><span class="n">SHIFT</span>

<span class="n">Result</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="mi">4</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">  </span><span class="err">‚úì</span>
</code></pre></div>

<h3 id="84-the-prec-directive">8.4 The <code>%prec</code> Directive<a class="header-link" href="#84-the-prec-directive" title="Permanent link">&para;</a></h3>
<p>Sometimes a production needs a different precedence than its rightmost terminal suggests. The <code>%prec</code> directive overrides this:</p>
<div class="highlight"><pre><span></span><code>expr<span class="w"> </span>:<span class="w"> </span>&#39;-&#39;<span class="w"> </span>expr<span class="w">  </span>%prec<span class="w"> </span>UMINUS<span class="w">    </span>/*<span class="w"> </span>unary<span class="w"> </span>minus<span class="w"> </span>*/
<span class="w">     </span>{
<span class="w">         </span>$$<span class="w"> </span>=<span class="w"> </span>-$<span class="m">2</span>;
<span class="w">     </span>}
<span class="w">     </span>;
</code></pre></div>

<p>Without <code>%prec UMINUS</code>, the production <code>expr -&gt; '-' expr</code> would have the precedence of <code>-</code> (additive level). With <code>%prec UMINUS</code>, it gets the higher unary minus precedence.</p>
<hr />
<h2 id="9-error-recovery-in-lr-parsers">9. Error Recovery in LR Parsers<a class="header-link" href="#9-error-recovery-in-lr-parsers" title="Permanent link">&para;</a></h2>
<h3 id="91-panic-mode">9.1 Panic Mode<a class="header-link" href="#91-panic-mode" title="Permanent link">&para;</a></h3>
<p>Similar to top-down parsing, but adapted for the shift-reduce framework:</p>
<ol>
<li>Pop states from the stack until finding a state $s$ where GOTO($s$, $A$) is defined for some error-recovery nonterminal $A$</li>
<li>Push $A$ and the GOTO state onto the stack</li>
<li>Discard input symbols until finding one on which the parser can continue</li>
</ol>
<h3 id="92-error-productions">9.2 Error Productions<a class="header-link" href="#92-error-productions" title="Permanent link">&para;</a></h3>
<p>Yacc/Bison provide the special <code>error</code> token for error recovery:</p>
<div class="highlight"><pre><span></span><code><span class="n">stmt</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="s1">&#39;;&#39;</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="s1">&#39;;&#39;</span><span class="w">      </span><span class="cm">/* on error, skip to next semicolon */</span>
<span class="w">     </span><span class="o">{</span>
<span class="w">         </span><span class="n">yyerrok</span><span class="o">;</span><span class="w">      </span><span class="cm">/* reset error state */</span>
<span class="w">         </span><span class="n">printf</span><span class="o">(</span><span class="s2">&quot;Recovered from error\n&quot;</span><span class="o">);</span>
<span class="w">     </span><span class="o">}</span>
<span class="w">     </span><span class="o">;</span>

<span class="n">block</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="s1">&#39;{&#39;</span><span class="w"> </span><span class="n">stmt_list</span><span class="w"> </span><span class="s1">&#39;}&#39;</span>
<span class="w">      </span><span class="o">|</span><span class="w"> </span><span class="s1">&#39;{&#39;</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="s1">&#39;}&#39;</span><span class="w">    </span><span class="cm">/* on error, skip to matching brace */</span>
<span class="w">      </span><span class="o">;</span>
</code></pre></div>

<p><strong>How <code>error</code> works:</strong></p>
<ol>
<li>When a syntax error occurs, the parser pops states until it finds one that can shift <code>error</code></li>
<li>It shifts the <code>error</code> token</li>
<li>It discards input tokens until it can successfully shift after the error production</li>
<li><code>yyerrok</code> tells the parser to resume normal error reporting (otherwise it suppresses errors for a few tokens)</li>
</ol>
<h3 id="93-implementation">9.3 Implementation<a class="header-link" href="#93-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SLRParserWithRecovery</span><span class="p">(</span><span class="n">SLRParser</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SLR parser with error recovery support.</span>

<span class="sd">    Uses a synchronization-based strategy:</span>
<span class="sd">    when an error occurs, pop states until we find one that</span>
<span class="sd">    can handle a synchronizing token.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grammar</span><span class="p">:</span> <span class="n">Grammar</span><span class="p">,</span> <span class="n">sync_tokens</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">grammar</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sync_tokens</span> <span class="o">=</span> <span class="n">sync_tokens</span> <span class="ow">or</span> <span class="p">{</span><span class="s2">&quot;;&quot;</span><span class="p">,</span> <span class="s2">&quot;)&quot;</span><span class="p">,</span> <span class="s2">&quot;}&quot;</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">parse_with_recovery</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">tokens</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parse with error recovery.</span>

<span class="sd">        Returns:</span>
<span class="sd">            (success, errors) where success is True if parsing completed</span>
<span class="sd">            and errors is a list of error messages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">input_syms</span> <span class="o">=</span> <span class="n">tokens</span> <span class="o">+</span> <span class="p">[</span><span class="n">EOF</span><span class="p">]</span>
        <span class="n">ip</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">state_stack</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">symbol_stack</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">state</span> <span class="o">=</span> <span class="n">state_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">input_syms</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span>

            <span class="n">action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">action_table</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">state</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">action</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># ERROR</span>
                <span class="n">error_msg</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Syntax error at position </span><span class="si">{</span><span class="n">ip</span><span class="si">}</span><span class="s2">: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;unexpected &#39;</span><span class="si">{</span><span class="n">current</span><span class="si">}</span><span class="s2">&#39; in state </span><span class="si">{</span><span class="n">state</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ERROR: </span><span class="si">{</span><span class="n">error_msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Recovery: skip input until sync token</span>
                <span class="n">recovered</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">while</span> <span class="n">ip</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_syms</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># Don&#39;t skip $</span>
                    <span class="k">if</span> <span class="n">input_syms</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sync_tokens</span><span class="p">:</span>
                        <span class="c1"># Try to find a state that can handle this</span>
                        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">state_stack</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">test_action</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">action_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                                <span class="p">(</span><span class="n">state_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">input_syms</span><span class="p">[</span><span class="n">ip</span><span class="p">])</span>
                            <span class="p">)</span>
                            <span class="k">if</span> <span class="n">test_action</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">recovered</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="k">break</span>
                            <span class="n">state_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                            <span class="k">if</span> <span class="n">symbol_stack</span><span class="p">:</span>
                                <span class="n">symbol_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

                        <span class="k">if</span> <span class="n">recovered</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                                <span class="nb">print</span><span class="p">(</span>
                                    <span class="sa">f</span><span class="s2">&quot;  Recovered at &#39;</span><span class="si">{</span><span class="n">input_syms</span><span class="p">[</span><span class="n">ip</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;in state </span><span class="si">{</span><span class="n">state_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                                <span class="p">)</span>
                            <span class="k">break</span>
                    <span class="n">ip</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="n">recovered</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">action</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;shift&quot;</span><span class="p">:</span>
                <span class="n">symbol_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
                <span class="n">state_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">action</span><span class="o">.</span><span class="n">state</span><span class="p">)</span>
                <span class="n">ip</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">action</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;reduce&quot;</span><span class="p">:</span>
                <span class="n">rhs_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">action</span><span class="o">.</span><span class="n">rhs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">action</span><span class="o">.</span><span class="n">rhs</span> <span class="o">==</span> <span class="p">(</span><span class="n">EPSILON</span><span class="p">,):</span>
                    <span class="n">rhs_len</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rhs_len</span><span class="p">):</span>
                    <span class="n">state_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="n">symbol_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="n">symbol_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">action</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
                <span class="n">goto_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">goto_table</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">state_stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">action</span><span class="o">.</span><span class="n">lhs</span><span class="p">)</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">goto_state</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">False</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span>
                <span class="n">state_stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">goto_state</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">action</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">&quot;accept&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">errors</span>
</code></pre></div>

<hr />
<h2 id="10-advanced-topics">10. Advanced Topics<a class="header-link" href="#10-advanced-topics" title="Permanent link">&para;</a></h2>
<h3 id="101-glr-parsing">10.1 GLR Parsing<a class="header-link" href="#101-glr-parsing" title="Permanent link">&para;</a></h3>
<p><strong>Generalized LR (GLR)</strong> parsing handles ambiguous and nondeterministic grammars by maintaining multiple parse stacks simultaneously. When a conflict occurs, the parser <strong>forks</strong> into multiple parallel parsers.</p>
<div class="highlight"><pre><span></span><code><span class="nt">GLR</span><span class="w"> </span><span class="nt">Parsing</span><span class="o">:</span><span class="w"> </span><span class="nt">Fork</span><span class="w"> </span><span class="nt">on</span><span class="w"> </span><span class="nt">Conflict</span>

<span class="w">    </span><span class="nt">Before</span><span class="w"> </span><span class="nt">conflict</span><span class="o">:</span><span class="w">     </span><span class="nt">After</span><span class="w"> </span><span class="nt">fork</span><span class="o">:</span>
<span class="w">    </span><span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span><span class="w">         </span><span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="w">    </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nt">Stack</span><span class="w"> </span><span class="nt">A</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w">         </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nt">Stack</span><span class="w"> </span><span class="nt">A</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w"> </span><span class="err">‚îÄ‚îÄ</span><span class="nt">shift</span><span class="err">‚îÄ‚îÄ‚ñ∂</span><span class="w">  </span><span class="nt">Stack</span><span class="w"> </span><span class="nt">A</span><span class="s1">&#39;</span>
<span class="s1">    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò         ‚îÇ         ‚îÇ ‚îÄ‚îÄreduce‚îÄ‚îÄ‚ñ∂ Stack A&#39;</span><span class="err">&#39;</span>
<span class="w">                        </span><span class="err">‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>

<span class="w">    </span><span class="nt">Both</span><span class="w"> </span><span class="nt">stacks</span><span class="w"> </span><span class="nt">continue</span><span class="w"> </span><span class="nt">independently</span><span class="o">.</span>
<span class="w">    </span><span class="nt">Invalid</span><span class="w"> </span><span class="nt">parses</span><span class="w"> </span><span class="nt">die</span><span class="w"> </span><span class="nt">out</span><span class="o">;</span><span class="w"> </span><span class="nt">valid</span><span class="w"> </span><span class="nt">ones</span><span class="w"> </span><span class="nt">converge</span><span class="o">.</span>
</code></pre></div>

<p><strong>Used by:</strong> tree-sitter (for incremental parsing in editors), Elkhound, Bison's <code>%glr-parser</code> mode.</p>
<h3 id="102-incremental-parsing">10.2 Incremental Parsing<a class="header-link" href="#102-incremental-parsing" title="Permanent link">&para;</a></h3>
<p>Modern editors (VS Code, Neovim) need to re-parse files after every keystroke. <strong>Incremental parsing</strong> reuses previous parse results for unchanged portions of the file.</p>
<p><strong>tree-sitter</strong> is the most prominent incremental parser:</p>
<ol>
<li>Maintains the parse tree from the previous edit</li>
<li>When the user types, only the affected tree nodes are re-parsed</li>
<li>Uses a GLR algorithm for robustness with syntactically incorrect code</li>
<li>Achieves sub-millisecond parse times for typical edits</li>
</ol>
<h3 id="103-operator-precedence-parsing">10.3 Operator Precedence Parsing<a class="header-link" href="#103-operator-precedence-parsing" title="Permanent link">&para;</a></h3>
<p>For expression-heavy languages, <strong>operator precedence parsing</strong> (also called <strong>Pratt parsing</strong>) provides a simpler alternative to full LR parsing:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">pratt_parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">min_precedence</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pratt parser / precedence climbing for expressions.</span>

<span class="sd">    A simple, elegant alternative to LR for expression parsing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">parse_atom</span><span class="p">(</span><span class="n">tokens</span><span class="p">)</span>

    <span class="k">while</span> <span class="p">(</span>
        <span class="n">tokens</span><span class="o">.</span><span class="n">peek</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="ow">and</span> <span class="n">get_precedence</span><span class="p">(</span><span class="n">tokens</span><span class="o">.</span><span class="n">peek</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="n">min_precedence</span>
    <span class="p">):</span>
        <span class="n">op</span> <span class="o">=</span> <span class="n">tokens</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
        <span class="n">prec</span> <span class="o">=</span> <span class="n">get_precedence</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>
        <span class="n">assoc</span> <span class="o">=</span> <span class="n">get_associativity</span><span class="p">(</span><span class="n">op</span><span class="p">)</span>

        <span class="c1"># For left-associative: next_min = prec + 1</span>
        <span class="c1"># For right-associative: next_min = prec</span>
        <span class="n">next_min</span> <span class="o">=</span> <span class="n">prec</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">assoc</span> <span class="o">==</span> <span class="s2">&quot;left&quot;</span> <span class="k">else</span> <span class="n">prec</span>

        <span class="n">right</span> <span class="o">=</span> <span class="n">pratt_parse</span><span class="p">(</span><span class="n">tokens</span><span class="p">,</span> <span class="n">next_min</span><span class="p">)</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">BinOp</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">left</span>
</code></pre></div>

<hr />
<h2 id="11-summary">11. Summary<a class="header-link" href="#11-summary" title="Permanent link">&para;</a></h2>
<p>Bottom-up parsing is the dominant strategy in production compilers and parser generators. Its ability to handle left-recursive grammars and its systematic approach to ambiguity resolution make it highly practical.</p>
<p><strong>Key concepts:</strong></p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Shift-reduce</strong></td>
<td>The basic operation: shift input onto stack or reduce a handle</td>
</tr>
<tr>
<td><strong>Handle</strong></td>
<td>The RHS that should be reduced at each step (always at stack top)</td>
</tr>
<tr>
<td><strong>LR(0) items</strong></td>
<td>Productions with a dot marking parse progress</td>
</tr>
<tr>
<td><strong>Closure</strong></td>
<td>Adding implied items when dot is before a nonterminal</td>
</tr>
<tr>
<td><strong>GOTO</strong></td>
<td>Transitioning between item sets by advancing the dot</td>
</tr>
<tr>
<td><strong>SLR(1)</strong></td>
<td>LR(0) automaton + FOLLOW sets for reduce decisions</td>
</tr>
<tr>
<td><strong>LR(1)</strong></td>
<td>Items carry specific lookaheads; most precise</td>
</tr>
<tr>
<td><strong>LALR(1)</strong></td>
<td>Merged LR(1) states; practical sweet spot (Yacc, Bison)</td>
</tr>
<tr>
<td><strong>Precedence</strong></td>
<td>Systematic conflict resolution for operator grammars</td>
</tr>
</tbody>
</table>
<p><strong>Which LR variant to use?</strong></p>
<ul>
<li><strong>SLR(1)</strong>: For simple grammars and educational purposes</li>
<li><strong>LALR(1)</strong>: For most practical parser generators (Yacc, Bison, PLY)</li>
<li><strong>LR(1)</strong>: When LALR(1) has spurious reduce-reduce conflicts</li>
<li><strong>GLR</strong>: For ambiguous grammars or when you need maximum flexibility</li>
</ul>
<hr />
<h2 id="exercises">Exercises<a class="header-link" href="#exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-lr0-automaton-construction">Exercise 1: LR(0) Automaton Construction<a class="header-link" href="#exercise-1-lr0-automaton-construction" title="Permanent link">&para;</a></h3>
<p>Construct the complete LR(0) automaton for the following grammar:</p>
<p>$$
\begin{aligned}
S' &\to S \\
S &\to A\ B \\
A &\to a \\
B &\to b
\end{aligned}
$$</p>
<p>Draw all states with their item sets and label all transitions. How many states does the automaton have?</p>
<h3 id="exercise-2-slr1-table-construction">Exercise 2: SLR(1) Table Construction<a class="header-link" href="#exercise-2-slr1-table-construction" title="Permanent link">&para;</a></h3>
<p>For the augmented grammar:</p>
<p>$$
\begin{aligned}
S' &\to S \\
S &\to C\ C \\
C &\to c\ C \mid d
\end{aligned}
$$</p>
<ol>
<li>Construct the LR(0) automaton.</li>
<li>Compute FIRST and FOLLOW sets.</li>
<li>Build the SLR(1) parsing table.</li>
<li>Trace the parse of the input string <code>c d c d</code>.</li>
</ol>
<h3 id="exercise-3-slr-vs-lr1">Exercise 3: SLR vs LR(1)<a class="header-link" href="#exercise-3-slr-vs-lr1" title="Permanent link">&para;</a></h3>
<p>Consider the grammar:</p>
<p>$$
\begin{aligned}
S &\to L = R \mid R \\
L &\to * R \mid \textbf{id} \\
R &\to L
\end{aligned}
$$</p>
<ol>
<li>Show that this grammar is <strong>not</strong> SLR(1) by constructing the SLR table and identifying the conflict.</li>
<li>Explain why the grammar <strong>is</strong> LR(1) (you may describe the relevant LR(1) items without building the full automaton).</li>
</ol>
<h3 id="exercise-4-ply-parser">Exercise 4: PLY Parser<a class="header-link" href="#exercise-4-ply-parser" title="Permanent link">&para;</a></h3>
<p>Using PLY (or writing an equivalent LALR parser by hand), implement a parser for a simple calculator language that supports:</p>
<ul>
<li>Integer and floating-point numbers</li>
<li>Arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>**</code> (power)</li>
<li>Unary negation: <code>-x</code></li>
<li>Parenthesized expressions</li>
<li>Variable assignment: <code>x = expr</code></li>
<li>Print: <code>print expr</code></li>
</ul>
<p>Define appropriate precedence and associativity for all operators. Test with inputs like <code>x = 2 + 3 * 4</code> and <code>print x ** 2</code>.</p>
<h3 id="exercise-5-conflict-analysis">Exercise 5: Conflict Analysis<a class="header-link" href="#exercise-5-conflict-analysis" title="Permanent link">&para;</a></h3>
<p>For the grammar:</p>
<div class="highlight"><pre><span></span><code><span class="n">stmt</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">THEN</span><span class="w"> </span><span class="n">stmt</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">IF</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">THEN</span><span class="w"> </span><span class="n">stmt</span><span class="w"> </span><span class="n">ELSE</span><span class="w"> </span><span class="n">stmt</span>
<span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">OTHER</span>
<span class="w">     </span><span class="o">;</span>
</code></pre></div>

<ol>
<li>Construct enough of the LALR(1) automaton to identify the shift-reduce conflict.</li>
<li>Explain what the <code>%left</code> or <code>%nonassoc</code> declaration would do if applied to <code>ELSE</code>.</li>
<li>Why is "shift on conflict" the right default for the dangling else?</li>
</ol>
<h3 id="exercise-6-error-recovery">Exercise 6: Error Recovery<a class="header-link" href="#exercise-6-error-recovery" title="Permanent link">&para;</a></h3>
<p>Extend the SLR parser implementation from Section 4.2 to support error recovery using error productions. Add these error rules to the expression grammar:</p>
<div class="highlight"><pre><span></span><code><span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nf">error</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">T</span><span class="w">     </span><span class="c1">// recover from bad left operand</span>
<span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nf">error</span><span class="w">     </span><span class="c1">// recover from bad right operand</span>
<span class="n">F</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="w"> </span><span class="nf">error</span><span class="w"> </span><span class="p">)</span><span class="w">     </span><span class="c1">// recover from bad parenthesized expression</span>
</code></pre></div>

<p>Test with inputs: <code>+ id * id</code>, <code>id + * id</code>, <code>( + ) * id</code>.</p>
<hr />
<p><a href="./05_Top_Down_Parsing.md">Previous: 05_Top_Down_Parsing.md</a> | <a href="./07_Abstract_Syntax_Trees.md">Next: 07_Abstract_Syntax_Trees.md</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/05_Top_Down_Parsing.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 5: Top-Down Parsing</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/07_Abstract_Syntax_Trees.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 7: Abstract Syntax Trees</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}