{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 7: Abstract Syntax Trees - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Lesson 7: Abstract Syntax Trees</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 7: Abstract Syntax Trees</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/06_Bottom_Up_Parsing.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 6: Bottom-Up Parsing</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/08_Semantic_Analysis.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 8: Semantic Analysis</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#learning-objectives">Learning Objectives</a></li>
<li><a href="#1-introduction-why-asts">1. Introduction: Why ASTs?</a><ul>
<li><a href="#11-concrete-syntax-tree-parse-tree">1.1 Concrete Syntax Tree (Parse Tree)</a></li>
<li><a href="#12-abstract-syntax-tree-ast">1.2 Abstract Syntax Tree (AST)</a></li>
<li><a href="#13-cst-vs-ast-comparison">1.3 CST vs AST Comparison</a></li>
<li><a href="#14-the-ast-as-central-data-structure">1.4 The AST as Central Data Structure</a></li>
</ul>
</li>
<li><a href="#2-ast-node-design">2. AST Node Design</a><ul>
<li><a href="#21-algebraic-data-types">2.1 Algebraic Data Types</a></li>
<li><a href="#22-python-dataclasses">2.2 Python Dataclasses</a></li>
<li><a href="#23-design-principles">2.3 Design Principles</a></li>
</ul>
</li>
<li><a href="#3-the-visitor-pattern">3. The Visitor Pattern</a><ul>
<li><a href="#31-motivation">3.1 Motivation</a></li>
<li><a href="#32-classic-visitor-pattern">3.2 Classic Visitor Pattern</a></li>
<li><a href="#33-evaluator-visitor">3.3 Evaluator Visitor</a></li>
<li><a href="#34-statement-visitor-full-interpreter">3.4 Statement Visitor (Full Interpreter)</a></li>
</ul>
</li>
<li><a href="#4-tree-traversal-strategies">4. Tree Traversal Strategies</a><ul>
<li><a href="#41-pre-order-traversal">4.1 Pre-Order Traversal</a></li>
<li><a href="#42-post-order-traversal">4.2 Post-Order Traversal</a></li>
<li><a href="#43-in-order-traversal">4.3 In-Order Traversal</a></li>
<li><a href="#44-generic-tree-walker">4.4 Generic Tree Walker</a></li>
</ul>
</li>
<li><a href="#5-pretty-printing">5. Pretty Printing</a><ul>
<li><a href="#51-what-is-pretty-printing">5.1 What is Pretty Printing?</a></li>
<li><a href="#52-implementation">5.2 Implementation</a></li>
</ul>
</li>
<li><a href="#6-ast-transformations">6. AST Transformations</a><ul>
<li><a href="#61-constant-folding">6.1 Constant Folding</a></li>
<li><a href="#62-desugaring">6.2 Desugaring</a></li>
</ul>
</li>
<li><a href="#7-source-location-tracking">7. Source Location Tracking</a><ul>
<li><a href="#71-why-track-locations">7.1 Why Track Locations?</a></li>
<li><a href="#72-propagating-locations">7.2 Propagating Locations</a></li>
<li><a href="#73-error-reporting-with-locations">7.3 Error Reporting with Locations</a></li>
</ul>
</li>
<li><a href="#8-pattern-matching-on-asts">8. Pattern Matching on ASTs</a><ul>
<li><a href="#81-python-310-structural-pattern-matching">8.1 Python 3.10+ Structural Pattern Matching</a></li>
<li><a href="#82-pre-310-alternative-isinstance-chains">8.2 Pre-3.10 Alternative: isinstance Chains</a></li>
</ul>
</li>
<li><a href="#9-ast-serialization">9. AST Serialization</a><ul>
<li><a href="#91-json-serialization">9.1 JSON Serialization</a></li>
<li><a href="#92-s-expression-serialization">9.2 S-Expression Serialization</a></li>
</ul>
</li>
<li><a href="#10-real-world-ast-examples">10. Real-World AST Examples</a><ul>
<li><a href="#101-pythons-ast-module">10.1 Python's ast Module</a></li>
<li><a href="#102-rusts-syn-crate">10.2 Rust's syn Crate</a></li>
<li><a href="#103-babel-javascript">10.3 Babel (JavaScript)</a></li>
</ul>
</li>
<li><a href="#11-summary">11. Summary</a></li>
<li><a href="#exercises">Exercises</a><ul>
<li><a href="#exercise-1-ast-node-design">Exercise 1: AST Node Design</a></li>
<li><a href="#exercise-2-complete-visitor">Exercise 2: Complete Visitor</a></li>
<li><a href="#exercise-3-pretty-printer-enhancement">Exercise 3: Pretty Printer Enhancement</a></li>
<li><a href="#exercise-4-constant-propagation">Exercise 4: Constant Propagation</a></li>
<li><a href="#exercise-5-ast-diff">Exercise 5: AST Diff</a></li>
<li><a href="#exercise-6-round-trip-test">Exercise 6: Round-Trip Test</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-7-abstract-syntax-trees">Lesson 7: Abstract Syntax Trees<a class="header-link" href="#lesson-7-abstract-syntax-trees" title="Permanent link">&para;</a></h1>
<h2 id="learning-objectives">Learning Objectives<a class="header-link" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<p>After completing this lesson, you will be able to:</p>
<ol>
<li><strong>Distinguish</strong> between concrete syntax trees (parse trees) and abstract syntax trees (ASTs)</li>
<li><strong>Design</strong> AST node types using algebraic data types and Python dataclasses</li>
<li><strong>Implement</strong> the visitor pattern for traversing and transforming ASTs</li>
<li><strong>Apply</strong> multiple tree traversal strategies (pre-order, post-order, in-order)</li>
<li><strong>Build</strong> a pretty printer that reconstructs source code from an AST</li>
<li><strong>Perform</strong> AST transformations such as constant folding and desugaring</li>
<li><strong>Track</strong> source locations in AST nodes for error reporting</li>
<li><strong>Serialize</strong> ASTs to JSON and S-expression formats</li>
</ol>
<hr />
<h2 id="1-introduction-why-asts">1. Introduction: Why ASTs?<a class="header-link" href="#1-introduction-why-asts" title="Permanent link">&para;</a></h2>
<p>When a parser processes source code, it produces a tree representation of the program's structure. There are two kinds of trees we need to distinguish:</p>
<h3 id="11-concrete-syntax-tree-parse-tree">1.1 Concrete Syntax Tree (Parse Tree)<a class="header-link" href="#11-concrete-syntax-tree-parse-tree" title="Permanent link">&para;</a></h3>
<p>A <strong>concrete syntax tree</strong> (CST), also called a <strong>parse tree</strong>, faithfully mirrors the grammar. Every nonterminal and terminal appears as a node, including syntactic noise like parentheses, commas, and keywords that exist only for disambiguation.</p>
<div class="highlight"><pre><span></span><code>Parse tree for &quot;2 + 3 <span class="gs">* 4&quot;:</span>

<span class="gs">            E</span>
<span class="gs">           /|\</span>
<span class="gs">          E  +  T</span>
<span class="gs">          |    /|\</span>
<span class="gs">          T  T  *</span>  F
          |  |     |
          F  F     4
          |  |
          2  3
</code></pre></div>

<h3 id="12-abstract-syntax-tree-ast">1.2 Abstract Syntax Tree (AST)<a class="header-link" href="#12-abstract-syntax-tree-ast" title="Permanent link">&para;</a></h3>
<p>An <strong>abstract syntax tree</strong> strips away all syntactic details and retains only the <strong>essential structure</strong> of the program. Parentheses, operator-precedence scaffolding, and intermediate nonterminals are all gone.</p>
<div class="highlight"><pre><span></span><code>AST for &quot;2 + 3 * 4&quot;:

        Add
       /   \
      2    Mul
          /   \
         3     4
</code></pre></div>

<h3 id="13-cst-vs-ast-comparison">1.3 CST vs AST Comparison<a class="header-link" href="#13-cst-vs-ast-comparison" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Concrete Syntax Tree</th>
<th>Abstract Syntax Tree</th>
</tr>
</thead>
<tbody>
<tr>
<td>Structure</td>
<td>Mirrors grammar exactly</td>
<td>Captures semantic structure</td>
</tr>
<tr>
<td>Nodes</td>
<td>One per grammar symbol</td>
<td>One per meaningful construct</td>
</tr>
<tr>
<td>Parentheses</td>
<td>Explicitly represented</td>
<td>Implicit in tree structure</td>
</tr>
<tr>
<td>Precedence</td>
<td>Encoded via nonterminals ($E$, $T$, $F$)</td>
<td>Encoded by tree depth</td>
</tr>
<tr>
<td>Size</td>
<td>Larger (many internal nodes)</td>
<td>Smaller (only essential nodes)</td>
</tr>
<tr>
<td>Use cases</td>
<td>Parsing theory, CST-based tools</td>
<td>Compilers, interpreters, linters</td>
</tr>
</tbody>
</table>
<h3 id="14-the-ast-as-central-data-structure">1.4 The AST as Central Data Structure<a class="header-link" href="#14-the-ast-as-central-data-structure" title="Permanent link">&para;</a></h3>
<p>The AST is the <strong>lingua franca</strong> of compiler internals. Nearly every subsequent phase operates on it:</p>
<div class="highlight"><pre><span></span><code><span class="nx">Source</span><span class="w"> </span><span class="nx">Code</span>
<span class="w">    </span><span class="err">‚îÇ</span>
<span class="w">    </span><span class="err">‚ñº</span>
<span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="err">‚îÇ</span><span class="w">  </span><span class="nx">Lexer</span><span class="w">  </span><span class="err">‚îÇ</span>
<span class="err">‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>
<span class="w">     </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">tokens</span>
<span class="w">     </span><span class="err">‚ñº</span>
<span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Parser</span><span class="w">  </span><span class="err">‚îÇ</span>
<span class="err">‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>
<span class="w">     </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">AST</span><span class="w">                    </span><span class="err">‚óÑ‚îÄ‚îÄ</span><span class="w"> </span><span class="nx">We</span><span class="w"> </span><span class="nx">are</span><span class="w"> </span><span class="nx">here</span>
<span class="w">     </span><span class="err">‚ñº</span>
<span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Semantic</span><span class="w">     </span><span class="err">‚îÇ</span><span class="w"> </span><span class="err">‚îÄ‚îÄ‚ñ∂</span><span class="w"> </span><span class="nx">annotated</span><span class="w"> </span><span class="nx">AST</span><span class="w"> </span><span class="p">(</span><span class="nx">types</span><span class="p">,</span><span class="w"> </span><span class="nx">scopes</span><span class="p">)</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Analysis</span><span class="w">     </span><span class="err">‚îÇ</span>
<span class="err">‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>
<span class="w">       </span><span class="err">‚îÇ</span>
<span class="w">       </span><span class="err">‚ñº</span>
<span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">IR</span><span class="w">           </span><span class="err">‚îÇ</span><span class="w"> </span><span class="err">‚îÄ‚îÄ‚ñ∂</span><span class="w"> </span><span class="nx">intermediate</span><span class="w"> </span><span class="nx">representation</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Generation</span><span class="w">   </span><span class="err">‚îÇ</span>
<span class="err">‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>
<span class="w">       </span><span class="err">‚îÇ</span>
<span class="w">       </span><span class="err">‚ñº</span>
<span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Optimization</span><span class="w"> </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nx">Code</span><span class="w"> </span><span class="nx">Gen</span><span class="w">   </span><span class="err">‚îÇ</span>
<span class="err">‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>
</code></pre></div>

<hr />
<h2 id="2-ast-node-design">2. AST Node Design<a class="header-link" href="#2-ast-node-design" title="Permanent link">&para;</a></h2>
<h3 id="21-algebraic-data-types">2.1 Algebraic Data Types<a class="header-link" href="#21-algebraic-data-types" title="Permanent link">&para;</a></h3>
<p>In languages with algebraic data types (Haskell, OCaml, Rust), ASTs are naturally expressed as sum types (tagged unions):</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- Haskell example</span>
<span class="kr">data</span><span class="w"> </span><span class="kt">Expr</span>
<span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="kt">IntLit</span><span class="w"> </span><span class="kt">Int</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="kt">BoolLit</span><span class="w"> </span><span class="kt">Bool</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="kt">Var</span><span class="w"> </span><span class="kt">String</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="kt">BinOp</span><span class="w"> </span><span class="kt">Op</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="kt">Expr</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="kt">UnaryOp</span><span class="w"> </span><span class="kt">Op</span><span class="w"> </span><span class="kt">Expr</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="kt">Call</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="p">[</span><span class="kt">Expr</span><span class="p">]</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="kt">IfExpr</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="kt">Expr</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Op</span><span class="w"> </span><span class="ow">=</span><span class="w"> </span><span class="kt">Add</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Sub</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Mul</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Div</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Eq</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Lt</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">And</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="kt">Or</span>

<span class="kr">data</span><span class="w"> </span><span class="kt">Stmt</span>
<span class="w">    </span><span class="ow">=</span><span class="w"> </span><span class="kt">ExprStmt</span><span class="w"> </span><span class="kt">Expr</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="kt">LetStmt</span><span class="w"> </span><span class="kt">String</span><span class="w"> </span><span class="kt">Expr</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="kt">ReturnStmt</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Expr</span><span class="p">)</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="kt">Block</span><span class="w"> </span><span class="p">[</span><span class="kt">Stmt</span><span class="p">]</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="kt">WhileStmt</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="kt">Stmt</span>
<span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="kt">IfStmt</span><span class="w"> </span><span class="kt">Expr</span><span class="w"> </span><span class="kt">Stmt</span><span class="w"> </span><span class="p">(</span><span class="kt">Maybe</span><span class="w"> </span><span class="kt">Stmt</span><span class="p">)</span>
</code></pre></div>

<h3 id="22-python-dataclasses">2.2 Python Dataclasses<a class="header-link" href="#22-python-dataclasses" title="Permanent link">&para;</a></h3>
<p>Python does not have native algebraic data types, but we can achieve a similar design using <code>dataclasses</code> and inheritance. This is the approach used by CPython's own <code>ast</code> module.</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">AST Node Definitions Using Python Dataclasses</span>

<span class="sd">This module defines a complete AST for a small imperative language</span>
<span class="sd">with expressions, statements, and a simple type system.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Source Location Tracking ‚îÄ‚îÄ‚îÄ</span>

<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SourceLocation</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Tracks where in the source code a construct appears.&quot;&quot;&quot;</span>
    <span class="n">line</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">column</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">end_line</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">end_column</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">filename</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&lt;unknown&gt;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">end_line</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;-</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">end_line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">end_column</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">column</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Base AST Node ‚îÄ‚îÄ‚îÄ</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ASTNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for all AST nodes.&quot;&quot;&quot;</span>
    <span class="n">loc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SourceLocation</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">repr</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compare</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Operators ‚îÄ‚îÄ‚îÄ</span>

<span class="k">class</span><span class="w"> </span><span class="nc">BinOpKind</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">ADD</span> <span class="o">=</span> <span class="s2">&quot;+&quot;</span>
    <span class="n">SUB</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
    <span class="n">MUL</span> <span class="o">=</span> <span class="s2">&quot;*&quot;</span>
    <span class="n">DIV</span> <span class="o">=</span> <span class="s2">&quot;/&quot;</span>
    <span class="n">MOD</span> <span class="o">=</span> <span class="s2">&quot;%&quot;</span>
    <span class="n">POW</span> <span class="o">=</span> <span class="s2">&quot;**&quot;</span>
    <span class="n">EQ</span> <span class="o">=</span> <span class="s2">&quot;==&quot;</span>
    <span class="n">NE</span> <span class="o">=</span> <span class="s2">&quot;!=&quot;</span>
    <span class="n">LT</span> <span class="o">=</span> <span class="s2">&quot;&lt;&quot;</span>
    <span class="n">GT</span> <span class="o">=</span> <span class="s2">&quot;&gt;&quot;</span>
    <span class="n">LE</span> <span class="o">=</span> <span class="s2">&quot;&lt;=&quot;</span>
    <span class="n">GE</span> <span class="o">=</span> <span class="s2">&quot;&gt;=&quot;</span>
    <span class="n">AND</span> <span class="o">=</span> <span class="s2">&quot;and&quot;</span>
    <span class="n">OR</span> <span class="o">=</span> <span class="s2">&quot;or&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">UnaryOpKind</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">NEG</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
    <span class="n">NOT</span> <span class="o">=</span> <span class="s2">&quot;not&quot;</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Type Annotations ‚îÄ‚îÄ‚îÄ</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TypeAnnotation</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for type annotations in the AST.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SimpleType</span><span class="p">(</span><span class="n">TypeAnnotation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple named type: int, float, bool, str.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ListType</span><span class="p">(</span><span class="n">TypeAnnotation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A list type: list[T].&quot;&quot;&quot;</span>
    <span class="n">element_type</span><span class="p">:</span> <span class="n">TypeAnnotation</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FuncType</span><span class="p">(</span><span class="n">TypeAnnotation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A function type: (T1, T2) -&gt; R.&quot;&quot;&quot;</span>
    <span class="n">param_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TypeAnnotation</span><span class="p">]</span>
    <span class="n">return_type</span><span class="p">:</span> <span class="n">TypeAnnotation</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">OptionalType</span><span class="p">(</span><span class="n">TypeAnnotation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An optional type: T?.&quot;&quot;&quot;</span>
    <span class="n">inner_type</span><span class="p">:</span> <span class="n">TypeAnnotation</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Expressions ‚îÄ‚îÄ‚îÄ</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Expr</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for all expression nodes.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">IntLiteral</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Integer literal: 42.&quot;&quot;&quot;</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FloatLiteral</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Floating-point literal: 3.14.&quot;&quot;&quot;</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">float</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BoolLiteral</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Boolean literal: true, false.&quot;&quot;&quot;</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">StringLiteral</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;String literal: &quot;hello&quot;.&quot;&quot;&quot;</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NilLiteral</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Nil/null literal.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Identifier</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Variable reference: x, foo.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BinaryExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Binary operation: a + b, x == y.&quot;&quot;&quot;</span>
    <span class="n">op</span><span class="p">:</span> <span class="n">BinOpKind</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">Expr</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">UnaryExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Unary operation: -x, not y.&quot;&quot;&quot;</span>
    <span class="n">op</span><span class="p">:</span> <span class="n">UnaryOpKind</span>
    <span class="n">operand</span><span class="p">:</span> <span class="n">Expr</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CallExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function call: f(a, b, c).&quot;&quot;&quot;</span>
    <span class="n">callee</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">arguments</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expr</span><span class="p">]</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">IndexExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Indexing: a[i].&quot;&quot;&quot;</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">index</span><span class="p">:</span> <span class="n">Expr</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MemberExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Member access: a.b.&quot;&quot;&quot;</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">member</span><span class="p">:</span> <span class="nb">str</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">IfExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Conditional expression: if cond then a else b.&quot;&quot;&quot;</span>
    <span class="n">condition</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">then_expr</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">else_expr</span><span class="p">:</span> <span class="n">Expr</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ListExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;List literal: [1, 2, 3].&quot;&quot;&quot;</span>
    <span class="n">elements</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Expr</span><span class="p">]</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">LambdaExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Lambda expression: fn(x, y) =&gt; x + y.&quot;&quot;&quot;</span>
    <span class="n">params</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Parameter</span><span class="p">]</span>
    <span class="n">body</span><span class="p">:</span> <span class="n">Expr</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Statements ‚îÄ‚îÄ‚îÄ</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Stmt</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for all statement nodes.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Parameter</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function parameter with optional type annotation.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">type_ann</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TypeAnnotation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ExprStmt</span><span class="p">(</span><span class="n">Stmt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Expression used as a statement: f(x);.&quot;&quot;&quot;</span>
    <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">LetStmt</span><span class="p">(</span><span class="n">Stmt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Variable declaration: let x: int = 42;.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">type_ann</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TypeAnnotation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">initializer</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AssignStmt</span><span class="p">(</span><span class="n">Stmt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assignment: x = expr;.&quot;&quot;&quot;</span>
    <span class="n">target</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Expr</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ReturnStmt</span><span class="p">(</span><span class="n">Stmt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return statement: return expr;.&quot;&quot;&quot;</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Expr</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">IfStmt</span><span class="p">(</span><span class="n">Stmt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;If statement: if (cond) { ... } else { ... }.&quot;&quot;&quot;</span>
    <span class="n">condition</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">then_body</span><span class="p">:</span> <span class="n">Block</span>
    <span class="n">else_body</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Block</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">WhileStmt</span><span class="p">(</span><span class="n">Stmt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;While loop: while (cond) { ... }.&quot;&quot;&quot;</span>
    <span class="n">condition</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">body</span><span class="p">:</span> <span class="n">Block</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ForStmt</span><span class="p">(</span><span class="n">Stmt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;For loop: for (x in collection) { ... }.&quot;&quot;&quot;</span>
    <span class="n">var_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">iterable</span><span class="p">:</span> <span class="n">Expr</span>
    <span class="n">body</span><span class="p">:</span> <span class="n">Block</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Block</span><span class="p">(</span><span class="n">Stmt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Block of statements: { stmt1; stmt2; ... }.&quot;&quot;&quot;</span>
    <span class="n">statements</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Stmt</span><span class="p">]</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FuncDecl</span><span class="p">(</span><span class="n">Stmt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function declaration: fn name(params) -&gt; RetType { body }.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">params</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Parameter</span><span class="p">]</span>
    <span class="n">return_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TypeAnnotation</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">body</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Block</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PrintStmt</span><span class="p">(</span><span class="n">Stmt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print statement: print(expr);.&quot;&quot;&quot;</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Expr</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Program ‚îÄ‚îÄ‚îÄ</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Program</span><span class="p">(</span><span class="n">ASTNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;The top-level AST node representing an entire program.&quot;&quot;&quot;</span>
    <span class="n">statements</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Stmt</span><span class="p">]</span>
</code></pre></div>

<h3 id="23-design-principles">2.3 Design Principles<a class="header-link" href="#23-design-principles" title="Permanent link">&para;</a></h3>
<p><strong>1. Favor immutability.</strong> AST nodes should be treated as immutable after construction. Transformations create new nodes rather than modifying existing ones.</p>
<p><strong>2. Separate expressions and statements.</strong> Even though some languages blur the line (Rust, Kotlin), keeping them separate in the AST simplifies analysis.</p>
<p><strong>3. Include source locations.</strong> Every node should carry the source position for error reporting. Using <code>field(default=None, repr=False, compare=False)</code> keeps the location from cluttering output and comparisons.</p>
<p><strong>4. Use enums for finite choices.</strong> Operators, type kinds, and other finite sets should be enums, not strings. This prevents typos and enables exhaustive matching.</p>
<p><strong>5. Keep it minimal.</strong> The AST should not include syntactic sugar. Desugar during parsing or in a separate pass:</p>
<table>
<thead>
<tr>
<th>Source Syntax</th>
<th>Desugared AST</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>x += 5</code></td>
<td><code>AssignStmt(x, BinaryExpr(ADD, x, 5))</code></td>
</tr>
<tr>
<td><code>for x in range(10)</code></td>
<td><code>WhileStmt(...)</code> (or keep ForStmt if semantically distinct)</td>
</tr>
<tr>
<td><code>a?.b</code></td>
<td><code>IfExpr(a != nil, a.b, nil)</code></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="3-the-visitor-pattern">3. The Visitor Pattern<a class="header-link" href="#3-the-visitor-pattern" title="Permanent link">&para;</a></h2>
<h3 id="31-motivation">3.1 Motivation<a class="header-link" href="#31-motivation" title="Permanent link">&para;</a></h3>
<p>Once we have an AST, we need to traverse it for various purposes: type checking, code generation, pretty printing, optimization, and more. The <strong>visitor pattern</strong> separates the traversal logic from the AST node definitions, allowing us to add new operations without modifying the AST classes.</p>
<h3 id="32-classic-visitor-pattern">3.2 Classic Visitor Pattern<a class="header-link" href="#32-classic-visitor-pattern" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Visitor Pattern for AST Traversal</span>

<span class="sd">The visitor pattern allows defining new operations on the AST</span>
<span class="sd">without modifying the node classes. Each visitor class implements</span>
<span class="sd">a visit method for each node type.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Generic</span>

<span class="n">T</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ASTVisitor</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base visitor class.</span>

<span class="sd">    For each AST node type, define a visit_&lt;NodeType&gt; method.</span>
<span class="sd">    The generic dispatch method routes based on the node&#39;s class name.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dispatch to the appropriate visit method.&quot;&quot;&quot;</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;visit_</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">visitor_method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">visitor_method</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generic_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called when no specific visitor method exists.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;No visit_</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> method defined &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;in </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ExprVisitor</span><span class="p">(</span><span class="n">Generic</span><span class="p">[</span><span class="n">T</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Visitor specialized for expression nodes.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;visit_</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">visitor_method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">visitor_method</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generic_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;No visit_</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> method&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_IntLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_FloatLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">FloatLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_BoolLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BoolLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_StringLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">StringLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_BinaryExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BinaryExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_UnaryExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">UnaryExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_CallExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">CallExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_IfExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IfExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">T</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</code></pre></div>

<h3 id="33-evaluator-visitor">3.3 Evaluator Visitor<a class="header-link" href="#33-evaluator-visitor" title="Permanent link">&para;</a></h3>
<p>A simple interpreter that evaluates expressions by visiting nodes:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Evaluator</span><span class="p">(</span><span class="n">ExprVisitor</span><span class="p">[</span><span class="nb">object</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Evaluates expression ASTs to produce values.</span>

<span class="sd">    This is the simplest useful visitor: a tree-walking interpreter.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">environment</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_IntLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_FloatLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">FloatLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_BoolLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BoolLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_StringLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">StringLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">environment</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Undefined variable: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">environment</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_BinaryExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BinaryExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">SUB</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">DIV</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MOD</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">POW</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">**</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">EQ</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">NE</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LT</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GT</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LE</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GE</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">AND</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">OR</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="ow">or</span> <span class="n">b</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="n">op_func</span> <span class="o">=</span> <span class="n">ops</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">op_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown operator: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">op_func</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_UnaryExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">UnaryExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
        <span class="n">operand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NEG</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">operand</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NOT</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">operand</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown unary operator: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_IfExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IfExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">then_expr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">else_expr</span><span class="p">)</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Demo ‚îÄ‚îÄ‚îÄ</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Build AST for: (2 + 3) * 4</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">BinaryExpr</span><span class="p">(</span>
        <span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span>
        <span class="n">left</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
            <span class="n">left</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
            <span class="n">right</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">right</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">evaluator</span> <span class="o">=</span> <span class="n">Evaluator</span><span class="p">()</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(2 + 3) * 4 = </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Output: 20</span>

    <span class="c1"># Build AST for: if 3 &gt; 2 then 10 else 20</span>
    <span class="n">ast2</span> <span class="o">=</span> <span class="n">IfExpr</span><span class="p">(</span>
        <span class="n">condition</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
            <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span>
            <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">then_expr</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
        <span class="n">else_expr</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">result2</span> <span class="o">=</span> <span class="n">evaluator</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">ast2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;if 3 &gt; 2 then 10 else 20 = </span><span class="si">{</span><span class="n">result2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Output: 10</span>
</code></pre></div>

<h3 id="34-statement-visitor-full-interpreter">3.4 Statement Visitor (Full Interpreter)<a class="header-link" href="#34-statement-visitor-full-interpreter" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Interpreter</span><span class="p">(</span><span class="n">ASTVisitor</span><span class="p">[</span><span class="kc">None</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A tree-walking interpreter that executes statement ASTs.</span>

<span class="sd">    Handles variable declarations, assignments, control flow,</span>
<span class="sd">    and function calls.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">object</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr_eval</span> <span class="o">=</span> <span class="n">Evaluator</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expr_eval</span><span class="o">.</span><span class="n">environment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">FuncDecl</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">eval_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">expr_eval</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Program</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Program</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">statements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Block</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">statements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_ExprStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ExprStmt</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_LetStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">LetStmt</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">initializer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">initializer</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_AssignStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">AssignStmt</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Can only assign to identifiers&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_PrintStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">PrintStmt</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_IfStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IfStmt</span><span class="p">):</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">then_body</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">else_body</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">else_body</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_WhileStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">WhileStmt</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">eval_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_FuncDecl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">FuncDecl</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Demo ‚îÄ‚îÄ‚îÄ</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Build AST for:</span>
    <span class="c1">#   let x = 10;</span>
    <span class="c1">#   let y = 20;</span>
    <span class="c1">#   if (x &lt; y) { print(x + y); } else { print(0); }</span>
    <span class="n">program</span> <span class="o">=</span> <span class="n">Program</span><span class="p">(</span><span class="n">statements</span><span class="o">=</span><span class="p">[</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">20</span><span class="p">)),</span>
        <span class="n">IfStmt</span><span class="p">(</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span>
                <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LT</span><span class="p">,</span>
                <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span>
                <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="n">then_body</span><span class="o">=</span><span class="n">Block</span><span class="p">([</span>
                <span class="n">PrintStmt</span><span class="p">(</span><span class="n">BinaryExpr</span><span class="p">(</span>
                    <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
                    <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span>
                    <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">),</span>
                <span class="p">))</span>
            <span class="p">]),</span>
            <span class="n">else_body</span><span class="o">=</span><span class="n">Block</span><span class="p">([</span>
                <span class="n">PrintStmt</span><span class="p">(</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
            <span class="p">]),</span>
        <span class="p">),</span>
    <span class="p">])</span>

    <span class="n">interpreter</span> <span class="o">=</span> <span class="n">Interpreter</span><span class="p">()</span>
    <span class="n">interpreter</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="c1"># Output: 30</span>
</code></pre></div>

<hr />
<h2 id="4-tree-traversal-strategies">4. Tree Traversal Strategies<a class="header-link" href="#4-tree-traversal-strategies" title="Permanent link">&para;</a></h2>
<h3 id="41-pre-order-traversal">4.1 Pre-Order Traversal<a class="header-link" href="#41-pre-order-traversal" title="Permanent link">&para;</a></h3>
<p>Visit the node <strong>before</strong> its children. Used for: printing, serialization, tree copying.</p>
<p>$$\text{visit}(n) = \text{process}(n); \quad \text{visit}(n.\text{child}_1); \quad \text{visit}(n.\text{child}_2); \quad \ldots$$</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">preorder</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">,</span> <span class="n">depth</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pre-order traversal: visit node, then children.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">*</span> <span class="n">depth</span> <span class="o">+</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">UnaryExpr</span><span class="p">):</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">CallExpr</span><span class="p">):</span>
        <span class="n">preorder</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">callee</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">arguments</span><span class="p">:</span>
            <span class="n">preorder</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Block</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">statements</span><span class="p">:</span>
            <span class="n">preorder</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="c1"># ... other node types</span>
</code></pre></div>

<h3 id="42-post-order-traversal">4.2 Post-Order Traversal<a class="header-link" href="#42-post-order-traversal" title="Permanent link">&para;</a></h3>
<p>Visit children <strong>before</strong> the node. Used for: evaluation, code generation, computing synthesized attributes.</p>
<p>$$\text{visit}(n) = \text{visit}(n.\text{child}_1); \quad \text{visit}(n.\text{child}_2); \quad \ldots; \quad \text{process}(n)$$</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">postorder_eval</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Post-order evaluation: evaluate children, then compute node.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
        <span class="c1"># Evaluate children first (post-order)</span>
        <span class="n">left_val</span> <span class="o">=</span> <span class="n">postorder_eval</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_val</span> <span class="o">=</span> <span class="n">postorder_eval</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="c1"># Then process this node</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left_val</span> <span class="o">+</span> <span class="n">right_val</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">left_val</span> <span class="o">*</span> <span class="n">right_val</span>
        <span class="c1"># ... other operators</span>
    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot evaluate: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="43-in-order-traversal">4.3 In-Order Traversal<a class="header-link" href="#43-in-order-traversal" title="Permanent link">&para;</a></h3>
<p>Visit left child, then node, then right child. Primarily used for: printing infix expressions, binary search trees.</p>
<p>$$\text{visit}(n) = \text{visit}(n.\text{left}); \quad \text{process}(n); \quad \text{visit}(n.\text{right})$$</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">inorder_print</span><span class="p">(</span><span class="n">node</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">needs_parens</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;In-order traversal to produce infix notation.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
        <span class="n">left_str</span> <span class="o">=</span> <span class="n">inorder_print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">right_str</span> <span class="o">=</span> <span class="n">inorder_print</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">left_str</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">right_str</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">needs_parens</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">return</span> <span class="n">result</span>
    <span class="k">return</span> <span class="s2">&quot;?&quot;</span>
</code></pre></div>

<h3 id="44-generic-tree-walker">4.4 Generic Tree Walker<a class="header-link" href="#44-generic-tree-walker" title="Permanent link">&para;</a></h3>
<p>A reusable walker that visits all children of any AST node:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TreeWalker</span><span class="p">(</span><span class="n">ASTVisitor</span><span class="p">[</span><span class="kc">None</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generic walker that visits all children of every node.</span>

<span class="sd">    Override specific visit methods to add behavior.</span>
<span class="sd">    Default behavior: just recurse into children.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generic_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Visit all children by inspecting dataclass fields.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">is_dataclass</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">fields</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;loc&quot;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ASTNode</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">ASTNode</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">VariableCollector</span><span class="p">(</span><span class="n">TreeWalker</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Collects all variable names referenced in the AST.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span> <span class="nb">set</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>


<span class="c1"># Usage:</span>
<span class="c1"># collector = VariableCollector()</span>
<span class="c1"># collector.visit(program_ast)</span>
<span class="c1"># print(collector.variables)  # {&#39;x&#39;, &#39;y&#39;, &#39;z&#39;, ...}</span>
</code></pre></div>

<hr />
<h2 id="5-pretty-printing">5. Pretty Printing<a class="header-link" href="#5-pretty-printing" title="Permanent link">&para;</a></h2>
<h3 id="51-what-is-pretty-printing">5.1 What is Pretty Printing?<a class="header-link" href="#51-what-is-pretty-printing" title="Permanent link">&para;</a></h3>
<p><strong>Pretty printing</strong> converts an AST back into human-readable source code. It is the inverse of parsing. A good pretty printer:</p>
<ul>
<li>Produces syntactically valid output</li>
<li>Handles indentation consistently</li>
<li>Minimizes unnecessary parentheses</li>
<li>Preserves the program's semantics</li>
</ul>
<h3 id="52-implementation">5.2 Implementation<a class="header-link" href="#52-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">AST Pretty Printer</span>

<span class="sd">Converts AST nodes back into readable source code.</span>
<span class="sd">Handles indentation, operator precedence (for minimal parentheses),</span>
<span class="sd">and multi-line formatting.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">PrettyPrinter</span><span class="p">(</span><span class="n">ASTVisitor</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pretty-prints AST nodes to source code strings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indent_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;    &quot;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indent_str</span> <span class="o">=</span> <span class="n">indent_str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indent_level</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">indent</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent_str</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">indent_level</span>

    <span class="c1"># ‚îÄ‚îÄ‚îÄ Operator precedence for minimal parentheses ‚îÄ‚îÄ‚îÄ</span>

    <span class="n">PRECEDENCE</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">OR</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">AND</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">EQ</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">NE</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LT</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GT</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LE</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GE</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">SUB</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">DIV</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MOD</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">POW</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_expr_precedence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">PRECEDENCE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">100</span>  <span class="c1"># literals, identifiers, calls: never need parens</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_paren_if_needed</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">child</span><span class="p">:</span> <span class="n">Expr</span><span class="p">,</span> <span class="n">parent_prec</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">is_right</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add parentheses if child has lower precedence than parent.&quot;&quot;&quot;</span>
        <span class="n">child_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>
        <span class="n">child_prec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_expr_precedence</span><span class="p">(</span><span class="n">child</span><span class="p">)</span>

        <span class="n">needs_parens</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">child_prec</span> <span class="o">&lt;</span> <span class="n">parent_prec</span><span class="p">:</span>
            <span class="n">needs_parens</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">child_prec</span> <span class="o">==</span> <span class="n">parent_prec</span> <span class="ow">and</span> <span class="n">is_right</span><span class="p">:</span>
            <span class="c1"># For left-associative operators, right child at same</span>
            <span class="c1"># precedence needs parens: a - (b - c)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">child</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="n">BinOpKind</span><span class="o">.</span><span class="n">SUB</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">DIV</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MOD</span>
            <span class="p">):</span>
                <span class="n">needs_parens</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">child_str</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">if</span> <span class="n">needs_parens</span> <span class="k">else</span> <span class="n">child_str</span>

    <span class="c1"># ‚îÄ‚îÄ‚îÄ Expressions ‚îÄ‚îÄ‚îÄ</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_IntLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_FloatLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">FloatLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_BoolLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BoolLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;true&quot;</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="k">else</span> <span class="s2">&quot;false&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_StringLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">StringLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="c1"># Escape special characters</span>
        <span class="n">escaped</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">value</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\\\</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\\</span><span class="s1">&quot;&#39;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">t&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">escaped</span><span class="si">}</span><span class="s1">&quot;&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_NilLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">NilLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;nil&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_BinaryExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BinaryExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">prec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">PRECEDENCE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">left_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paren_if_needed</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">prec</span><span class="p">)</span>
        <span class="n">right_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_paren_if_needed</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">prec</span><span class="p">,</span> <span class="n">is_right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">left_str</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">right_str</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_UnaryExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">UnaryExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">operand_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NEG</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;-(</span><span class="si">{</span><span class="n">operand_str</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;-</span><span class="si">{</span><span class="n">operand_str</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NOT</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;not </span><span class="si">{</span><span class="n">operand_str</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}{</span><span class="n">operand_str</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_CallExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">CallExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">callee_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">callee</span><span class="p">)</span>
        <span class="n">args_str</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">callee_str</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">args_str</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_IndexExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IndexExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">obj_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">idx_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obj_str</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="n">idx_str</span><span class="si">}</span><span class="s2">]&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_MemberExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">MemberExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">obj_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obj_str</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">member</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_IfExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IfExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="n">then</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">then_expr</span><span class="p">)</span>
        <span class="n">els</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">else_expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;if </span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2"> then </span><span class="si">{</span><span class="n">then</span><span class="si">}</span><span class="s2"> else </span><span class="si">{</span><span class="n">els</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_ListExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ListExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">elems</span><span class="si">}</span><span class="s2">]&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_LambdaExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">LambdaExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_format_param</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;fn(</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">) =&gt; </span><span class="si">{</span><span class="n">body</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># ‚îÄ‚îÄ‚îÄ Statements ‚îÄ‚îÄ‚îÄ</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Program</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Program</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span> <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">statements</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Block</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">statements</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="se">{{}}</span><span class="s2">&quot;</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="se">{{</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indent_level</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">statements</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">stmt</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">indent_level</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_ExprStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ExprStmt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span><span class="si">}</span><span class="s2">;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_LetStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">LetStmt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="s2">let </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">type_ann</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">type_ann</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">initializer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot; = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">initializer</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_AssignStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">AssignStmt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}{</span><span class="n">target</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_ReturnStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ReturnStmt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="s2">return </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="s2">return;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_IfStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IfStmt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="n">then_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">then_body</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="s2">if (</span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="n">then_str</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">else_body</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">else_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">else_body</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; else </span><span class="si">{</span><span class="n">else_str</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_WhileStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">WhileStmt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="s2">while (</span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="n">body</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_ForStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ForStmt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">iterable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">iterable</span><span class="p">)</span>
        <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="s2">for (</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">var_name</span><span class="si">}</span><span class="s2"> in </span><span class="si">{</span><span class="n">iterable</span><span class="si">}</span><span class="s2">) &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">body</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_FuncDecl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">FuncDecl</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_format_param</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">return_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="s2">fn </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="n">ret</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">body</span><span class="o">.</span><span class="n">lstrip</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="s2">fn </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">)</span><span class="si">{</span><span class="n">ret</span><span class="si">}</span><span class="s2">;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_PrintStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">PrintStmt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">indent</span><span class="si">}</span><span class="s2">print(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">);&quot;</span>

    <span class="c1"># ‚îÄ‚îÄ‚îÄ Types ‚îÄ‚îÄ‚îÄ</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_SimpleType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">SimpleType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_ListType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ListType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">inner</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">element_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;list[</span><span class="si">{</span><span class="n">inner</span><span class="si">}</span><span class="s2">]&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_FuncType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">FuncType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">params</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="n">ret</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_OptionalType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">OptionalType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">inner_type</span><span class="p">)</span><span class="si">}</span><span class="s2">?&quot;</span>

    <span class="c1"># ‚îÄ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ‚îÄ</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_format_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="n">Parameter</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">type_ann</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">type_ann</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Demo ‚îÄ‚îÄ‚îÄ</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">program</span> <span class="o">=</span> <span class="n">Program</span><span class="p">(</span><span class="n">statements</span><span class="o">=</span><span class="p">[</span>
        <span class="n">FuncDecl</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;factorial&quot;</span><span class="p">,</span>
            <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))],</span>
            <span class="n">return_type</span><span class="o">=</span><span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">),</span>
            <span class="n">body</span><span class="o">=</span><span class="n">Block</span><span class="p">([</span>
                <span class="n">IfStmt</span><span class="p">(</span>
                    <span class="n">condition</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span>
                        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LE</span><span class="p">,</span>
                        <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">),</span>
                        <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                    <span class="p">),</span>
                    <span class="n">then_body</span><span class="o">=</span><span class="n">Block</span><span class="p">([</span><span class="n">ReturnStmt</span><span class="p">(</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">1</span><span class="p">))]),</span>
                    <span class="n">else_body</span><span class="o">=</span><span class="n">Block</span><span class="p">([</span>
                        <span class="n">ReturnStmt</span><span class="p">(</span><span class="n">BinaryExpr</span><span class="p">(</span>
                            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span>
                            <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">),</span>
                            <span class="n">CallExpr</span><span class="p">(</span>
                                <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;factorial&quot;</span><span class="p">),</span>
                                <span class="p">[</span><span class="n">BinaryExpr</span><span class="p">(</span>
                                    <span class="n">BinOpKind</span><span class="o">.</span><span class="n">SUB</span><span class="p">,</span>
                                    <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">),</span>
                                    <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                                <span class="p">)],</span>
                            <span class="p">),</span>
                        <span class="p">))</span>
                    <span class="p">]),</span>
                <span class="p">),</span>
            <span class="p">]),</span>
        <span class="p">),</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">),</span>
                <span class="n">CallExpr</span><span class="p">(</span><span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;factorial&quot;</span><span class="p">),</span> <span class="p">[</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">5</span><span class="p">)])),</span>
        <span class="n">PrintStmt</span><span class="p">(</span><span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">)),</span>
    <span class="p">])</span>

    <span class="n">printer</span> <span class="o">=</span> <span class="n">PrettyPrinter</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">printer</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">program</span><span class="p">))</span>
</code></pre></div>

<p><strong>Output:</strong></p>
<div class="highlight"><pre><span></span><code><span class="nt">fn</span><span class="w"> </span><span class="nt">factorial</span><span class="o">(</span><span class="nt">n</span><span class="o">:</span><span class="w"> </span><span class="nt">int</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">if</span><span class="w"> </span><span class="err">(n</span><span class="w"> </span><span class="err">&lt;=</span><span class="w"> </span><span class="err">1)</span><span class="w"> </span><span class="err">{</span>
<span class="w">        </span><span class="err">return</span><span class="w"> </span><span class="err">1</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w"> </span><span class="nt">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="err">return</span><span class="w"> </span><span class="err">n</span><span class="w"> </span><span class="err">*</span><span class="w"> </span><span class="err">factorial(n</span><span class="w"> </span><span class="err">-</span><span class="w"> </span><span class="err">1)</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="err">}</span>
<span class="nt">let</span><span class="w"> </span><span class="nt">result</span><span class="o">:</span><span class="w"> </span><span class="nt">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">factorial</span><span class="o">(</span><span class="nt">5</span><span class="o">);</span>
<span class="nt">print</span><span class="o">(</span><span class="nt">result</span><span class="o">);</span>
</code></pre></div>

<hr />
<h2 id="6-ast-transformations">6. AST Transformations<a class="header-link" href="#6-ast-transformations" title="Permanent link">&para;</a></h2>
<h3 id="61-constant-folding">6.1 Constant Folding<a class="header-link" href="#61-constant-folding" title="Permanent link">&para;</a></h3>
<p><strong>Constant folding</strong> evaluates expressions with known values at compile time:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ConstantFolder</span><span class="p">(</span><span class="n">ASTVisitor</span><span class="p">[</span><span class="n">ASTNode</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constant folding: evaluate constant expressions at compile time.</span>

<span class="sd">    Examples:</span>
<span class="sd">        2 + 3       =&gt;  5</span>
<span class="sd">        4 * 1       =&gt;  4 (identity)</span>
<span class="sd">        0 * x       =&gt;  0 (zero multiplication)</span>
<span class="sd">        x + 0       =&gt;  x (identity)</span>
<span class="sd">        true and x  =&gt;  x (short-circuit simplification)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_IntLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_FloatLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">FloatLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_BoolLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BoolLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_StringLiteral</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">StringLiteral</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_Identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">node</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_BinaryExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">BinaryExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="c1"># Both operands are integer literals: compute at compile time</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_eval_int_op</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">BoolLiteral</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">ZeroDivisionError</span><span class="p">,</span> <span class="ne">OverflowError</span><span class="p">):</span>
                <span class="k">pass</span>  <span class="c1"># Cannot fold; leave as-is</span>

        <span class="c1"># Identity simplifications</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">left</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">right</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">left</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">right</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">left</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">SUB</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">)</span> <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">left</span>

        <span class="c1"># Return simplified node</span>
        <span class="k">return</span> <span class="n">BinaryExpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_UnaryExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">UnaryExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="n">operand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NEG</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="o">-</span><span class="n">operand</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NOT</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">BoolLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BoolLiteral</span><span class="p">(</span><span class="ow">not</span> <span class="n">operand</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>

        <span class="c1"># Double negation elimination: --x =&gt; x</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NEG</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">UnaryExpr</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">operand</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NEG</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">operand</span><span class="o">.</span><span class="n">operand</span>

        <span class="k">return</span> <span class="n">UnaryExpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_eval_int_op</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="n">BinOpKind</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">SUB</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">DIV</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">//</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MOD</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">POW</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">**</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">EQ</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">NE</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LT</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GT</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LE</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GE</span><span class="p">:</span> <span class="k">lambda</span><span class="p">:</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">ops</span><span class="p">[</span><span class="n">op</span><span class="p">]()</span>

    <span class="c1"># Pass through for other nodes (transform children)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_CallExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">CallExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="n">callee</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">callee</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">arguments</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">CallExpr</span><span class="p">(</span><span class="n">callee</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">loc</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_IfExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IfExpr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
        <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">BoolLiteral</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">cond</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">then_expr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">else_expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">IfExpr</span><span class="p">(</span>
            <span class="n">cond</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">then_expr</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">else_expr</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="n">node</span><span class="o">.</span><span class="n">loc</span><span class="p">,</span>
        <span class="p">)</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Demo ‚îÄ‚îÄ‚îÄ</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># AST for: (2 + 3) * x + 0</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">BinaryExpr</span><span class="p">(</span>
        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
        <span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span>
            <span class="n">BinaryExpr</span><span class="p">(</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">3</span><span class="p">)),</span>
            <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="n">printer</span> <span class="o">=</span> <span class="n">PrettyPrinter</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before: </span><span class="si">{</span><span class="n">printer</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Before: (2 + 3) * x + 0</span>

    <span class="n">folder</span> <span class="o">=</span> <span class="n">ConstantFolder</span><span class="p">()</span>
    <span class="n">folded</span> <span class="o">=</span> <span class="n">folder</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After:  </span><span class="si">{</span><span class="n">printer</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">folded</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># After:  5 * x</span>
</code></pre></div>

<h3 id="62-desugaring">6.2 Desugaring<a class="header-link" href="#62-desugaring" title="Permanent link">&para;</a></h3>
<p><strong>Desugaring</strong> transforms syntactic sugar into simpler, core constructs:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Desugarer</span><span class="p">(</span><span class="n">ASTVisitor</span><span class="p">[</span><span class="n">ASTNode</span><span class="p">]):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform syntactic sugar into core language constructs.</span>

<span class="sd">    Examples:</span>
<span class="sd">        for (x in list) { body }</span>
<span class="sd">            =&gt; let _iter = list;</span>
<span class="sd">               let _i = 0;</span>
<span class="sd">               while (_i &lt; len(_iter)) {</span>
<span class="sd">                   let x = _iter[_i];</span>
<span class="sd">                   body;</span>
<span class="sd">                   _i = _i + 1;</span>
<span class="sd">               }</span>

<span class="sd">        x += 5  =&gt;  x = x + 5</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_fresh_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;_tmp&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="bp">self</span><span class="o">.</span><span class="n">_temp_counter</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">visit_ForStmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ForStmt</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Block</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Desugar for-in loop to while loop.&quot;&quot;&quot;</span>
        <span class="n">iter_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fresh_name</span><span class="p">(</span><span class="s2">&quot;_iter&quot;</span><span class="p">)</span>
        <span class="n">idx_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fresh_name</span><span class="p">(</span><span class="s2">&quot;_i&quot;</span><span class="p">)</span>

        <span class="n">iterable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">iterable</span><span class="p">)</span>
        <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Block</span><span class="p">(</span><span class="n">statements</span><span class="o">=</span><span class="p">[</span>
            <span class="c1"># let _iter = iterable;</span>
            <span class="n">LetStmt</span><span class="p">(</span><span class="n">iter_name</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">iterable</span><span class="p">),</span>
            <span class="c1"># let _i = 0;</span>
            <span class="n">LetStmt</span><span class="p">(</span><span class="n">idx_name</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
            <span class="c1"># while (_i &lt; len(_iter)) { ... }</span>
            <span class="n">WhileStmt</span><span class="p">(</span>
                <span class="n">condition</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span>
                    <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LT</span><span class="p">,</span>
                    <span class="n">Identifier</span><span class="p">(</span><span class="n">idx_name</span><span class="p">),</span>
                    <span class="n">CallExpr</span><span class="p">(</span><span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;len&quot;</span><span class="p">),</span> <span class="p">[</span><span class="n">Identifier</span><span class="p">(</span><span class="n">iter_name</span><span class="p">)]),</span>
                <span class="p">),</span>
                <span class="n">body</span><span class="o">=</span><span class="n">Block</span><span class="p">(</span><span class="n">statements</span><span class="o">=</span><span class="p">[</span>
                    <span class="c1"># let x = _iter[_i];</span>
                    <span class="n">LetStmt</span><span class="p">(</span>
                        <span class="n">node</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span>
                        <span class="n">initializer</span><span class="o">=</span><span class="n">IndexExpr</span><span class="p">(</span>
                            <span class="n">Identifier</span><span class="p">(</span><span class="n">iter_name</span><span class="p">),</span>
                            <span class="n">Identifier</span><span class="p">(</span><span class="n">idx_name</span><span class="p">),</span>
                        <span class="p">),</span>
                    <span class="p">),</span>
                    <span class="c1"># original body</span>
                    <span class="n">body</span><span class="p">,</span>
                    <span class="c1"># _i = _i + 1;</span>
                    <span class="n">AssignStmt</span><span class="p">(</span>
                        <span class="n">Identifier</span><span class="p">(</span><span class="n">idx_name</span><span class="p">),</span>
                        <span class="n">BinaryExpr</span><span class="p">(</span>
                            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
                            <span class="n">Identifier</span><span class="p">(</span><span class="n">idx_name</span><span class="p">),</span>
                            <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
                        <span class="p">),</span>
                    <span class="p">),</span>
                <span class="p">]),</span>
            <span class="p">),</span>
        <span class="p">])</span>

    <span class="c1"># ... other visit methods pass through unchanged</span>
</code></pre></div>

<hr />
<h2 id="7-source-location-tracking">7. Source Location Tracking<a class="header-link" href="#7-source-location-tracking" title="Permanent link">&para;</a></h2>
<h3 id="71-why-track-locations">7.1 Why Track Locations?<a class="header-link" href="#71-why-track-locations" title="Permanent link">&para;</a></h3>
<p>Source locations are essential for:</p>
<ol>
<li><strong>Error messages</strong>: "Type error at line 42, column 15"</li>
<li><strong>Debugger support</strong>: Mapping compiled code back to source lines</li>
<li><strong>IDE features</strong>: Go-to-definition, hover information, refactoring</li>
<li><strong>Source maps</strong>: Mapping generated JavaScript back to TypeScript</li>
</ol>
<h3 id="72-propagating-locations">7.2 Propagating Locations<a class="header-link" href="#72-propagating-locations" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">parse_binary_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse a binary expression, tracking source locations.&quot;&quot;&quot;</span>
    <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_token</span><span class="o">.</span><span class="n">loc</span>  <span class="c1"># Remember start position</span>

    <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_unary_expr</span><span class="p">()</span>

    <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_token</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="p">(</span>
        <span class="n">TokenType</span><span class="o">.</span><span class="n">PLUS</span><span class="p">,</span> <span class="n">TokenType</span><span class="o">.</span><span class="n">MINUS</span><span class="p">,</span>
        <span class="n">TokenType</span><span class="o">.</span><span class="n">STAR</span><span class="p">,</span> <span class="n">TokenType</span><span class="o">.</span><span class="n">SLASH</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="n">op_token</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_token</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">advance</span><span class="p">()</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_unary_expr</span><span class="p">()</span>

        <span class="c1"># Create node with location spanning left to right</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">token_to_binop</span><span class="p">(</span><span class="n">op_token</span><span class="p">),</span>
            <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">,</span>
            <span class="n">loc</span><span class="o">=</span><span class="n">SourceLocation</span><span class="p">(</span>
                <span class="n">line</span><span class="o">=</span><span class="n">start</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="n">column</span><span class="o">=</span><span class="n">start</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
                <span class="n">end_line</span><span class="o">=</span><span class="n">right</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">end_line</span> <span class="k">if</span> <span class="n">right</span><span class="o">.</span><span class="n">loc</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">end_column</span><span class="o">=</span><span class="n">right</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">end_column</span> <span class="k">if</span> <span class="n">right</span><span class="o">.</span><span class="n">loc</span> <span class="k">else</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                <span class="n">filename</span><span class="o">=</span><span class="n">start</span><span class="o">.</span><span class="n">filename</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">left</span>
</code></pre></div>

<h3 id="73-error-reporting-with-locations">7.3 Error Reporting with Locations<a class="header-link" href="#73-error-reporting-with-locations" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CompilerError</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A compiler error with source location and context.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">loc</span><span class="p">:</span> <span class="n">SourceLocation</span><span class="p">,</span>
        <span class="n">source_lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">severity</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;error&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">message</span> <span class="o">=</span> <span class="n">message</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loc</span> <span class="o">=</span> <span class="n">loc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">source_lines</span> <span class="o">=</span> <span class="n">source_lines</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">severity</span> <span class="o">=</span> <span class="n">severity</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">format</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Format the error like Rust/GCC-style diagnostics.&quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">severity</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;  --&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">filename</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">line</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">column</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">line</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">source_lines</span><span class="p">):</span>
            <span class="n">line_num</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">line</span>
            <span class="n">source_line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">source_lines</span><span class="p">[</span><span class="n">line_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   |&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">line_num</span><span class="si">:</span><span class="s2">&gt;3</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">source_line</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="c1"># Underline the error location</span>
            <span class="n">padding</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">column</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span>
                <span class="mi">1</span><span class="p">,</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">end_column</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">column</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loc</span><span class="o">.</span><span class="n">end_column</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">underline</span> <span class="o">=</span> <span class="s2">&quot;^&quot;</span> <span class="o">*</span> <span class="n">length</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   | </span><span class="si">{</span><span class="n">padding</span><span class="si">}{</span><span class="n">underline</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<span class="c1"># Example output:</span>
<span class="c1">#</span>
<span class="c1"># error: Type mismatch: expected int, found string</span>
<span class="c1">#   --&gt; main.lang:42:15</span>
<span class="c1">#    |</span>
<span class="c1">#  42 |     let x: int = &quot;hello&quot;;</span>
<span class="c1">#    |                ^^^^^^^</span>
</code></pre></div>

<hr />
<h2 id="8-pattern-matching-on-asts">8. Pattern Matching on ASTs<a class="header-link" href="#8-pattern-matching-on-asts" title="Permanent link">&para;</a></h2>
<h3 id="81-python-310-structural-pattern-matching">8.1 Python 3.10+ Structural Pattern Matching<a class="header-link" href="#81-python-310-structural-pattern-matching" title="Permanent link">&para;</a></h3>
<p>Python 3.10 introduced <code>match</code>/<code>case</code> statements that work beautifully with dataclass-based ASTs:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simplify</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplify expressions using pattern matching.</span>

<span class="sd">    Python 3.10+ structural pattern matching provides a clean</span>
<span class="sd">    way to match and transform AST nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">match</span> <span class="n">expr</span><span class="p">:</span>
        <span class="c1"># Constant folding: literal + literal</span>
        <span class="k">case</span> <span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
            <span class="n">left</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">a</span><span class="p">),</span>
            <span class="n">right</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">b</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

        <span class="k">case</span> <span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span>
            <span class="n">left</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">a</span><span class="p">),</span>
            <span class="n">right</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">b</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>

        <span class="c1"># Identity: x + 0 =&gt; x</span>
        <span class="k">case</span> <span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
            <span class="n">left</span><span class="o">=</span><span class="n">e</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="c1"># Identity: 0 + x =&gt; x</span>
        <span class="k">case</span> <span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
            <span class="n">left</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">right</span><span class="o">=</span><span class="n">e</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="c1"># Identity: x * 1 =&gt; x</span>
        <span class="k">case</span> <span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span>
            <span class="n">left</span><span class="o">=</span><span class="n">e</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="c1"># Absorbing: x * 0 =&gt; 0</span>
        <span class="k">case</span> <span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span>
            <span class="n">right</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Double negation: --x =&gt; x</span>
        <span class="k">case</span> <span class="n">UnaryExpr</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NEG</span><span class="p">,</span>
            <span class="n">operand</span><span class="o">=</span><span class="n">UnaryExpr</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NEG</span><span class="p">,</span> <span class="n">operand</span><span class="o">=</span><span class="n">inner</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>

        <span class="c1"># Not not x =&gt; x</span>
        <span class="k">case</span> <span class="n">UnaryExpr</span><span class="p">(</span>
            <span class="n">op</span><span class="o">=</span><span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NOT</span><span class="p">,</span>
            <span class="n">operand</span><span class="o">=</span><span class="n">UnaryExpr</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NOT</span><span class="p">,</span> <span class="n">operand</span><span class="o">=</span><span class="n">inner</span><span class="p">),</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>

        <span class="c1"># If true =&gt; then branch</span>
        <span class="k">case</span> <span class="n">IfExpr</span><span class="p">(</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">BoolLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="n">then_expr</span><span class="o">=</span><span class="n">then_e</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">then_e</span><span class="p">)</span>

        <span class="c1"># If false =&gt; else branch</span>
        <span class="k">case</span> <span class="n">IfExpr</span><span class="p">(</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">BoolLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span>
            <span class="n">else_expr</span><span class="o">=</span><span class="n">else_e</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">simplify</span><span class="p">(</span><span class="n">else_e</span><span class="p">)</span>

        <span class="c1"># Default: recurse into children</span>
        <span class="k">case</span> <span class="n">BinaryExpr</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">right</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BinaryExpr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">simplify</span><span class="p">(</span><span class="n">left</span><span class="p">),</span> <span class="n">simplify</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>

        <span class="k">case</span> <span class="n">UnaryExpr</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">op</span><span class="p">,</span> <span class="n">operand</span><span class="o">=</span><span class="n">operand</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">UnaryExpr</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">simplify</span><span class="p">(</span><span class="n">operand</span><span class="p">))</span>

        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">expr</span>
</code></pre></div>

<h3 id="82-pre-310-alternative-isinstance-chains">8.2 Pre-3.10 Alternative: isinstance Chains<a class="header-link" href="#82-pre-310-alternative-isinstance-chains" title="Permanent link">&para;</a></h3>
<p>For Python versions before 3.10, we use the traditional approach:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simplify_compat</span><span class="p">(</span><span class="n">expr</span><span class="p">:</span> <span class="n">Expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Expr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pattern matching using isinstance (Python &lt; 3.10).&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="n">simplify_compat</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="n">simplify_compat</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="c1"># Constant folding</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">)</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="n">left</span><span class="o">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="c1"># Identity: x + 0 =&gt; x</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">right</span><span class="o">.</span><span class="n">value</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">left</span>

        <span class="k">return</span> <span class="n">BinaryExpr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">UnaryExpr</span><span class="p">):</span>
        <span class="n">operand</span> <span class="o">=</span> <span class="n">simplify_compat</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NEG</span>
            <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">operand</span><span class="p">,</span> <span class="n">UnaryExpr</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">operand</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NEG</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">operand</span><span class="o">.</span><span class="n">operand</span>

        <span class="k">return</span> <span class="n">UnaryExpr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">operand</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">expr</span>
</code></pre></div>

<hr />
<h2 id="9-ast-serialization">9. AST Serialization<a class="header-link" href="#9-ast-serialization" title="Permanent link">&para;</a></h2>
<h3 id="91-json-serialization">9.1 JSON Serialization<a class="header-link" href="#91-json-serialization" title="Permanent link">&para;</a></h3>
<p>JSON is the most common serialization format for ASTs, used by tools like Babel (JavaScript), rustc, and many LSP implementations.</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">AST Serialization to JSON and S-expressions.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">json</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">dataclasses</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ASTSerializer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Serialize AST nodes to JSON-compatible dictionaries.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert an AST node to a JSON-serializable dictionary.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_type&quot;</span><span class="p">:</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">is_dataclass</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">result</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">fields</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serialize_value</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_serialize_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">object</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Serialize a field value.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ASTNode</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_serialize_value</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Enum</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">value</span><span class="o">.</span><span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">SourceLocation</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">{</span>
                <span class="s2">&quot;line&quot;</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">line</span><span class="p">,</span>
                <span class="s2">&quot;column&quot;</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">column</span><span class="p">,</span>
                <span class="s2">&quot;end_line&quot;</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">end_line</span><span class="p">,</span>
                <span class="s2">&quot;end_column&quot;</span><span class="p">:</span> <span class="n">value</span><span class="o">.</span><span class="n">end_column</span><span class="p">,</span>
            <span class="p">}</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">,</span> <span class="n">indent</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert an AST node to a JSON string.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_dict</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ASTNode</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reconstruct an AST node from a dictionary.&quot;&quot;&quot;</span>
        <span class="c1"># This requires a registry of node types</span>
        <span class="n">node_types</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;IntLiteral&quot;</span><span class="p">:</span> <span class="n">IntLiteral</span><span class="p">,</span>
            <span class="s2">&quot;FloatLiteral&quot;</span><span class="p">:</span> <span class="n">FloatLiteral</span><span class="p">,</span>
            <span class="s2">&quot;BoolLiteral&quot;</span><span class="p">:</span> <span class="n">BoolLiteral</span><span class="p">,</span>
            <span class="s2">&quot;StringLiteral&quot;</span><span class="p">:</span> <span class="n">StringLiteral</span><span class="p">,</span>
            <span class="s2">&quot;Identifier&quot;</span><span class="p">:</span> <span class="n">Identifier</span><span class="p">,</span>
            <span class="s2">&quot;BinaryExpr&quot;</span><span class="p">:</span> <span class="n">BinaryExpr</span><span class="p">,</span>
            <span class="s2">&quot;UnaryExpr&quot;</span><span class="p">:</span> <span class="n">UnaryExpr</span><span class="p">,</span>
            <span class="s2">&quot;CallExpr&quot;</span><span class="p">:</span> <span class="n">CallExpr</span><span class="p">,</span>
            <span class="s2">&quot;LetStmt&quot;</span><span class="p">:</span> <span class="n">LetStmt</span><span class="p">,</span>
            <span class="s2">&quot;PrintStmt&quot;</span><span class="p">:</span> <span class="n">PrintStmt</span><span class="p">,</span>
            <span class="s2">&quot;Program&quot;</span><span class="p">:</span> <span class="n">Program</span><span class="p">,</span>
            <span class="c1"># ... register all node types</span>
        <span class="p">}</span>

        <span class="n">type_name</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;_type&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">type_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">node_types</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown AST node type: </span><span class="si">{</span><span class="n">type_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">cls</span> <span class="o">=</span> <span class="n">node_types</span><span class="p">[</span><span class="n">type_name</span><span class="p">]</span>
        <span class="c1"># Reconstruct fields (simplified -- real implementation</span>
        <span class="c1"># would need recursive deserialization)</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">fields</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="n">data</span> <span class="ow">and</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s2">&quot;_type&quot;</span><span class="p">:</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Demo ‚îÄ‚îÄ‚îÄ</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">BinaryExpr</span><span class="p">(</span>
        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
        <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">BinaryExpr</span><span class="p">(</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">4</span><span class="p">)),</span>
    <span class="p">)</span>

    <span class="n">serializer</span> <span class="o">=</span> <span class="n">ASTSerializer</span><span class="p">()</span>
    <span class="n">json_str</span> <span class="o">=</span> <span class="n">serializer</span><span class="o">.</span><span class="n">to_json</span><span class="p">(</span><span class="n">ast</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;JSON representation:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">json_str</span><span class="p">)</span>
</code></pre></div>

<p><strong>Output:</strong></p>
<div class="highlight"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;_type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;BinaryExpr&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;op&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
<span class="w">  </span><span class="nt">&quot;left&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;_type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;IntLiteral&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;loc&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;right&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nt">&quot;_type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;BinaryExpr&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;op&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
<span class="w">    </span><span class="nt">&quot;left&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;_type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;IntLiteral&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;loc&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;right&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;_type&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;IntLiteral&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;value&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;loc&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="nt">&quot;loc&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span>
<span class="w">  </span><span class="p">},</span>
<span class="w">  </span><span class="nt">&quot;loc&quot;</span><span class="p">:</span><span class="w"> </span><span class="kc">null</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="92-s-expression-serialization">9.2 S-Expression Serialization<a class="header-link" href="#92-s-expression-serialization" title="Permanent link">&para;</a></h3>
<p>S-expressions provide a compact, Lisp-like representation that is easy to read and parse:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SExprSerializer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Serialize AST to S-expression format.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">to_sexpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">ASTNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert AST to S-expression string.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">FloatLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BoolLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;#t&quot;</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="k">else</span> <span class="s2">&quot;#f&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">StringLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s1">&#39;&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s1">&quot;&#39;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">NilLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;nil&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">left</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">right</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">UnaryExpr</span><span class="p">):</span>
            <span class="n">operand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">operand</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">CallExpr</span><span class="p">):</span>
            <span class="n">callee</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">callee</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(call </span><span class="si">{</span><span class="n">callee</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">LetStmt</span><span class="p">):</span>
            <span class="n">init</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">initializer</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">initializer</span> <span class="k">else</span> <span class="s2">&quot;nil&quot;</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(let </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">init</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">IfStmt</span><span class="p">):</span>
            <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
            <span class="n">then</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">then_body</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">else_body</span><span class="p">:</span>
                <span class="n">els</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">else_body</span><span class="p">)</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(if </span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">then</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">els</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(if </span><span class="si">{</span><span class="n">cond</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">then</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Block</span><span class="p">):</span>
            <span class="n">stmts</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">statements</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(block </span><span class="si">{</span><span class="n">stmts</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">PrintStmt</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(print </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Program</span><span class="p">):</span>
            <span class="n">stmts</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">statements</span><span class="p">)</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(program </span><span class="si">{</span><span class="n">stmts</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">FuncDecl</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">params</span><span class="p">)</span>
            <span class="n">body</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span> <span class="k">else</span> <span class="s2">&quot;()&quot;</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(fn </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">) </span><span class="si">{</span><span class="n">body</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ReturnStmt</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(return </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="k">return</span> <span class="s2">&quot;(return)&quot;</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">WhileStmt</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;(while </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">AssignStmt</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;(set! </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span><span class="si">}</span><span class="s2"> &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">ExprStmt</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(&lt;unknown&gt; </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">)&quot;</span>


<span class="c1"># ‚îÄ‚îÄ‚îÄ Demo ‚îÄ‚îÄ‚îÄ</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">ast</span> <span class="o">=</span> <span class="n">BinaryExpr</span><span class="p">(</span>
        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
        <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span>
        <span class="n">BinaryExpr</span><span class="p">(</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)),</span>
    <span class="p">)</span>

    <span class="n">sexpr</span> <span class="o">=</span> <span class="n">SExprSerializer</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sexpr</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">ast</span><span class="p">))</span>
    <span class="c1"># Output: (+ 2 (* 3 x))</span>

    <span class="c1"># A more complex program</span>
    <span class="n">program</span> <span class="o">=</span> <span class="n">Program</span><span class="p">(</span><span class="n">statements</span><span class="o">=</span><span class="p">[</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">initializer</span><span class="o">=</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span>
        <span class="n">WhileStmt</span><span class="p">(</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span>
                <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="p">),</span>
            <span class="n">body</span><span class="o">=</span><span class="n">Block</span><span class="p">([</span>
                <span class="n">PrintStmt</span><span class="p">(</span><span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)),</span>
                <span class="n">AssignStmt</span><span class="p">(</span>
                    <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span>
                    <span class="n">BinaryExpr</span><span class="p">(</span>
                        <span class="n">BinOpKind</span><span class="o">.</span><span class="n">SUB</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                    <span class="p">),</span>
                <span class="p">),</span>
            <span class="p">]),</span>
        <span class="p">),</span>
    <span class="p">])</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">sexpr</span><span class="o">.</span><span class="n">to_sexpr</span><span class="p">(</span><span class="n">program</span><span class="p">))</span>
    <span class="c1"># Output: (program (let x 10) (while (&gt; x 0) (block (print x) (set! x (- x 1)))))</span>
</code></pre></div>

<hr />
<h2 id="10-real-world-ast-examples">10. Real-World AST Examples<a class="header-link" href="#10-real-world-ast-examples" title="Permanent link">&para;</a></h2>
<h3 id="101-pythons-ast-module">10.1 Python's ast Module<a class="header-link" href="#101-pythons-ast-module" title="Permanent link">&para;</a></h3>
<p>Python provides a built-in <code>ast</code> module that exposes the AST used by CPython:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">ast</span>

<span class="n">source</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">def factorial(n):</span>
<span class="s2">    if n &lt;= 1:</span>
<span class="s2">        return 1</span>
<span class="s2">    return n * factorial(n - 1)</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="n">tree</span> <span class="o">=</span> <span class="n">ast</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ast</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div>

<p><strong>Output (abbreviated):</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">Module</span><span class="p">(</span>
<span class="w">  </span><span class="n">body</span><span class="o">=[</span>
<span class="w">    </span><span class="n">FunctionDef</span><span class="p">(</span>
<span class="w">      </span><span class="n">name</span><span class="o">=</span><span class="c">&#39;factorial&#39;,</span>
<span class="w">      </span><span class="n">args</span><span class="o">=</span><span class="n">arguments</span><span class="p">(</span><span class="n">args</span><span class="o">=[</span><span class="n">arg</span><span class="p">(</span><span class="n">arg</span><span class="o">=</span><span class="c">&#39;n&#39;)]),</span>
<span class="w">      </span><span class="n">body</span><span class="o">=[</span>
<span class="w">        </span><span class="k">If</span><span class="p">(</span>
<span class="w">          </span><span class="n">test</span><span class="o">=</span><span class="n">Compare</span><span class="p">(</span>
<span class="w">            </span><span class="n">left</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="c">&#39;n&#39;),</span>
<span class="w">            </span><span class="n">ops</span><span class="o">=[</span><span class="n">LtE</span><span class="p">()</span><span class="o">]</span><span class="p">,</span>
<span class="w">            </span><span class="n">comparators</span><span class="o">=[</span><span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">]</span>
<span class="w">          </span><span class="p">),</span>
<span class="w">          </span><span class="n">body</span><span class="o">=[</span><span class="k">Return</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">Constant</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">]</span><span class="p">,</span>
<span class="w">          </span><span class="ow">orelse</span><span class="o">=[]</span>
<span class="w">        </span><span class="p">),</span>
<span class="w">        </span><span class="k">Return</span><span class="p">(</span>
<span class="w">          </span><span class="n">value</span><span class="o">=</span><span class="n">BinOp</span><span class="p">(</span>
<span class="w">            </span><span class="n">left</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="c">&#39;n&#39;),</span>
<span class="w">            </span><span class="n">op</span><span class="o">=</span><span class="n">Mult</span><span class="p">(),</span>
<span class="w">            </span><span class="n">right</span><span class="o">=</span><span class="k">Call</span><span class="p">(</span>
<span class="w">              </span><span class="n">func</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="c">&#39;factorial&#39;),</span>
<span class="w">              </span><span class="n">args</span><span class="o">=[</span><span class="n">BinOp</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">Name</span><span class="p">(</span><span class="n">id</span><span class="o">=</span><span class="c">&#39;n&#39;), op=Sub(), right=Constant(value=1))]</span>
<span class="w">            </span><span class="p">)</span>
<span class="w">          </span><span class="p">)</span>
<span class="w">        </span><span class="p">)</span>
<span class="w">      </span><span class="o">]</span>
<span class="w">    </span><span class="p">)</span>
<span class="w">  </span><span class="o">]</span>
<span class="p">)</span>
</code></pre></div>

<h3 id="102-rusts-syn-crate">10.2 Rust's syn Crate<a class="header-link" href="#102-rusts-syn-crate" title="Permanent link">&para;</a></h3>
<p>Rust's <code>syn</code> crate parses Rust source code into AST types. The AST closely mirrors Rust's syntax with types like <code>ExprBinary</code>, <code>ExprIf</code>, <code>ItemFn</code>, etc.</p>
<h3 id="103-babel-javascript">10.3 Babel (JavaScript)<a class="header-link" href="#103-babel-javascript" title="Permanent link">&para;</a></h3>
<p>Babel uses the <strong>ESTree</strong> AST specification, which defines standard node types for JavaScript. ASTs are represented as JSON objects with a <code>type</code> field.</p>
<hr />
<h2 id="11-summary">11. Summary<a class="header-link" href="#11-summary" title="Permanent link">&para;</a></h2>
<p>The abstract syntax tree is the central data structure in any compiler or language tool. It provides a clean, structural representation of the source program that is amenable to analysis and transformation.</p>
<p><strong>Key concepts:</strong></p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CST vs AST</strong></td>
<td>CST mirrors grammar; AST captures semantic structure</td>
</tr>
<tr>
<td><strong>Node design</strong></td>
<td>Use dataclasses/algebraic types with clear type hierarchies</td>
</tr>
<tr>
<td><strong>Visitor pattern</strong></td>
<td>Separate traversal logic from node definitions</td>
</tr>
<tr>
<td><strong>Pre/post/in-order</strong></td>
<td>Different traversal orders for different purposes</td>
</tr>
<tr>
<td><strong>Pretty printing</strong></td>
<td>Convert AST back to readable source code</td>
</tr>
<tr>
<td><strong>Constant folding</strong></td>
<td>Evaluate compile-time known expressions</td>
</tr>
<tr>
<td><strong>Desugaring</strong></td>
<td>Simplify syntactic sugar into core constructs</td>
</tr>
<tr>
<td><strong>Source locations</strong></td>
<td>Track where each construct appears for error reporting</td>
</tr>
<tr>
<td><strong>Serialization</strong></td>
<td>JSON and S-expressions for tool interoperability</td>
</tr>
</tbody>
</table>
<p><strong>Design guidelines:</strong></p>
<ol>
<li>Keep AST nodes minimal -- desugar during or after parsing</li>
<li>Use algebraic data types (or dataclasses + enums) for type safety</li>
<li>Always include source locations for good error messages</li>
<li>Make nodes immutable; transformations create new trees</li>
<li>The visitor pattern scales well to many analysis passes</li>
<li>Consider serialization early if interoperability with tools is needed</li>
</ol>
<hr />
<h2 id="exercises">Exercises<a class="header-link" href="#exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-ast-node-design">Exercise 1: AST Node Design<a class="header-link" href="#exercise-1-ast-node-design" title="Permanent link">&para;</a></h3>
<p>Design AST node types (using Python dataclasses) for the following language features:</p>
<ol>
<li>Array literals: <code>[1, 2, 3]</code></li>
<li>Dictionary literals: <code>{key: value, ...}</code></li>
<li>Slice expressions: <code>a[1:5]</code>, <code>a[:3]</code>, <code>a[::2]</code></li>
<li>Try-catch: <code>try { ... } catch (e: Error) { ... } finally { ... }</code></li>
<li>Pattern matching: <code>match x { 1 =&gt; "one", 2 =&gt; "two", _ =&gt; "other" }</code></li>
</ol>
<h3 id="exercise-2-complete-visitor">Exercise 2: Complete Visitor<a class="header-link" href="#exercise-2-complete-visitor" title="Permanent link">&para;</a></h3>
<p>Implement a <code>DepthCalculator</code> visitor that computes the maximum depth of an expression AST. For example, <code>IntLiteral(5)</code> has depth 1, and <code>BinaryExpr(ADD, IntLiteral(2), IntLiteral(3))</code> has depth 2.</p>
<h3 id="exercise-3-pretty-printer-enhancement">Exercise 3: Pretty Printer Enhancement<a class="header-link" href="#exercise-3-pretty-printer-enhancement" title="Permanent link">&para;</a></h3>
<p>Extend the pretty printer to handle:</p>
<ol>
<li>Multi-line function calls when arguments exceed a line width (e.g., 80 characters)</li>
<li>Trailing commas in list literals</li>
<li>Comments (you will need to add a comment field to appropriate AST nodes)</li>
</ol>
<h3 id="exercise-4-constant-propagation">Exercise 4: Constant Propagation<a class="header-link" href="#exercise-4-constant-propagation" title="Permanent link">&para;</a></h3>
<p>Implement a <code>ConstantPropagator</code> that tracks variable assignments and substitutes known values:</p>
<div class="highlight"><pre><span></span><code>let x = 5;           let x = 5;
let y = x + 3;  =&gt;   let y = 8;
print(y * 2);         print(16);
</code></pre></div>

<p>This requires combining the constant folder with a simple environment that tracks variable-to-value mappings.</p>
<h3 id="exercise-5-ast-diff">Exercise 5: AST Diff<a class="header-link" href="#exercise-5-ast-diff" title="Permanent link">&para;</a></h3>
<p>Implement a function <code>ast_diff(old: ASTNode, new: ASTNode) -&gt; list[Change]</code> that computes the differences between two ASTs. Each <code>Change</code> should record what was added, removed, or modified and where (source location).</p>
<p>This is useful for incremental compilation and intelligent code review tools.</p>
<h3 id="exercise-6-round-trip-test">Exercise 6: Round-Trip Test<a class="header-link" href="#exercise-6-round-trip-test" title="Permanent link">&para;</a></h3>
<p>Write a test that verifies the <strong>round-trip property</strong>: parse source code to an AST, pretty-print the AST back to source code, parse again, and verify that both ASTs are structurally identical.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">test_round_trip</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="n">ast1</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="n">regenerated</span> <span class="o">=</span> <span class="n">pretty_print</span><span class="p">(</span><span class="n">ast1</span><span class="p">)</span>
    <span class="n">ast2</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">regenerated</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ast1</span> <span class="o">==</span> <span class="n">ast2</span><span class="p">,</span> <span class="s2">&quot;Round-trip failed!&quot;</span>
</code></pre></div>

<p>Identify cases where round-tripping may fail (e.g., comments, whitespace, parenthesization differences) and discuss how to handle them.</p>
<hr />
<p><a href="./06_Bottom_Up_Parsing.md">Previous: 06_Bottom_Up_Parsing.md</a> | <a href="./08_Semantic_Analysis.md">Next: 08_Semantic_Analysis.md</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/06_Bottom_Up_Parsing.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 6: Bottom-Up Parsing</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/08_Semantic_Analysis.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 8: Semantic Analysis</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}