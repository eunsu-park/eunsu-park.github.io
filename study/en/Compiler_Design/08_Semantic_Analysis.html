{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 8: Semantic Analysis - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">ğŸ </span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">ğŸ’»</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        í•œêµ­ì–´
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">â˜€ï¸</span>
                    <span class="theme-icon dark">ğŸŒ™</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Lesson 8: Semantic Analysis</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 8: Semantic Analysis</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/07_Abstract_Syntax_Trees.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 7: Abstract Syntax Trees</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/09_Intermediate_Representations.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 9: Intermediate Representations</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#learning-objectives">Learning Objectives</a></li>
<li><a href="#1-introduction-the-role-of-semantic-analysis">1. Introduction: The Role of Semantic Analysis</a><ul>
<li><a href="#11-what-parsing-cannot-check">1.1 What Parsing Cannot Check</a></li>
<li><a href="#12-semantic-analysis-pipeline">1.2 Semantic Analysis Pipeline</a></li>
</ul>
</li>
<li><a href="#2-attribute-grammars">2. Attribute Grammars</a><ul>
<li><a href="#21-concept">2.1 Concept</a></li>
<li><a href="#22-s-attributed-grammars">2.2 S-Attributed Grammars</a></li>
<li><a href="#23-l-attributed-grammars">2.3 L-Attributed Grammars</a></li>
<li><a href="#24-comparison">2.4 Comparison</a></li>
</ul>
</li>
<li><a href="#3-symbol-tables">3. Symbol Tables</a><ul>
<li><a href="#31-purpose">3.1 Purpose</a></li>
<li><a href="#32-scope-management">3.2 Scope Management</a></li>
<li><a href="#33-implementation-strategies">3.3 Implementation Strategies</a></li>
<li><a href="#34-complete-implementation">3.4 Complete Implementation</a></li>
</ul>
</li>
<li><a href="#4-type-systems">4. Type Systems</a><ul>
<li><a href="#41-static-vs-dynamic-typing">4.1 Static vs Dynamic Typing</a></li>
<li><a href="#42-strong-vs-weak-typing">4.2 Strong vs Weak Typing</a></li>
<li><a href="#43-type-system-design-spectrum">4.3 Type System Design Spectrum</a></li>
</ul>
</li>
<li><a href="#5-type-checking">5. Type Checking</a><ul>
<li><a href="#51-type-checking-rules">5.1 Type Checking Rules</a></li>
<li><a href="#52-type-checker-implementation">5.2 Type Checker Implementation</a></li>
</ul>
</li>
<li><a href="#6-type-inference">6. Type Inference</a><ul>
<li><a href="#61-local-type-inference">6.1 Local Type Inference</a></li>
<li><a href="#62-hindley-milner-type-inference">6.2 Hindley-Milner Type Inference</a></li>
<li><a href="#63-unification-algorithm">6.3 Unification Algorithm</a></li>
</ul>
</li>
<li><a href="#7-type-compatibility-and-coercion">7. Type Compatibility and Coercion</a><ul>
<li><a href="#71-type-compatibility-rules">7.1 Type Compatibility Rules</a></li>
<li><a href="#72-implicit-coercion">7.2 Implicit Coercion</a></li>
</ul>
</li>
<li><a href="#8-overloading-resolution">8. Overloading Resolution</a><ul>
<li><a href="#81-what-is-overloading">8.1 What is Overloading?</a></li>
<li><a href="#82-resolution-algorithm">8.2 Resolution Algorithm</a></li>
</ul>
</li>
<li><a href="#9-declaration-processing">9. Declaration Processing</a><ul>
<li><a href="#91-forward-references">9.1 Forward References</a></li>
<li><a href="#92-two-pass-strategy">9.2 Two-Pass Strategy</a></li>
<li><a href="#93-topological-sorting">9.3 Topological Sorting</a></li>
</ul>
</li>
<li><a href="#10-semantic-error-reporting">10. Semantic Error Reporting</a><ul>
<li><a href="#101-error-categories">10.1 Error Categories</a></li>
<li><a href="#102-error-recovery-in-type-checking">10.2 Error Recovery in Type Checking</a></li>
<li><a href="#103-helpful-error-messages">10.3 Helpful Error Messages</a></li>
</ul>
</li>
<li><a href="#11-summary">11. Summary</a></li>
<li><a href="#exercises">Exercises</a><ul>
<li><a href="#exercise-1-symbol-table-extension">Exercise 1: Symbol Table Extension</a></li>
<li><a href="#exercise-2-full-type-checker">Exercise 2: Full Type Checker</a></li>
<li><a href="#exercise-3-type-inference">Exercise 3: Type Inference</a></li>
<li><a href="#exercise-4-semantic-error-catalog">Exercise 4: Semantic Error Catalog</a></li>
<li><a href="#exercise-5-overloading-with-generics">Exercise 5: Overloading with Generics</a></li>
<li><a href="#exercise-6-control-flow-analysis">Exercise 6: Control Flow Analysis</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-8-semantic-analysis">Lesson 8: Semantic Analysis<a class="header-link" href="#lesson-8-semantic-analysis" title="Permanent link">&para;</a></h1>
<h2 id="learning-objectives">Learning Objectives<a class="header-link" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<p>After completing this lesson, you will be able to:</p>
<ol>
<li><strong>Explain</strong> the role of semantic analysis in the compilation pipeline</li>
<li><strong>Distinguish</strong> between syntax-directed translation using S-attributed and L-attributed grammars</li>
<li><strong>Implement</strong> symbol tables with proper scope management using hash tables</li>
<li><strong>Describe</strong> type systems along the dimensions of static/dynamic and strong/weak</li>
<li><strong>Implement</strong> type checking rules for expressions, statements, and functions</li>
<li><strong>Understand</strong> the basics of Hindley-Milner type inference</li>
<li><strong>Handle</strong> type compatibility, coercion, overloading resolution, and declaration processing</li>
<li><strong>Report</strong> semantic errors with clear messages and source locations</li>
</ol>
<hr />
<h2 id="1-introduction-the-role-of-semantic-analysis">1. Introduction: The Role of Semantic Analysis<a class="header-link" href="#1-introduction-the-role-of-semantic-analysis" title="Permanent link">&para;</a></h2>
<p>After parsing produces an AST, the compiler must verify that the program is <strong>meaningful</strong> -- not just syntactically correct, but semantically valid. Semantic analysis bridges the gap between syntax and code generation.</p>
<h3 id="11-what-parsing-cannot-check">1.1 What Parsing Cannot Check<a class="header-link" href="#11-what-parsing-cannot-check" title="Permanent link">&para;</a></h3>
<p>Parsing ensures the program follows the grammar, but many important properties are beyond the grammar's reach:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Example of Violation</th>
<th>Detected By</th>
</tr>
</thead>
<tbody>
<tr>
<td>Variable declared before use</td>
<td><code>x = y + 1;</code> (y not declared)</td>
<td>Semantic analysis</td>
</tr>
<tr>
<td>Type compatibility</td>
<td><code>"hello" + 42</code> (string + int)</td>
<td>Type checker</td>
</tr>
<tr>
<td>Function arity</td>
<td><code>f(1, 2)</code> when f takes 3 args</td>
<td>Type checker</td>
</tr>
<tr>
<td>Return type</td>
<td><code>fn foo() -&gt; int { return "hi"; }</code></td>
<td>Type checker</td>
</tr>
<tr>
<td>Break outside loop</td>
<td><code>break;</code> in global scope</td>
<td>Semantic analysis</td>
</tr>
<tr>
<td>Duplicate declarations</td>
<td><code>let x = 1; let x = 2;</code> in same scope</td>
<td>Symbol table</td>
</tr>
<tr>
<td>Access control</td>
<td>Reading a private field</td>
<td>Semantic analysis</td>
</tr>
</tbody>
</table>
<h3 id="12-semantic-analysis-pipeline">1.2 Semantic Analysis Pipeline<a class="header-link" href="#12-semantic-analysis-pipeline" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="w">            </span><span class="nx">AST</span><span class="w"> </span><span class="p">(</span><span class="nx">from</span><span class="w"> </span><span class="nx">parser</span><span class="p">)</span>
<span class="w">             </span><span class="err">â”‚</span>
<span class="w">             </span><span class="err">â–¼</span>
<span class="w">    </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">Name</span><span class="w"> </span><span class="nx">Resolution</span><span class="w">   </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">Build</span><span class="w"> </span><span class="nx">symbol</span><span class="w"> </span><span class="nx">tables</span><span class="p">,</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="p">(</span><span class="nx">Scope</span><span class="w"> </span><span class="nx">Analysis</span><span class="p">)</span><span class="w">  </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">resolve</span><span class="w"> </span><span class="nx">identifiers</span>
<span class="w">    </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="w">             </span><span class="err">â”‚</span>
<span class="w">             </span><span class="err">â–¼</span>
<span class="w">    </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">Type</span><span class="w"> </span><span class="nx">Checking</span><span class="w"> </span><span class="o">/</span><span class="w">   </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">Verify</span><span class="w"> </span><span class="k">type</span><span class="w"> </span><span class="nx">correctness</span><span class="p">,</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">Type</span><span class="w"> </span><span class="nx">Inference</span><span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">annotate</span><span class="w"> </span><span class="nx">AST</span><span class="w"> </span><span class="nx">with</span><span class="w"> </span><span class="nx">types</span>
<span class="w">    </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="w">             </span><span class="err">â”‚</span>
<span class="w">             </span><span class="err">â–¼</span>
<span class="w">    </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">Other</span><span class="w"> </span><span class="nx">Checks</span><span class="w">      </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">Control</span><span class="w"> </span><span class="nx">flow</span><span class="p">,</span><span class="w"> </span><span class="nx">reachability</span><span class="p">,</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">                    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">initialization</span><span class="p">,</span><span class="w"> </span><span class="nx">etc</span><span class="p">.</span>
<span class="w">    </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="w">             </span><span class="err">â”‚</span>
<span class="w">             </span><span class="err">â–¼</span>
<span class="w">        </span><span class="nx">Annotated</span><span class="w"> </span><span class="nx">AST</span>
<span class="w">    </span><span class="p">(</span><span class="nx">ready</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">IR</span><span class="w"> </span><span class="nx">generation</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="2-attribute-grammars">2. Attribute Grammars<a class="header-link" href="#2-attribute-grammars" title="Permanent link">&para;</a></h2>
<h3 id="21-concept">2.1 Concept<a class="header-link" href="#21-concept" title="Permanent link">&para;</a></h3>
<p>An <strong>attribute grammar</strong> augments a context-free grammar with <strong>attributes</strong> attached to grammar symbols and <strong>semantic rules</strong> that define how to compute them. This formalism provides a rigorous way to define semantic analysis.</p>
<p>Each grammar symbol $X$ can have:
- <strong>Synthesized attributes</strong>: Computed from the attributes of $X$'s children (information flows up)
- <strong>Inherited attributes</strong>: Computed from the attributes of $X$'s parent or siblings (information flows down)</p>
<h3 id="22-s-attributed-grammars">2.2 S-Attributed Grammars<a class="header-link" href="#22-s-attributed-grammars" title="Permanent link">&para;</a></h3>
<p>An <strong>S-attributed grammar</strong> uses only <strong>synthesized</strong> attributes. Information flows strictly bottom-up. These are the simplest and can be evaluated in a single post-order traversal.</p>
<p><strong>Example: Calculator with synthesized <code>val</code> attribute</strong></p>
<p>$$
\begin{aligned}
E &\to E_1 + T & \quad E.\text{val} &= E_1.\text{val} + T.\text{val} \\
E &\to T & \quad E.\text{val} &= T.\text{val} \\
T &\to T_1 * F & \quad T.\text{val} &= T_1.\text{val} \times F.\text{val} \\
T &\to F & \quad T.\text{val} &= F.\text{val} \\
F &\to (\ E\ ) & \quad F.\text{val} &= E.\text{val} \\
F &\to \textbf{num} & \quad F.\text{val} &= \textbf{num}.\text{lexval}
\end{aligned}
$$</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">S-Attributed Grammar Evaluation</span>

<span class="sd">Demonstrates synthesized attribute computation</span>
<span class="sd">for a simple expression evaluator.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">evaluate_s_attributed</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Post-order evaluation (S-attributed).</span>
<span class="sd">    All attributes are synthesized (flow bottom-up).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">match</span> <span class="n">node</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">v</span>

        <span class="k">case</span> <span class="n">BinaryExpr</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">l</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">r</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">evaluate_s_attributed</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">evaluate_s_attributed</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="k">case</span> <span class="n">BinaryExpr</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">l</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">r</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">evaluate_s_attributed</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">evaluate_s_attributed</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported node: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="23-l-attributed-grammars">2.3 L-Attributed Grammars<a class="header-link" href="#23-l-attributed-grammars" title="Permanent link">&para;</a></h3>
<p>An <strong>L-attributed grammar</strong> allows inherited attributes, but with a restriction: for a production $A \to X_1 X_2 \cdots X_n$, the inherited attributes of $X_i$ can depend only on:</p>
<ol>
<li>Inherited attributes of $A$ (the parent)</li>
<li>Attributes (synthesized or inherited) of $X_1, X_2, \ldots, X_{i-1}$ (the left siblings)</li>
</ol>
<p>This ensures attributes can be computed in a single <strong>left-to-right</strong> traversal.</p>
<p><strong>Example: Type declaration with inherited type attribute</strong></p>
<p>$$
\begin{aligned}
D &\to T\ L & \quad L.\text{type} &= T.\text{type} \\
T &\to \textbf{int} & \quad T.\text{type} &= \text{integer} \\
T &\to \textbf{float} & \quad T.\text{type} &= \text{float} \\
L &\to L_1 ,\ \textbf{id} & \quad L_1.\text{type} &= L.\text{type}; \quad \text{addtype}(\textbf{id}, L.\text{type}) \\
L &\to \textbf{id} & \quad & \text{addtype}(\textbf{id}, L.\text{type})
\end{aligned}
$$</p>
<p>Here, <code>L.type</code> is an <strong>inherited</strong> attribute that flows from left to right, carrying the declared type to each identifier.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">process_declaration</span><span class="p">(</span><span class="n">type_node</span><span class="p">,</span> <span class="n">id_list</span><span class="p">,</span> <span class="n">symbol_table</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    L-attributed evaluation: the type flows from left (T) to right (L).</span>

<span class="sd">    For &quot;int x, y, z&quot;:</span>
<span class="sd">      T.type = int         (synthesized)</span>
<span class="sd">      L.type = T.type      (inherited from left sibling)</span>
<span class="sd">      addtype(x, int)      (uses inherited type)</span>
<span class="sd">      addtype(y, int)</span>
<span class="sd">      addtype(z, int)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">declared_type</span> <span class="o">=</span> <span class="n">resolve_type</span><span class="p">(</span><span class="n">type_node</span><span class="p">)</span>  <span class="c1"># synthesized from T</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">id_list</span><span class="p">:</span>
        <span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">declared_type</span><span class="p">)</span>  <span class="c1"># inherited to L</span>
</code></pre></div>

<h3 id="24-comparison">2.4 Comparison<a class="header-link" href="#24-comparison" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Property</th>
<th>S-Attributed</th>
<th>L-Attributed</th>
</tr>
</thead>
<tbody>
<tr>
<td>Attribute direction</td>
<td>Bottom-up only</td>
<td>Bottom-up + restricted top-down</td>
</tr>
<tr>
<td>Evaluation order</td>
<td>Post-order</td>
<td>Left-to-right depth-first</td>
</tr>
<tr>
<td>Complexity</td>
<td>Simpler</td>
<td>More flexible</td>
</tr>
<tr>
<td>LR parsers</td>
<td>Directly supported</td>
<td>Requires adaptation</td>
</tr>
<tr>
<td>LL parsers</td>
<td>Supported</td>
<td>Directly supported</td>
</tr>
<tr>
<td>Use cases</td>
<td>Expression evaluation, code gen</td>
<td>Type propagation, scope management</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="3-symbol-tables">3. Symbol Tables<a class="header-link" href="#3-symbol-tables" title="Permanent link">&para;</a></h2>
<h3 id="31-purpose">3.1 Purpose<a class="header-link" href="#31-purpose" title="Permanent link">&para;</a></h3>
<p>A <strong>symbol table</strong> is the data structure that maps names (identifiers) to their attributes (type, scope, memory location, etc.). It is the backbone of semantic analysis.</p>
<p>Every time the compiler encounters:
- A <strong>declaration</strong> (<code>let x: int = 5</code>): add a new entry
- A <strong>reference</strong> (<code>print(x)</code>): look up an existing entry</p>
<h3 id="32-scope-management">3.2 Scope Management<a class="header-link" href="#32-scope-management" title="Permanent link">&para;</a></h3>
<p>Most languages support <strong>nested scopes</strong>: a block can contain inner blocks, each with their own declarations that may shadow outer ones.</p>
<div class="highlight"><pre><span></span><code>fn outer() {
    let x = 1;           // scope level 1
    {
        let y = 2;       // scope level 2
        let x = 10;      // shadows outer x
        {
            let z = 3;   // scope level 3
            print(x);    // resolves to inner x (= 10)
        }
        // z is no longer visible
    }
    // y and inner x are no longer visible
    print(x);            // resolves to outer x (= 1)
}
</code></pre></div>

<h3 id="33-implementation-strategies">3.3 Implementation Strategies<a class="header-link" href="#33-implementation-strategies" title="Permanent link">&para;</a></h3>
<p><strong>Strategy 1: Chained Hash Tables (scope stack)</strong></p>
<p>Each scope gets its own hash table. Lookup searches from the innermost scope outward.</p>
<div class="highlight"><pre><span></span><code><span class="n">Scope</span><span class="w"> </span><span class="n">Stack</span><span class="o">:</span>

<span class="w">    </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">Scope</span><span class="w"> </span><span class="mi">3</span><span class="w">      </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">scope</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span><span class="w">     </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="w">           </span><span class="err">â”‚</span><span class="w"> </span><span class="n">parent</span>
<span class="w">    </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">Scope</span><span class="w"> </span><span class="mi">2</span><span class="w">      </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span><span class="w">     </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span><span class="w">     </span><span class="err">â”‚</span><span class="w">  </span><span class="p">(</span><span class="n">shadows</span><span class="w"> </span><span class="n">Scope</span><span class="w"> </span><span class="mi">1</span><span class="s">&#39;s x)</span>
<span class="s">    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="s">           â”‚ parent</span>
<span class="s">    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="s">    â”‚ Scope 1      â”‚</span>
<span class="s">    â”‚ x -&gt; int     â”‚</span>
<span class="s">    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
</code></pre></div>

<p><strong>Strategy 2: Single hash table with scope markers</strong></p>
<p>Use one hash table but maintain a stack of scope markers. When exiting a scope, remove all entries added since the last marker.</p>
<h3 id="34-complete-implementation">3.4 Complete Implementation<a class="header-link" href="#34-complete-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Symbol Table with Scope Management</span>

<span class="sd">Implements a chained-scope symbol table using hash tables.</span>
<span class="sd">Each scope has its own dictionary, and lookup walks up the chain.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span>


<span class="c1"># â”€â”€â”€ Types â”€â”€â”€</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TypeKind</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">INT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">FLOAT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">BOOL</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">STRING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">VOID</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">FUNC</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">LIST</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">ERROR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>      <span class="c1"># special type for error recovery</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Type</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a type in the type system.&quot;&quot;&quot;</span>
    <span class="n">kind</span><span class="p">:</span> <span class="n">TypeKind</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FuncType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function type: (param_types) -&gt; return_type.&quot;&quot;&quot;</span>
    <span class="n">kind</span><span class="p">:</span> <span class="n">TypeKind</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">FUNC</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">param_types</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">return_type</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">VOID</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">return_type</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ListType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;List type: list[element_type].&quot;&quot;&quot;</span>
    <span class="n">kind</span><span class="p">:</span> <span class="n">TypeKind</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">LIST</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">element_type</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;list[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="si">}</span><span class="s2">]&quot;</span>


<span class="c1"># Commonly used types</span>
<span class="n">INT_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">)</span>
<span class="n">FLOAT_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">)</span>
<span class="n">BOOL_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">BOOL</span><span class="p">)</span>
<span class="n">STRING_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">STRING</span><span class="p">)</span>
<span class="n">VOID_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">VOID</span><span class="p">)</span>
<span class="n">ERROR_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>


<span class="c1"># â”€â”€â”€ Symbol â”€â”€â”€</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SymbolKind</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">VARIABLE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">FUNCTION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">PARAMETER</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">TYPE_ALIAS</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Symbol</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a named entity in the program.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        name: the identifier</span>
<span class="sd">        type: the entity&#39;s type</span>
<span class="sd">        kind: variable, function, parameter, etc.</span>
<span class="sd">        scope_level: nesting depth where defined</span>
<span class="sd">        is_mutable: whether the binding can be reassigned</span>
<span class="sd">        is_initialized: whether a value has been assigned</span>
<span class="sd">        loc: source location of the declaration</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Type</span>
    <span class="n">kind</span><span class="p">:</span> <span class="n">SymbolKind</span>
    <span class="n">scope_level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">is_mutable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_initialized</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">loc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># SourceLocation</span>


<span class="c1"># â”€â”€â”€ Scope â”€â”€â”€</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Scope</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single scope level containing symbol definitions.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        symbols: hash table mapping names to symbols</span>
<span class="sd">        parent: enclosing scope (None for global scope)</span>
<span class="sd">        level: nesting depth (0 = global)</span>
<span class="sd">        name: optional scope name (function name, block, etc.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">symbols</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Scope</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&lt;anonymous&gt;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">define</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a new symbol in this scope.</span>

<span class="sd">        Returns the previous symbol if there was a duplicate</span>
<span class="sd">        in THIS scope (not parent scopes), or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">existing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">symbol</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span>
        <span class="n">symbol</span><span class="o">.</span><span class="n">scope_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span>
        <span class="k">return</span> <span class="n">existing</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Look up a symbol in THIS scope only (no parent chain).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Look up a symbol, searching up the scope chain.</span>

<span class="sd">        Returns the first matching symbol found (innermost scope wins).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">scope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sym</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return all symbols defined in this scope.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>


<span class="c1"># â”€â”€â”€ Symbol Table â”€â”€â”€</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SymbolTable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manages a stack of scopes for name resolution.</span>

<span class="sd">    Usage:</span>
<span class="sd">        table = SymbolTable()</span>
<span class="sd">        table.define(&quot;x&quot;, INT_TYPE, SymbolKind.VARIABLE)</span>

<span class="sd">        table.enter_scope(&quot;if-body&quot;)</span>
<span class="sd">        table.define(&quot;y&quot;, BOOL_TYPE, SymbolKind.VARIABLE)</span>
<span class="sd">        table.define(&quot;x&quot;, FLOAT_TYPE, SymbolKind.VARIABLE)  # shadows outer x</span>

<span class="sd">        sym = table.lookup(&quot;x&quot;)  # finds inner x (float)</span>
<span class="sd">        table.exit_scope()</span>

<span class="sd">        sym = table.lookup(&quot;x&quot;)  # finds outer x (int)</span>
<span class="sd">        sym = table.lookup(&quot;y&quot;)  # None (out of scope)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span> <span class="o">=</span> <span class="n">Scope</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&lt;global&gt;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">scope_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">level</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">enter_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Enter a new nested scope.&quot;&quot;&quot;</span>
        <span class="n">new_scope</span> <span class="o">=</span> <span class="n">Scope</span><span class="p">(</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="n">new_scope</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exit_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Scope</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exit the current scope and return to the enclosing scope.</span>

<span class="sd">        Returns the exited scope (useful for inspecting its symbols).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot exit global scope&quot;</span><span class="p">)</span>
        <span class="n">exited</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">return</span> <span class="n">exited</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">define</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="nb">type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">SymbolKind</span> <span class="o">=</span> <span class="n">SymbolKind</span><span class="o">.</span><span class="n">VARIABLE</span><span class="p">,</span>
        <span class="n">mutable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">initialized</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">loc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Symbol</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a new symbol in the current scope.</span>

<span class="sd">        Reports an error if the name is already defined in the</span>
<span class="sd">        current scope (not parent scopes -- shadowing is allowed).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
            <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
            <span class="n">scope_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scope_level</span><span class="p">,</span>
            <span class="n">is_mutable</span><span class="o">=</span><span class="n">mutable</span><span class="p">,</span>
            <span class="n">is_initialized</span><span class="o">=</span><span class="n">initialized</span><span class="p">,</span>
            <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">existing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">existing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Duplicate definition: &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; is already defined &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;in scope &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(previous definition at </span><span class="si">{</span><span class="n">existing</span><span class="o">.</span><span class="n">loc</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">symbol</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Look up a symbol by name, searching from current to global scope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Look up a symbol in the current scope only.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">lookup_local</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Symbol</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resolve a name reference, reporting an error if not found.</span>

<span class="sd">        Returns the symbol if found, or a dummy ERROR symbol.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Undefined name: &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; is not defined &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(referenced at </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">ERROR_TYPE</span><span class="p">,</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">SymbolKind</span><span class="o">.</span><span class="n">VARIABLE</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">sym</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_scopes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Debug: print all scopes and their symbols.&quot;&quot;&quot;</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span>
        <span class="k">while</span> <span class="n">scope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Scope &#39;</span><span class="si">{</span><span class="n">scope</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; (level </span><span class="si">{</span><span class="n">scope</span><span class="o">.</span><span class="n">level</span><span class="si">}</span><span class="s2">):&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">mut</span> <span class="o">=</span> <span class="s2">&quot;mut&quot;</span> <span class="k">if</span> <span class="n">sym</span><span class="o">.</span><span class="n">is_mutable</span> <span class="k">else</span> <span class="s2">&quot;const&quot;</span>
                <span class="n">init</span> <span class="o">=</span> <span class="s2">&quot;init&quot;</span> <span class="k">if</span> <span class="n">sym</span><span class="o">.</span><span class="n">is_initialized</span> <span class="k">else</span> <span class="s2">&quot;uninit&quot;</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">kind</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">mut</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">init</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">parent</span>


<span class="c1"># â”€â”€â”€ Demo â”€â”€â”€</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">SymbolTable</span><span class="p">()</span>

    <span class="c1"># Global scope</span>
    <span class="n">table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;print&quot;</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">(</span>
        <span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">STRING_TYPE</span><span class="p">,),</span> <span class="n">return_type</span><span class="o">=</span><span class="n">VOID_TYPE</span>
    <span class="p">),</span> <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Enter function scope</span>
    <span class="n">table</span><span class="o">.</span><span class="n">enter_scope</span><span class="p">(</span><span class="s2">&quot;main&quot;</span><span class="p">)</span>
    <span class="n">table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">FLOAT_TYPE</span><span class="p">,</span> <span class="n">SymbolKind</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">BOOL_TYPE</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># shadows global x</span>

    <span class="c1"># Enter block scope</span>
    <span class="n">table</span><span class="o">.</span><span class="n">enter_scope</span><span class="p">(</span><span class="s2">&quot;if-body&quot;</span><span class="p">)</span>
    <span class="n">table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="n">STRING_TYPE</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Current scope state:&quot;</span><span class="p">)</span>
    <span class="n">table</span><span class="o">.</span><span class="n">print_scopes</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Lookups</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;print&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">]:</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sym</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> (level </span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">scope_level</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> -&gt; UNDEFINED&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Errors:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Exit scopes</span>
    <span class="n">table</span><span class="o">.</span><span class="n">exit_scope</span><span class="p">()</span>
    <span class="n">table</span><span class="o">.</span><span class="n">exit_scope</span><span class="p">()</span>

    <span class="c1"># Now x refers to global int again</span>
    <span class="n">sym</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After exiting scopes: x -&gt; </span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p><strong>Expected output:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">Current</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="n">state</span><span class="p">:</span>
<span class="n">Scope</span><span class="w"> </span><span class="s1">&#39;if-body&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">2</span><span class="p">):</span>
<span class="w">  </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">(</span><span class="n">VARIABLE</span><span class="p">,</span><span class="w"> </span><span class="n">mut</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="p">)</span>
<span class="n">Scope</span><span class="w"> </span><span class="s1">&#39;main&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">1</span><span class="p">):</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="p">(</span><span class="n">PARAMETER</span><span class="p">,</span><span class="w"> </span><span class="n">mut</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="p">)</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="p">(</span><span class="n">VARIABLE</span><span class="p">,</span><span class="w"> </span><span class="n">mut</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="p">)</span>
<span class="n">Scope</span><span class="w"> </span><span class="s1">&#39;&lt;global&gt;&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">0</span><span class="p">):</span>
<span class="w">  </span><span class="nb">print</span><span class="p">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="p">(</span><span class="n">FUNCTION</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="n">uninit</span><span class="p">)</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="n">VARIABLE</span><span class="p">,</span><span class="w"> </span><span class="n">mut</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="p">)</span>

<span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="nb">print</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="n">w</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">UNDEFINED</span>

<span class="n">Errors</span><span class="p">:</span>
<span class="w">  </span><span class="n">Undefined</span><span class="w"> </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;w&#39;</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">defined</span><span class="w"> </span><span class="p">(</span><span class="n">referenced</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">None</span><span class="p">)</span>

<span class="n">After</span><span class="w"> </span><span class="n">exiting</span><span class="w"> </span><span class="n">scopes</span><span class="p">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb nb-Type">int</span>
</code></pre></div>

<hr />
<h2 id="4-type-systems">4. Type Systems<a class="header-link" href="#4-type-systems" title="Permanent link">&para;</a></h2>
<h3 id="41-static-vs-dynamic-typing">4.1 Static vs Dynamic Typing<a class="header-link" href="#41-static-vs-dynamic-typing" title="Permanent link">&para;</a></h3>
<p><strong>Static typing</strong> checks types at <strong>compile time</strong>. Every expression has a known type before the program runs.</p>
<table>
<thead>
<tr>
<th>Language</th>
<th>Typing</th>
</tr>
</thead>
<tbody>
<tr>
<td>C, C++, Java, Rust, Go, Haskell</td>
<td>Static</td>
</tr>
<tr>
<td>Python, JavaScript, Ruby, Lisp</td>
<td>Dynamic</td>
</tr>
<tr>
<td>TypeScript, Mypy, Dart</td>
<td>Gradually typed (static + dynamic)</td>
</tr>
</tbody>
</table>
<p><strong>Dynamic typing</strong> checks types at <strong>runtime</strong>. Variables can hold values of any type.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Static typing (pseudo-code)</span>
<span class="n">let</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>         <span class="c1"># COMPILE ERROR: type mismatch</span>

<span class="c1"># Dynamic typing (Python)</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>         <span class="c1"># OK at runtime</span>
</code></pre></div>

<h3 id="42-strong-vs-weak-typing">4.2 Strong vs Weak Typing<a class="header-link" href="#42-strong-vs-weak-typing" title="Permanent link">&para;</a></h3>
<p><strong>Strong typing</strong> means implicit type conversions are restricted. Operations on incompatible types produce errors.</p>
<p><strong>Weak typing</strong> means implicit conversions (coercions) happen freely.</p>
<table>
<thead>
<tr>
<th></th>
<th>Strong</th>
<th>Weak</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Static</strong></td>
<td>Rust, Haskell, Java</td>
<td>C, C++</td>
</tr>
<tr>
<td><strong>Dynamic</strong></td>
<td>Python, Ruby</td>
<td>JavaScript, PHP</td>
</tr>
</tbody>
</table>
<p><strong>Examples of weak typing (JavaScript):</strong></p>
<div class="highlight"><pre><span></span><code><span class="s2">&quot;5&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">3</span><span class="w">       </span><span class="c1">// &quot;53&quot; (number coerced to string)</span>
<span class="s2">&quot;5&quot;</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">3</span><span class="w">       </span><span class="c1">// 2    (string coerced to number)</span>
<span class="kc">true</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kc">true</span><span class="w">   </span><span class="c1">// 2    (booleans coerced to numbers)</span>
</code></pre></div>

<p><strong>Examples of strong typing (Python):</strong></p>
<div class="highlight"><pre><span></span><code><span class="s2">&quot;5&quot;</span> <span class="o">+</span> <span class="mi">3</span>       <span class="c1"># TypeError: can only concatenate str to str</span>
<span class="kc">True</span> <span class="o">+</span> <span class="kc">True</span>   <span class="c1"># 2 (bool is a subclass of int -- deliberate design)</span>
</code></pre></div>

<h3 id="43-type-system-design-spectrum">4.3 Type System Design Spectrum<a class="header-link" href="#43-type-system-design-spectrum" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">           </span><span class="nx">Type</span><span class="w"> </span><span class="nx">System</span><span class="w"> </span><span class="nx">Design</span><span class="w"> </span><span class="nx">Space</span><span class="w">                   </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">                                                      </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">Weak</span><span class="w"> </span><span class="err">â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º</span><span class="w"> </span><span class="nx">Strong</span><span class="w">  </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">                                                      </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">   </span><span class="nx">C</span><span class="w">         </span><span class="nx">Java</span><span class="w">       </span><span class="nx">Haskell</span><span class="w">     </span><span class="nx">Rust</span><span class="w">              </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">   </span><span class="err">â”‚</span><span class="w">          </span><span class="err">â”‚</span><span class="w">           </span><span class="err">â”‚</span><span class="w">          </span><span class="err">â”‚</span><span class="w">                 </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">   </span><span class="err">â–¼</span><span class="w">          </span><span class="err">â–¼</span><span class="w">           </span><span class="err">â–¼</span><span class="w">          </span><span class="err">â–¼</span><span class="w">                 </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">implicit</span><span class="w">   </span><span class="nx">some</span><span class="w">        </span><span class="nx">no</span><span class="w">         </span><span class="nx">no</span><span class="w"> </span><span class="nx">implicit</span><span class="w">       </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">casts</span><span class="w">      </span><span class="nx">coercion</span><span class="w">    </span><span class="nx">coercion</span><span class="w">   </span><span class="nx">conversion</span><span class="w">        </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">                                    </span><span class="o">+</span><span class="w"> </span><span class="nx">ownership</span><span class="w">       </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">                                                      </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">JavaScript</span><span class="w">  </span><span class="nx">Python</span><span class="w">     </span><span class="nx">OCaml</span><span class="w">                        </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">   </span><span class="err">â”‚</span><span class="w">          </span><span class="err">â”‚</span><span class="w">           </span><span class="err">â”‚</span><span class="w">                            </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">   </span><span class="err">â–¼</span><span class="w">          </span><span class="err">â–¼</span><span class="w">           </span><span class="err">â–¼</span><span class="w">                            </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">lots</span><span class="w"> </span><span class="nx">of</span><span class="w">    </span><span class="nx">few</span><span class="w">         </span><span class="nx">no</span><span class="w">                           </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">coercion</span><span class="w">   </span><span class="nx">coercion</span><span class="w">    </span><span class="nx">coercion</span><span class="w">                     </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
</code></pre></div>

<hr />
<h2 id="5-type-checking">5. Type Checking<a class="header-link" href="#5-type-checking" title="Permanent link">&para;</a></h2>
<h3 id="51-type-checking-rules">5.1 Type Checking Rules<a class="header-link" href="#51-type-checking-rules" title="Permanent link">&para;</a></h3>
<p>Type checking verifies that operations are applied to operands of compatible types. We express type checking rules as <strong>judgments</strong>:</p>
<p>$$\Gamma \vdash e : \tau$$</p>
<p>Read as: "Under type environment $\Gamma$, expression $e$ has type $\tau$."</p>
<p><strong>Core typing rules (expressed semi-formally):</strong></p>
<p>$$
\frac{}{\Gamma \vdash n : \text{int}} \quad (\text{Int Literal})
$$</p>
<p>$$
\frac{}{\Gamma \vdash \text{true} : \text{bool}} \quad (\text{Bool Literal})
$$</p>
<p>$$
\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \quad (\text{Variable})
$$</p>
<p>$$
\frac{\Gamma \vdash e_1 : \text{int} \quad \Gamma \vdash e_2 : \text{int}}{\Gamma \vdash e_1 + e_2 : \text{int}} \quad (\text{Int Addition})
$$</p>
<p>$$
\frac{\Gamma \vdash e_1 : \tau_1 \quad \Gamma \vdash e_2 : \tau_2 \quad \tau_1 = \tau_2 \quad \tau_1 \in \{\text{int}, \text{float}\}}{\Gamma \vdash e_1 < e_2 : \text{bool}} \quad (\text{Comparison})
$$</p>
<p>$$
\frac{\Gamma \vdash e : \text{bool} \quad \Gamma \vdash s_1 : \text{ok} \quad \Gamma \vdash s_2 : \text{ok}}{\Gamma \vdash \textbf{if}\ (e)\ s_1\ \textbf{else}\ s_2 : \text{ok}} \quad (\text{If Statement})
$$</p>
<p>$$
\frac{\Gamma \vdash f : (\tau_1, \ldots, \tau_n) \to \tau_r \quad \Gamma \vdash e_i : \tau_i \text{ for } i = 1 \ldots n}{\Gamma \vdash f(e_1, \ldots, e_n) : \tau_r} \quad (\text{Function Call})
$$</p>
<h3 id="52-type-checker-implementation">5.2 Type Checker Implementation<a class="header-link" href="#52-type-checker-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Type Checker Implementation</span>

<span class="sd">Walks the AST, verifies type correctness, and annotates</span>
<span class="sd">nodes with their resolved types.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TypeChecker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs type checking on an AST.</span>

<span class="sd">    Uses the symbol table for name resolution and type lookup.</span>
<span class="sd">    Reports type errors with source locations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span> <span class="o">=</span> <span class="n">SymbolTable</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Register built-in functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_register_builtins</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_register_builtins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Register built-in functions in the global scope.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="s2">&quot;print&quot;</span><span class="p">,</span>
            <span class="n">FuncType</span><span class="p">(</span><span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">STRING_TYPE</span><span class="p">,),</span> <span class="n">return_type</span><span class="o">=</span><span class="n">VOID_TYPE</span><span class="p">),</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span>
            <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="s2">&quot;len&quot;</span><span class="p">,</span>
            <span class="n">FuncType</span><span class="p">(</span><span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">STRING_TYPE</span><span class="p">,),</span> <span class="n">return_type</span><span class="o">=</span><span class="n">INT_TYPE</span><span class="p">),</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span>
            <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="s2">&quot;str&quot;</span><span class="p">,</span>
            <span class="n">FuncType</span><span class="p">(</span><span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">INT_TYPE</span><span class="p">,),</span> <span class="n">return_type</span><span class="o">=</span><span class="n">STRING_TYPE</span><span class="p">),</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span>
            <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Record a type error.&quot;&quot;&quot;</span>
        <span class="n">loc_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; at </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">loc</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TypeError</span><span class="si">{</span><span class="n">loc_str</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_program</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Type-check an entire program.</span>

<span class="sd">        Returns True if no type errors were found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">program</span><span class="o">.</span><span class="n">statements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_stmt</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c1"># â”€â”€â”€ Expression Type Checking â”€â”€â”€</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Type-check an expression and return its type.</span>

<span class="sd">        This is the core of the type checker. Each expression</span>
<span class="sd">        form has specific typing rules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">INT_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">FloatLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">FLOAT_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BoolLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BOOL_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">StringLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">STRING_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">NilLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">VOID_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_identifier</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_binary</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">UnaryExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_unary</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">CallExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_call</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IndexExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_index</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IfExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">ListExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_list_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown expression type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a variable reference.&quot;&quot;&quot;</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Propagate symbol table errors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sym</span><span class="o">.</span><span class="n">is_initialized</span> <span class="ow">and</span> <span class="n">sym</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; may not be initialized&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">type</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Type-check a binary expression.</span>

<span class="sd">        Rules:</span>
<span class="sd">        - Arithmetic (+, -, *, /, %, **): both operands numeric, result is</span>
<span class="sd">          the wider type (int &lt; float)</span>
<span class="sd">        - String concatenation (+): both operands string, result string</span>
<span class="sd">        - Comparison (&lt;, &gt;, &lt;=, &gt;=): both operands numeric, result bool</span>
<span class="sd">        - Equality (==, !=): operands same type, result bool</span>
<span class="sd">        - Logical (and, or): both operands bool, result bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="c1"># Skip further checking if either side has errors</span>
        <span class="k">if</span> <span class="n">left_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">right_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span>

        <span class="c1"># Arithmetic operators</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">SUB</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">DIV</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MOD</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">POW</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="c1"># String concatenation</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">op</span> <span class="o">==</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span>
                <span class="ow">and</span> <span class="n">left_type</span> <span class="o">==</span> <span class="n">STRING_TYPE</span>
                <span class="ow">and</span> <span class="n">right_type</span> <span class="o">==</span> <span class="n">STRING_TYPE</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">STRING_TYPE</span>

            <span class="c1"># Numeric operations</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">left_type</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">right_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wider_numeric</span><span class="p">(</span><span class="n">left_type</span><span class="p">,</span> <span class="n">right_type</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Operator &#39;</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39; not supported for types &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">left_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">right_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="c1"># Comparison operators</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LT</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LE</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">left_type</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">right_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">BOOL_TYPE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot compare &#39;</span><span class="si">{</span><span class="n">left_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">right_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="c1"># Equality operators</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">EQ</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">NE</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types_compatible</span><span class="p">(</span><span class="n">left_type</span><span class="p">,</span> <span class="n">right_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">BOOL_TYPE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot compare &#39;</span><span class="si">{</span><span class="n">left_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">right_type</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;for equality&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="c1"># Logical operators</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">AND</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">OR</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left_type</span> <span class="o">==</span> <span class="n">BOOL_TYPE</span> <span class="ow">and</span> <span class="n">right_type</span> <span class="o">==</span> <span class="n">BOOL_TYPE</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BOOL_TYPE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Logical operator &#39;</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39; requires bool operands, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got &#39;</span><span class="si">{</span><span class="n">left_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">right_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown operator: </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ERROR_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a unary expression.&quot;&quot;&quot;</span>
        <span class="n">operand_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">operand_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NEG</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">operand_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">operand_type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unary &#39;-&#39; requires numeric operand, got &#39;</span><span class="si">{</span><span class="n">operand_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NOT</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">operand_type</span> <span class="o">==</span> <span class="n">BOOL_TYPE</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BOOL_TYPE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unary &#39;not&#39; requires bool operand, got &#39;</span><span class="si">{</span><span class="n">operand_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">return</span> <span class="n">ERROR_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Type-check a function call.</span>

<span class="sd">        Verifies that:</span>
<span class="sd">        1. The callee has a function type</span>
<span class="sd">        2. The number of arguments matches</span>
<span class="sd">        3. Each argument type matches the parameter type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">callee_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">callee</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">callee_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callee_type</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">callee</span><span class="si">}</span><span class="s2">&#39; is not callable &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(type is &#39;</span><span class="si">{</span><span class="n">callee_type</span><span class="si">}</span><span class="s2">&#39;)&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="c1"># Check argument count</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">callee_type</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span>
        <span class="n">actual</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expected</span> <span class="o">!=</span> <span class="n">actual</span><span class="p">:</span>
            <span class="n">callee_name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">callee</span><span class="o">.</span><span class="n">name</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">callee</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;function&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">callee_name</span><span class="si">}</span><span class="s2">&#39; expects </span><span class="si">{</span><span class="n">expected</span><span class="si">}</span><span class="s2"> argument(s), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">actual</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="c1"># Check argument types</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">param_type</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">arguments</span><span class="p">,</span> <span class="n">callee_type</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">arg_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_assignable</span><span class="p">(</span><span class="n">param_type</span><span class="p">,</span> <span class="n">arg_type</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Argument </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">: expected &#39;</span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;got &#39;</span><span class="si">{</span><span class="n">arg_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">callee_type</span><span class="o">.</span><span class="n">return_type</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check an index expression: a[i].&quot;&quot;&quot;</span>
        <span class="n">obj_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">idx_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">idx_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj_type</span><span class="p">,</span> <span class="n">ListType</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx_type</span> <span class="o">!=</span> <span class="n">INT_TYPE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;List index must be int, got &#39;</span><span class="si">{</span><span class="n">idx_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">obj_type</span><span class="o">.</span><span class="n">element_type</span>

        <span class="k">if</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">STRING_TYPE</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx_type</span> <span class="o">!=</span> <span class="n">INT_TYPE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;String index must be int, got &#39;</span><span class="si">{</span><span class="n">idx_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">STRING_TYPE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Type &#39;</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">&#39; does not support indexing&quot;</span><span class="p">,</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_if_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a conditional expression.&quot;&quot;&quot;</span>
        <span class="n">cond_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="n">then_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">then_expr</span><span class="p">)</span>
        <span class="n">else_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">else_expr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">BOOL_TYPE</span> <span class="ow">and</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Condition must be bool, got &#39;</span><span class="si">{</span><span class="n">cond_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">then_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">else_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">if</span> <span class="n">then_type</span> <span class="o">!=</span> <span class="n">else_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;If branches have different types: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">then_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">else_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">return</span> <span class="n">then_type</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_list_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a list literal.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ListType</span><span class="p">(</span><span class="n">element_type</span><span class="o">=</span><span class="n">VOID_TYPE</span><span class="p">)</span>  <span class="c1"># empty list</span>

        <span class="n">elem_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">elem_type</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span> <span class="ow">and</span> <span class="n">elem_type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;List elements have inconsistent types: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">return</span> <span class="n">ListType</span><span class="p">(</span><span class="n">element_type</span><span class="o">=</span><span class="n">elem_type</span><span class="p">)</span>

    <span class="c1"># â”€â”€â”€ Statement Type Checking â”€â”€â”€</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a statement.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">LetStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_let</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">AssignStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_assign</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">ExprStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">PrintStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">IfStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_stmt</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">WhileStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_while</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">Block</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_block</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">FuncDecl</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_func_decl</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">ReturnStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_return</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">ForStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_for</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown statement type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_let</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a let declaration.&quot;&quot;&quot;</span>
        <span class="n">declared_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">type_ann</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">declared_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">type_ann</span><span class="p">)</span>

        <span class="n">init_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">initializer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">initializer</span><span class="p">)</span>

        <span class="c1"># Determine the variable&#39;s type</span>
        <span class="k">if</span> <span class="n">declared_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">init_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_assignable</span><span class="p">(</span><span class="n">declared_type</span><span class="p">,</span> <span class="n">init_type</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot assign &#39;</span><span class="si">{</span><span class="n">init_type</span><span class="si">}</span><span class="s2">&#39; to variable &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">stmt</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; of type &#39;</span><span class="si">{</span><span class="n">declared_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="n">var_type</span> <span class="o">=</span> <span class="n">declared_type</span>
        <span class="k">elif</span> <span class="n">declared_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">var_type</span> <span class="o">=</span> <span class="n">declared_type</span>
        <span class="k">elif</span> <span class="n">init_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">var_type</span> <span class="o">=</span> <span class="n">init_type</span>  <span class="c1"># type inference from initializer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">stmt</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; has no type annotation &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;and no initializer&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">var_type</span> <span class="o">=</span> <span class="n">ERROR_TYPE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="n">stmt</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">var_type</span><span class="p">,</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">VARIABLE</span><span class="p">,</span>
            <span class="n">initialized</span><span class="o">=</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">initializer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">loc</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check an assignment statement.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span>
                <span class="n">stmt</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">sym</span><span class="o">.</span><span class="n">is_mutable</span> <span class="ow">and</span> <span class="n">sym</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot assign to immutable variable &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">stmt</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>

            <span class="n">value_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_assignable</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot assign &#39;</span><span class="si">{</span><span class="n">value_type</span><span class="si">}</span><span class="s2">&#39; to &#39;</span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>

            <span class="n">sym</span><span class="o">.</span><span class="n">is_initialized</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Complex assignment target (e.g., a[i] = ...)</span>
            <span class="n">target_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
            <span class="n">value_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_assignable</span><span class="p">(</span><span class="n">target_type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot assign &#39;</span><span class="si">{</span><span class="n">value_type</span><span class="si">}</span><span class="s2">&#39; to &#39;</span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_if_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check an if statement.&quot;&quot;&quot;</span>
        <span class="n">cond_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">BOOL_TYPE</span> <span class="ow">and</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;If condition must be bool, got &#39;</span><span class="si">{</span><span class="n">cond_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">then_body</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_body</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">else_body</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_while</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a while loop.&quot;&quot;&quot;</span>
        <span class="n">cond_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">BOOL_TYPE</span> <span class="ow">and</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While condition must be bool, got &#39;</span><span class="si">{</span><span class="n">cond_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a for loop.&quot;&quot;&quot;</span>
        <span class="n">iter_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">iterable</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iter_type</span><span class="p">,</span> <span class="n">ListType</span><span class="p">):</span>
            <span class="n">elem_type</span> <span class="o">=</span> <span class="n">iter_type</span><span class="o">.</span><span class="n">element_type</span>
        <span class="k">elif</span> <span class="n">iter_type</span> <span class="o">==</span> <span class="n">STRING_TYPE</span><span class="p">:</span>
            <span class="n">elem_type</span> <span class="o">=</span> <span class="n">STRING_TYPE</span>
        <span class="k">elif</span> <span class="n">iter_type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot iterate over type &#39;</span><span class="si">{</span><span class="n">iter_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">elem_type</span> <span class="o">=</span> <span class="n">ERROR_TYPE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elem_type</span> <span class="o">=</span> <span class="n">ERROR_TYPE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">enter_scope</span><span class="p">(</span><span class="s2">&quot;for-body&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="n">stmt</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">,</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">VARIABLE</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">exit_scope</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a block of statements.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">enter_scope</span><span class="p">(</span><span class="s2">&quot;block&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">statements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_stmt</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">exit_scope</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_func_decl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a function declaration.&quot;&quot;&quot;</span>
        <span class="c1"># Resolve parameter types</span>
        <span class="n">param_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">type_ann</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">type_ann</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Parameter &#39;</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; has no type annotation&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">ERROR_TYPE</span>
            <span class="n">param_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

        <span class="c1"># Resolve return type</span>
        <span class="n">return_type</span> <span class="o">=</span> <span class="n">VOID_TYPE</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">return_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">return_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>

        <span class="c1"># Define function in current scope</span>
        <span class="n">func_type</span> <span class="o">=</span> <span class="n">FuncType</span><span class="p">(</span>
            <span class="n">param_types</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">param_types</span><span class="p">),</span>
            <span class="n">return_type</span><span class="o">=</span><span class="n">return_type</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="n">stmt</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func_type</span><span class="p">,</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">loc</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Check body in new scope</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">body</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prev_return</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span> <span class="o">=</span> <span class="n">return_type</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">enter_scope</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fn:</span><span class="si">{</span><span class="n">stmt</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">param_types</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span>
                    <span class="n">SymbolKind</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">statements</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">check_stmt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">exit_scope</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span> <span class="o">=</span> <span class="n">prev_return</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_return</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a return statement.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Return statement outside of function&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_assignable</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">value_type</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Return type mismatch: expected &#39;</span><span class="si">{</span><span class="n">expected</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;got &#39;</span><span class="si">{</span><span class="n">value_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span> <span class="o">!=</span> <span class="n">VOID_TYPE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Function should return &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;but return has no value&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>

    <span class="c1"># â”€â”€â”€ Type Resolution Helpers â”€â”€â”€</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_type_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ann</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a type annotation AST node to a Type.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">):</span>
            <span class="n">type_map</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="n">INT_TYPE</span><span class="p">,</span>
                <span class="s2">&quot;float&quot;</span><span class="p">:</span> <span class="n">FLOAT_TYPE</span><span class="p">,</span>
                <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="n">BOOL_TYPE</span><span class="p">,</span>
                <span class="s2">&quot;string&quot;</span><span class="p">:</span> <span class="n">STRING_TYPE</span><span class="p">,</span>
                <span class="s2">&quot;void&quot;</span><span class="p">:</span> <span class="n">VOID_TYPE</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">type_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown type: &#39;</span><span class="si">{</span><span class="n">ann</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ERROR_TYPE</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">ListType</span><span class="p">):</span>
            <span class="n">elem_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">element_type</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ListType</span><span class="p">(</span><span class="n">element_type</span><span class="o">=</span><span class="n">elem_t</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ann</span><span class="o">.</span><span class="n">param_types</span>
            <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">FuncType</span><span class="p">(</span><span class="n">param_types</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported type annotation: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ann</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_is_numeric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">,</span> <span class="n">TypeKind</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_wider_numeric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the wider of two numeric types (int &lt; float).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">FLOAT_TYPE</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">==</span> <span class="n">FLOAT_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FLOAT_TYPE</span>
        <span class="k">return</span> <span class="n">INT_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_type_assignable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if source type can be assigned to target type.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">source</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Don&#39;t cascade errors</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">source</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># Implicit widening: int -&gt; float</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">FLOAT_TYPE</span> <span class="ow">and</span> <span class="n">source</span> <span class="o">==</span> <span class="n">INT_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_types_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if two types can be compared for equality.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>


<span class="c1"># â”€â”€â”€ Demo â”€â”€â”€</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Build AST for a program with type errors</span>
    <span class="n">program</span> <span class="o">=</span> <span class="n">Program</span><span class="p">(</span><span class="n">statements</span><span class="o">=</span><span class="p">[</span>
        <span class="c1"># let x: int = 42;</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">),</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">42</span><span class="p">)),</span>
        <span class="c1"># let y: string = &quot;hello&quot;;</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">),</span> <span class="n">StringLiteral</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)),</span>
        <span class="c1"># let z = x + y;  -- TYPE ERROR: int + string</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">),</span>
        <span class="p">)),</span>
        <span class="c1"># fn add(a: int, b: int) -&gt; int { return a + b; }</span>
        <span class="n">FuncDecl</span><span class="p">(</span>
            <span class="s2">&quot;add&quot;</span><span class="p">,</span>
            <span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)),</span>
             <span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))],</span>
            <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">),</span>
            <span class="n">Block</span><span class="p">([</span>
                <span class="n">ReturnStmt</span><span class="p">(</span><span class="n">BinaryExpr</span><span class="p">(</span>
                    <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
                    <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span>
                <span class="p">))</span>
            <span class="p">]),</span>
        <span class="p">),</span>
        <span class="c1"># let result = add(1, &quot;two&quot;);  -- TYPE ERROR: string for int param</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">CallExpr</span><span class="p">(</span>
            <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">),</span>
            <span class="p">[</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">StringLiteral</span><span class="p">(</span><span class="s2">&quot;two&quot;</span><span class="p">)],</span>
        <span class="p">)),</span>
        <span class="c1"># if (x) { ... }  -- TYPE ERROR: int used as bool</span>
        <span class="n">IfStmt</span><span class="p">(</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span>
            <span class="n">then_body</span><span class="o">=</span><span class="n">Block</span><span class="p">([</span>
                <span class="n">PrintStmt</span><span class="p">(</span><span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)),</span>
            <span class="p">]),</span>
        <span class="p">),</span>
    <span class="p">])</span>

    <span class="n">checker</span> <span class="o">=</span> <span class="n">TypeChecker</span><span class="p">()</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">checker</span><span class="o">.</span><span class="n">check_program</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type check </span><span class="si">{</span><span class="s1">&#39;passed&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">success</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;FAILED&#39;</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">checker</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">checker</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span><span class="si">}</span><span class="s2"> error(s):&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="n">checker</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p><strong>Expected output:</strong></p>
<div class="highlight"><pre><span></span><code><span class="nx">Type</span><span class="w"> </span><span class="nx">check</span><span class="w"> </span><span class="nx">FAILED</span><span class="p">!</span>

<span class="nx">Found</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nx">error</span><span class="p">(</span><span class="nx">s</span><span class="p">):</span>
<span class="w">  </span><span class="nx">TypeError</span><span class="p">:</span><span class="w"> </span><span class="nx">Operator</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="nx">supported</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">types</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">int</span><span class="err">&#39;</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="err">&#39;</span><span class="kt">string</span><span class="err">&#39;</span>
<span class="w">  </span><span class="nx">TypeError</span><span class="p">:</span><span class="w"> </span><span class="nx">Argument</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"> </span><span class="nx">expected</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">int</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">got</span><span class="w"> </span><span class="err">&#39;</span><span class="kt">string</span><span class="err">&#39;</span>
<span class="w">  </span><span class="nx">TypeError</span><span class="p">:</span><span class="w"> </span><span class="nx">If</span><span class="w"> </span><span class="nx">condition</span><span class="w"> </span><span class="nx">must</span><span class="w"> </span><span class="nx">be</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">got</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">int</span><span class="err">&#39;</span>
</code></pre></div>

<hr />
<h2 id="6-type-inference">6. Type Inference<a class="header-link" href="#6-type-inference" title="Permanent link">&para;</a></h2>
<h3 id="61-local-type-inference">6.1 Local Type Inference<a class="header-link" href="#61-local-type-inference" title="Permanent link">&para;</a></h3>
<p>The simplest form of type inference: deduce a variable's type from its initializer.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># The type checker already supports this:</span>
<span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>           <span class="c1"># inferred as int</span>
<span class="n">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>         <span class="c1"># inferred as float</span>
<span class="n">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>        <span class="c1"># inferred as float (int + float -&gt; float)</span>
<span class="n">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>    <span class="c1"># inferred as string</span>
</code></pre></div>

<p>This is what TypeScript, Kotlin, Rust, and Go use for variable declarations.</p>
<h3 id="62-hindley-milner-type-inference">6.2 Hindley-Milner Type Inference<a class="header-link" href="#62-hindley-milner-type-inference" title="Permanent link">&para;</a></h3>
<p><strong>Hindley-Milner (HM)</strong> type inference is more powerful: it can infer the types of function parameters and return types without annotations. It is used by Haskell, OCaml, F#, and (in a restricted form) Rust.</p>
<p><strong>Core idea:</strong> Use <strong>type variables</strong> and <strong>unification</strong> to determine types.</p>
<p>$$
\frac{\Gamma, x:\alpha \vdash e : \tau}{\Gamma \vdash \lambda x.e : \alpha \to \tau}
$$</p>
<p>If we do not know the type of parameter $x$, we assign it a fresh type variable $\alpha$ and let unification determine its concrete type.</p>
<h3 id="63-unification-algorithm">6.3 Unification Algorithm<a class="header-link" href="#63-unification-algorithm" title="Permanent link">&para;</a></h3>
<p><strong>Unification</strong> finds a substitution $\sigma$ that makes two types equal: $\sigma(\tau_1) = \sigma(\tau_2)$.</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Simplified Hindley-Milner Type Inference</span>

<span class="sd">Implements type variables and unification for basic</span>
<span class="sd">type inference without explicit annotations.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TypeVar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A type variable that can be unified with other types.&quot;&quot;&quot;</span>

    <span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">TypeVar</span><span class="o">.</span><span class="n">_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;T</span><span class="si">{</span><span class="n">TypeVar</span><span class="o">.</span><span class="n">_counter</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;InferType&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;InferType&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Follow the chain of bindings to find the actual type.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
            <span class="n">resolved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span> <span class="o">=</span> <span class="n">resolved</span>  <span class="c1"># path compression</span>
            <span class="k">return</span> <span class="n">resolved</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">resolved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">resolved</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;?</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">resolved</span><span class="p">)</span>


<span class="c1"># For HM inference, types are:</span>
<span class="n">InferType</span> <span class="o">=</span> <span class="n">TypeVar</span> <span class="o">|</span> <span class="n">Type</span> <span class="o">|</span> <span class="n">FuncType</span>


<span class="k">def</span><span class="w"> </span><span class="nf">unify</span><span class="p">(</span><span class="n">t1</span><span class="p">:</span> <span class="n">InferType</span><span class="p">,</span> <span class="n">t2</span><span class="p">:</span> <span class="n">InferType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unify two types, binding type variables as needed.</span>

<span class="sd">    Returns True if unification succeeds, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Resolve any bound type variables</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>

    <span class="c1"># Same type variable: trivially unified</span>
    <span class="k">if</span> <span class="n">t1</span> <span class="ow">is</span> <span class="n">t2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># One is a type variable: bind it</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">occurs_in</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Occurs check: prevent infinite types</span>
        <span class="n">t1</span><span class="o">.</span><span class="n">bound_to</span> <span class="o">=</span> <span class="n">t2</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">occurs_in</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">t2</span><span class="o">.</span><span class="n">bound_to</span> <span class="o">=</span> <span class="n">t1</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># Both are concrete types: must be the same kind</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">Type</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span>

    <span class="c1"># Both are function types: unify parameter and return types</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">param_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">param_types</span><span class="p">,</span> <span class="n">t2</span><span class="o">.</span><span class="n">param_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">unify</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">unify</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">return_type</span><span class="p">,</span> <span class="n">t2</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span><span class="w"> </span><span class="nf">occurs_in</span><span class="p">(</span><span class="n">var</span><span class="p">:</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">InferType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Occurs check: does type variable `var` appear in type `t`?</span>

<span class="sd">    This prevents creating infinite types like T = T -&gt; T.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">var</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">param_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">occurs_in</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">pt</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">occurs_in</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="c1"># â”€â”€â”€ Simple Type Inferencer â”€â”€â”€</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TypeInferencer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple Hindley-Milner style type inference.</span>

<span class="sd">    Assigns type variables to unknown types and uses</span>
<span class="sd">    unification to determine concrete types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">InferType</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fresh_var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeVar</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a fresh type variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TypeVar</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">infer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InferType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Infer the type of an expression.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">INT_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BoolLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BOOL_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">StringLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">STRING_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Undefined: </span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
            <span class="n">left_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">right_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">SUB</span><span class="p">,</span>
                <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">DIV</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Both sides must be the same numeric type</span>
                <span class="n">result_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">unify</span><span class="p">(</span><span class="n">left_t</span><span class="p">,</span> <span class="n">result_var</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Type error in left operand of &#39;</span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">unify</span><span class="p">(</span><span class="n">right_t</span><span class="p">,</span> <span class="n">result_var</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Type error in right operand of &#39;</span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">result_var</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>

            <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="n">BinOpKind</span><span class="o">.</span><span class="n">EQ</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LT</span><span class="p">,</span>
                <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LE</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">unify</span><span class="p">(</span><span class="n">left_t</span><span class="p">,</span> <span class="n">right_t</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Comparison type mismatch&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">BOOL_TYPE</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">LambdaExpr</span><span class="p">):</span>
            <span class="c1"># Î»(x, y) =&gt; body</span>
            <span class="n">param_vars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
                <span class="n">tv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tv</span>
                <span class="n">param_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tv</span><span class="p">)</span>

            <span class="n">body_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">FuncType</span><span class="p">(</span>
                <span class="n">param_types</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">param_vars</span>
                <span class="p">),</span>
                <span class="n">return_type</span><span class="o">=</span><span class="p">(</span>
                    <span class="n">body_type</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body_type</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">)</span> <span class="k">else</span> <span class="n">body_type</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">CallExpr</span><span class="p">):</span>
            <span class="n">func_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">callee</span><span class="p">)</span>
            <span class="n">arg_types</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">arguments</span><span class="p">]</span>

            <span class="n">ret_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>
            <span class="n">expected_func</span> <span class="o">=</span> <span class="n">FuncType</span><span class="p">(</span>
                <span class="n">param_types</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">arg_types</span><span class="p">),</span>
                <span class="n">return_type</span><span class="o">=</span><span class="n">ret_var</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">unify</span><span class="p">(</span><span class="n">func_type</span><span class="p">,</span> <span class="n">expected_func</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Function call type mismatch&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">ret_var</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>


<span class="c1"># â”€â”€â”€ Demo â”€â”€â”€</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">inferencer</span> <span class="o">=</span> <span class="n">TypeInferencer</span><span class="p">()</span>

    <span class="c1"># Infer type of: fn(x) =&gt; x + 1</span>
    <span class="c1"># Expected: (int) -&gt; int</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">LambdaExpr</span><span class="p">(</span>
        <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)],</span>
        <span class="n">body</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
            <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span>
            <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="n">result_type</span> <span class="o">=</span> <span class="n">inferencer</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fn(x) =&gt; x + 1 : </span><span class="si">{</span><span class="n">result_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Output: fn(x) =&gt; x + 1 : (int) -&gt; int</span>

    <span class="c1"># Infer: fn(a, b) =&gt; a + b</span>
    <span class="c1"># Expected: (?T, ?T) -&gt; ?T  (polymorphic)</span>
    <span class="n">inferencer2</span> <span class="o">=</span> <span class="n">TypeInferencer</span><span class="p">()</span>
    <span class="n">expr2</span> <span class="o">=</span> <span class="n">LambdaExpr</span><span class="p">(</span>
        <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)],</span>
        <span class="n">body</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
            <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span>
            <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="n">result_type2</span> <span class="o">=</span> <span class="n">inferencer2</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fn(a, b) =&gt; a + b : </span><span class="si">{</span><span class="n">result_type2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="7-type-compatibility-and-coercion">7. Type Compatibility and Coercion<a class="header-link" href="#7-type-compatibility-and-coercion" title="Permanent link">&para;</a></h2>
<h3 id="71-type-compatibility-rules">7.1 Type Compatibility Rules<a class="header-link" href="#71-type-compatibility-rules" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Rule</th>
<th>Description</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Identity</strong></td>
<td>Same type is always compatible</td>
<td><code>int</code> = <code>int</code></td>
</tr>
<tr>
<td><strong>Widening</strong></td>
<td>Smaller numeric type fits larger</td>
<td><code>int</code> -&gt; <code>float</code></td>
</tr>
<tr>
<td><strong>Subtyping</strong></td>
<td>Subtype compatible with supertype</td>
<td><code>Cat</code> -&gt; <code>Animal</code></td>
</tr>
<tr>
<td><strong>Structural</strong></td>
<td>Same structure = compatible</td>
<td><code>{x: int, y: int}</code> = <code>{x: int, y: int}</code></td>
</tr>
<tr>
<td><strong>Nominal</strong></td>
<td>Same name = compatible</td>
<td>Java class types</td>
</tr>
</tbody>
</table>
<h3 id="72-implicit-coercion">7.2 Implicit Coercion<a class="header-link" href="#72-implicit-coercion" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">can_coerce</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if source can be implicitly coerced to target.</span>

<span class="sd">    Coercion rules (ordered by safety):</span>
<span class="sd">    1. int -&gt; float    (widening, safe)</span>
<span class="sd">    2. int -&gt; string   (via str(), if language supports it)</span>
<span class="sd">    3. float -&gt; int    (narrowing, UNSAFE -- not allowed implicitly)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">COERCION_TABLE</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">,</span> <span class="n">TypeKind</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">):</span> <span class="kc">True</span><span class="p">,</span>   <span class="c1"># safe widening</span>
        <span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">,</span> <span class="n">TypeKind</span><span class="o">.</span><span class="n">BOOL</span><span class="p">):</span> <span class="kc">False</span><span class="p">,</span>    <span class="c1"># no implicit</span>
        <span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">):</span> <span class="kc">False</span><span class="p">,</span>   <span class="c1"># narrowing, rejected</span>
        <span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">):</span> <span class="kc">True</span><span class="p">,</span>     <span class="c1"># true=1, false=0</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">COERCION_TABLE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">kind</span><span class="p">),</span> <span class="kc">False</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">insert_coercion</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">source_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">target_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrap an expression in an explicit coercion node if needed.</span>

<span class="sd">    This makes the implicit coercion explicit in the AST,</span>
<span class="sd">    which simplifies code generation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">source_type</span> <span class="o">==</span> <span class="n">target_type</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">if</span> <span class="n">can_coerce</span><span class="p">(</span><span class="n">source_type</span><span class="p">,</span> <span class="n">target_type</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CallExpr</span><span class="p">(</span>
            <span class="n">callee</span><span class="o">=</span><span class="n">Identifier</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;__coerce_</span><span class="si">{</span><span class="n">source_type</span><span class="si">}</span><span class="s2">_to_</span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">[</span><span class="n">expr</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Cannot coerce &#39;</span><span class="si">{</span><span class="n">source_type</span><span class="si">}</span><span class="s2">&#39; to &#39;</span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
    <span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="8-overloading-resolution">8. Overloading Resolution<a class="header-link" href="#8-overloading-resolution" title="Permanent link">&para;</a></h2>
<h3 id="81-what-is-overloading">8.1 What is Overloading?<a class="header-link" href="#81-what-is-overloading" title="Permanent link">&para;</a></h3>
<p><strong>Overloading</strong> allows multiple functions (or operators) to share the same name but have different parameter types. The compiler must resolve which version to call based on the argument types.</p>
<h3 id="82-resolution-algorithm">8.2 Resolution Algorithm<a class="header-link" href="#82-resolution-algorithm" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">resolve_overload</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">arg_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span>
    <span class="n">candidates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">FuncType</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FuncType</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resolve an overloaded function call.</span>

<span class="sd">    Strategy:</span>
<span class="sd">    1. Find exact matches</span>
<span class="sd">    2. If no exact match, find matches with implicit coercion</span>
<span class="sd">    3. If multiple matches, prefer the most specific one</span>
<span class="sd">    4. If still ambiguous, report an error</span>

<span class="sd">    Returns the resolved function type, or None if ambiguous/no match.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Phase 1: Exact matches</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_types</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">p</span> <span class="o">==</span> <span class="n">a</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">param_types</span><span class="p">,</span> <span class="n">arg_types</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">exact</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exact</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">exact</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exact</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># ambiguous</span>

    <span class="c1"># Phase 2: Matches with coercion</span>
    <span class="n">coercible</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_types</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">can_coerce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">param_types</span><span class="p">,</span> <span class="n">arg_types</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">coercible</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coercible</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coercible</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Phase 3: Most specific match</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coercible</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Prefer the candidate requiring fewer coercions</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">coercion_count</span><span class="p">(</span><span class="n">candidate</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="mi">0</span> <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">a</span> <span class="k">else</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">param_types</span><span class="p">,</span> <span class="n">arg_types</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">coercible</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">coercion_count</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coercion_count</span><span class="p">(</span><span class="n">coercible</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">coercion_count</span><span class="p">(</span><span class="n">coercible</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">coercible</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># no match or ambiguous</span>


<span class="c1"># â”€â”€â”€ Example â”€â”€â”€</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Overloaded &quot;add&quot; function</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">FuncType</span><span class="p">(</span><span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">INT_TYPE</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">),</span> <span class="n">return_type</span><span class="o">=</span><span class="n">INT_TYPE</span><span class="p">),</span>
        <span class="n">FuncType</span><span class="p">(</span>
            <span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">FLOAT_TYPE</span><span class="p">,</span> <span class="n">FLOAT_TYPE</span><span class="p">),</span>
            <span class="n">return_type</span><span class="o">=</span><span class="n">FLOAT_TYPE</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">FuncType</span><span class="p">(</span>
            <span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">STRING_TYPE</span><span class="p">,</span> <span class="n">STRING_TYPE</span><span class="p">),</span>
            <span class="n">return_type</span><span class="o">=</span><span class="n">STRING_TYPE</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>

    <span class="c1"># add(1, 2) -&gt; exact match: (int, int) -&gt; int</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">resolve_overload</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_TYPE</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">],</span> <span class="n">candidates</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;add(int, int) resolves to: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># add(1, 2.0) -&gt; coercion match: (float, float) -&gt; float</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">resolve_overload</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_TYPE</span><span class="p">,</span> <span class="n">FLOAT_TYPE</span><span class="p">],</span> <span class="n">candidates</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;add(int, float) resolves to: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># add(&quot;a&quot;, &quot;b&quot;) -&gt; exact match: (string, string) -&gt; string</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">resolve_overload</span><span class="p">(</span>
        <span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">STRING_TYPE</span><span class="p">,</span> <span class="n">STRING_TYPE</span><span class="p">],</span> <span class="n">candidates</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;add(string, string) resolves to: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># add(1, &quot;b&quot;) -&gt; no match</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">resolve_overload</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_TYPE</span><span class="p">,</span> <span class="n">STRING_TYPE</span><span class="p">],</span> <span class="n">candidates</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;add(int, string) resolves to: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="9-declaration-processing">9. Declaration Processing<a class="header-link" href="#9-declaration-processing" title="Permanent link">&para;</a></h2>
<h3 id="91-forward-references">9.1 Forward References<a class="header-link" href="#91-forward-references" title="Permanent link">&para;</a></h3>
<p>Many languages allow declarations to reference names that appear later in the source:</p>
<div class="highlight"><pre><span></span><code><span class="nt">fn</span><span class="w"> </span><span class="nt">is_even</span><span class="o">(</span><span class="nt">n</span><span class="o">:</span><span class="w"> </span><span class="nt">int</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">if</span><span class="w"> </span><span class="err">(n</span><span class="w"> </span><span class="err">==</span><span class="w"> </span><span class="err">0)</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">true</span><span class="p">;</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="err">is_odd(n</span><span class="w"> </span><span class="err">-</span><span class="w"> </span><span class="err">1)</span><span class="p">;</span><span class="w">      </span><span class="err">//</span><span class="w"> </span><span class="err">forward</span><span class="w"> </span><span class="err">reference</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">is_odd</span>
<span class="p">}</span>

<span class="nt">fn</span><span class="w"> </span><span class="nt">is_odd</span><span class="o">(</span><span class="nt">n</span><span class="o">:</span><span class="w"> </span><span class="nt">int</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">if</span><span class="w"> </span><span class="err">(n</span><span class="w"> </span><span class="err">==</span><span class="w"> </span><span class="err">0)</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">false</span><span class="p">;</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="err">is_even(n</span><span class="w"> </span><span class="err">-</span><span class="w"> </span><span class="err">1)</span><span class="p">;</span><span class="w">     </span><span class="err">//</span><span class="w"> </span><span class="err">backward</span><span class="w"> </span><span class="err">reference</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">is_even</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="92-two-pass-strategy">9.2 Two-Pass Strategy<a class="header-link" href="#92-two-pass-strategy" title="Permanent link">&para;</a></h3>
<p>To handle forward references, use two passes over declarations:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">check_declarations_two_pass</span><span class="p">(</span><span class="n">declarations</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Two-pass declaration processing.</span>

<span class="sd">    Pass 1: Register all names and their types (signatures)</span>
<span class="sd">    Pass 2: Check function bodies (using all registered names)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">symbol_table</span> <span class="o">=</span> <span class="n">SymbolTable</span><span class="p">()</span>

    <span class="c1"># Pass 1: Register signatures</span>
    <span class="k">for</span> <span class="n">decl</span> <span class="ow">in</span> <span class="n">declarations</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">FuncDecl</span><span class="p">):</span>
            <span class="n">param_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">decl</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">resolve_type_annotation</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">type_ann</span><span class="p">)</span>
                <span class="n">param_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

            <span class="n">return_type</span> <span class="o">=</span> <span class="n">VOID_TYPE</span>
            <span class="k">if</span> <span class="n">decl</span><span class="o">.</span><span class="n">return_type</span><span class="p">:</span>
                <span class="n">return_type</span> <span class="o">=</span> <span class="n">resolve_type_annotation</span><span class="p">(</span><span class="n">decl</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>

            <span class="n">func_type</span> <span class="o">=</span> <span class="n">FuncType</span><span class="p">(</span>
                <span class="n">param_types</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">param_types</span><span class="p">),</span>
                <span class="n">return_type</span><span class="o">=</span><span class="n">return_type</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
                <span class="n">decl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func_type</span><span class="p">,</span>
                <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">LetStmt</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">decl</span><span class="o">.</span><span class="n">type_ann</span><span class="p">:</span>
                <span class="n">var_type</span> <span class="o">=</span> <span class="n">resolve_type_annotation</span><span class="p">(</span><span class="n">decl</span><span class="o">.</span><span class="n">type_ann</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var_type</span> <span class="o">=</span> <span class="n">ERROR_TYPE</span>  <span class="c1"># Need initializer for inference</span>
            <span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
                <span class="n">decl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">var_type</span><span class="p">,</span> <span class="n">SymbolKind</span><span class="o">.</span><span class="n">VARIABLE</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="c1"># Pass 2: Check bodies</span>
    <span class="k">for</span> <span class="n">decl</span> <span class="ow">in</span> <span class="n">declarations</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">FuncDecl</span><span class="p">)</span> <span class="ow">and</span> <span class="n">decl</span><span class="o">.</span><span class="n">body</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_function_body</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">symbol_table</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">LetStmt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">decl</span><span class="o">.</span><span class="n">initializer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_initializer</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">symbol_table</span><span class="p">)</span>
</code></pre></div>

<h3 id="93-topological-sorting">9.3 Topological Sorting<a class="header-link" href="#93-topological-sorting" title="Permanent link">&para;</a></h3>
<p>For non-function declarations that depend on each other, topological sorting ensures declarations are processed in dependency order:</p>
<div class="highlight"><pre><span></span><code><span class="n">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">// depends on b</span>
<span class="n">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">       </span><span class="c1">// no dependencies</span>
<span class="n">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">    </span><span class="c1">// depends on a and b</span>

<span class="n">Dependency</span><span class="w"> </span><span class="nf">graph</span><span class="o">:</span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">b</span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">b</span>

<span class="n">Topological</span><span class="w"> </span><span class="n">order</span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">c</span>
</code></pre></div>

<hr />
<h2 id="10-semantic-error-reporting">10. Semantic Error Reporting<a class="header-link" href="#10-semantic-error-reporting" title="Permanent link">&para;</a></h2>
<h3 id="101-error-categories">10.1 Error Categories<a class="header-link" href="#101-error-categories" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Category</th>
<th>Example</th>
<th>Severity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Undefined name</td>
<td><code>print(x)</code> where x not defined</td>
<td>Error</td>
</tr>
<tr>
<td>Type mismatch</td>
<td><code>"hello" + 42</code></td>
<td>Error</td>
</tr>
<tr>
<td>Wrong arity</td>
<td><code>f(1, 2)</code> but f takes 1 arg</td>
<td>Error</td>
</tr>
<tr>
<td>Duplicate definition</td>
<td><code>let x = 1; let x = 2;</code></td>
<td>Error (or warning)</td>
</tr>
<tr>
<td>Unused variable</td>
<td><code>let x = 5;</code> (x never read)</td>
<td>Warning</td>
</tr>
<tr>
<td>Unreachable code</td>
<td>Code after <code>return</code></td>
<td>Warning</td>
</tr>
<tr>
<td>Implicit narrowing</td>
<td><code>let x: int = 3.14;</code></td>
<td>Warning (or error)</td>
</tr>
<tr>
<td>Shadowing</td>
<td>Inner <code>x</code> shadows outer <code>x</code></td>
<td>Info/Warning</td>
</tr>
</tbody>
</table>
<h3 id="102-error-recovery-in-type-checking">10.2 Error Recovery in Type Checking<a class="header-link" href="#102-error-recovery-in-type-checking" title="Permanent link">&para;</a></h3>
<p>The type checker should continue after errors to report as many issues as possible in one pass. The key technique is the <strong>error type</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># ERROR_TYPE acts as a &quot;universal&quot; type that is compatible with everything.</span>
<span class="c1"># This prevents cascading errors.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_type_assignable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">source</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Suppress cascading errors</span>
    <span class="c1"># ... normal checking</span>
</code></pre></div>

<h3 id="103-helpful-error-messages">10.3 Helpful Error Messages<a class="header-link" href="#103-helpful-error-messages" title="Permanent link">&para;</a></h3>
<p>Good compiler errors should be:</p>
<ol>
<li><strong>Precise</strong>: Point to the exact location of the problem</li>
<li><strong>Clear</strong>: Explain what is wrong in plain language</li>
<li><strong>Helpful</strong>: Suggest how to fix the issue</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DiagnosticFormatter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Format semantic errors with context and suggestions.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">type_mismatch</span><span class="p">(</span>
        <span class="n">expected</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
        <span class="n">actual</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
        <span class="n">context</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">loc</span><span class="p">,</span>
        <span class="n">source_lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;error: type mismatch in </span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;  --&gt; </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">loc</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">loc</span><span class="o">.</span><span class="n">line</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_lines</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">source_lines</span><span class="p">[</span><span class="n">loc</span><span class="o">.</span><span class="n">line</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   |&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">loc</span><span class="o">.</span><span class="n">line</span><span class="si">:</span><span class="s2">&gt;3</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;   | </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">column</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;~&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">loc</span><span class="o">.</span><span class="n">end_column</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">loc</span><span class="o">.</span><span class="n">column</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   = expected: </span><span class="si">{</span><span class="n">expected</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   = found:    </span><span class="si">{</span><span class="n">actual</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Suggestions</span>
        <span class="k">if</span> <span class="n">expected</span> <span class="o">==</span> <span class="n">INT_TYPE</span> <span class="ow">and</span> <span class="n">actual</span> <span class="o">==</span> <span class="n">FLOAT_TYPE</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;   = help: use an explicit cast: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;int(value)&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">expected</span> <span class="o">==</span> <span class="n">STRING_TYPE</span> <span class="ow">and</span> <span class="n">actual</span> <span class="o">==</span> <span class="n">INT_TYPE</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;   = help: convert to string: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;str(value)&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
</code></pre></div>

<p><strong>Example formatted error:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">error</span><span class="o">:</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">mismatch</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="n">argument</span>
<span class="w">  </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">main</span><span class="o">.</span><span class="na">lang</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">20</span>
<span class="w">   </span><span class="o">|</span>
<span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s2">&quot;two&quot;</span><span class="o">);</span>
<span class="w">   </span><span class="o">|</span><span class="w">                       </span><span class="o">~~~~~</span>
<span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">expected</span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">found</span><span class="o">:</span><span class="w">    </span><span class="n">string</span>
<span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">help</span><span class="o">:</span><span class="w"> </span><span class="n">convert</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">possible</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">(</span><span class="s2">&quot;two&quot;</span><span class="o">)</span>
</code></pre></div>

<hr />
<h2 id="11-summary">11. Summary<a class="header-link" href="#11-summary" title="Permanent link">&para;</a></h2>
<p>Semantic analysis is the bridge between syntactic correctness (parsing) and meaningful program behavior (code generation). It verifies that the program makes sense: names are defined, types are consistent, and language rules are followed.</p>
<p><strong>Key concepts:</strong></p>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Attribute grammars</strong></td>
<td>Formalize how semantic information flows in the parse tree</td>
</tr>
<tr>
<td><strong>S-attributed</strong></td>
<td>Synthesized attributes only; bottom-up evaluation</td>
</tr>
<tr>
<td><strong>L-attributed</strong></td>
<td>Synthesized + left-to-right inherited; single-pass evaluation</td>
</tr>
<tr>
<td><strong>Symbol table</strong></td>
<td>Maps names to their types, scopes, and attributes</td>
</tr>
<tr>
<td><strong>Scope management</strong></td>
<td>Chained hash tables for nested scopes with shadowing</td>
</tr>
<tr>
<td><strong>Type checking</strong></td>
<td>Verify that operations are applied to compatible types</td>
</tr>
<tr>
<td><strong>Type inference</strong></td>
<td>Deduce types from usage (local inference or HM unification)</td>
</tr>
<tr>
<td><strong>Coercion</strong></td>
<td>Implicit type conversion (e.g., int to float)</td>
</tr>
<tr>
<td><strong>Overloading</strong></td>
<td>Resolving the right function from multiple candidates</td>
</tr>
<tr>
<td><strong>Error recovery</strong></td>
<td>Using ERROR_TYPE to prevent cascading type errors</td>
</tr>
</tbody>
</table>
<p><strong>Design guidelines:</strong></p>
<ol>
<li>Use a two-pass approach (register declarations, then check bodies) for forward references</li>
<li>Design an error type that suppresses cascading errors</li>
<li>Track source locations throughout for precise error reporting</li>
<li>Keep coercion rules explicit and minimal to avoid surprises</li>
<li>Support both explicit type annotations and local type inference</li>
<li>Report all errors in a single pass (do not stop at the first error)</li>
</ol>
<hr />
<h2 id="exercises">Exercises<a class="header-link" href="#exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-symbol-table-extension">Exercise 1: Symbol Table Extension<a class="header-link" href="#exercise-1-symbol-table-extension" title="Permanent link">&para;</a></h3>
<p>Extend the <code>SymbolTable</code> class to track:</p>
<ol>
<li><strong>Unused variables</strong>: After type-checking, report variables that were defined but never referenced</li>
<li><strong>Shadowing warnings</strong>: Report when an inner scope variable shadows an outer one</li>
<li><strong>Constant propagation</strong>: Track which variables are bound to known constants</li>
</ol>
<h3 id="exercise-2-full-type-checker">Exercise 2: Full Type Checker<a class="header-link" href="#exercise-2-full-type-checker" title="Permanent link">&para;</a></h3>
<p>Extend the type checker to handle these additional constructs:</p>
<ol>
<li>Array/list operations: <code>append</code>, <code>pop</code>, <code>len</code></li>
<li>String operations: <code>+</code> (concatenation), <code>len</code>, indexing</li>
<li>Compound assignment: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></li>
<li>Ternary operator: <code>cond ? then_expr : else_expr</code></li>
</ol>
<p>Ensure proper type checking for each operation and write test cases with both valid and invalid programs.</p>
<h3 id="exercise-3-type-inference">Exercise 3: Type Inference<a class="header-link" href="#exercise-3-type-inference" title="Permanent link">&para;</a></h3>
<p>Implement local type inference that handles:</p>
<div class="highlight"><pre><span></span><code><span class="n">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">                 </span><span class="o">//</span><span class="w"> </span><span class="n">inferred</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nc">int</span>
<span class="n">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">1, 2, 3</span><span class="o">]</span><span class="p">;</span><span class="w">         </span><span class="o">//</span><span class="w"> </span><span class="n">inferred</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">list</span><span class="o">[</span><span class="n">int</span><span class="o">]</span>
<span class="n">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">inferred</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">int</span>
<span class="n">let</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="k">true</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">inferred</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nc">int</span>
</code></pre></div>

<p>Your inferencer should produce helpful errors when inference fails (e.g., <code>let a = [];</code> -- cannot infer element type of empty list).</p>
<h3 id="exercise-4-semantic-error-catalog">Exercise 4: Semantic Error Catalog<a class="header-link" href="#exercise-4-semantic-error-catalog" title="Permanent link">&para;</a></h3>
<p>Create a test suite that exercises at least 15 different semantic errors. For each error, write:</p>
<ol>
<li>A minimal program that triggers it</li>
<li>The expected error message</li>
<li>A corrected version of the program</li>
</ol>
<p>Example errors to include: undefined variable, type mismatch in assignment, wrong number of arguments, return outside function, break outside loop, duplicate function parameter names, recursive type definition.</p>
<h3 id="exercise-5-overloading-with-generics">Exercise 5: Overloading with Generics<a class="header-link" href="#exercise-5-overloading-with-generics" title="Permanent link">&para;</a></h3>
<p>Extend the overloading resolution to handle simple generics:</p>
<div class="highlight"><pre><span></span><code><span class="nt">fn</span><span class="w"> </span><span class="nt">identity</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;(</span><span class="nt">x</span><span class="o">:</span><span class="w"> </span><span class="nt">T</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">T</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nt">fn</span><span class="w"> </span><span class="nt">pair</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">U</span><span class="o">&gt;(</span><span class="nt">a</span><span class="o">:</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">b</span><span class="o">:</span><span class="w"> </span><span class="nt">U</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="o">&gt;</span><span class="w"> </span><span class="o">(</span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">U</span><span class="o">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">(a,</span><span class="w"> </span><span class="err">b)</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="nt">identity</span><span class="o">(</span><span class="nt">5</span><span class="o">)</span><span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nt">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">int</span><span class="o">,</span><span class="w"> </span><span class="nt">returns</span><span class="w"> </span><span class="nt">int</span>
<span class="nt">identity</span><span class="o">(</span><span class="s2">&quot;hello&quot;</span><span class="o">)</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="nt">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">string</span><span class="o">,</span><span class="w"> </span><span class="nt">returns</span><span class="w"> </span><span class="nt">string</span>
<span class="nt">pair</span><span class="o">(</span><span class="nt">1</span><span class="o">,</span><span class="w"> </span><span class="s2">&quot;two&quot;</span><span class="o">)</span><span class="w">       </span><span class="o">//</span><span class="w"> </span><span class="nt">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">int</span><span class="o">,</span><span class="w"> </span><span class="nt">U</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">string</span><span class="o">,</span><span class="w"> </span><span class="nt">returns</span><span class="w"> </span><span class="o">(</span><span class="nt">int</span><span class="o">,</span><span class="w"> </span><span class="nt">string</span><span class="o">)</span>
</code></pre></div>

<p>Implement the generic instantiation logic: when calling <code>identity(5)</code>, determine that <code>T = int</code> and verify the return type is <code>int</code>.</p>
<h3 id="exercise-6-control-flow-analysis">Exercise 6: Control Flow Analysis<a class="header-link" href="#exercise-6-control-flow-analysis" title="Permanent link">&para;</a></h3>
<p>Implement a semantic analysis pass that checks:</p>
<ol>
<li>Every function with a non-void return type returns on all paths</li>
<li><code>break</code> and <code>continue</code> only appear inside loops</li>
<li>Code after <code>return</code> is unreachable (emit a warning)</li>
<li>Variables are initialized before use on all paths</li>
</ol>
<p>This requires analyzing the control flow graph of each function. Start with a simplified version that handles if-else and while loops.</p>
<hr />
<p><a href="./07_Abstract_Syntax_Trees.md">Previous: 07_Abstract_Syntax_Trees.md</a> | <a href="./09_Intermediate_Representations.md">Next: 09_Intermediate_Representations.md</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/07_Abstract_Syntax_Trees.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 7: Abstract Syntax Trees</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/09_Intermediate_Representations.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 9: Intermediate Representations</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">â†‘</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}