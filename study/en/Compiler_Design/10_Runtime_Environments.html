{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 10: Runtime Environments - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">ğŸ </span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">ğŸ’»</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        í•œêµ­ì–´
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">â˜€ï¸</span>
                    <span class="theme-icon dark">ğŸŒ™</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Lesson 10: Runtime Environments</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 10: Runtime Environments</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/09_Intermediate_Representations.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 9: Intermediate Representations</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/11_Code_Generation.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 11: Code Generation</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#learning-objectives">Learning Objectives</a></li>
<li><a href="#1-storage-organization">1. Storage Organization</a><ul>
<li><a href="#11-the-memory-model">1.1 The Memory Model</a></li>
<li><a href="#12-code-text-segment">1.2 Code (Text) Segment</a></li>
<li><a href="#13-staticglobal-data">1.3 Static/Global Data</a></li>
<li><a href="#14-the-stack">1.4 The Stack</a></li>
<li><a href="#15-the-heap">1.5 The Heap</a></li>
<li><a href="#16-address-space-layout-randomization-aslr">1.6 Address Space Layout Randomization (ASLR)</a></li>
</ul>
</li>
<li><a href="#2-activation-records-stack-frames">2. Activation Records (Stack Frames)</a><ul>
<li><a href="#21-what-is-an-activation-record">2.1 What Is an Activation Record?</a></li>
<li><a href="#22-structure-of-an-activation-record">2.2 Structure of an Activation Record</a></li>
<li><a href="#23-components-in-detail">2.3 Components in Detail</a><ul>
<li><a href="#return-address">Return Address</a></li>
<li><a href="#dynamic-link-saved-frame-pointer">Dynamic Link (Saved Frame Pointer)</a></li>
<li><a href="#static-link-access-link">Static Link (Access Link)</a></li>
<li><a href="#saved-registers">Saved Registers</a></li>
<li><a href="#local-variables">Local Variables</a></li>
<li><a href="#temporaries">Temporaries</a></li>
</ul>
</li>
<li><a href="#24-accessing-local-variables">2.4 Accessing Local Variables</a></li>
<li><a href="#25-example-function-call-sequence">2.5 Example: Function Call Sequence</a></li>
</ul>
</li>
<li><a href="#3-calling-conventions">3. Calling Conventions</a><ul>
<li><a href="#31-what-is-a-calling-convention">3.1 What Is a Calling Convention?</a></li>
<li><a href="#32-cdecl-c-declaration">3.2 cdecl (C Declaration)</a></li>
<li><a href="#33-stdcall">3.3 stdcall</a></li>
<li><a href="#34-system-v-amd64-abi-linuxmacos-x86-64">3.4 System V AMD64 ABI (Linux/macOS x86-64)</a></li>
<li><a href="#35-comparison-table">3.5 Comparison Table</a></li>
<li><a href="#36-windows-x64-calling-convention">3.6 Windows x64 Calling Convention</a></li>
</ul>
</li>
<li><a href="#4-parameter-passing-mechanisms">4. Parameter Passing Mechanisms</a><ul>
<li><a href="#41-call-by-value">4.1 Call by Value</a></li>
<li><a href="#42-call-by-reference">4.2 Call by Reference</a></li>
<li><a href="#43-call-by-value-result-copy-in-copy-out">4.3 Call by Value-Result (Copy-In, Copy-Out)</a></li>
<li><a href="#44-call-by-name">4.4 Call by Name</a></li>
<li><a href="#45-comparison-of-parameter-passing-mechanisms">4.5 Comparison of Parameter Passing Mechanisms</a></li>
</ul>
</li>
<li><a href="#5-nested-functions-and-static-scoping">5. Nested Functions and Static Scoping</a><ul>
<li><a href="#51-the-problem-of-nested-scopes">5.1 The Problem of Nested Scopes</a></li>
<li><a href="#52-access-links-static-links">5.2 Access Links (Static Links)</a></li>
<li><a href="#53-how-access-links-are-maintained">5.3 How Access Links Are Maintained</a></li>
<li><a href="#54-displays">5.4 Displays</a></li>
<li><a href="#55-comparison-access-links-vs-displays">5.5 Comparison: Access Links vs Displays</a></li>
<li><a href="#56-closures">5.6 Closures</a></li>
</ul>
</li>
<li><a href="#6-dynamic-scoping-vs-static-scoping">6. Dynamic Scoping vs Static Scoping</a><ul>
<li><a href="#61-static-lexical-scoping">6.1 Static (Lexical) Scoping</a></li>
<li><a href="#62-dynamic-scoping">6.2 Dynamic Scoping</a></li>
<li><a href="#63-runtime-implementation">6.3 Runtime Implementation</a><ul>
<li><a href="#static-scoping-runtime">Static Scoping Runtime</a></li>
<li><a href="#dynamic-scoping-runtime">Dynamic Scoping Runtime</a></li>
</ul>
</li>
<li><a href="#64-python-simulation-static-vs-dynamic-scoping">6.4 Python Simulation: Static vs Dynamic Scoping</a></li>
</ul>
</li>
<li><a href="#7-heap-management">7. Heap Management</a><ul>
<li><a href="#71-why-heap-allocation">7.1 Why Heap Allocation?</a></li>
<li><a href="#72-explicit-allocation-and-deallocation">7.2 Explicit Allocation and Deallocation</a></li>
<li><a href="#73-free-list-management">7.3 Free List Management</a><ul>
<li><a href="#allocation-strategies">Allocation Strategies</a></li>
<li><a href="#coalescing">Coalescing</a></li>
</ul>
</li>
<li><a href="#74-buddy-system">7.4 Buddy System</a></li>
<li><a href="#75-garbage-collection-overview">7.5 Garbage Collection (Overview)</a></li>
</ul>
</li>
<li><a href="#8-memory-layout-in-practice">8. Memory Layout in Practice</a><ul>
<li><a href="#81-examining-a-c-programs-layout">8.1 Examining a C Program's Layout</a></li>
<li><a href="#82-stack-frame-layout-on-x86-64-system-v-abi">8.2 Stack Frame Layout on x86-64 (System V ABI)</a></li>
</ul>
</li>
<li><a href="#9-stack-unwinding-for-exceptions">9. Stack Unwinding for Exceptions</a><ul>
<li><a href="#91-the-problem">9.1 The Problem</a></li>
<li><a href="#92-approaches">9.2 Approaches</a><ul>
<li><a href="#table-based-unwinding">Table-Based Unwinding</a></li>
<li><a href="#setjmplongjmp-based">Setjmp/Longjmp-Based</a></li>
</ul>
</li>
<li><a href="#93-stack-unwinding-process">9.3 Stack Unwinding Process</a></li>
</ul>
</li>
<li><a href="#10-python-simulation-runtime-call-stack">10. Python Simulation: Runtime Call Stack</a></li>
<li><a href="#11-compiler-support-for-runtime-environments">11. Compiler Support for Runtime Environments</a><ul>
<li><a href="#111-what-the-compiler-generates">11.1 What the Compiler Generates</a></li>
<li><a href="#112-symbol-table-information">11.2 Symbol Table Information</a></li>
<li><a href="#113-frame-layout-optimization">11.3 Frame Layout Optimization</a></li>
</ul>
</li>
<li><a href="#12-summary">12. Summary</a></li>
<li><a href="#exercises">Exercises</a><ul>
<li><a href="#exercise-1-stack-frame-diagram">Exercise 1: Stack Frame Diagram</a></li>
<li><a href="#exercise-2-access-links">Exercise 2: Access Links</a></li>
<li><a href="#exercise-3-calling-convention-comparison">Exercise 3: Calling Convention Comparison</a></li>
<li><a href="#exercise-4-dynamic-vs-static-scoping">Exercise 4: Dynamic vs Static Scoping</a></li>
<li><a href="#exercise-5-buddy-system">Exercise 5: Buddy System</a></li>
<li><a href="#exercise-6-implementation-challenge">Exercise 6: Implementation Challenge</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-10-runtime-environments">Lesson 10: Runtime Environments<a class="header-link" href="#lesson-10-runtime-environments" title="Permanent link">&para;</a></h1>
<h2 id="learning-objectives">Learning Objectives<a class="header-link" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<p>After completing this lesson, you will be able to:</p>
<ol>
<li><strong>Describe</strong> the standard memory layout of a running program (code, static, stack, heap)</li>
<li><strong>Explain</strong> activation records (stack frames) and their contents</li>
<li><strong>Compare</strong> calling conventions (cdecl, stdcall, System V AMD64 ABI) and their implications</li>
<li><strong>Implement</strong> parameter passing mechanisms: by value, by reference, and by name</li>
<li><strong>Handle</strong> nested functions using access links and displays</li>
<li><strong>Distinguish</strong> between static and dynamic scoping and their runtime implementations</li>
<li><strong>Describe</strong> heap management strategies (free lists, buddy system, garbage collection)</li>
<li><strong>Simulate</strong> a runtime call stack in Python</li>
</ol>
<hr />
<h2 id="1-storage-organization">1. Storage Organization<a class="header-link" href="#1-storage-organization" title="Permanent link">&para;</a></h2>
<h3 id="11-the-memory-model">1.1 The Memory Model<a class="header-link" href="#11-the-memory-model" title="Permanent link">&para;</a></h3>
<p>When a compiled program runs, the operating system allocates memory organized into distinct regions. Each region serves a specific purpose:</p>
<div class="highlight"><pre><span></span><code><span class="n">High</span><span class="w"> </span><span class="n">addresses</span>
<span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="err">â”‚</span><span class="w">       </span><span class="n">Stack</span><span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">grows</span><span class="w"> </span><span class="n">downward</span>
<span class="err">â”‚</span><span class="w">         </span><span class="err">â”‚</span><span class="w">           </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">         </span><span class="err">â–¼</span><span class="w">           </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">                     </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">         </span><span class="err">â–²</span><span class="w">           </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">         </span><span class="err">â”‚</span><span class="w">           </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">        </span><span class="n">Heap</span><span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">grows</span><span class="w"> </span><span class="n">upward</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">    </span><span class="n">Static</span><span class="o">/</span><span class="n">Global</span><span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="nb">load</span><span class="w"> </span><span class="n">time</span>
<span class="err">â”‚</span><span class="w">       </span><span class="n">Data</span><span class="w">          </span><span class="err">â”‚</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">    </span><span class="n">Read</span><span class="o">-</span><span class="n">Only</span><span class="w"> </span><span class="n">Data</span><span class="w">   </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="n">literals</span><span class="p">,</span><span class="w"> </span><span class="n">constants</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">       </span><span class="n">Code</span><span class="w">          </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">text</span><span class="w"> </span><span class="n">segment</span><span class="w"> </span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>
<span class="err">â”‚</span><span class="w">      </span><span class="p">(</span><span class="n">Text</span><span class="p">)</span><span class="w">         </span><span class="err">â”‚</span>
<span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="n">Low</span><span class="w"> </span><span class="n">addresses</span>
</code></pre></div>

<h3 id="12-code-text-segment">1.2 Code (Text) Segment<a class="header-link" href="#12-code-text-segment" title="Permanent link">&para;</a></h3>
<p>The <strong>code segment</strong> (or text segment) holds the machine instructions of the compiled program.</p>
<p><strong>Properties</strong>:
- <strong>Read-only</strong>: Prevents accidental or malicious modification of instructions
- <strong>Sharable</strong>: Multiple processes running the same program can share a single copy
- <strong>Fixed size</strong>: Determined at compile/link time
- <strong>Loaded once</strong>: Mapped into memory when the process starts</p>
<h3 id="13-staticglobal-data">1.3 Static/Global Data<a class="header-link" href="#13-staticglobal-data" title="Permanent link">&para;</a></h3>
<p>The <strong>static data</strong> area stores global variables and variables declared as <code>static</code> within functions. This region has a fixed size determined at compile time.</p>
<p>It is typically subdivided:</p>
<table>
<thead>
<tr>
<th>Sub-region</th>
<th>Contents</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>.data</code></td>
<td>Initialized global/static variables</td>
<td><code>int count = 42;</code></td>
</tr>
<tr>
<td><code>.bss</code></td>
<td>Uninitialized global/static variables (zero-filled)</td>
<td><code>static int buffer[1024];</code></td>
</tr>
<tr>
<td><code>.rodata</code></td>
<td>Read-only data: string literals, constants</td>
<td><code>"Hello, World!"</code></td>
</tr>
</tbody>
</table>
<p><strong>Addressing</strong>: Variables in the static area have <strong>absolute addresses</strong> known at link time. The compiler generates direct address references.</p>
<h3 id="14-the-stack">1.4 The Stack<a class="header-link" href="#14-the-stack" title="Permanent link">&para;</a></h3>
<p>The <strong>stack</strong> is used for function call management. It stores:</p>
<ul>
<li><strong>Activation records</strong> (stack frames) for each active function call</li>
<li><strong>Local variables</strong> of functions</li>
<li><strong>Parameters</strong> passed to functions</li>
<li><strong>Return addresses</strong> for resuming the caller</li>
<li><strong>Saved registers</strong> that the callee must preserve</li>
</ul>
<p>The stack grows <strong>downward</strong> in most architectures (toward lower addresses). The <strong>stack pointer</strong> (SP) marks the current top of the stack, and the <strong>frame pointer</strong> (FP, also called the base pointer BP) marks a fixed reference point within the current frame.</p>
<h3 id="15-the-heap">1.5 The Heap<a class="header-link" href="#15-the-heap" title="Permanent link">&para;</a></h3>
<p>The <strong>heap</strong> is used for dynamically allocated memory -- data whose size or lifetime cannot be determined at compile time.</p>
<p><strong>Examples</strong>:
- <code>malloc()</code> / <code>free()</code> in C
- <code>new</code> / <code>delete</code> in C++
- Object creation in Java, Python
- Dynamically sized arrays, linked lists, trees</p>
<p>The heap grows <strong>upward</strong> (toward higher addresses). Between the stack and heap is unused address space, providing room for both to grow.</p>
<h3 id="16-address-space-layout-randomization-aslr">1.6 Address Space Layout Randomization (ASLR)<a class="header-link" href="#16-address-space-layout-randomization-aslr" title="Permanent link">&para;</a></h3>
<p>Modern operating systems randomize the positions of the stack, heap, and shared libraries at each program execution. This makes it harder for attackers to predict memory addresses, mitigating buffer overflow exploits and return-oriented programming (ROP) attacks.</p>
<hr />
<h2 id="2-activation-records-stack-frames">2. Activation Records (Stack Frames)<a class="header-link" href="#2-activation-records-stack-frames" title="Permanent link">&para;</a></h2>
<h3 id="21-what-is-an-activation-record">2.1 What Is an Activation Record?<a class="header-link" href="#21-what-is-an-activation-record" title="Permanent link">&para;</a></h3>
<p>Every time a function is called, a new <strong>activation record</strong> (or <strong>stack frame</strong>) is pushed onto the runtime stack. This record contains all the information needed to execute the function and return to the caller.</p>
<h3 id="22-structure-of-an-activation-record">2.2 Structure of an Activation Record<a class="header-link" href="#22-structure-of-an-activation-record" title="Permanent link">&para;</a></h3>
<p>A typical activation record looks like this (growing downward from high to low addresses):</p>
<div class="highlight"><pre><span></span><code><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><span class="w">  </span><span class="n">High</span><span class="w"> </span><span class="n">address</span>
<span class="err">â”‚</span><span class="w">    </span><span class="n">Arguments</span><span class="w"> </span><span class="n">passed</span><span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">pushed</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">caller</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">stack</span><span class="p">)</span>
<span class="err">â”‚</span><span class="w">    </span><span class="n">by</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">caller</span><span class="w">       </span><span class="err">â”‚</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">    </span><span class="n">Return</span><span class="w"> </span><span class="n">address</span><span class="w">      </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">pushed</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">CALL</span><span class="w"> </span><span class="n">instruction</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span><span class="w">  </span><span class="err">â—€â”€â”€</span><span class="w"> </span><span class="n">Frame</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="p">(</span><span class="n">FP</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">BP</span><span class="p">)</span>
<span class="err">â”‚</span><span class="w">    </span><span class="n">Saved</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="n">FP</span><span class="w">        </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">dynamic</span><span class="w"> </span><span class="n">link</span><span class="w"> </span><span class="p">(</span><span class="n">previous</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="n">pointer</span><span class="p">)</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">    </span><span class="n">Saved</span><span class="w"> </span><span class="n">registers</span><span class="w">     </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">callee</span><span class="o">-</span><span class="n">saved</span><span class="w"> </span><span class="n">registers</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">    </span><span class="n">Local</span><span class="w"> </span><span class="n">variables</span><span class="w">     </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">function</span><span class="s1">&#39;s local storage</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">    </span><span class="n">Temporaries</span><span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">compiler</span><span class="o">-</span><span class="n">generated</span><span class="w"> </span><span class="n">temporaries</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">    </span><span class="n">Outgoing</span><span class="w"> </span><span class="n">arguments</span><span class="w">  </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â†</span><span class="w"> </span><span class="n">arguments</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">functions</span><span class="w"> </span><span class="n">this</span>
<span class="err">â”‚</span><span class="w">    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">needed</span><span class="p">)</span><span class="w">         </span><span class="err">â”‚</span><span class="w">     </span><span class="n">function</span><span class="w"> </span><span class="n">calls</span>
<span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><span class="w">  </span><span class="err">â—€â”€â”€</span><span class="w"> </span><span class="n">Stack</span><span class="w"> </span><span class="n">pointer</span><span class="w"> </span><span class="p">(</span><span class="n">SP</span><span class="p">)</span>
<span class="w">                           </span><span class="n">Low</span><span class="w"> </span><span class="n">address</span>
</code></pre></div>

<h3 id="23-components-in-detail">2.3 Components in Detail<a class="header-link" href="#23-components-in-detail" title="Permanent link">&para;</a></h3>
<h4 id="return-address">Return Address<a class="header-link" href="#return-address" title="Permanent link">&para;</a></h4>
<p>The address of the instruction in the caller to which control should return after the callee finishes. On x86, the <code>CALL</code> instruction automatically pushes the return address onto the stack.</p>
<h4 id="dynamic-link-saved-frame-pointer">Dynamic Link (Saved Frame Pointer)<a class="header-link" href="#dynamic-link-saved-frame-pointer" title="Permanent link">&para;</a></h4>
<p>A pointer to the caller's activation record (specifically, the caller's frame pointer). This forms a <strong>chain</strong> of frames that can be traversed for debugging (stack unwinding).</p>
<div class="highlight"><pre><span></span><code>       Caller&#39;s frame
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
FP â”€â”€â–¶ â”‚ saved FP â”‚ â”€â”€â”€â–¶ Previous frame ...
       â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
       â”‚  locals  â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></div>

<h4 id="static-link-access-link">Static Link (Access Link)<a class="header-link" href="#static-link-access-link" title="Permanent link">&para;</a></h4>
<p>Used for nested functions (discussed in Section 5). Points to the activation record of the lexically enclosing function.</p>
<h4 id="saved-registers">Saved Registers<a class="header-link" href="#saved-registers" title="Permanent link">&para;</a></h4>
<p>Registers that the callee is required to preserve (callee-saved registers). The function saves them at entry and restores them before returning.</p>
<h4 id="local-variables">Local Variables<a class="header-link" href="#local-variables" title="Permanent link">&para;</a></h4>
<p>Storage for the function's local variables, allocated at known offsets from the frame pointer.</p>
<h4 id="temporaries">Temporaries<a class="header-link" href="#temporaries" title="Permanent link">&para;</a></h4>
<p>Compiler-generated temporary values that do not fit in registers.</p>
<h3 id="24-accessing-local-variables">2.4 Accessing Local Variables<a class="header-link" href="#24-accessing-local-variables" title="Permanent link">&para;</a></h3>
<p>Local variables are accessed at fixed <strong>offsets</strong> from the frame pointer:</p>
<div class="highlight"><pre><span></span><code><span class="nx">Variable</span><span class="w"> </span><span class="nx">x</span><span class="w"> </span><span class="nx">declared</span><span class="w"> </span><span class="nx">at</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="o">-</span><span class="mi">8</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">FP</span><span class="p">:</span>
<span class="w">    </span><span class="nx">x</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">FP</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">8</span>

<span class="nx">Parameter</span><span class="w"> </span><span class="nx">p</span><span class="w"> </span><span class="nx">declared</span><span class="w"> </span><span class="nx">at</span><span class="w"> </span><span class="nx">offset</span><span class="w"> </span><span class="o">+</span><span class="mi">16</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">FP</span><span class="w"> </span><span class="p">(</span><span class="nx">above</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">address</span><span class="p">):</span>
<span class="w">    </span><span class="nx">p</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">FP</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">16</span>
</code></pre></div>

<p>The frame pointer provides a stable reference even as the stack pointer moves during function execution (e.g., when pushing arguments for a nested call).</p>
<h3 id="25-example-function-call-sequence">2.5 Example: Function Call Sequence<a class="header-link" href="#25-example-function-call-sequence" title="Permanent link">&para;</a></h3>
<p>Consider the following C code:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>The sequence of events during the call <code>add(x, y)</code>:</p>
<p><strong>1. Caller (main) -- Before the call</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="nx">push</span><span class="w"> </span><span class="nx">y</span><span class="w">        </span><span class="p">;</span><span class="w"> </span><span class="nx">push</span><span class="w"> </span><span class="nx">second</span><span class="w"> </span><span class="nx">argument</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nx">use</span><span class="w"> </span><span class="nx">register</span><span class="p">)</span>
<span class="nx">push</span><span class="w"> </span><span class="nx">x</span><span class="w">        </span><span class="p">;</span><span class="w"> </span><span class="nx">push</span><span class="w"> </span><span class="nx">first</span><span class="w"> </span><span class="nx">argument</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nx">use</span><span class="w"> </span><span class="nx">register</span><span class="p">)</span>
<span class="nx">call</span><span class="w"> </span><span class="nx">add</span><span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="nx">push</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nx">address</span><span class="p">,</span><span class="w"> </span><span class="nx">jump</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">add</span>
</code></pre></div>

<p><strong>2. Callee (add) -- Function prologue</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="nv">push</span><span class="w"> </span><span class="nv">rbp</span><span class="w">      </span><span class="c1">; save caller&#39;s frame pointer</span>
<span class="nv">mov</span><span class="w"> </span><span class="nv">rbp</span>,<span class="w"> </span><span class="nv">rsp</span><span class="w">  </span><span class="c1">; set new frame pointer</span>
<span class="nv">sub</span><span class="w"> </span><span class="nv">rsp</span>,<span class="w"> </span><span class="mi">16</span><span class="w">   </span><span class="c1">; allocate space for locals</span>
</code></pre></div>

<p><strong>3. Callee (add) -- Function body</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">mov</span><span class="w"> </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">rbp</span><span class="o">+</span><span class="mi">16</span><span class="p">]</span><span class="w">   </span><span class="p">;</span><span class="w"> </span><span class="nb">load</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="n">a</span>
<span class="n">add</span><span class="w"> </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">rbp</span><span class="o">+</span><span class="mi">24</span><span class="p">]</span><span class="w">   </span><span class="p">;</span><span class="w"> </span><span class="n">add</span><span class="w"> </span><span class="n">parameter</span><span class="w"> </span><span class="n">b</span>
<span class="n">mov</span><span class="w"> </span><span class="p">[</span><span class="n">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">],</span><span class="w"> </span><span class="n">eax</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="n">result</span>
</code></pre></div>

<p><strong>4. Callee (add) -- Function epilogue</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">mov</span><span class="w"> </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="nb">load</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">register</span>
<span class="n">mov</span><span class="w"> </span><span class="n">rsp</span><span class="p">,</span><span class="w"> </span><span class="n">rbp</span><span class="w">         </span><span class="p">;</span><span class="w"> </span><span class="n">deallocate</span><span class="w"> </span><span class="n">locals</span>
<span class="n">pop</span><span class="w"> </span><span class="n">rbp</span><span class="w">              </span><span class="p">;</span><span class="w"> </span><span class="n">restore</span><span class="w"> </span><span class="n">caller</span><span class="s1">&#39;s frame pointer</span>
<span class="n">ret</span><span class="w">                  </span><span class="p">;</span><span class="w"> </span><span class="n">pop</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">jump</span><span class="w"> </span><span class="n">back</span>
</code></pre></div>

<p><strong>5. Caller (main) -- After the call</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="nv">add</span><span class="w"> </span><span class="nv">rsp</span>,<span class="w"> </span><span class="mi">16</span><span class="w">          </span><span class="c1">; clean up arguments (in cdecl)</span>
<span class="nv">mov</span><span class="w"> </span>[<span class="nv">rbp</span><span class="o">-</span><span class="mi">24</span>],<span class="w"> </span><span class="nv">eax</span><span class="w">    </span><span class="c1">; store return value in z</span>
</code></pre></div>

<hr />
<h2 id="3-calling-conventions">3. Calling Conventions<a class="header-link" href="#3-calling-conventions" title="Permanent link">&para;</a></h2>
<h3 id="31-what-is-a-calling-convention">3.1 What Is a Calling Convention?<a class="header-link" href="#31-what-is-a-calling-convention" title="Permanent link">&para;</a></h3>
<p>A <strong>calling convention</strong> is a protocol that defines:</p>
<ol>
<li><strong>How arguments are passed</strong> (registers? stack? which order?)</li>
<li><strong>Who cleans up the stack</strong> (caller or callee?)</li>
<li><strong>Which registers are preserved</strong> (caller-saved vs callee-saved)</li>
<li><strong>How the return value is delivered</strong></li>
<li><strong>How the stack frame is structured</strong></li>
</ol>
<p>Calling conventions ensure that separately compiled functions can interact correctly.</p>
<h3 id="32-cdecl-c-declaration">3.2 cdecl (C Declaration)<a class="header-link" href="#32-cdecl-c-declaration" title="Permanent link">&para;</a></h3>
<p>The default calling convention for C on 32-bit x86.</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>cdecl</th>
</tr>
</thead>
<tbody>
<tr>
<td>Arguments</td>
<td>Pushed right-to-left on the stack</td>
</tr>
<tr>
<td>Stack cleanup</td>
<td>Caller cleans up</td>
</tr>
<tr>
<td>Return value</td>
<td>In <code>EAX</code> (integers), <code>ST(0)</code> (floats)</td>
</tr>
<tr>
<td>Callee-saved</td>
<td><code>EBX</code>, <code>ESI</code>, <code>EDI</code>, <code>EBP</code></td>
</tr>
<tr>
<td>Variadic support</td>
<td>Yes (caller knows arg count)</td>
</tr>
</tbody>
</table>
<p><strong>Right-to-left pushing</strong> means the first argument ends up at the lowest stack address, closest to the top of the stack. This enables variable-argument functions (<code>printf</code>, etc.) because the first argument is always at a known offset.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// Call: add(3, 4)</span>
<span class="n">push</span><span class="w"> </span><span class="mi">4</span><span class="w">         </span><span class="p">;</span><span class="w"> </span><span class="n">second</span><span class="w"> </span><span class="n">argument</span>
<span class="n">push</span><span class="w"> </span><span class="mi">3</span><span class="w">         </span><span class="p">;</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">argument</span>
<span class="nb">call</span><span class="w"> </span><span class="n">add</span>
<span class="n">add</span><span class="w"> </span><span class="n">esp</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">caller</span><span class="w"> </span><span class="n">cleans</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">args</span><span class="w"> </span>Ã—<span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">bytes</span><span class="p">)</span>
</code></pre></div>

<h3 id="33-stdcall">3.3 stdcall<a class="header-link" href="#33-stdcall" title="Permanent link">&para;</a></h3>
<p>Used by the Windows API (Win32 API).</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>stdcall</th>
</tr>
</thead>
<tbody>
<tr>
<td>Arguments</td>
<td>Pushed right-to-left on the stack</td>
</tr>
<tr>
<td>Stack cleanup</td>
<td><strong>Callee</strong> cleans up</td>
</tr>
<tr>
<td>Return value</td>
<td>In <code>EAX</code></td>
</tr>
<tr>
<td>Variadic support</td>
<td>No (callee must know exact arg count)</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code><span class="c1">// Callee epilogue includes:</span>
<span class="n">ret</span><span class="w"> </span><span class="mi">8</span><span class="w">          </span><span class="p">;</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nb">and</span><span class="w"> </span><span class="n">pop</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="n">args</span><span class="w"> </span>Ã—<span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">bytes</span><span class="p">)</span>
</code></pre></div>

<p><strong>Advantage</strong>: Slightly smaller code size because the cleanup instruction appears once in the callee rather than at every call site.</p>
<p><strong>Disadvantage</strong>: Cannot support variadic functions.</p>
<h3 id="34-system-v-amd64-abi-linuxmacos-x86-64">3.4 System V AMD64 ABI (Linux/macOS x86-64)<a class="header-link" href="#34-system-v-amd64-abi-linuxmacos-x86-64" title="Permanent link">&para;</a></h3>
<p>The modern 64-bit calling convention used on Linux, macOS, FreeBSD, and other Unix-like systems.</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>System V AMD64</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integer args (first 6)</td>
<td><code>RDI</code>, <code>RSI</code>, <code>RDX</code>, <code>RCX</code>, <code>R8</code>, <code>R9</code></td>
</tr>
<tr>
<td>Float args (first 8)</td>
<td><code>XMM0</code>--<code>XMM7</code></td>
</tr>
<tr>
<td>Additional args</td>
<td>Pushed right-to-left on the stack</td>
</tr>
<tr>
<td>Stack cleanup</td>
<td>Caller</td>
</tr>
<tr>
<td>Return value</td>
<td><code>RAX</code> (integer), <code>XMM0</code> (float)</td>
</tr>
<tr>
<td>Callee-saved</td>
<td><code>RBX</code>, <code>RBP</code>, <code>R12</code>--<code>R15</code></td>
</tr>
<tr>
<td>Stack alignment</td>
<td>16-byte aligned before <code>CALL</code></td>
</tr>
<tr>
<td>Red zone</td>
<td>128 bytes below RSP (leaf functions can use without adjusting RSP)</td>
</tr>
</tbody>
</table>
<p><strong>Example</strong>: Call <code>f(1, 2, 3, 4, 5, 6, 7, 8)</code>:</p>
<div class="highlight"><pre><span></span><code><span class="c1">; Arguments 1-6 in registers</span>
<span class="nf">mov</span><span class="w"> </span><span class="no">rdi</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="nf">mov</span><span class="w"> </span><span class="no">rsi</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span>
<span class="nf">mov</span><span class="w"> </span><span class="no">rdx</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span>
<span class="nf">mov</span><span class="w"> </span><span class="no">rcx</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span>
<span class="nf">mov</span><span class="w"> </span><span class="no">r8</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span>
<span class="nf">mov</span><span class="w"> </span><span class="no">r9</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span>
<span class="c1">; Arguments 7-8 on the stack (right to left)</span>
<span class="nf">push</span><span class="w"> </span><span class="mi">8</span>
<span class="nf">push</span><span class="w"> </span><span class="mi">7</span>
<span class="nf">call</span><span class="w"> </span><span class="no">f</span>
<span class="nf">add</span><span class="w"> </span><span class="no">rsp</span><span class="p">,</span><span class="w"> </span><span class="mi">16</span><span class="w">   </span><span class="c1">; caller cleans up stack args</span>
</code></pre></div>

<h3 id="35-comparison-table">3.5 Comparison Table<a class="header-link" href="#35-comparison-table" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>cdecl (x86)</th>
<th>stdcall (x86)</th>
<th>System V AMD64</th>
</tr>
</thead>
<tbody>
<tr>
<td>Arg passing</td>
<td>Stack only</td>
<td>Stack only</td>
<td>6 regs + stack</td>
</tr>
<tr>
<td>Arg order</td>
<td>Right-to-left</td>
<td>Right-to-left</td>
<td>Left-to-right (regs)</td>
</tr>
<tr>
<td>Cleanup</td>
<td>Caller</td>
<td>Callee</td>
<td>Caller</td>
</tr>
<tr>
<td>Variadic</td>
<td>Yes</td>
<td>No</td>
<td>Yes</td>
</tr>
<tr>
<td>Performance</td>
<td>Moderate</td>
<td>Moderate</td>
<td>Better (register passing)</td>
</tr>
<tr>
<td>Platform</td>
<td>Unix/Windows 32-bit</td>
<td>Windows 32-bit</td>
<td>Linux/macOS 64-bit</td>
</tr>
</tbody>
</table>
<h3 id="36-windows-x64-calling-convention">3.6 Windows x64 Calling Convention<a class="header-link" href="#36-windows-x64-calling-convention" title="Permanent link">&para;</a></h3>
<p>For completeness, Windows 64-bit uses a different convention:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Windows x64</th>
</tr>
</thead>
<tbody>
<tr>
<td>Integer args (first 4)</td>
<td><code>RCX</code>, <code>RDX</code>, <code>R8</code>, <code>R9</code></td>
</tr>
<tr>
<td>Float args (first 4)</td>
<td><code>XMM0</code>--<code>XMM3</code></td>
</tr>
<tr>
<td>Shadow space</td>
<td>32 bytes reserved by caller for callee's use</td>
</tr>
<tr>
<td>Return value</td>
<td><code>RAX</code> (integer), <code>XMM0</code> (float)</td>
</tr>
<tr>
<td>Stack alignment</td>
<td>16-byte aligned</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="4-parameter-passing-mechanisms">4. Parameter Passing Mechanisms<a class="header-link" href="#4-parameter-passing-mechanisms" title="Permanent link">&para;</a></h2>
<h3 id="41-call-by-value">4.1 Call by Value<a class="header-link" href="#41-call-by-value" title="Permanent link">&para;</a></h3>
<p>The <strong>caller</strong> evaluates the argument expression and passes a <strong>copy</strong> of the value to the callee. Modifications to the parameter inside the callee do not affect the original variable.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">   </span><span class="c1">// Modifies the local copy only</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="n">increment</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// a is still 5</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Implementation</strong>: The value is copied into the callee's parameter slot (register or stack location).</p>
<p><strong>Languages</strong>: C, Java (primitives), Go (non-pointer types)</p>
<h3 id="42-call-by-reference">4.2 Call by Reference<a class="header-link" href="#42-call-by-reference" title="Permanent link">&para;</a></h3>
<p>The caller passes the <strong>address</strong> (reference) of the argument. The callee can read and modify the original variable through this address.</p>
<div class="highlight"><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">&amp;</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">   </span><span class="c1">// Modifies the original variable</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">    </span><span class="n">increment</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// a is now 6</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Implementation</strong>: The address of the variable is passed. Inside the callee, every access to the parameter is an indirect memory access through the pointer.</p>
<div class="highlight"><pre><span></span><code><span class="p">;</span><span class="w"> </span><span class="nl">Caller</span><span class="p">:</span>
<span class="n">lea</span><span class="w"> </span><span class="n">rdi</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">rbp-8</span><span class="o">]</span><span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">pass</span><span class="w"> </span><span class="n">address</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">a</span>
<span class="k">call</span><span class="w"> </span><span class="n">increment</span>

<span class="p">;</span><span class="w"> </span><span class="nl">Callee</span><span class="p">:</span>
<span class="n">mov</span><span class="w"> </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">rdi</span><span class="o">]</span><span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">dereference</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">read</span><span class="w"> </span><span class="n">a</span>
<span class="k">add</span><span class="w"> </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span>
<span class="n">mov</span><span class="w"> </span><span class="o">[</span><span class="n">rdi</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">eax</span><span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">dereference</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="n">a</span>
</code></pre></div>

<p><strong>Languages</strong>: C++ (references), Fortran (default), C# (<code>ref</code> parameters)</p>
<h3 id="43-call-by-value-result-copy-in-copy-out">4.3 Call by Value-Result (Copy-In, Copy-Out)<a class="header-link" href="#43-call-by-value-result-copy-in-copy-out" title="Permanent link">&para;</a></h3>
<p>The value is <strong>copied in</strong> when the function is called and <strong>copied out</strong> when the function returns. This differs from call-by-reference when aliasing occurs.</p>
<div class="highlight"><pre><span></span><code><span class="k">proc</span><span class="nv">edure</span><span class="w"> </span><span class="nv">swap</span><span class="p">(</span><span class="nv">x</span><span class="p">,</span><span class="w"> </span><span class="nv">y</span><span class="p">):</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="nf">Copies</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">actual</span><span class="w"> </span><span class="nv">args</span><span class="w"> </span><span class="nv">are</span><span class="w"> </span><span class="nv">made</span><span class="w"> </span><span class="p">(</span><span class="nv">copy</span><span class="o">-</span><span class="nv">in</span><span class="p">)</span>
<span class="w">    </span><span class="nf">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">x</span>
<span class="w">    </span><span class="nf">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">y</span>
<span class="w">    </span><span class="nf">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">temp</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="nf">Copies</span><span class="w"> </span><span class="nv">are</span><span class="w"> </span><span class="nv">written</span><span class="w"> </span><span class="nv">back</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">actuals</span><span class="w"> </span><span class="p">(</span><span class="nv">copy</span><span class="o">-</span><span class="nv">out</span><span class="p">)</span>
</code></pre></div>

<p>If called as <code>swap(a, a)</code> with call-by-reference, the result is undefined because both parameters alias the same variable. With call-by-value-result, the final value depends on which copy-out happens last.</p>
<p><strong>Languages</strong>: Ada (<code>in out</code> parameters)</p>
<h3 id="44-call-by-name">4.4 Call by Name<a class="header-link" href="#44-call-by-name" title="Permanent link">&para;</a></h3>
<p>The argument is not evaluated at the call site. Instead, the <strong>text</strong> (or a closure-like thunk) of the argument expression is passed. Each time the callee refers to the parameter, the expression is re-evaluated in the caller's environment.</p>
<p>This is historically associated with Algol 60. The argument is essentially a <strong>thunk</strong> -- a parameterless function that, when called, evaluates the expression.</p>
<p><strong>Classic example -- Jensen's device</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="o">//</span><span class="w"> </span><span class="n">Algol</span><span class="w"> </span><span class="mi">60</span><span class="w"> </span><span class="n">pseudocode</span>
<span class="n">real</span><span class="w"> </span><span class="n">procedure</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">i</span><span class="o">,</span><span class="w"> </span><span class="n">lo</span><span class="o">,</span><span class="w"> </span><span class="n">hi</span><span class="o">,</span><span class="w"> </span><span class="n">expr</span><span class="p">);</span>
<span class="w">    </span><span class="n">name</span><span class="w"> </span><span class="n">i</span><span class="o">,</span><span class="w"> </span><span class="n">expr</span><span class="p">;</span><span class="w">       </span><span class="o">//</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">name</span>
<span class="w">    </span><span class="n">value</span><span class="w"> </span><span class="n">lo</span><span class="o">,</span><span class="w"> </span><span class="n">hi</span><span class="p">;</span><span class="w">       </span><span class="o">//</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="k">by</span><span class="w"> </span><span class="n">value</span>
<span class="w">    </span><span class="n">integer</span><span class="w"> </span><span class="n">i</span><span class="o">,</span><span class="w"> </span><span class="n">lo</span><span class="o">,</span><span class="w"> </span><span class="n">hi</span><span class="p">;</span>
<span class="w">    </span><span class="n">real</span><span class="w"> </span><span class="n">expr</span><span class="p">;</span>
<span class="n">begin</span>
<span class="w">    </span><span class="n">real</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="w">    </span><span class="n">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">lo</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">until</span><span class="w"> </span><span class="n">hi</span><span class="w"> </span><span class="k">do</span>
<span class="w">        </span><span class="n">s</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">expr</span><span class="p">;</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">expr</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">re</span><span class="o">-</span><span class="n">evaluated</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">iteration</span>
<span class="w">    </span><span class="n">sum</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<span class="k">end</span><span class="p">;</span>

<span class="o">//</span><span class="w"> </span><span class="n">Usage</span><span class="o">:</span><span class="w"> </span><span class="n">compute</span><span class="w"> </span><span class="n">sum</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="mi">10</span>
<span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sum</span><span class="p">(</span><span class="n">i</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">10</span><span class="o">,</span><span class="w"> </span><span class="n">i</span><span class="o">*</span><span class="n">i</span><span class="p">);</span>
</code></pre></div>

<p>Each time <code>expr</code> is referenced, the thunk <code>i*i</code> is evaluated with the current value of <code>i</code>.</p>
<p><strong>Implementation</strong>: A thunk is a small closure containing the expression code and the environment in which to evaluate it.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Python simulation of call-by-name using thunks</span>

<span class="k">def</span><span class="w"> </span><span class="nf">call_by_name_demo</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate call-by-name with thunks.&quot;&quot;&quot;</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">i_thunk</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Thunk that returns the current value of i.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">i</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">a_i_thunk</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Thunk that evaluates a[i] each time it is called.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_a_i</span><span class="p">(</span><span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Thunk to set a[i].&quot;&quot;&quot;</span>
        <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="c1"># Simulate swap(i, a[i]) with call-by-name</span>
    <span class="c1"># Each access to parameters re-evaluates the thunk</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before: i=</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, a=</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># swap body: temp = x; x = y; y = temp</span>
    <span class="n">temp</span> <span class="o">=</span> <span class="n">i_thunk</span><span class="p">()</span>            <span class="c1"># temp = i (evaluates to 0)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">a_i_thunk</span><span class="p">()</span>             <span class="c1"># i = a[i] = a[0] = 1</span>
    <span class="n">set_a_i</span><span class="p">(</span><span class="n">temp</span><span class="p">)</span>               <span class="c1"># a[i] = temp, but now i=1, so a[1] = 0</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After:  i=</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">, a=</span><span class="si">{</span><span class="n">a</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Result: i=1, a=[1, 0, 3, 4, 5]</span>
    <span class="c1"># Note: a[0] is unchanged because by the time we write,</span>
    <span class="c1"># i has changed to 1</span>

<span class="n">call_by_name_demo</span><span class="p">()</span>
</code></pre></div>

<h3 id="45-comparison-of-parameter-passing-mechanisms">4.5 Comparison of Parameter Passing Mechanisms<a class="header-link" href="#45-comparison-of-parameter-passing-mechanisms" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Mechanism</th>
<th>Evaluation time</th>
<th>Aliasing effects</th>
<th>Performance</th>
</tr>
</thead>
<tbody>
<tr>
<td>By value</td>
<td>At call site</td>
<td>None</td>
<td>Copy cost</td>
</tr>
<tr>
<td>By reference</td>
<td>At call site</td>
<td>Yes</td>
<td>Indirection cost</td>
</tr>
<tr>
<td>By value-result</td>
<td>At call + return</td>
<td>Defined by copy order</td>
<td>Two copies</td>
</tr>
<tr>
<td>By name</td>
<td>Each use</td>
<td>Complex</td>
<td>Thunk overhead per use</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="5-nested-functions-and-static-scoping">5. Nested Functions and Static Scoping<a class="header-link" href="#5-nested-functions-and-static-scoping" title="Permanent link">&para;</a></h2>
<h3 id="51-the-problem-of-nested-scopes">5.1 The Problem of Nested Scopes<a class="header-link" href="#51-the-problem-of-nested-scopes" title="Permanent link">&para;</a></h3>
<p>Languages like Pascal, Ada, Python, and ML allow functions to be nested inside other functions. A nested function can access variables from its enclosing scope:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">outer</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">middle</span><span class="p">():</span>
        <span class="n">y</span> <span class="o">=</span> <span class="mi">20</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">inner</span><span class="p">():</span>
            <span class="c1"># inner can access x, y, and its own locals</span>
            <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">30</span>

        <span class="k">return</span> <span class="n">inner</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">middle</span><span class="p">()</span>
</code></pre></div>

<p>When <code>inner</code> executes, it needs to access <code>x</code> from <code>outer</code>'s frame and <code>y</code> from <code>middle</code>'s frame. But these frames are on the stack, and <code>inner</code>'s frame is the topmost. How does <code>inner</code> find the frames of its lexically enclosing functions?</p>
<h3 id="52-access-links-static-links">5.2 Access Links (Static Links)<a class="header-link" href="#52-access-links-static-links" title="Permanent link">&para;</a></h3>
<p>An <strong>access link</strong> (or <strong>static link</strong>) is a pointer stored in each activation record that points to the activation record of the <strong>lexically enclosing function</strong>.</p>
<div class="highlight"><pre><span></span><code>Stack:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  inner&#39;s frame     â”‚
â”‚  access link â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”
â”‚  local: (none)     â”‚   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  middle&#39;s frame    â”‚ â—€â”€â”˜
â”‚  access link â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”
â”‚  local: y = 20     â”‚   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  outer&#39;s frame     â”‚ â—€â”€â”˜
â”‚  access link = nil â”‚
â”‚  local: x = 10     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></div>

<p>To access a variable at nesting depth $d_{\text{var}}$ from a function at nesting depth $d_{\text{func}}$, the runtime follows $d_{\text{func}} - d_{\text{var}}$ access links.</p>
<p><strong>Time complexity for variable access</strong>: $O(d_{\text{func}} - d_{\text{var}})$, proportional to the nesting depth difference.</p>
<h3 id="53-how-access-links-are-maintained">5.3 How Access Links Are Maintained<a class="header-link" href="#53-how-access-links-are-maintained" title="Permanent link">&para;</a></h3>
<p>When function $f$ at depth $d_f$ calls function $g$ at depth $d_g$:</p>
<ol>
<li>If $d_g = d_f + 1$ (calling a directly nested function):</li>
<li>
<p>$g$'s access link points to $f$'s frame.</p>
</li>
<li>
<p>If $d_g \leq d_f$ (calling a function at the same or outer level):</p>
</li>
<li>Follow $d_f - d_g + 1$ access links from $f$'s frame to find the frame of $g$'s lexically enclosing function.</li>
<li>$g$'s access link points to that frame.</li>
</ol>
<h3 id="54-displays">5.4 Displays<a class="header-link" href="#54-displays" title="Permanent link">&para;</a></h3>
<p>A <strong>display</strong> is an array-based optimization for access links. Instead of following a chain of links, the display maintains a global array $D$ where $D[i]$ holds a pointer to the most recent activation record at nesting depth $i$.</p>
<div class="highlight"><pre><span></span><code>Display D:
D[0] â”€â”€â–¶ outer&#39;s frame
D[1] â”€â”€â–¶ middle&#39;s frame
D[2] â”€â”€â–¶ inner&#39;s frame
</code></pre></div>

<p><strong>Access a variable at depth $k$</strong>: Simply look up $D[k]$ and add the offset. This is $O(1)$ regardless of nesting depth.</p>
<p><strong>Maintenance</strong>: When entering a function at depth $k$:
1. Save the old value of $D[k]$
2. Set $D[k]$ to the current frame pointer</p>
<p>When leaving:
1. Restore $D[k]$ from the saved value</p>
<h3 id="55-comparison-access-links-vs-displays">5.5 Comparison: Access Links vs Displays<a class="header-link" href="#55-comparison-access-links-vs-displays" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Access Links</th>
<th>Displays</th>
</tr>
</thead>
<tbody>
<tr>
<td>Storage</td>
<td>One pointer per frame</td>
<td>Global array (size = max depth)</td>
</tr>
<tr>
<td>Variable access</td>
<td>$O(\text{depth difference})$</td>
<td>$O(1)$</td>
</tr>
<tr>
<td>Maintenance</td>
<td>Simple pointer assignment</td>
<td>Save/restore array entry</td>
</tr>
<tr>
<td>Closures</td>
<td>Natural (link is part of closure)</td>
<td>More complex (must capture array state)</td>
</tr>
<tr>
<td>Common in</td>
<td>Modern compilers</td>
<td>Older compilers (Burroughs B5000)</td>
</tr>
</tbody>
</table>
<h3 id="56-closures">5.6 Closures<a class="header-link" href="#56-closures" title="Permanent link">&para;</a></h3>
<p>A <strong>closure</strong> captures a function together with its lexical environment (the access link or equivalent). When a function is returned as a value or stored in a data structure, the closure ensures it can still access variables from its enclosing scope.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">make_adder</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="n">y</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>    <span class="c1"># x is captured from make_adder&#39;s scope</span>
    <span class="k">return</span> <span class="n">add</span>           <span class="c1"># Returns a closure</span>

<span class="n">add5</span> <span class="o">=</span> <span class="n">make_adder</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">add5</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span>           <span class="c1"># Output: 8</span>
</code></pre></div>

<p><strong>Implementation challenges</strong>:
- If the enclosing function's frame is on the stack, it will be deallocated when the function returns.
- The closure must keep the captured variables alive, typically by allocating them on the <strong>heap</strong> instead of the stack (this is called "variable escape" or "closure conversion").</p>
<hr />
<h2 id="6-dynamic-scoping-vs-static-scoping">6. Dynamic Scoping vs Static Scoping<a class="header-link" href="#6-dynamic-scoping-vs-static-scoping" title="Permanent link">&para;</a></h2>
<h3 id="61-static-lexical-scoping">6.1 Static (Lexical) Scoping<a class="header-link" href="#61-static-lexical-scoping" title="Permanent link">&para;</a></h3>
<p>In <strong>static scoping</strong>, the binding of a variable is determined by the program's text (the lexical structure). A variable reference is resolved by looking outward through enclosing scopes at compile time.</p>
<div class="highlight"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>

<span class="k">def</span><span class="w"> </span><span class="nf">foo</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">x</span>     <span class="c1"># Always refers to the global x (=10)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">bar</span><span class="p">():</span>
    <span class="n">x</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="k">return</span> <span class="n">foo</span><span class="p">()</span> <span class="c1"># foo still sees x=10 (static scoping)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">bar</span><span class="p">())</span>     <span class="c1"># Output: 10</span>
</code></pre></div>

<p><strong>Implementation</strong>: Access links or displays at runtime. The chain of scopes is determined by where functions are <strong>defined</strong>, not where they are <strong>called</strong>.</p>
<h3 id="62-dynamic-scoping">6.2 Dynamic Scoping<a class="header-link" href="#62-dynamic-scoping" title="Permanent link">&para;</a></h3>
<p>In <strong>dynamic scoping</strong>, the binding of a variable is determined by the runtime call chain. A variable reference is resolved by looking through the <strong>call stack</strong> for the most recent binding.</p>
<div class="highlight"><pre><span></span><code><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span>

<span class="nv">function</span><span class="w"> </span><span class="nv">foo</span><span class="ss">()</span>:
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">x</span><span class="w">     </span><span class="o">//</span><span class="w"> </span><span class="nv">In</span><span class="w"> </span><span class="nv">dynamic</span><span class="w"> </span><span class="nv">scoping</span>,<span class="w"> </span><span class="nv">depends</span><span class="w"> </span><span class="nv">on</span><span class="w"> </span><span class="nv">who</span><span class="w"> </span><span class="nv">called</span><span class="w"> </span><span class="nv">foo</span>

<span class="nv">function</span><span class="w"> </span><span class="nv">bar</span><span class="ss">()</span>:
<span class="w">    </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">20</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">foo</span><span class="ss">()</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nv">foo</span><span class="w"> </span><span class="nv">sees</span><span class="w"> </span><span class="nv">x</span><span class="o">=</span><span class="mi">20</span><span class="w"> </span><span class="nv">because</span><span class="w"> </span><span class="nv">bar</span><span class="err">&#39;s binding is on the stack</span>

<span class="err">bar()            // returns 20 (dynamic scoping)</span>
</code></pre></div>

<p><strong>Languages</strong>: Early Lisp, Bash/shell scripts, Emacs Lisp, Perl (with <code>local</code>).</p>
<h3 id="63-runtime-implementation">6.3 Runtime Implementation<a class="header-link" href="#63-runtime-implementation" title="Permanent link">&para;</a></h3>
<h4 id="static-scoping-runtime">Static Scoping Runtime<a class="header-link" href="#static-scoping-runtime" title="Permanent link">&para;</a></h4>
<ul>
<li>Use <strong>access links</strong> that follow lexical nesting</li>
<li>Variable locations are determined at <strong>compile time</strong> (offset from a specific frame)</li>
<li>The access link chain is based on <strong>where functions are defined</strong></li>
</ul>
<h4 id="dynamic-scoping-runtime">Dynamic Scoping Runtime<a class="header-link" href="#dynamic-scoping-runtime" title="Permanent link">&para;</a></h4>
<p>There are two common implementations:</p>
<p><strong>1. Deep access</strong>: Walk up the <strong>call stack</strong> (dynamic chain) searching for the variable binding. Each frame stores variable names along with their values.</p>
<div class="highlight"><pre><span></span><code><span class="k">function</span><span class="w"> </span><span class="nf">lookup</span><span class="p">(</span>var_name<span class="p">):</span>
<span class="w">    </span><span class="n">frame</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">current_frame</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">frame</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="nb">null</span><span class="p">:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="n">var_name</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">frame</span><span class="p">.</span><span class="n">locals</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">frame</span><span class="p">.</span><span class="n">locals</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span>
<span class="w">        </span><span class="n">frame</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">frame</span><span class="p">.</span><span class="n">dynamic_link</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">follow</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="n">chain</span>
<span class="w">    </span><span class="nb">error</span><span class="p">(</span><span class="s">&quot;unbound variable&quot;</span><span class="p">)</span>
</code></pre></div>

<p><strong>Time complexity</strong>: $O(d)$ where $d$ is the depth of the call stack.</p>
<p><strong>2. Shallow access</strong>: Maintain a <strong>central table</strong> (one entry per variable name) that always holds the current binding. When a function is entered, save the old binding and install the new one. When the function exits, restore the old binding.</p>
<div class="highlight"><pre><span></span><code><span class="n">central_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{}</span>
<span class="n">save_stack</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{}</span>

<span class="k">function</span><span class="w"> </span><span class="n">enter_scope</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span><span class="w"> </span><span class="k">value</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="k">save</span><span class="w"> </span><span class="k">old</span><span class="w"> </span><span class="n">central_table</span><span class="o">[</span><span class="n">var_name</span><span class="o">]</span>
<span class="w">    </span><span class="n">central_table</span><span class="o">[</span><span class="n">var_name</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">value</span>

<span class="k">function</span><span class="w"> </span><span class="n">exit_scope</span><span class="p">(</span><span class="n">var_name</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">central_table</span><span class="o">[</span><span class="n">var_name</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">saved</span><span class="w"> </span><span class="k">value</span>
</code></pre></div>

<p><strong>Time complexity</strong>: $O(1)$ for variable access; $O(k)$ for entering/exiting a scope with $k$ local variables.</p>
<h3 id="64-python-simulation-static-vs-dynamic-scoping">6.4 Python Simulation: Static vs Dynamic Scoping<a class="header-link" href="#64-python-simulation-static-vs-dynamic-scoping" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;Demonstrate the difference between static and dynamic scoping.&quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Environment</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A simple environment for variable lookup.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bindings</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span> <span class="o">=</span> <span class="n">bindings</span> <span class="ow">or</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unbound variable: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>


<span class="c1"># ---------- Static Scoping ----------</span>

<span class="k">class</span><span class="w"> </span><span class="nc">StaticScopingInterpreter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpreter with static (lexical) scoping.</span>
<span class="sd">    Each function captures its definition environment.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">define_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">define_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">def_env</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Store a function as a closure: (params, body, defining_env).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">env</span> <span class="o">=</span> <span class="n">def_env</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span>
        <span class="n">closure</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>  <span class="c1"># Captures definition environment</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">closure</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">closure</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">call_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call a function. Variable lookup uses the DEFINITION environment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">closure</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">def_env</span> <span class="o">=</span> <span class="n">closure</span>

        <span class="c1"># Create new scope with definition environment as parent (static)</span>
        <span class="n">call_env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">(</span>
            <span class="n">bindings</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">)),</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">def_env</span>  <span class="c1"># &lt;-- STATIC: uses definition environment</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">body</span><span class="p">(</span><span class="n">call_env</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DynamicScopingInterpreter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interpreter with dynamic scoping.</span>
<span class="sd">    Variable lookup follows the call chain.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">define_var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">define_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">call_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">caller_env</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call a function. Variable lookup uses the CALLER&#39;s environment.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="n">params</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="n">func</span>

        <span class="n">parent</span> <span class="o">=</span> <span class="n">caller_env</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span>

        <span class="c1"># Create new scope with caller&#39;s environment as parent (dynamic)</span>
        <span class="n">call_env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">(</span>
            <span class="n">bindings</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">)),</span>
            <span class="n">parent</span><span class="o">=</span><span class="n">parent</span>  <span class="c1"># &lt;-- DYNAMIC: uses caller&#39;s environment</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">body</span><span class="p">(</span><span class="n">call_env</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_scoping</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate the difference.&quot;&quot;&quot;</span>

    <span class="c1"># --- Static Scoping ---</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Static Scoping ===&quot;</span><span class="p">)</span>
    <span class="n">static</span> <span class="o">=</span> <span class="n">StaticScopingInterpreter</span><span class="p">()</span>
    <span class="n">static</span><span class="o">.</span><span class="n">define_var</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="c1"># foo returns x (defined in global scope where x=10)</span>
    <span class="n">static</span><span class="o">.</span><span class="n">define_function</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="p">[],</span>
        <span class="k">lambda</span> <span class="n">env</span><span class="p">:</span> <span class="n">env</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>

    <span class="c1"># bar sets x=20 locally, then calls foo</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">bar_body_static</span><span class="p">(</span><span class="n">env</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">static</span><span class="o">.</span><span class="n">call_function</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="p">[])</span>

    <span class="n">static</span><span class="o">.</span><span class="n">define_function</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="p">[],</span>
        <span class="k">lambda</span> <span class="n">env</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">),</span>
            <span class="n">static</span><span class="o">.</span><span class="n">call_function</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="p">[])</span>
        <span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">static</span><span class="o">.</span><span class="n">call_function</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  bar() calls foo(), foo sees x = </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Static: foo sees x=10 (from its definition environment)</span>

    <span class="c1"># --- Dynamic Scoping ---</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Dynamic Scoping ===&quot;</span><span class="p">)</span>
    <span class="n">dynamic</span> <span class="o">=</span> <span class="n">DynamicScopingInterpreter</span><span class="p">()</span>
    <span class="n">dynamic</span><span class="o">.</span><span class="n">define_var</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="n">dynamic</span><span class="o">.</span><span class="n">define_function</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="p">[],</span>
        <span class="k">lambda</span> <span class="n">env</span><span class="p">:</span> <span class="n">env</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">bar_body_dynamic</span><span class="p">(</span><span class="n">env</span><span class="p">):</span>
        <span class="n">env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dynamic</span><span class="o">.</span><span class="n">call_function</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span> <span class="p">[],</span> <span class="n">caller_env</span><span class="o">=</span><span class="n">env</span><span class="p">)</span>

    <span class="n">dynamic</span><span class="o">.</span><span class="n">define_function</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="p">[],</span> <span class="n">bar_body_dynamic</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">dynamic</span><span class="o">.</span><span class="n">call_function</span><span class="p">(</span><span class="s2">&quot;bar&quot;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  bar() calls foo(), foo sees x = </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Dynamic: foo sees x=20 (from bar&#39;s environment on the call chain)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo_scoping</span><span class="p">()</span>
</code></pre></div>

<p><strong>Expected output</strong>:</p>
<div class="highlight"><pre><span></span><code>=== Static Scoping ===
  bar() calls foo(), foo sees x = 10

=== Dynamic Scoping ===
  bar() calls foo(), foo sees x = 20
</code></pre></div>

<hr />
<h2 id="7-heap-management">7. Heap Management<a class="header-link" href="#7-heap-management" title="Permanent link">&para;</a></h2>
<h3 id="71-why-heap-allocation">7.1 Why Heap Allocation?<a class="header-link" href="#71-why-heap-allocation" title="Permanent link">&para;</a></h3>
<p>The stack provides efficient memory management for data with <strong>last-in, first-out</strong> lifetimes. But not all data follows this pattern:</p>
<ul>
<li>Objects whose lifetime extends beyond the function that created them</li>
<li>Data structures that grow or shrink dynamically (lists, trees, hash tables)</li>
<li>Closures that capture variables from enclosing scopes</li>
</ul>
<p>Such data must be allocated on the <strong>heap</strong>.</p>
<h3 id="72-explicit-allocation-and-deallocation">7.2 Explicit Allocation and Deallocation<a class="header-link" href="#72-explicit-allocation-and-deallocation" title="Permanent link">&para;</a></h3>
<p>In languages like C and C++, the programmer explicitly manages heap memory:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">p</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">100</span><span class="p">);</span><span class="w">  </span><span class="c1">// allocate</span>
<span class="c1">// ... use p ...</span>
<span class="n">free</span><span class="p">(</span><span class="n">p</span><span class="p">);</span><span class="w">                              </span><span class="c1">// deallocate</span>
</code></pre></div>

<p><strong>Problems with explicit management</strong>:
- <strong>Memory leaks</strong>: Forgetting to free memory
- <strong>Dangling pointers</strong>: Using memory after it has been freed
- <strong>Double free</strong>: Freeing the same memory twice
- <strong>Fragmentation</strong>: Free blocks scattered throughout the heap</p>
<h3 id="73-free-list-management">7.3 Free List Management<a class="header-link" href="#73-free-list-management" title="Permanent link">&para;</a></h3>
<p>A <strong>free list</strong> is a linked list of free memory blocks. The allocator searches this list to find a suitable block for each allocation request.</p>
<div class="highlight"><pre><span></span><code>Heap:
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚USED â”‚  FREE    â”‚USED â”‚ FREE â”‚USED â”‚  FREE    â”‚
â”‚100B â”‚  200B    â”‚150B â”‚  50B â”‚80B  â”‚  300B    â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Free list:
head â”€â”€â–¶ [200B] â”€â”€â–¶ [50B] â”€â”€â–¶ [300B] â”€â”€â–¶ null
</code></pre></div>

<h4 id="allocation-strategies">Allocation Strategies<a class="header-link" href="#allocation-strategies" title="Permanent link">&para;</a></h4>
<p><strong>First Fit</strong>: Scan the free list from the beginning and return the first block that is large enough.
- Fast allocation
- Tends to cause fragmentation at the beginning of the heap</p>
<p><strong>Best Fit</strong>: Scan the entire free list and return the smallest block that is large enough.
- Minimizes wasted space per allocation
- Slow (must scan entire list); creates many tiny unusable fragments</p>
<p><strong>Worst Fit</strong>: Return the largest free block.
- Leaves the biggest remaining fragment (might be useful later)
- Also slow; often performs poorly in practice</p>
<p><strong>Next Fit</strong>: Like first fit, but starts scanning from where the previous search left off.
- Distributes allocations more evenly across the heap
- Avoids always fragmenting the beginning</p>
<h4 id="coalescing">Coalescing<a class="header-link" href="#coalescing" title="Permanent link">&para;</a></h4>
<p>When a block is freed, the allocator checks whether adjacent blocks are also free and <strong>merges</strong> (coalesces) them into a larger block:</p>
<div class="highlight"><pre><span></span><code>Before free(B):
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  A  â”‚  B(used) â”‚  C  â”‚  D(free) â”‚
â”‚free â”‚          â”‚free â”‚          â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

After free(B) with coalescing:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   A + B + C (merged)    â”‚  D(free) â”‚
â”‚        free             â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></div>

<p>Coalescing reduces external fragmentation. To make coalescing efficient, each block typically stores:
- A <strong>header</strong> with the block size and allocation status
- A <strong>footer</strong> (boundary tag) with the block size, enabling backward coalescing</p>
<h3 id="74-buddy-system">7.4 Buddy System<a class="header-link" href="#74-buddy-system" title="Permanent link">&para;</a></h3>
<p>The <strong>buddy system</strong> organizes heap memory into blocks whose sizes are powers of 2. This simplifies splitting and coalescing.</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Memory is divided into blocks of sizes $2^0, 2^1, 2^2, \ldots, 2^k$</li>
<li>Maintain separate free lists for each block size</li>
</ol>
<p><strong>Allocation</strong> of $n$ bytes:
1. Round up $n$ to the next power of 2, say $2^j$
2. Find the smallest free block of size $\geq 2^j$
3. If the found block is larger than needed (say size $2^{j+k}$):
   - Split it repeatedly into <strong>buddies</strong> (two equal halves) until you get a block of size $2^j$
   - Add the unused buddies to their respective free lists</p>
<p><strong>Deallocation</strong>:
1. Free the block
2. Check if its <strong>buddy</strong> (the other half of the split) is also free
3. If yes, coalesce them into a larger block
4. Repeat coalescing recursively</p>
<p><strong>Finding the buddy</strong>: For a block of size $2^j$ at address $A$, its buddy is at:</p>
<p>$$\text{buddy}(A, j) = A \oplus 2^j$$</p>
<p>where $\oplus$ is the bitwise XOR operation.</p>
<p><strong>Example</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">Initial</span><span class="o">:</span><span class="w"> </span><span class="n">One</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="mi">1024</span><span class="w"> </span><span class="n">bytes</span>

<span class="n">Request</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="n">bytes</span><span class="w"> </span><span class="o">(</span><span class="n">rounded</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">128</span><span class="o">):</span>
<span class="mi">1024</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">split</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="mi">512</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">512</span>
<span class="w">           </span><span class="err">â†’</span><span class="w"> </span><span class="n">split</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="mi">256</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">256</span>
<span class="w">               </span><span class="err">â†’</span><span class="w"> </span><span class="n">split</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="mi">128</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">128</span>
<span class="w">                           </span><span class="err">â†‘</span><span class="w"> </span><span class="n">allocated</span>

<span class="n">Free</span><span class="w"> </span><span class="n">lists</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">allocation</span><span class="o">:</span>
<span class="mi">512</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="n">block</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="mi">512</span><span class="o">]</span>
<span class="mi">256</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="n">block</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="mi">256</span><span class="o">]</span>
<span class="mi">128</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="n">block</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="mi">128</span><span class="o">]</span><span class="w">    </span><span class="o">(</span><span class="n">the</span><span class="w"> </span><span class="n">other</span><span class="w"> </span><span class="n">buddy</span><span class="o">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;Buddy System allocator simulation.&quot;&quot;&quot;</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">math</span>


<span class="k">class</span><span class="w"> </span><span class="nc">BuddyAllocator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplified buddy system memory allocator.</span>
<span class="sd">    All sizes are powers of 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">total_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize with total_size (must be a power of 2).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_size</span> <span class="o">=</span> <span class="n">total_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_block</span> <span class="o">=</span> <span class="mi">16</span>  <span class="c1"># Minimum block size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">total_size</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_block</span><span class="p">))</span>

        <span class="c1"># Free lists indexed by order (2^order = block size)</span>
        <span class="c1"># Each entry is a set of block start addresses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_lists</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">order</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">}</span>

        <span class="c1"># Initially, one big free block</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_lists</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">max_order</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Track allocated blocks: address -&gt; order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocated</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_order_for_size</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the smallest order whose block size &gt;= requested size.&quot;&quot;&quot;</span>
        <span class="n">order</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_order</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">order</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_buddy_address</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">order</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the buddy&#39;s address using XOR.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">address</span> <span class="o">^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Allocate a block of at least &#39;size&#39; bytes.</span>
<span class="sd">        Returns the start address, or -1 if allocation fails.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">needed_order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_order_for_size</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="c1"># Find the smallest available block</span>
        <span class="n">found_order</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">needed_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_lists</span><span class="p">[</span><span class="n">order</span><span class="p">]:</span>
                <span class="n">found_order</span> <span class="o">=</span> <span class="n">order</span>
                <span class="k">break</span>

        <span class="k">if</span> <span class="n">found_order</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  FAILED: Cannot allocate </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2"> bytes&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Remove the block from the free list</span>
        <span class="n">address</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_lists</span><span class="p">[</span><span class="n">found_order</span><span class="p">])</span>  <span class="c1"># Take lowest address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_lists</span><span class="p">[</span><span class="n">found_order</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>

        <span class="c1"># Split down to the needed order</span>
        <span class="n">current_order</span> <span class="o">=</span> <span class="n">found_order</span>
        <span class="k">while</span> <span class="n">current_order</span> <span class="o">&gt;</span> <span class="n">needed_order</span><span class="p">:</span>
            <span class="n">current_order</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="c1"># Create a buddy at the upper half</span>
            <span class="n">buddy_addr</span> <span class="o">=</span> <span class="n">address</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">current_order</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">free_lists</span><span class="p">[</span><span class="n">current_order</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">buddy_addr</span><span class="p">)</span>

        <span class="c1"># Record the allocation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocated</span><span class="p">[</span><span class="n">address</span><span class="p">]</span> <span class="o">=</span> <span class="n">needed_order</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">needed_order</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Allocated </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2">B at address </span><span class="si">{</span><span class="n">address</span><span class="si">}</span><span class="s2"> &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;(block size </span><span class="si">{</span><span class="n">block_size</span><span class="si">}</span><span class="s2">B, order </span><span class="si">{</span><span class="n">needed_order</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">address</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Free a previously allocated block and coalesce with buddies.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">address</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocated</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  ERROR: Address </span><span class="si">{</span><span class="n">address</span><span class="si">}</span><span class="s2"> not allocated&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocated</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">address</span><span class="p">)</span>
        <span class="n">block_size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Freeing address </span><span class="si">{</span><span class="n">address</span><span class="si">}</span><span class="s2"> (block size </span><span class="si">{</span><span class="n">block_size</span><span class="si">}</span><span class="s2">B, order </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="c1"># Coalesce with buddies</span>
        <span class="n">current_addr</span> <span class="o">=</span> <span class="n">address</span>
        <span class="n">current_order</span> <span class="o">=</span> <span class="n">order</span>

        <span class="k">while</span> <span class="n">current_order</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span><span class="p">:</span>
            <span class="n">buddy_addr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buddy_address</span><span class="p">(</span><span class="n">current_addr</span><span class="p">,</span> <span class="n">current_order</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">buddy_addr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_lists</span><span class="p">[</span><span class="n">current_order</span><span class="p">]:</span>
                <span class="c1"># Buddy is free -- coalesce!</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">free_lists</span><span class="p">[</span><span class="n">current_order</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">buddy_addr</span><span class="p">)</span>
                <span class="c1"># The merged block starts at the lower address</span>
                <span class="n">current_addr</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">current_addr</span><span class="p">,</span> <span class="n">buddy_addr</span><span class="p">)</span>
                <span class="n">current_order</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Coalesced with buddy at </span><span class="si">{</span><span class="n">buddy_addr</span><span class="si">}</span><span class="s2"> &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;-&gt; new block at </span><span class="si">{</span><span class="n">current_addr</span><span class="si">}</span><span class="s2"> (order </span><span class="si">{</span><span class="n">current_order</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># Add the (possibly coalesced) block to the free list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_lists</span><span class="p">[</span><span class="n">current_order</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">current_addr</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print the current state of the allocator.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  Free lists:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">order</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_order</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_lists</span><span class="p">[</span><span class="n">order</span><span class="p">]:</span>
                <span class="n">size</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">order</span>
                <span class="n">addrs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_lists</span><span class="p">[</span><span class="n">order</span><span class="p">])</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Order </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">size</span><span class="si">:</span><span class="s2">4d</span><span class="si">}</span><span class="s2">B): </span><span class="si">{</span><span class="n">addrs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocated</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Allocated blocks:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">addr</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">allocated</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
                <span class="n">order</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocated</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Address </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">order</span><span class="si">}</span><span class="s2">B (order </span><span class="si">{</span><span class="n">order</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_buddy</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate buddy system allocation and deallocation.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Buddy System Allocator (1024 bytes) ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">allocator</span> <span class="o">=</span> <span class="n">BuddyAllocator</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Initial state:&quot;</span><span class="p">)</span>
    <span class="n">allocator</span><span class="o">.</span><span class="n">print_state</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--- Allocations ---&quot;</span><span class="p">)</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>   <span class="c1"># Needs 128B</span>
    <span class="n">a2</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>   <span class="c1"># Needs 256B</span>
    <span class="n">a3</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>    <span class="c1"># Needs 64B</span>
    <span class="n">a4</span> <span class="o">=</span> <span class="n">allocator</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>    <span class="c1"># Needs 64B</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After allocations:&quot;</span><span class="p">)</span>
    <span class="n">allocator</span><span class="o">.</span><span class="n">print_state</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;--- Deallocations ---&quot;</span><span class="p">)</span>
    <span class="n">allocator</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">a3</span><span class="p">)</span>
    <span class="n">allocator</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">a4</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After freeing a3 and a4:&quot;</span><span class="p">)</span>
    <span class="n">allocator</span><span class="o">.</span><span class="n">print_state</span><span class="p">()</span>

    <span class="n">allocator</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">a1</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After freeing a1:&quot;</span><span class="p">)</span>
    <span class="n">allocator</span><span class="o">.</span><span class="n">print_state</span><span class="p">()</span>

    <span class="n">allocator</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">a2</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;After freeing a2 (everything freed):&quot;</span><span class="p">)</span>
    <span class="n">allocator</span><span class="o">.</span><span class="n">print_state</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo_buddy</span><span class="p">()</span>
</code></pre></div>

<h3 id="75-garbage-collection-overview">7.5 Garbage Collection (Overview)<a class="header-link" href="#75-garbage-collection-overview" title="Permanent link">&para;</a></h3>
<p>Languages with automatic memory management (Java, Python, Go, OCaml) use <strong>garbage collection</strong> (GC) to reclaim unreachable heap objects.</p>
<p>Major GC strategies:</p>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>Description</th>
<th>Pros</th>
<th>Cons</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Reference counting</strong></td>
<td>Each object tracks how many references point to it</td>
<td>Immediate reclamation; simple</td>
<td>Cannot handle cycles; counter overhead</td>
</tr>
<tr>
<td><strong>Mark-and-sweep</strong></td>
<td>Mark reachable objects from roots, sweep unmarked</td>
<td>Handles cycles</td>
<td>Stop-the-world pauses; fragmentation</td>
</tr>
<tr>
<td><strong>Mark-and-compact</strong></td>
<td>Like mark-sweep, but compacts live objects</td>
<td>No fragmentation</td>
<td>Expensive object movement</td>
</tr>
<tr>
<td><strong>Copying (Cheney)</strong></td>
<td>Copy live objects to a new space</td>
<td>Fast allocation; no fragmentation</td>
<td>Halves available memory</td>
</tr>
<tr>
<td><strong>Generational</strong></td>
<td>Partition objects by age; collect young generation more often</td>
<td>Exploits generational hypothesis</td>
<td>Complex implementation</td>
</tr>
</tbody>
</table>
<p>The <strong>generational hypothesis</strong> states that most objects die young. Generational collectors exploit this by frequently collecting the <strong>nursery</strong> (young generation) and rarely collecting the <strong>old generation</strong>.</p>
<hr />
<h2 id="8-memory-layout-in-practice">8. Memory Layout in Practice<a class="header-link" href="#8-memory-layout-in-practice" title="Permanent link">&para;</a></h2>
<h3 id="81-examining-a-c-programs-layout">8.1 Examining a C Program's Layout<a class="header-link" href="#81-examining-a-c-programs-layout" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdlib.h&gt;</span>

<span class="c1">// Global/static data (.data and .bss)</span>
<span class="kt">int</span><span class="w"> </span><span class="n">global_initialized</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span><span class="w">     </span><span class="c1">// .data</span>
<span class="kt">int</span><span class="w"> </span><span class="n">global_uninitialized</span><span class="p">;</span><span class="w">        </span><span class="c1">// .bss</span>
<span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">static_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="p">;</span><span class="w">     </span><span class="c1">// .data</span>
<span class="k">const</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">string_lit</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;hello&quot;</span><span class="p">;</span><span class="w"> </span><span class="c1">// pointer in .data, string in .rodata</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">function</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Stack</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">local_var</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">array</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>

<span class="w">    </span><span class="c1">// Heap</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">heap_data</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">50</span><span class="p">);</span>

<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Code:    %p (function address)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">function</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Global:  %p (global_initialized)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">global_initialized</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;BSS:     %p (global_uninitialized)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">global_uninitialized</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Static:  %p (static_var)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">static_var</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Literal: %p (string literal)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">string_lit</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Stack:   %p (local_var)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">local_var</span><span class="p">);</span>
<span class="w">    </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Heap:    %p (malloc&#39;d data)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">heap_data</span><span class="p">);</span>

<span class="w">    </span><span class="n">free</span><span class="p">(</span><span class="n">heap_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">function</span><span class="p">();</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Typical output on x86-64 Linux</strong> (addresses vary due to ASLR):</p>
<div class="highlight"><pre><span></span><code><span class="n">Code</span><span class="o">:</span><span class="w">    </span><span class="mh">0x55a3b7c00169</span>
<span class="n">Global</span><span class="o">:</span><span class="w">  </span><span class="mh">0x55a3b7e03010</span>
<span class="n">BSS</span><span class="o">:</span><span class="w">     </span><span class="mh">0x55a3b7e03018</span>
<span class="n">Static</span><span class="o">:</span><span class="w">  </span><span class="mh">0x55a3b7e03014</span>
<span class="n">Literal</span><span class="o">:</span><span class="w"> </span><span class="mh">0x55a3b7c00200</span>
<span class="n">Stack</span><span class="o">:</span><span class="w">   </span><span class="mh">0x7ffd9a3b4c0c</span>
<span class="n">Heap</span><span class="o">:</span><span class="w">    </span><span class="mh">0x55a3b8a046b0</span>
</code></pre></div>

<p>Notice the large gap between stack addresses (<code>0x7ffd...</code>) and heap addresses (<code>0x55a3...</code>).</p>
<h3 id="82-stack-frame-layout-on-x86-64-system-v-abi">8.2 Stack Frame Layout on x86-64 (System V ABI)<a class="header-link" href="#82-stack-frame-layout-on-x86-64-system-v-abi" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">Higher</span><span class="w"> </span><span class="n">addresses</span>
<span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="err">â”‚</span><span class="w"> </span><span class="n">Argument</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">any</span><span class="p">)</span><span class="w">     </span><span class="err">â”‚</span><span class="w">  </span><span class="p">[</span><span class="n">RBP</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">24</span><span class="p">]</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w"> </span><span class="n">Argument</span><span class="w"> </span><span class="mi">7</span><span class="w">              </span><span class="err">â”‚</span><span class="w">  </span><span class="p">[</span><span class="n">RBP</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">16</span><span class="p">]</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w"> </span><span class="n">Return</span><span class="w"> </span><span class="n">address</span><span class="w">          </span><span class="err">â”‚</span><span class="w">  </span><span class="p">[</span><span class="n">RBP</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span><span class="w">   </span><span class="p">(</span><span class="n">pushed</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">CALL</span><span class="p">)</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w"> </span><span class="n">Saved</span><span class="w"> </span><span class="n">RBP</span><span class="w">               </span><span class="err">â”‚</span><span class="w">  </span><span class="p">[</span><span class="n">RBP</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">0</span><span class="p">]</span><span class="w">   </span><span class="err">â—€â”€â”€</span><span class="w"> </span><span class="n">RBP</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="n">here</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w"> </span><span class="n">Local</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="mi">1</span><span class="w">        </span><span class="err">â”‚</span><span class="w">  </span><span class="p">[</span><span class="n">RBP</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">8</span><span class="p">]</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w"> </span><span class="n">Local</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="mi">2</span><span class="w">        </span><span class="err">â”‚</span><span class="w">  </span><span class="p">[</span><span class="n">RBP</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">16</span><span class="p">]</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w"> </span><span class="n">Saved</span><span class="w"> </span><span class="n">callee</span><span class="o">-</span><span class="n">saved</span><span class="w"> </span><span class="n">regs</span><span class="w"> </span><span class="err">â”‚</span><span class="w">  </span><span class="p">[</span><span class="n">RBP</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">24</span><span class="p">]</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w"> </span><span class="n">Alignment</span><span class="w"> </span><span class="n">padding</span><span class="w">       </span><span class="err">â”‚</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w"> </span><span class="n">Outgoing</span><span class="w"> </span><span class="n">arg</span><span class="w"> </span><span class="mi">7</span><span class="o">+</span><span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â—€â”€â”€</span><span class="w"> </span><span class="n">RSP</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="n">here</span>
<span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="n">Lower</span><span class="w"> </span><span class="n">addresses</span>
</code></pre></div>

<p><strong>Red zone</strong>: On System V AMD64, leaf functions (functions that do not call other functions) may use up to 128 bytes below RSP without adjusting the stack pointer. This avoids the overhead of <code>sub rsp</code> / <code>add rsp</code> for small leaf functions.</p>
<hr />
<h2 id="9-stack-unwinding-for-exceptions">9. Stack Unwinding for Exceptions<a class="header-link" href="#9-stack-unwinding-for-exceptions" title="Permanent link">&para;</a></h2>
<h3 id="91-the-problem">9.1 The Problem<a class="header-link" href="#91-the-problem" title="Permanent link">&para;</a></h3>
<p>When an exception is thrown, control must transfer to an appropriate exception handler, potentially many frames up the call stack. All intervening frames must be properly cleaned up (destructors called, resources released).</p>
<h3 id="92-approaches">9.2 Approaches<a class="header-link" href="#92-approaches" title="Permanent link">&para;</a></h3>
<h4 id="table-based-unwinding">Table-Based Unwinding<a class="header-link" href="#table-based-unwinding" title="Permanent link">&para;</a></h4>
<p>Modern compilers (GCC, Clang) generate <strong>unwind tables</strong> that describe how to restore registers and unwind each frame. These tables are stored alongside the code and consulted only when an exception is thrown.</p>
<div class="highlight"><pre><span></span><code><span class="na">.eh_frame</span><span class="w"> </span><span class="no">section</span><span class="p">:</span>
<span class="w">  </span><span class="nl">Function:</span><span class="w"> </span><span class="nf">foo</span>
<span class="w">    </span><span class="nf">At</span><span class="w"> </span><span class="no">offset</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w">  </span><span class="no">CFA</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="no">RSP</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">8</span>
<span class="w">    </span><span class="nf">At</span><span class="w"> </span><span class="no">offset</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span><span class="w">  </span><span class="no">CFA</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="no">RSP</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">16</span><span class="p">,</span><span class="w"> </span><span class="no">RBP</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="p">[</span><span class="no">CFA</span><span class="w"> </span><span class="p">-</span><span class="w"> </span><span class="mi">16</span><span class="p">]</span>
<span class="w">    </span><span class="nf">At</span><span class="w"> </span><span class="no">offset</span><span class="w"> </span><span class="mi">8</span><span class="p">:</span><span class="w">  </span><span class="no">CFA</span><span class="w"> </span><span class="err">=</span><span class="w"> </span><span class="no">RBP</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="mi">16</span>
</code></pre></div>

<p><strong>Advantage</strong>: Zero cost when no exception is thrown (no extra instructions on the normal path).</p>
<p><strong>Disadvantage</strong>: Tables add to binary size.</p>
<h4 id="setjmplongjmp-based">Setjmp/Longjmp-Based<a class="header-link" href="#setjmplongjmp-based" title="Permanent link">&para;</a></h4>
<p>Older approach: use <code>setjmp</code> at each try block to save the current state, and <code>longjmp</code> to jump to the handler.</p>
<p><strong>Advantage</strong>: Simple implementation.</p>
<p><strong>Disadvantage</strong>: <code>setjmp</code> has a cost even when no exception is thrown.</p>
<h3 id="93-stack-unwinding-process">9.3 Stack Unwinding Process<a class="header-link" href="#93-stack-unwinding-process" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">Call</span><span class="w"> </span><span class="nl">stack</span><span class="w"> </span><span class="nv">when</span><span class="w"> </span><span class="nv">exception</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">thrown</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">baz</span><span class="ss">()</span>:

<span class="nv">main</span><span class="ss">()</span><span class="w"> </span>â†’<span class="w"> </span><span class="nv">foo</span><span class="ss">()</span><span class="w"> </span>â†’<span class="w"> </span><span class="nv">bar</span><span class="ss">()</span><span class="w"> </span>â†’<span class="w"> </span><span class="nv">baz</span><span class="ss">()</span>
<span class="w">                           </span>â†‘<span class="w"> </span><span class="nv">exception</span><span class="w"> </span><span class="nv">thrown</span><span class="w"> </span><span class="nv">here</span>

<span class="nv">Unwinding</span>:
<span class="mi">1</span>.<span class="w"> </span><span class="nv">Search</span><span class="w"> </span><span class="nv">baz</span><span class="ss">()</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">handler</span><span class="w"> </span>â†’<span class="w"> </span><span class="nv">none</span><span class="w"> </span><span class="nv">found</span>
<span class="mi">2</span>.<span class="w"> </span><span class="nv">Unwind</span><span class="w"> </span><span class="nv">baz</span><span class="ss">()</span><span class="err">&#39;s frame (run cleanups)</span>
<span class="err">3. Search bar() for a handler â†’ none found</span>
<span class="mi">4</span>.<span class="w"> </span><span class="nv">Unwind</span><span class="w"> </span><span class="nv">bar</span><span class="ss">()</span><span class="err">&#39;s frame (run cleanups)</span>
<span class="err">5. Search foo() for a handler â†’ FOUND</span>
<span class="mi">6</span>.<span class="w"> </span><span class="nv">Transfer</span><span class="w"> </span><span class="nv">control</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">foo</span><span class="ss">()</span><span class="err">&#39;s catch block</span>
</code></pre></div>

<hr />
<h2 id="10-python-simulation-runtime-call-stack">10. Python Simulation: Runtime Call Stack<a class="header-link" href="#10-python-simulation-runtime-call-stack" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Simulation of a runtime call stack with activation records,</span>
<span class="sd">demonstrating function calls, returns, and nested scopes.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ActivationRecord</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An activation record (stack frame) for a function call.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">function_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">return_address</span><span class="p">:</span> <span class="nb">int</span>                          <span class="c1"># Instruction index to return to</span>
    <span class="n">parameters</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">local_variables</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">temporaries</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">saved_registers</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">static_link</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;ActivationRecord&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># For nested functions</span>
    <span class="n">dynamic_link</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s1">&#39;ActivationRecord&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>   <span class="c1"># Caller&#39;s frame</span>
    <span class="n">return_value</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Look up a variable in this frame.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_variables</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a local variable.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;  Frame: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">function_name</span><span class="si">}</span><span class="s2">()&quot;</span><span class="p">]</span>
        <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Return addr: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">return_address</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Parameters: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_variables</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Locals: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">local_variables</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">temporaries</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Temps: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">temporaries</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">return_value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Return value: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">return_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">static_link</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Static link -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">static_link</span><span class="o">.</span><span class="n">function_name</span><span class="si">}</span><span class="s2">()&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dynamic_link</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Dynamic link -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dynamic_link</span><span class="o">.</span><span class="n">function_name</span><span class="si">}</span><span class="s2">()&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">RuntimeStack</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulation of the runtime call stack.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">ActivationRecord</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Program counter</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">current_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ActivationRecord</span><span class="p">]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">depth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">push_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">function_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span>
                   <span class="n">return_address</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
                   <span class="n">static_link</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ActivationRecord</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Push a new activation record (function call).&quot;&quot;&quot;</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="n">ActivationRecord</span><span class="p">(</span>
            <span class="n">function_name</span><span class="o">=</span><span class="n">function_name</span><span class="p">,</span>
            <span class="n">return_address</span><span class="o">=</span><span class="n">return_address</span><span class="p">,</span>
            <span class="n">parameters</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span>
            <span class="n">dynamic_link</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_frame</span><span class="p">,</span>
            <span class="n">static_link</span><span class="o">=</span><span class="n">static_link</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&gt;&gt;&gt; CALL </span><span class="si">{</span><span class="n">function_name</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="n">parameters</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Stack depth: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">pop_frame</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ActivationRecord</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pop the current activation record (function return).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Stack underflow!&quot;</span><span class="p">)</span>

        <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&lt;&lt;&lt; RETURN from </span><span class="si">{</span><span class="n">frame</span><span class="o">.</span><span class="n">function_name</span><span class="si">}</span><span class="s2">() &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;= </span><span class="si">{</span><span class="n">frame</span><span class="o">.</span><span class="n">return_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Stack depth: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Restore program counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">return_address</span>

        <span class="k">return</span> <span class="n">frame</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">use_static_scope</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Look up a variable using either static or dynamic scope chain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_static_scope</span><span class="p">:</span>
            <span class="c1"># Follow static links (lexical scoping)</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_frame</span>
            <span class="k">while</span> <span class="n">frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">value</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">static_link</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Follow dynamic links (dynamic scoping)</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_frame</span>
            <span class="k">while</span> <span class="n">frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">get_variable</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">value</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">dynamic_link</span>

        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; not found&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_stack</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print the entire call stack.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Runtime Stack ===&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  (empty)&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">marker</span> <span class="o">=</span> <span class="s2">&quot; â—€â”€â”€ TOP&quot;</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  [</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">]</span><span class="si">{</span><span class="n">marker</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">40</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_factorial</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate the execution of a recursive factorial function.</span>

<span class="sd">    def factorial(n):</span>
<span class="sd">        if n &lt;= 1:</span>
<span class="sd">            return 1</span>
<span class="sd">        return n * factorial(n - 1)</span>

<span class="sd">    result = factorial(4)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Simulating: result = factorial(4)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="n">RuntimeStack</span><span class="p">()</span>

    <span class="c1"># Push main&#39;s frame</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">push_frame</span><span class="p">(</span><span class="s2">&quot;main&quot;</span><span class="p">,</span> <span class="p">{},</span> <span class="n">return_address</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">current_frame</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Recursive calls: factorial(4) -&gt; factorial(3) -&gt; ... -&gt; factorial(1)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_factorial</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">return_addr</span><span class="p">):</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">push_frame</span><span class="p">(</span><span class="s2">&quot;factorial&quot;</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="n">n</span><span class="p">},</span> <span class="n">return_address</span><span class="o">=</span><span class="n">return_addr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">current_frame</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">print_stack</span><span class="p">()</span>
            <span class="n">returned</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop_frame</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">returned</span><span class="o">.</span><span class="n">return_value</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Recursive call</span>
            <span class="n">sub_result</span> <span class="o">=</span> <span class="n">simulate_factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">return_addr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">sub_result</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">current_frame</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">result</span>
            <span class="n">returned</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop_frame</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">returned</span><span class="o">.</span><span class="n">return_value</span>

    <span class="n">result</span> <span class="o">=</span> <span class="n">simulate_factorial</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="n">stack</span><span class="o">.</span><span class="n">current_frame</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">main: result = </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">stack</span><span class="o">.</span><span class="n">print_stack</span><span class="p">()</span>

    <span class="c1"># Pop main</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">current_frame</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">result</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">pop_frame</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_nested_functions</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate nested function calls with access links.</span>

<span class="sd">    def outer():</span>
<span class="sd">        x = 10</span>
<span class="sd">        def inner():</span>
<span class="sd">            return x + 20   # Accesses outer&#39;s x via static link</span>
<span class="sd">        return inner()</span>

<span class="sd">    result = outer()</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Simulating: nested functions with access links&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

    <span class="n">stack</span> <span class="o">=</span> <span class="n">RuntimeStack</span><span class="p">()</span>

    <span class="c1"># main frame</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">push_frame</span><span class="p">(</span><span class="s2">&quot;main&quot;</span><span class="p">,</span> <span class="p">{},</span> <span class="n">return_address</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="c1"># outer frame</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">push_frame</span><span class="p">(</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="p">{},</span> <span class="n">return_address</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">current_frame</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">outer_frame</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">current_frame</span>

    <span class="c1"># inner frame with static link to outer</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">push_frame</span><span class="p">(</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="p">{},</span> <span class="n">return_address</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                     <span class="n">static_link</span><span class="o">=</span><span class="n">outer_frame</span><span class="p">)</span>

    <span class="n">stack</span><span class="o">.</span><span class="n">print_stack</span><span class="p">()</span>

    <span class="c1"># inner accesses x through static link</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">lookup_variable</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">use_static_scope</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">20</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">inner: x (via static link) = </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;inner: result = </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Return from inner</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">current_frame</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">result</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">pop_frame</span><span class="p">()</span>

    <span class="c1"># Return from outer</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">current_frame</span><span class="o">.</span><span class="n">return_value</span> <span class="o">=</span> <span class="n">result</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">pop_frame</span><span class="p">()</span>

    <span class="c1"># Store in main</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">current_frame</span><span class="o">.</span><span class="n">set_variable</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">main: result = </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">stack</span><span class="o">.</span><span class="n">pop_frame</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo_factorial</span><span class="p">()</span>
    <span class="n">demo_nested_functions</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="11-compiler-support-for-runtime-environments">11. Compiler Support for Runtime Environments<a class="header-link" href="#11-compiler-support-for-runtime-environments" title="Permanent link">&para;</a></h2>
<h3 id="111-what-the-compiler-generates">11.1 What the Compiler Generates<a class="header-link" href="#111-what-the-compiler-generates" title="Permanent link">&para;</a></h3>
<p>The compiler is responsible for generating code that correctly manages the runtime environment:</p>
<ol>
<li><strong>Function prologue</strong>: Code at the start of each function that:</li>
<li>Saves the old frame pointer</li>
<li>Sets up the new frame pointer</li>
<li>Allocates space for local variables</li>
<li>
<p>Saves callee-saved registers</p>
</li>
<li>
<p><strong>Function epilogue</strong>: Code at the end of each function that:</p>
</li>
<li>Restores callee-saved registers</li>
<li>Deallocates local variables</li>
<li>Restores the old frame pointer</li>
<li>
<p>Returns to the caller</p>
</li>
<li>
<p><strong>Variable access code</strong>: Instructions that compute the address of a variable based on its scope:</p>
</li>
<li>Local variables: offset from FP</li>
<li>Parameters: positive offset from FP (or register)</li>
<li>
<p>Non-local variables: follow access links + offset</p>
</li>
<li>
<p><strong>Call-site code</strong>: Instructions at each function call that:</p>
</li>
<li>Evaluate and pass arguments</li>
<li>Save caller-saved registers</li>
<li>Perform the call</li>
<li>Handle the return value</li>
</ol>
<h3 id="112-symbol-table-information">11.2 Symbol Table Information<a class="header-link" href="#112-symbol-table-information" title="Permanent link">&para;</a></h3>
<p>The compiler's symbol table must record:</p>
<table>
<thead>
<tr>
<th>Information</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>Variable type and size</td>
<td>Determines stack offset and access width</td>
</tr>
<tr>
<td>Scope level</td>
<td>Determines how many access links to follow</td>
</tr>
<tr>
<td>Offset within frame</td>
<td>Address computation</td>
</tr>
<tr>
<td>Parameter index</td>
<td>Determines register or stack slot for arguments</td>
</tr>
<tr>
<td>Is it captured by a closure?</td>
<td>If yes, allocate on heap instead of stack</td>
</tr>
</tbody>
</table>
<h3 id="113-frame-layout-optimization">11.3 Frame Layout Optimization<a class="header-link" href="#113-frame-layout-optimization" title="Permanent link">&para;</a></h3>
<p>Modern compilers optimize frame layouts:</p>
<ul>
<li><strong>Reorder local variables</strong> to minimize padding (alignment)</li>
<li><strong>Omit the frame pointer</strong> when possible (use SP-relative addressing), freeing up a register</li>
<li><strong>Register allocation</strong> to keep frequently used variables in registers rather than on the stack</li>
<li><strong>Stack slot sharing</strong>: Variables with non-overlapping lifetimes can share the same stack slot</li>
</ul>
<hr />
<h2 id="12-summary">12. Summary<a class="header-link" href="#12-summary" title="Permanent link">&para;</a></h2>
<p>In this lesson, we explored how programs are organized in memory at runtime:</p>
<ol>
<li>
<p><strong>Memory layout</strong>: Code, static data, stack (grows down), and heap (grows up) are the four major regions.</p>
</li>
<li>
<p><strong>Activation records</strong> store everything needed for a function invocation: parameters, locals, return address, saved registers, and scope links.</p>
</li>
<li>
<p><strong>Calling conventions</strong> (cdecl, stdcall, System V AMD64) define the protocol for argument passing, stack cleanup, and register usage. The System V AMD64 ABI passes the first 6 integer arguments in registers for efficiency.</p>
</li>
<li>
<p><strong>Parameter passing mechanisms</strong> include call by value (copy), call by reference (address), call by value-result (copy in/out), and call by name (thunks).</p>
</li>
<li>
<p><strong>Nested functions</strong> require access links or displays to reach variables in enclosing scopes. Closures must keep captured variables alive beyond the enclosing function's lifetime.</p>
</li>
<li>
<p><strong>Static scoping</strong> resolves variables by lexical nesting (compile-time determinable), while <strong>dynamic scoping</strong> resolves by the runtime call chain.</p>
</li>
<li>
<p><strong>Heap management</strong> uses free lists (first fit, best fit) or the buddy system. Garbage collection automates reclamation in managed languages.</p>
</li>
<li>
<p><strong>Stack unwinding</strong> for exceptions uses table-based mechanisms for zero-cost exception handling on the normal path.</p>
</li>
</ol>
<hr />
<h2 id="exercises">Exercises<a class="header-link" href="#exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-stack-frame-diagram">Exercise 1: Stack Frame Diagram<a class="header-link" href="#exercise-1-stack-frame-diagram" title="Permanent link">&para;</a></h3>
<p>Draw the complete stack layout (with actual byte offsets from FP) for the following C function call on System V AMD64:</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">compute</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">d</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">e</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">f</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">g</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">h</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">h</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Note: <code>a</code>--<code>f</code> are passed in registers; <code>g</code> and <code>h</code> are on the stack.</p>
<h3 id="exercise-2-access-links">Exercise 2: Access Links<a class="header-link" href="#exercise-2-access-links" title="Permanent link">&para;</a></h3>
<p>Given the following nested function structure, draw the stack frames with access links when <code>innermost()</code> is executing:</p>
<div class="highlight"><pre><span></span><code><span class="k">function</span><span class="w"> </span><span class="nf">level0</span><span class="p">():</span>
<span class="w">    </span><span class="nb">var</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">function</span><span class="w"> </span><span class="nf">level1</span><span class="p">():</span>
<span class="w">        </span><span class="nb">var</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">        </span><span class="k">function</span><span class="w"> </span><span class="nf">level2</span><span class="p">():</span>
<span class="w">            </span><span class="nb">var</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">3</span>
<span class="w">            </span><span class="k">function</span><span class="w"> </span><span class="nf">level3</span><span class="p">():</span>
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">How</span><span class="w"> </span><span class="n">does</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="nb">find</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">c</span>?
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">level3</span><span class="p">()</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">level2</span><span class="p">()</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">level1</span><span class="p">()</span>
</code></pre></div>

<p>How many access links must be followed to reach <code>a</code> from <code>level3()</code>?</p>
<h3 id="exercise-3-calling-convention-comparison">Exercise 3: Calling Convention Comparison<a class="header-link" href="#exercise-3-calling-convention-comparison" title="Permanent link">&para;</a></h3>
<p>Translate the following function call into x86 assembly for both cdecl (32-bit) and System V AMD64 (64-bit):</p>
<div class="highlight"><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">multiply_add</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">);</span>
</code></pre></div>

<p>Show the argument passing, call instruction, and stack cleanup for each convention.</p>
<h3 id="exercise-4-dynamic-vs-static-scoping">Exercise 4: Dynamic vs Static Scoping<a class="header-link" href="#exercise-4-dynamic-vs-static-scoping" title="Permanent link">&para;</a></h3>
<p>Trace the execution of the following program under both static and dynamic scoping. What value does <code>baz()</code> return in each case?</p>
<div class="highlight"><pre><span></span><code><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>

<span class="nv">function</span><span class="w"> </span><span class="nv">foo</span><span class="ss">()</span>:
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">x</span>

<span class="nv">function</span><span class="w"> </span><span class="nv">bar</span><span class="ss">()</span>:
<span class="w">    </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">foo</span><span class="ss">()</span>

<span class="nv">function</span><span class="w"> </span><span class="nv">baz</span><span class="ss">()</span>:
<span class="w">    </span><span class="nv">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">bar</span><span class="ss">()</span>
</code></pre></div>

<h3 id="exercise-5-buddy-system">Exercise 5: Buddy System<a class="header-link" href="#exercise-5-buddy-system" title="Permanent link">&para;</a></h3>
<p>Given a buddy system allocator with 512 bytes of total memory:</p>
<ol>
<li>Show the state after allocating blocks of sizes: 50, 120, 30, 60</li>
<li>Show the state after freeing the 50-byte and 120-byte blocks</li>
<li>Does any coalescing occur? If so, describe which blocks merge.</li>
</ol>
<h3 id="exercise-6-implementation-challenge">Exercise 6: Implementation Challenge<a class="header-link" href="#exercise-6-implementation-challenge" title="Permanent link">&para;</a></h3>
<p>Extend the <code>RuntimeStack</code> simulation to support:
1. <strong>Exception handling</strong>: Implement try/catch blocks with stack unwinding
2. <strong>Closures</strong>: When a function returns a nested function, ensure the captured variables remain accessible (simulate heap allocation of captured variables)</p>
<p>Test with a program that creates a closure and then throws an exception through multiple frames.</p>
<hr />
<p><a href="./09_Intermediate_Representations.md">Previous: 09_Intermediate_Representations.md</a> | <a href="./11_Code_Generation.md">Next: 11_Code_Generation.md</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/09_Intermediate_Representations.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 9: Intermediate Representations</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/11_Code_Generation.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 11: Code Generation</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">â†‘</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}