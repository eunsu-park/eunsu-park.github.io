{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 11: Code Generation - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Lesson 11: Code Generation</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 11: Code Generation</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/10_Runtime_Environments.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 10: Runtime Environments</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/12_Optimization_Local_and_Global.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 12: Optimization -- Local and Global</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#learning-objectives">Learning Objectives</a></li>
<li><a href="#1-target-machine-model">1. Target Machine Model</a><ul>
<li><a href="#11-why-a-machine-model">1.1 Why a Machine Model?</a></li>
<li><a href="#12-a-simple-target-machine">1.2 A Simple Target Machine</a></li>
<li><a href="#13-addressing-modes">1.3 Addressing Modes</a></li>
<li><a href="#14-instruction-set">1.4 Instruction Set</a></li>
<li><a href="#15-instruction-costs">1.5 Instruction Costs</a></li>
</ul>
</li>
<li><a href="#2-instruction-selection">2. Instruction Selection</a><ul>
<li><a href="#21-the-problem">2.1 The Problem</a></li>
<li><a href="#22-tree-pattern-matching">2.2 Tree Pattern Matching</a></li>
<li><a href="#23-tiles">2.3 Tiles</a></li>
<li><a href="#24-optimal-tiling-vs-maximal-munch">2.4 Optimal Tiling vs Maximal Munch</a></li>
<li><a href="#25-the-maximal-munch-algorithm">2.5 The Maximal Munch Algorithm</a></li>
<li><a href="#26-python-implementation-maximal-munch">2.6 Python Implementation: Maximal Munch</a></li>
</ul>
</li>
<li><a href="#3-register-allocation">3. Register Allocation</a><ul>
<li><a href="#31-the-problem">3.1 The Problem</a></li>
<li><a href="#32-why-register-allocation-matters">3.2 Why Register Allocation Matters</a></li>
<li><a href="#33-liveness-analysis">3.3 Liveness Analysis</a></li>
<li><a href="#34-interference-graph">3.4 Interference Graph</a></li>
<li><a href="#35-graph-coloring-register-allocation">3.5 Graph Coloring Register Allocation</a><ul>
<li><a href="#chaitins-algorithm">Chaitin's Algorithm</a></li>
<li><a href="#example">Example</a></li>
</ul>
</li>
<li><a href="#36-spilling">3.6 Spilling</a></li>
<li><a href="#37-linear-scan-register-allocation">3.7 Linear Scan Register Allocation</a></li>
<li><a href="#38-python-implementation-linear-scan">3.8 Python Implementation: Linear Scan</a></li>
</ul>
</li>
<li><a href="#4-instruction-scheduling">4. Instruction Scheduling</a><ul>
<li><a href="#41-the-problem">4.1 The Problem</a></li>
<li><a href="#42-list-scheduling">4.2 List Scheduling</a></li>
<li><a href="#43-example-list-scheduling">4.3 Example: List Scheduling</a></li>
<li><a href="#44-software-pipelining-overview">4.4 Software Pipelining (Overview)</a></li>
</ul>
</li>
<li><a href="#5-peephole-optimization">5. Peephole Optimization</a><ul>
<li><a href="#51-what-is-peephole-optimization">5.1 What Is Peephole Optimization?</a></li>
<li><a href="#52-common-peephole-optimizations">5.2 Common Peephole Optimizations</a><ul>
<li><a href="#redundant-loadstore-elimination">Redundant Load/Store Elimination</a></li>
<li><a href="#redundant-moves">Redundant Moves</a></li>
<li><a href="#strength-reduction">Strength Reduction</a></li>
<li><a href="#algebraic-simplification">Algebraic Simplification</a></li>
<li><a href="#branch-optimization">Branch Optimization</a></li>
<li><a href="#unreachable-code-elimination">Unreachable Code Elimination</a></li>
</ul>
</li>
<li><a href="#53-python-implementation-peephole-optimizer">5.3 Python Implementation: Peephole Optimizer</a></li>
</ul>
</li>
<li><a href="#6-code-generation-for-language-constructs">6. Code Generation for Language Constructs</a><ul>
<li><a href="#61-expressions">6.1 Expressions</a></li>
<li><a href="#62-control-flow">6.2 Control Flow</a><ul>
<li><a href="#if-else">If-Else</a></li>
<li><a href="#while-loop">While Loop</a></li>
<li><a href="#for-loop">For Loop</a></li>
<li><a href="#short-circuit-boolean-evaluation">Short-Circuit Boolean Evaluation</a></li>
</ul>
</li>
<li><a href="#63-function-calls">6.3 Function Calls</a></li>
</ul>
</li>
<li><a href="#7-stack-machine-code-generator">7. Stack Machine Code Generator</a><ul>
<li><a href="#71-what-is-a-stack-machine">7.1 What Is a Stack Machine?</a></li>
<li><a href="#72-stack-machine-instruction-set">7.2 Stack Machine Instruction Set</a></li>
<li><a href="#73-complete-stack-machine-implementation">7.3 Complete Stack Machine Implementation</a></li>
</ul>
</li>
<li><a href="#8-machine-dependent-optimization">8. Machine-Dependent Optimization</a><ul>
<li><a href="#81-utilizing-special-instructions">8.1 Utilizing Special Instructions</a></li>
<li><a href="#82-addressing-mode-selection">8.2 Addressing Mode Selection</a></li>
<li><a href="#83-conditional-execution-arm">8.3 Conditional Execution (ARM)</a></li>
<li><a href="#84-branch-prediction-hints">8.4 Branch Prediction Hints</a></li>
</ul>
</li>
<li><a href="#9-summary">9. Summary</a></li>
<li><a href="#exercises">Exercises</a><ul>
<li><a href="#exercise-1-maximal-munch">Exercise 1: Maximal Munch</a></li>
<li><a href="#exercise-2-register-allocation">Exercise 2: Register Allocation</a></li>
<li><a href="#exercise-3-instruction-scheduling">Exercise 3: Instruction Scheduling</a></li>
<li><a href="#exercise-4-peephole-optimization">Exercise 4: Peephole Optimization</a></li>
<li><a href="#exercise-5-stack-machine">Exercise 5: Stack Machine</a></li>
<li><a href="#exercise-6-implementation-challenge">Exercise 6: Implementation Challenge</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-11-code-generation">Lesson 11: Code Generation<a class="header-link" href="#lesson-11-code-generation" title="Permanent link">&para;</a></h1>
<h2 id="learning-objectives">Learning Objectives<a class="header-link" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<p>After completing this lesson, you will be able to:</p>
<ol>
<li><strong>Describe</strong> the target machine model used for code generation</li>
<li><strong>Explain</strong> instruction selection via tree pattern matching and tiling</li>
<li><strong>Implement</strong> the Maximal Munch algorithm for instruction selection</li>
<li><strong>Apply</strong> register allocation techniques: graph coloring and linear scan</li>
<li><strong>Understand</strong> instruction scheduling (list scheduling, software pipelining overview)</li>
<li><strong>Perform</strong> peephole optimization on generated code</li>
<li><strong>Generate</strong> code for expressions, control flow, and function calls</li>
<li><strong>Implement</strong> a complete code generator for a stack machine in Python</li>
</ol>
<hr />
<h2 id="1-target-machine-model">1. Target Machine Model<a class="header-link" href="#1-target-machine-model" title="Permanent link">&para;</a></h2>
<h3 id="11-why-a-machine-model">1.1 Why a Machine Model?<a class="header-link" href="#11-why-a-machine-model" title="Permanent link">&para;</a></h3>
<p>Code generation translates the intermediate representation (IR) into instructions for a specific target machine. To study code generation techniques in a machine-independent way, we define an abstract target machine model that captures the essential features of real architectures.</p>
<h3 id="12-a-simple-target-machine">1.2 A Simple Target Machine<a class="header-link" href="#12-a-simple-target-machine" title="Permanent link">&para;</a></h3>
<p>Our model machine has the following characteristics:</p>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>Registers</td>
<td>$R_0, R_1, \ldots, R_{k-1}$ (general purpose)</td>
</tr>
<tr>
<td>Memory</td>
<td>Byte-addressable, word size = 4 bytes</td>
</tr>
<tr>
<td>Instructions</td>
<td>Three-address form: <code>op dst, src1, src2</code></td>
</tr>
<tr>
<td>Addressing modes</td>
<td>Register, immediate, register-indirect, indexed</td>
</tr>
<tr>
<td>Stack</td>
<td>Grows downward, SP register</td>
</tr>
</tbody>
</table>
<h3 id="13-addressing-modes">1.3 Addressing Modes<a class="header-link" href="#13-addressing-modes" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Mode</th>
<th>Syntax</th>
<th>Meaning</th>
<th>Use Case</th>
</tr>
</thead>
<tbody>
<tr>
<td>Register</td>
<td><code>R0</code></td>
<td>Value in register R0</td>
<td>Local variables in registers</td>
</tr>
<tr>
<td>Immediate</td>
<td><code>#42</code></td>
<td>Constant value 42</td>
<td>Constants, offsets</td>
</tr>
<tr>
<td>Register-indirect</td>
<td><code>[R0]</code></td>
<td>Memory at address in R0</td>
<td>Pointer dereference</td>
</tr>
<tr>
<td>Indexed</td>
<td><code>[R0 + #8]</code></td>
<td>Memory at R0 + 8</td>
<td>Array access, struct fields</td>
</tr>
<tr>
<td>Direct</td>
<td><code>[addr]</code></td>
<td>Memory at absolute address</td>
<td>Global variables</td>
</tr>
</tbody>
</table>
<h3 id="14-instruction-set">1.4 Instruction Set<a class="header-link" href="#14-instruction-set" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">Arithmetic</span><span class="p">:</span>
<span class="w">    </span><span class="n">ADD</span><span class="w">  </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="n">Rs1</span><span class="p">,</span><span class="w"> </span><span class="n">Rs2</span><span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">Rd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rs1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">Rs2</span>
<span class="w">    </span><span class="n">SUB</span><span class="w">  </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="n">Rs1</span><span class="p">,</span><span class="w"> </span><span class="n">Rs2</span><span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">Rd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rs1</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Rs2</span>
<span class="w">    </span><span class="n">MUL</span><span class="w">  </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="n">Rs1</span><span class="p">,</span><span class="w"> </span><span class="n">Rs2</span><span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">Rd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rs1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">Rs2</span>
<span class="w">    </span><span class="n">DIV</span><span class="w">  </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="n">Rs1</span><span class="p">,</span><span class="w"> </span><span class="n">Rs2</span><span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">Rd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rs1</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">Rs2</span>
<span class="w">    </span><span class="n">ADDI</span><span class="w"> </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="n">Rs</span><span class="p">,</span><span class="w"> </span><span class="c1">#imm    ; Rd = Rs + imm</span>

<span class="n">Data</span><span class="w"> </span><span class="n">movement</span><span class="p">:</span>
<span class="w">    </span><span class="n">MOV</span><span class="w">  </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="n">Rs</span><span class="w">          </span><span class="p">;</span><span class="w"> </span><span class="n">Rd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rs</span>
<span class="w">    </span><span class="n">MOVI</span><span class="w"> </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="c1">#imm        ; Rd = imm (load immediate)</span>
<span class="w">    </span><span class="n">LOAD</span><span class="w"> </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">Rs</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="c1">#off] ; Rd = Mem[Rs + off]</span>
<span class="w">    </span><span class="n">STORE</span><span class="w"> </span><span class="n">Rs</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">Rd</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="c1">#off]; Mem[Rd + off] = Rs</span>

<span class="n">Control</span><span class="w"> </span><span class="n">flow</span><span class="p">:</span>
<span class="w">    </span><span class="n">CMP</span><span class="w">  </span><span class="n">Rs1</span><span class="p">,</span><span class="w"> </span><span class="n">Rs2</span><span class="w">        </span><span class="p">;</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">condition</span><span class="w"> </span><span class="n">flags</span>
<span class="w">    </span><span class="n">BEQ</span><span class="w">  </span><span class="n">label</span><span class="w">           </span><span class="p">;</span><span class="w"> </span><span class="n">Branch</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">equal</span>
<span class="w">    </span><span class="n">BNE</span><span class="w">  </span><span class="n">label</span><span class="w">           </span><span class="p">;</span><span class="w"> </span><span class="n">Branch</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">equal</span>
<span class="w">    </span><span class="n">BLT</span><span class="w">  </span><span class="n">label</span><span class="w">           </span><span class="p">;</span><span class="w"> </span><span class="n">Branch</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">less</span><span class="w"> </span><span class="n">than</span>
<span class="w">    </span><span class="n">BGT</span><span class="w">  </span><span class="n">label</span><span class="w">           </span><span class="p">;</span><span class="w"> </span><span class="n">Branch</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">greater</span><span class="w"> </span><span class="n">than</span>
<span class="w">    </span><span class="n">BLE</span><span class="w">  </span><span class="n">label</span><span class="w">           </span><span class="p">;</span><span class="w"> </span><span class="n">Branch</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">less</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">equal</span>
<span class="w">    </span><span class="n">BGE</span><span class="w">  </span><span class="n">label</span><span class="w">           </span><span class="p">;</span><span class="w"> </span><span class="n">Branch</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">greater</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">equal</span>
<span class="w">    </span><span class="n">JMP</span><span class="w">  </span><span class="n">label</span><span class="w">           </span><span class="p">;</span><span class="w"> </span><span class="n">Unconditional</span><span class="w"> </span><span class="n">jump</span>
<span class="w">    </span><span class="n">CALL</span><span class="w"> </span><span class="n">label</span><span class="w">           </span><span class="p">;</span><span class="w"> </span><span class="n">Function</span><span class="w"> </span><span class="n">call</span><span class="w"> </span><span class="p">(</span><span class="n">push</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">jump</span><span class="p">)</span>
<span class="w">    </span><span class="n">RET</span><span class="w">                  </span><span class="p">;</span><span class="w"> </span><span class="n">Return</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">address</span><span class="p">,</span><span class="w"> </span><span class="n">jump</span><span class="p">)</span>

<span class="n">Stack</span><span class="p">:</span>
<span class="w">    </span><span class="n">PUSH</span><span class="w"> </span><span class="n">Rs</span><span class="w">              </span><span class="p">;</span><span class="w"> </span><span class="n">Push</span><span class="w"> </span><span class="n">register</span><span class="w"> </span><span class="n">onto</span><span class="w"> </span><span class="n">stack</span>
<span class="w">    </span><span class="n">POP</span><span class="w">  </span><span class="n">Rd</span><span class="w">              </span><span class="p">;</span><span class="w"> </span><span class="n">Pop</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">register</span>
</code></pre></div>

<h3 id="15-instruction-costs">1.5 Instruction Costs<a class="header-link" href="#15-instruction-costs" title="Permanent link">&para;</a></h3>
<p>Different instructions have different costs (in cycles):</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>Cost</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>ADD, SUB, MOV</td>
<td>1</td>
<td>Register-register operations</td>
</tr>
<tr>
<td>MUL</td>
<td>3</td>
<td>Multiplication is slower</td>
</tr>
<tr>
<td>DIV</td>
<td>10-40</td>
<td>Division is very expensive</td>
</tr>
<tr>
<td>LOAD</td>
<td>4 (L1 hit)</td>
<td>Memory access (cache dependent)</td>
</tr>
<tr>
<td>STORE</td>
<td>1 (buffered)</td>
<td>Write buffer hides latency</td>
</tr>
<tr>
<td>Branch (taken)</td>
<td>2</td>
<td>Pipeline flush penalty</td>
</tr>
<tr>
<td>Branch (not taken)</td>
<td>1</td>
<td>Predicted correctly</td>
</tr>
</tbody>
</table>
<p>The code generator should prefer cheaper instructions when possible (e.g., using shifts instead of multiply by powers of 2).</p>
<hr />
<h2 id="2-instruction-selection">2. Instruction Selection<a class="header-link" href="#2-instruction-selection" title="Permanent link">&para;</a></h2>
<h3 id="21-the-problem">2.1 The Problem<a class="header-link" href="#21-the-problem" title="Permanent link">&para;</a></h3>
<p>Instruction selection maps IR operations to target machine instructions. The challenge is that:</p>
<ol>
<li>A single IR operation may correspond to multiple machine instructions</li>
<li>A single machine instruction may cover multiple IR operations</li>
<li>Different instruction sequences may compute the same result with different costs</li>
<li>The optimal choice depends on context (register availability, surrounding instructions)</li>
</ol>
<h3 id="22-tree-pattern-matching">2.2 Tree Pattern Matching<a class="header-link" href="#22-tree-pattern-matching" title="Permanent link">&para;</a></h3>
<p>Many architectures have instructions that can perform compound operations (e.g., <code>LOAD R0, [R1 + R2*4 + #8]</code> performs an addition, a multiplication, and a memory load in one instruction).</p>
<p>The idea of <strong>tree pattern matching</strong> is to:</p>
<ol>
<li>Represent the IR as expression trees</li>
<li>Define <strong>tiles</strong> -- tree patterns that correspond to single machine instructions</li>
<li><strong>Cover</strong> the IR tree with non-overlapping tiles that minimize total cost</li>
</ol>
<h3 id="23-tiles">2.3 Tiles<a class="header-link" href="#23-tiles" title="Permanent link">&para;</a></h3>
<p>A <strong>tile</strong> is a tree pattern paired with a machine instruction and a cost.</p>
<p>Example tiles for our target machine:</p>
<div class="highlight"><pre><span></span><code><span class="n">Tile</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">register</span><span class="w">                    </span><span class="n">Tile</span><span class="w"> </span><span class="mi">2</span><span class="err">:</span><span class="w"> </span><span class="k">immediate</span>
<span class="nl">Pattern</span><span class="p">:</span><span class="w">   </span><span class="n">reg</span><span class="w">                      </span><span class="nl">Pattern</span><span class="p">:</span><span class="w">   </span><span class="n">#imm</span>
<span class="nl">Instr</span><span class="p">:</span><span class="w">     </span><span class="p">(</span><span class="k">none</span><span class="p">,</span><span class="w"> </span><span class="n">already</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">reg</span><span class="p">)</span><span class="w">   </span><span class="nl">Instr</span><span class="p">:</span><span class="w">     </span><span class="n">MOVI</span><span class="w"> </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="n">#imm</span>
<span class="nl">Cost</span><span class="p">:</span><span class="w">      </span><span class="mi">0</span><span class="w">                        </span><span class="nl">Cost</span><span class="p">:</span><span class="w">      </span><span class="mi">1</span>

<span class="n">Tile</span><span class="w"> </span><span class="mi">3</span><span class="err">:</span><span class="w"> </span><span class="k">add</span><span class="w">                         </span><span class="n">Tile</span><span class="w"> </span><span class="mi">4</span><span class="err">:</span><span class="w"> </span><span class="k">add</span><span class="w"> </span><span class="k">immediate</span>
<span class="nl">Pattern</span><span class="p">:</span><span class="w">     </span><span class="o">+</span><span class="w">                      </span><span class="nl">Pattern</span><span class="p">:</span><span class="w">     </span><span class="o">+</span>
<span class="w">            </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">                                 </span><span class="o">/</span><span class="w"> </span><span class="err">\</span>
<span class="w">          </span><span class="n">reg</span><span class="w">  </span><span class="n">reg</span><span class="w">                            </span><span class="n">reg</span><span class="w">  </span><span class="n">#imm</span>
<span class="nl">Instr</span><span class="p">:</span><span class="w">   </span><span class="k">ADD</span><span class="w"> </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="n">Rs1</span><span class="p">,</span><span class="w"> </span><span class="n">Rs2</span><span class="w">          </span><span class="nl">Instr</span><span class="p">:</span><span class="w">   </span><span class="n">ADDI</span><span class="w"> </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="n">Rs</span><span class="p">,</span><span class="w"> </span><span class="n">#imm</span>
<span class="nl">Cost</span><span class="p">:</span><span class="w">    </span><span class="mi">1</span><span class="w">                          </span><span class="nl">Cost</span><span class="p">:</span><span class="w">    </span><span class="mi">1</span>

<span class="n">Tile</span><span class="w"> </span><span class="mi">5</span><span class="err">:</span><span class="w"> </span><span class="k">load</span><span class="w">                        </span><span class="n">Tile</span><span class="w"> </span><span class="mi">6</span><span class="err">:</span><span class="w"> </span><span class="n">indexed</span><span class="w"> </span><span class="k">load</span>
<span class="nl">Pattern</span><span class="p">:</span><span class="w">   </span><span class="n">MEM</span><span class="w">                      </span><span class="nl">Pattern</span><span class="p">:</span><span class="w">   </span><span class="n">MEM</span>
<span class="w">            </span><span class="o">|</span><span class="w">                                   </span><span class="o">|</span>
<span class="w">           </span><span class="n">reg</span><span class="w">                                  </span><span class="o">+</span>
<span class="w">                                               </span><span class="o">/</span><span class="w"> </span><span class="err">\</span>
<span class="nl">Instr</span><span class="p">:</span><span class="w">   </span><span class="k">LOAD</span><span class="w"> </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">Rs</span><span class="o">]</span><span class="w">                       </span><span class="n">reg</span><span class="w">  </span><span class="n">#imm</span>
<span class="nl">Cost</span><span class="p">:</span><span class="w">    </span><span class="mi">4</span><span class="w">                          </span><span class="nl">Instr</span><span class="p">:</span><span class="w">   </span><span class="k">LOAD</span><span class="w"> </span><span class="n">Rd</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">Rs + #imm</span><span class="o">]</span>
<span class="w">                                    </span><span class="nl">Cost</span><span class="p">:</span><span class="w">    </span><span class="mi">4</span>

<span class="n">Tile</span><span class="w"> </span><span class="mi">7</span><span class="err">:</span><span class="w"> </span><span class="n">store</span><span class="w">                       </span><span class="n">Tile</span><span class="w"> </span><span class="mi">8</span><span class="err">:</span><span class="w"> </span><span class="n">indexed</span><span class="w"> </span><span class="n">store</span>
<span class="nl">Pattern</span><span class="p">:</span><span class="w">  </span><span class="n">STORE</span><span class="w">                     </span><span class="nl">Pattern</span><span class="p">:</span><span class="w">  </span><span class="n">STORE</span>
<span class="w">          </span><span class="o">/</span><span class="w">   </span><span class="err">\</span><span class="w">                               </span><span class="o">/</span><span class="w">    </span><span class="err">\</span>
<span class="w">        </span><span class="n">addr</span><span class="w">   </span><span class="n">reg</span><span class="w">                           </span><span class="o">+</span><span class="w">      </span><span class="n">reg</span>
<span class="w">                                            </span><span class="o">/</span><span class="w"> </span><span class="err">\</span>
<span class="nl">Instr</span><span class="p">:</span><span class="w">  </span><span class="n">STORE</span><span class="w"> </span><span class="n">Rs</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">Rd</span><span class="o">]</span><span class="w">                    </span><span class="n">reg</span><span class="w">  </span><span class="n">#imm</span>
<span class="nl">Cost</span><span class="p">:</span><span class="w">   </span><span class="mi">1</span><span class="w">                           </span><span class="nl">Instr</span><span class="p">:</span><span class="w">  </span><span class="n">STORE</span><span class="w"> </span><span class="n">Rs</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">Rd + #imm</span><span class="o">]</span>
<span class="w">                                    </span><span class="nl">Cost</span><span class="p">:</span><span class="w">   </span><span class="mi">1</span>
</code></pre></div>

<h3 id="24-optimal-tiling-vs-maximal-munch">2.4 Optimal Tiling vs Maximal Munch<a class="header-link" href="#24-optimal-tiling-vs-maximal-munch" title="Permanent link">&para;</a></h3>
<p>There are two main strategies for covering the tree with tiles:</p>
<p><strong>Optimal Tiling</strong>: Find the set of tiles that covers the entire tree with minimum total cost. This can be solved with dynamic programming bottom-up on the tree.</p>
<p><strong>Maximal Munch</strong> (greedy): At each node, select the largest (most-covering) tile that matches, starting from the root. This is simpler but may not find the globally optimal solution.</p>
<p>In practice, Maximal Munch produces results that are close to optimal and is widely used.</p>
<h3 id="25-the-maximal-munch-algorithm">2.5 The Maximal Munch Algorithm<a class="header-link" href="#25-the-maximal-munch-algorithm" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">function</span><span class="w"> </span><span class="nf">maximal_munch</span><span class="p">(</span>node<span class="p">):</span>
<span class="w">    </span><span class="n">Find</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">largest</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="nb">matches</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">this</span><span class="w"> </span><span class="n">node</span>
<span class="w">    </span><span class="p">(</span><span class="n">matching</span><span class="w"> </span><span class="n">means</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="nb">pattern</span><span class="w"> </span><span class="nb">matches</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">subtree</span><span class="w"> </span><span class="n">rooted</span><span class="w"> </span><span class="n">here</span><span class="p">)</span>

<span class="w">    </span><span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">selected</span><span class="w"> </span><span class="n">tile</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">corresponds</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">a</span>
<span class="w">    </span><span class="n">subtree</span><span class="w"> </span><span class="p">(</span><span class="n">not</span><span class="w"> </span><span class="n">yet</span><span class="w"> </span><span class="n">covered</span><span class="p">):</span>
<span class="w">        </span><span class="n">Recursively</span><span class="w"> </span><span class="n">apply</span><span class="w"> </span><span class="n">maximal_munch</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">subtree</span>

<span class="w">    </span><span class="n">Emit</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">associated</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">selected</span><span class="w"> </span><span class="n">tile</span>
</code></pre></div>

<p>The algorithm works <strong>top-down</strong>: it matches the largest pattern at the root, then recursively processes the remaining subtrees.</p>
<p><strong>Example</strong>: Generate code for <code>a[i] = b + 1</code></p>
<p>IR tree:</p>
<div class="highlight"><pre><span></span><code>        STORE
       /     \
      +       +
     / \     / \
    a   *   b   1
       / \
      i   4
</code></pre></div>

<p>Maximal Munch might match:
1. At root: STORE tile covering <code>STORE(addr, value)</code> -- emits STORE instruction
2. Left child <code>+</code>: ADD tile for <code>a + (i * 4)</code> or indexed addressing
3. Right child <code>+</code>: ADDI tile for <code>b + 1</code></p>
<h3 id="26-python-implementation-maximal-munch">2.6 Python Implementation: Maximal Munch<a class="header-link" href="#26-python-implementation-maximal-munch" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;Instruction selection via Maximal Munch algorithm.&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span>


<span class="c1"># ---------- IR Tree Nodes ----------</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">IRNode</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for IR tree nodes.&quot;&quot;&quot;</span>
    <span class="k">pass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Const</span><span class="p">(</span><span class="n">IRNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Integer constant.&quot;&quot;&quot;</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Reg</span><span class="p">(</span><span class="n">IRNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Virtual register reference.&quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BinOp</span><span class="p">(</span><span class="n">IRNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Binary operation.&quot;&quot;&quot;</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">str</span>        <span class="c1"># &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">IRNode</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">IRNode</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Mem</span><span class="p">(</span><span class="n">IRNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Memory access (load).&quot;&quot;&quot;</span>
    <span class="n">address</span><span class="p">:</span> <span class="n">IRNode</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Store</span><span class="p">(</span><span class="n">IRNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Memory store.&quot;&quot;&quot;</span>
    <span class="n">address</span><span class="p">:</span> <span class="n">IRNode</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">IRNode</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CJump</span><span class="p">(</span><span class="n">IRNode</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Conditional jump.&quot;&quot;&quot;</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">str</span>           <span class="c1"># &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;==&#39;, &#39;!=&#39;, &#39;&lt;=&#39;, &#39;&gt;=&#39;</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">IRNode</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">IRNode</span>
    <span class="n">true_label</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">false_label</span><span class="p">:</span> <span class="nb">str</span>


<span class="c1"># ---------- Machine Instructions ----------</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MachineInstr</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A target machine instruction.&quot;&quot;&quot;</span>
    <span class="n">opcode</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">operands</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">comment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;  ; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;    </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">opcode</span><span class="si">:</span><span class="s2">6s</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">ops</span><span class="si">}{</span><span class="n">comment</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="c1"># ---------- Maximal Munch Code Generator ----------</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MaximalMunchCodeGen</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Instruction selection using the Maximal Munch (greedy) algorithm.</span>
<span class="sd">    Generates code for a simple RISC-like target.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">MachineInstr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reg_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">new_reg</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Allocate a new virtual register.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_reg_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;v</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_reg_counter</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opcode</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">operands</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">comment</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MachineInstr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Emit a machine instruction.&quot;&quot;&quot;</span>
        <span class="n">instr</span> <span class="o">=</span> <span class="n">MachineInstr</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="n">operands</span> <span class="ow">or</span> <span class="p">[],</span> <span class="n">comment</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">instr</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">munch_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IRNode</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate code for an expression node using Maximal Munch.</span>
<span class="sd">        Returns the register holding the result.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># --- Tile: Constant ---</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Const</span><span class="p">):</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_reg</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;MOVI&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">rd</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;#</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
                      <span class="sa">f</span><span class="s2">&quot;load constant </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rd</span>

        <span class="c1"># --- Tile: Register ---</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Reg</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>

        <span class="c1"># --- Tile: Memory load with indexed addressing ---</span>
        <span class="c1"># Pattern: MEM(BinOp(+, e1, Const(n)))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Mem</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">)</span> \
           <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">Const</span><span class="p">):</span>
            <span class="n">base_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_reg</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;LOAD&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">rd</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">base_reg</span><span class="si">}</span><span class="s2"> + #</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">],</span>
                      <span class="sa">f</span><span class="s2">&quot;indexed load&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rd</span>

        <span class="c1"># --- Tile: Memory load with register addressing ---</span>
        <span class="c1"># Pattern: MEM(e)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Mem</span><span class="p">):</span>
            <span class="n">addr_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_reg</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;LOAD&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">rd</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">addr_reg</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">],</span>
                      <span class="s2">&quot;register-indirect load&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rd</span>

        <span class="c1"># --- Tile: Add immediate ---</span>
        <span class="c1"># Pattern: BinOp(+, e, Const(n))</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">)</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> \
           <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">Const</span><span class="p">):</span>
            <span class="n">rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_reg</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;ADDI&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">rd</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;#</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
                      <span class="sa">f</span><span class="s2">&quot;add immediate </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rd</span>

        <span class="c1"># --- Tile: Add immediate (commuted) ---</span>
        <span class="c1"># Pattern: BinOp(+, Const(n), e)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">)</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> \
           <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">Const</span><span class="p">):</span>
            <span class="n">rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_reg</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;ADDI&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">rd</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;#</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
                      <span class="sa">f</span><span class="s2">&quot;add immediate </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rd</span>

        <span class="c1"># --- Tile: Multiply by power of 2 ‚Üí shift ---</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">)</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span> \
           <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">Const</span><span class="p">)</span> \
           <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span> <span class="o">&gt;</span> <span class="mi">0</span> \
           <span class="ow">and</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">rs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">shift</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_reg</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;SHL&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">rd</span><span class="p">,</span> <span class="n">rs</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;#</span><span class="si">{</span><span class="n">shift</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">],</span>
                      <span class="sa">f</span><span class="s2">&quot;multiply by </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2"> via shift&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rd</span>

        <span class="c1"># --- Tile: General binary operation ---</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">):</span>
            <span class="n">rs1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">rs2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_reg</span><span class="p">()</span>
            <span class="n">op_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="s1">&#39;ADD&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="s1">&#39;SUB&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="s1">&#39;MUL&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="s1">&#39;DIV&#39;</span><span class="p">}</span>
            <span class="n">opcode</span> <span class="o">=</span> <span class="n">op_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="s1">&#39;BINOP&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="p">[</span><span class="n">rd</span><span class="p">,</span> <span class="n">rs1</span><span class="p">,</span> <span class="n">rs2</span><span class="p">],</span>
                      <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> operation&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rd</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot generate code for: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">munch_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="n">IRNode</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate code for a statement node.&quot;&quot;&quot;</span>

        <span class="c1"># --- Tile: Indexed store ---</span>
        <span class="c1"># Pattern: Store(BinOp(+, e1, Const(n)), e2)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Store</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">)</span> \
           <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> \
           <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">Const</span><span class="p">):</span>
            <span class="n">base_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">val_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="o">.</span><span class="n">right</span><span class="o">.</span><span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;STORE&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">val_reg</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">base_reg</span><span class="si">}</span><span class="s2"> + #</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">],</span>
                      <span class="s2">&quot;indexed store&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># --- Tile: General store ---</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Store</span><span class="p">):</span>
            <span class="n">addr_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">address</span><span class="p">)</span>
            <span class="n">val_reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;STORE&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">val_reg</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">addr_reg</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">],</span>
                      <span class="s2">&quot;register-indirect store&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># --- Tile: Conditional jump ---</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">CJump</span><span class="p">):</span>
            <span class="n">rs1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">rs2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;CMP&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">rs1</span><span class="p">,</span> <span class="n">rs2</span><span class="p">],</span>
                      <span class="sa">f</span><span class="s2">&quot;compare for </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">branch_map</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span> <span class="s1">&#39;BLT&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="s1">&#39;BGT&#39;</span><span class="p">,</span> <span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="s1">&#39;BEQ&#39;</span><span class="p">,</span>
                <span class="s1">&#39;!=&#39;</span><span class="p">:</span> <span class="s1">&#39;BNE&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;=&#39;</span><span class="p">:</span> <span class="s1">&#39;BLE&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">:</span> <span class="s1">&#39;BGE&#39;</span>
            <span class="p">}</span>
            <span class="n">opcode</span> <span class="o">=</span> <span class="n">branch_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="s1">&#39;BR&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">true_label</span><span class="p">],</span>
                      <span class="sa">f</span><span class="s2">&quot;branch to </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">true_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="s2">&quot;JMP&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">false_label</span><span class="p">],</span>
                      <span class="sa">f</span><span class="s2">&quot;fall-through to </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">false_label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Expression statement: just evaluate for side effects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print all generated instructions.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">instr</span><span class="p">)</span>


<span class="c1"># ---------- Examples ----------</span>

<span class="k">def</span><span class="w"> </span><span class="nf">demo_expression</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate code for: result = a[i*4 + 8] + 1&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Expression: a[i*4 + 8] + 1 ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># IR tree: BinOp(+, Mem(BinOp(+, BinOp(*, i, 4), 8)), 1)</span>
    <span class="c1"># Simplified: Mem(BinOp(+, BinOp(+, a, BinOp(*, i, 4)), 8))</span>
    <span class="n">ir</span> <span class="o">=</span> <span class="n">BinOp</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
        <span class="n">Mem</span><span class="p">(</span>
            <span class="n">BinOp</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
                <span class="n">BinOp</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span>
                    <span class="n">Reg</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span>
                    <span class="n">BinOp</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">Reg</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">),</span> <span class="n">Const</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
                <span class="p">),</span>
                <span class="n">Const</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">),</span>
        <span class="n">Const</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">gen</span> <span class="o">=</span> <span class="n">MaximalMunchCodeGen</span><span class="p">()</span>
    <span class="n">result_reg</span> <span class="o">=</span> <span class="n">gen</span><span class="o">.</span><span class="n">munch_expr</span><span class="p">(</span><span class="n">ir</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Result in register: </span><span class="si">{</span><span class="n">result_reg</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">print_code</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_array_store</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate code for: a[i] = b + c&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Statement: a[i] = b + c ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Store(BinOp(+, a, BinOp(*, i, 4)), BinOp(+, b, c))</span>
    <span class="n">ir</span> <span class="o">=</span> <span class="n">Store</span><span class="p">(</span>
        <span class="n">address</span><span class="o">=</span><span class="n">BinOp</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">Reg</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">BinOp</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">Reg</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">),</span> <span class="n">Const</span><span class="p">(</span><span class="mi">4</span><span class="p">))),</span>
        <span class="n">value</span><span class="o">=</span><span class="n">BinOp</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">Reg</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span> <span class="n">Reg</span><span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="n">gen</span> <span class="o">=</span> <span class="n">MaximalMunchCodeGen</span><span class="p">()</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">munch_stmt</span><span class="p">(</span><span class="n">ir</span><span class="p">)</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">print_code</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_conditional</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate code for: if (x &lt; y) goto L1 else goto L2&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Conditional: if (x &lt; y) goto L1 else goto L2 ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">ir</span> <span class="o">=</span> <span class="n">CJump</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">Reg</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="n">Reg</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">),</span> <span class="s2">&quot;L1&quot;</span><span class="p">,</span> <span class="s2">&quot;L2&quot;</span><span class="p">)</span>

    <span class="n">gen</span> <span class="o">=</span> <span class="n">MaximalMunchCodeGen</span><span class="p">()</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">munch_stmt</span><span class="p">(</span><span class="n">ir</span><span class="p">)</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">print_code</span><span class="p">()</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo_expression</span><span class="p">()</span>
    <span class="n">demo_array_store</span><span class="p">()</span>
    <span class="n">demo_conditional</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="3-register-allocation">3. Register Allocation<a class="header-link" href="#3-register-allocation" title="Permanent link">&para;</a></h2>
<h3 id="31-the-problem">3.1 The Problem<a class="header-link" href="#31-the-problem" title="Permanent link">&para;</a></h3>
<p>The IR uses an unlimited number of virtual registers (or temporaries), but real machines have a small, fixed number of physical registers ($k$ registers). Register allocation assigns virtual registers to physical registers, <strong>spilling</strong> some to memory when $k$ registers are insufficient.</p>
<h3 id="32-why-register-allocation-matters">3.2 Why Register Allocation Matters<a class="header-link" href="#32-why-register-allocation-matters" title="Permanent link">&para;</a></h3>
<p>Register access is orders of magnitude faster than memory access:</p>
<table>
<thead>
<tr>
<th>Access</th>
<th>Latency (cycles)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Register</td>
<td>0-1</td>
</tr>
<tr>
<td>L1 cache</td>
<td>3-5</td>
</tr>
<tr>
<td>L2 cache</td>
<td>10-15</td>
</tr>
<tr>
<td>L3 cache</td>
<td>30-50</td>
</tr>
<tr>
<td>Main memory</td>
<td>100-300</td>
</tr>
</tbody>
</table>
<p>Good register allocation can dramatically improve program performance.</p>
<h3 id="33-liveness-analysis">3.3 Liveness Analysis<a class="header-link" href="#33-liveness-analysis" title="Permanent link">&para;</a></h3>
<p>Before allocating registers, we must determine which variables are <strong>live</strong> at each program point. A variable is <strong>live</strong> at a point if it holds a value that may be needed in the future.</p>
<p><strong>Definitions</strong>:
- A variable $v$ is <strong>defined</strong> at point $p$ if $p$ assigns to $v$
- A variable $v$ is <strong>used</strong> at point $p$ if $p$ reads $v$
- A variable $v$ is <strong>live</strong> at point $p$ if there is a path from $p$ to a use of $v$ that does not pass through a redefinition of $v$</p>
<p><strong>Data flow equations</strong> (computed backward):</p>
<p>$$\text{LiveIn}(B) = \text{Use}(B) \cup (\text{LiveOut}(B) - \text{Def}(B))$$</p>
<p>$$\text{LiveOut}(B) = \bigcup_{S \in \text{succ}(B)} \text{LiveIn}(S)$$</p>
<h3 id="34-interference-graph">3.4 Interference Graph<a class="header-link" href="#34-interference-graph" title="Permanent link">&para;</a></h3>
<p>Two variables <strong>interfere</strong> if they are simultaneously live at some program point. The <strong>interference graph</strong> $G = (V, E)$ has:</p>
<ul>
<li>Vertices $V$: one per variable (virtual register)</li>
<li>Edges $E$: $(u, v) \in E$ if $u$ and $v$ interfere</li>
</ul>
<p>Register allocation becomes a <strong>graph coloring</strong> problem: assign $k$ colors (physical registers) to the vertices such that no two adjacent vertices have the same color.</p>
<h3 id="35-graph-coloring-register-allocation">3.5 Graph Coloring Register Allocation<a class="header-link" href="#35-graph-coloring-register-allocation" title="Permanent link">&para;</a></h3>
<p>The graph coloring approach to register allocation was introduced by Chaitin (1981).</p>
<h4 id="chaitins-algorithm">Chaitin's Algorithm<a class="header-link" href="#chaitins-algorithm" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">repeat</span><span class="p">:</span>
<span class="w">    </span><span class="mf">1.</span><span class="w"> </span><span class="n">Build</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">interference</span><span class="w"> </span><span class="n">graph</span>
<span class="w">    </span><span class="mf">2.</span><span class="w"> </span><span class="n">Simplify</span><span class="p">:</span><span class="w"> </span><span class="n">While</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">exists</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">degree</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">k</span><span class="p">:</span>
<span class="w">       </span><span class="o">-</span><span class="w"> </span><span class="n">Remove</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">graph</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">push</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">stack</span>
<span class="w">       </span><span class="o">-</span><span class="w"> </span><span class="p">(</span><span class="n">It</span><span class="w"> </span><span class="n">can</span><span class="w"> </span><span class="n">always</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">colored</span><span class="w"> </span><span class="n">since</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">fewer</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">neighbors</span><span class="p">)</span>
<span class="w">    </span><span class="mf">3.</span><span class="w"> </span><span class="n">Spill</span><span class="p">:</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">such</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">exists</span><span class="p">:</span>
<span class="w">       </span><span class="o">-</span><span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">spill</span><span class="w"> </span><span class="p">(</span><span class="n">heuristic</span><span class="p">:</span><span class="w"> </span><span class="n">high</span><span class="w"> </span><span class="n">degree</span><span class="p">,</span><span class="w"> </span><span class="n">low</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">frequency</span><span class="p">)</span>
<span class="w">       </span><span class="o">-</span><span class="w"> </span><span class="n">Insert</span><span class="w"> </span><span class="nb">load</span><span class="o">/</span><span class="n">store</span><span class="w"> </span><span class="n">instructions</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">spilled</span><span class="w"> </span><span class="n">variable</span>
<span class="w">       </span><span class="o">-</span><span class="w"> </span><span class="n">Go</span><span class="w"> </span><span class="n">back</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">step</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="mf">4.</span><span class="w"> </span><span class="n">Select</span><span class="p">:</span><span class="w"> </span><span class="n">Pop</span><span class="w"> </span><span class="n">nodes</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">assign</span><span class="w"> </span><span class="n">colors</span>
<span class="w">       </span><span class="o">-</span><span class="w"> </span><span class="n">Each</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">fewer</span><span class="w"> </span><span class="n">than</span><span class="w"> </span><span class="n">k</span><span class="w"> </span><span class="n">colored</span><span class="w"> </span><span class="n">neighbors</span><span class="p">,</span><span class="w"> </span><span class="n">so</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">color</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">available</span>
</code></pre></div>

<h4 id="example">Example<a class="header-link" href="#example" title="Permanent link">&para;</a></h4>
<p>Consider 4 virtual registers $\{a, b, c, d\}$ with interference graph:</p>
<div class="highlight"><pre><span></span><code>a --- b
|  X  |     (a-b, a-c, b-c, b-d interfere)
c --- d
   |
   b
</code></pre></div>

<p>Wait, let us be precise:
- $a$ interferes with $b$ and $c$
- $b$ interferes with $a$, $c$, and $d$
- $c$ interferes with $a$ and $b$
- $d$ interferes with $b$</p>
<p>With $k = 3$ registers:</p>
<div class="highlight"><pre><span></span><code><span class="nx">Step</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="nx">Simplify</span><span class="p">):</span>
<span class="w">  </span><span class="nx">d</span><span class="w"> </span><span class="nx">has</span><span class="w"> </span><span class="nx">degree</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="nx">push</span><span class="w"> </span><span class="nx">d</span><span class="p">,</span><span class="w"> </span><span class="nx">remove</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">graph</span>
<span class="w">  </span><span class="nx">a</span><span class="w"> </span><span class="nx">has</span><span class="w"> </span><span class="nx">degree</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="nx">push</span><span class="w"> </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">remove</span>
<span class="w">  </span><span class="nx">c</span><span class="w"> </span><span class="nx">has</span><span class="w"> </span><span class="nx">degree</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="nx">push</span><span class="w"> </span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">remove</span>
<span class="w">  </span><span class="nx">b</span><span class="w"> </span><span class="nx">has</span><span class="w"> </span><span class="nx">degree</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="nx">push</span><span class="w"> </span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="nx">remove</span>

<span class="nx">Stack</span><span class="w"> </span><span class="p">(</span><span class="nx">top</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">bottom</span><span class="p">):</span><span class="w"> </span><span class="p">[</span><span class="nx">b</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">,</span><span class="w"> </span><span class="nx">a</span><span class="p">,</span><span class="w"> </span><span class="nx">d</span><span class="p">]</span>

<span class="nx">Step</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="nx">Select</span><span class="p">):</span>
<span class="w">  </span><span class="nx">Pop</span><span class="w"> </span><span class="nx">b</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="nx">assign</span><span class="w"> </span><span class="nx">R0</span><span class="w"> </span><span class="p">(</span><span class="nx">no</span><span class="w"> </span><span class="nx">neighbors</span><span class="w"> </span><span class="nx">colored</span><span class="w"> </span><span class="nx">yet</span><span class="p">)</span>
<span class="w">  </span><span class="nx">Pop</span><span class="w"> </span><span class="nx">c</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="nx">neighbors</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nx">b</span><span class="p">=</span><span class="nx">R0</span><span class="p">}</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="nx">assign</span><span class="w"> </span><span class="nx">R1</span>
<span class="w">  </span><span class="nx">Pop</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="nx">neighbors</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nx">b</span><span class="p">=</span><span class="nx">R0</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">=</span><span class="nx">R1</span><span class="p">}</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="nx">assign</span><span class="w"> </span><span class="nx">R2</span>
<span class="w">  </span><span class="nx">Pop</span><span class="w"> </span><span class="nx">d</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="nx">neighbors</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="nx">b</span><span class="p">=</span><span class="nx">R0</span><span class="p">}</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="nx">assign</span><span class="w"> </span><span class="nx">R1</span><span class="w"> </span><span class="p">(</span><span class="k">or</span><span class="w"> </span><span class="nx">R2</span><span class="p">)</span>

<span class="nx">Result</span><span class="p">:</span><span class="w"> </span><span class="nx">a</span><span class="p">=</span><span class="nx">R2</span><span class="p">,</span><span class="w"> </span><span class="nx">b</span><span class="p">=</span><span class="nx">R0</span><span class="p">,</span><span class="w"> </span><span class="nx">c</span><span class="p">=</span><span class="nx">R1</span><span class="p">,</span><span class="w"> </span><span class="nx">d</span><span class="p">=</span><span class="nx">R1</span>
</code></pre></div>

<h3 id="36-spilling">3.6 Spilling<a class="header-link" href="#36-spilling" title="Permanent link">&para;</a></h3>
<p>When the graph cannot be $k$-colored (no node has degree $< k$), we must <strong>spill</strong> a variable to memory. This means:</p>
<ol>
<li>Before each use of the spilled variable, insert a <code>LOAD</code> from memory</li>
<li>After each definition, insert a <code>STORE</code> to memory</li>
<li>The spilled variable no longer needs a register (or needs one only briefly)</li>
<li>Rebuild the interference graph and try again</li>
</ol>
<p><strong>Spill heuristics</strong>:
- Spill the variable with the highest degree (most interference)
- Spill the variable used least frequently (lowest use count)
- Spill the variable with the highest degree/use ratio
- Avoid spilling variables inside loops</p>
<h3 id="37-linear-scan-register-allocation">3.7 Linear Scan Register Allocation<a class="header-link" href="#37-linear-scan-register-allocation" title="Permanent link">&para;</a></h3>
<p>Graph coloring is effective but expensive for large programs. <strong>Linear scan</strong> is a faster alternative used in JIT compilers (e.g., HotSpot JVM, V8).</p>
<p><strong>Idea</strong>: Process variables in order of their <strong>live intervals</strong> (the range from first definition to last use). Allocate registers greedily:</p>
<div class="highlight"><pre><span></span><code><span class="n">Algorithm</span><span class="o">:</span><span class="w"> </span><span class="n">Linear</span><span class="w"> </span><span class="n">Scan</span><span class="w"> </span><span class="n">Register</span><span class="w"> </span><span class="n">Allocation</span>

<span class="n">Input</span><span class="o">:</span><span class="w">  </span><span class="n">Live</span><span class="w"> </span><span class="n">intervals</span><span class="w"> </span><span class="n">sorted</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">start</span><span class="w"> </span><span class="n">point</span>
<span class="w">        </span><span class="n">k</span><span class="w"> </span><span class="n">available</span><span class="w"> </span><span class="n">registers</span>

<span class="mi">1</span><span class="o">.</span><span class="w"> </span><span class="n">active</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[]</span><span class="w">  </span><span class="o">(</span><span class="n">intervals</span><span class="w"> </span><span class="n">currently</span><span class="w"> </span><span class="n">occupying</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">register</span><span class="o">)</span>
<span class="mi">2</span><span class="o">.</span><span class="w"> </span><span class="n">free_regs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">R0</span><span class="o">,</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">R</span><span class="o">(</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="o">)}</span>

<span class="mi">3</span><span class="o">.</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">interval</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">order</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">increasing</span><span class="w"> </span><span class="n">start</span><span class="o">:</span>
<span class="w">    </span><span class="n">a</span><span class="o">.</span><span class="w"> </span><span class="n">Expire</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="n">intervals</span><span class="o">:</span>
<span class="w">       </span><span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">active</span><span class="w"> </span><span class="o">(</span><span class="n">sorted</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">point</span><span class="o">):</span>
<span class="w">           </span><span class="k">if</span><span class="w"> </span><span class="n">j</span><span class="o">.</span><span class="na">end</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="na">start</span><span class="o">:</span>
<span class="w">               </span><span class="n">remove</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">active</span>
<span class="w">               </span><span class="k">return</span><span class="w"> </span><span class="n">j</span><span class="o">.</span><span class="na">register</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">free_regs</span>

<span class="w">    </span><span class="n">b</span><span class="o">.</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">free_regs</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">empty</span><span class="o">:</span>
<span class="w">       </span><span class="n">Spill</span><span class="o">:</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">interval</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">active</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">latest</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">point</span>
<span class="w">              </span><span class="k">if</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">end</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">i</span><span class="o">.</span><span class="na">end</span><span class="o">:</span>
<span class="w">                  </span><span class="n">spill</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">interval</span><span class="o">,</span><span class="w"> </span><span class="n">give</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="n">register</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">i</span>
<span class="w">              </span><span class="k">else</span><span class="o">:</span>
<span class="w">                  </span><span class="n">spill</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">(</span><span class="n">assign</span><span class="w"> </span><span class="n">memory</span><span class="w"> </span><span class="n">location</span><span class="o">)</span>

<span class="w">    </span><span class="n">c</span><span class="o">.</span><span class="w"> </span><span class="k">else</span><span class="o">:</span>
<span class="w">       </span><span class="n">Allocate</span><span class="o">:</span><span class="w"> </span><span class="n">assign</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">register</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">free_regs</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">i</span>
<span class="w">       </span><span class="n">add</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">active</span>
</code></pre></div>

<p><strong>Time complexity</strong>: $O(n \log n)$ where $n$ is the number of intervals (sorting dominates).</p>
<p><strong>Comparison</strong>:</p>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Graph Coloring</th>
<th>Linear Scan</th>
</tr>
</thead>
<tbody>
<tr>
<td>Quality</td>
<td>Better (global view)</td>
<td>Good (not optimal)</td>
</tr>
<tr>
<td>Compile time</td>
<td>$O(n^2)$ or worse</td>
<td>$O(n \log n)$</td>
</tr>
<tr>
<td>Use case</td>
<td>Ahead-of-time compilers</td>
<td>JIT compilers</td>
</tr>
<tr>
<td>Handles coalescing</td>
<td>Naturally</td>
<td>Additional pass needed</td>
</tr>
</tbody>
</table>
<h3 id="38-python-implementation-linear-scan">3.8 Python Implementation: Linear Scan<a class="header-link" href="#38-python-implementation-linear-scan" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;Linear Scan Register Allocation.&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">LiveInterval</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A live interval for a virtual register.&quot;&quot;&quot;</span>
    <span class="n">vreg</span><span class="p">:</span> <span class="nb">str</span>      <span class="c1"># Virtual register name</span>
    <span class="n">start</span><span class="p">:</span> <span class="nb">int</span>     <span class="c1"># First definition point</span>
    <span class="n">end</span><span class="p">:</span> <span class="nb">int</span>       <span class="c1"># Last use point</span>
    <span class="n">preg</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span> <span class="c1"># Assigned physical register (or &quot;spill&quot;)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">alloc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">preg</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">preg</span> <span class="k">else</span> <span class="s2">&quot;unallocated&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">vreg</span><span class="si">}</span><span class="s2">: [</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">] -&gt; </span><span class="si">{</span><span class="n">alloc</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LinearScanAllocator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Linear scan register allocator.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_physical_regs</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">num_physical_regs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">physical_regs</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;R</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_physical_regs</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_regs</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">physical_regs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">LiveInterval</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Sorted by end point</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spilled</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">LiveInterval</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">LiveInterval</span><span class="p">]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform linear scan allocation.</span>
<span class="sd">        Modifies interval.preg in place.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sort by start point</span>
        <span class="n">intervals</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">iv</span><span class="p">:</span> <span class="n">iv</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
            <span class="c1"># Expire old intervals</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_expire_old</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_regs</span><span class="p">:</span>
                <span class="c1"># Must spill</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_spill_at</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Allocate a register</span>
                <span class="n">reg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_regs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">iv</span><span class="o">.</span><span class="n">preg</span> <span class="o">=</span> <span class="n">reg</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_expire_old</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">:</span> <span class="n">LiveInterval</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove intervals that have ended before the current one starts.&quot;&quot;&quot;</span>
        <span class="n">still_active</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">iv</span><span class="o">.</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">.</span><span class="n">start</span><span class="p">:</span>
                <span class="c1"># This interval has expired</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">free_regs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">preg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">still_active</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">iv</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">still_active</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_spill_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">current</span><span class="p">:</span> <span class="n">LiveInterval</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spill either the current interval or the one ending latest.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">current</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
            <span class="c1"># Spill the active interval ending latest</span>
            <span class="n">spill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">current</span><span class="o">.</span><span class="n">preg</span> <span class="o">=</span> <span class="n">spill</span><span class="o">.</span><span class="n">preg</span>
            <span class="n">spill</span><span class="o">.</span><span class="n">preg</span> <span class="o">=</span> <span class="s2">&quot;SPILL&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spilled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spill</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">active</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Spill the current interval</span>
            <span class="n">current</span><span class="o">.</span><span class="n">preg</span> <span class="o">=</span> <span class="s2">&quot;SPILL&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spilled</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_linear_scan</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate linear scan register allocation.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Linear Scan Register Allocation ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">intervals</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">LiveInterval</span><span class="p">(</span><span class="s2">&quot;t1&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>  <span class="n">end</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span>
        <span class="n">LiveInterval</span><span class="p">(</span><span class="s2">&quot;t2&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>  <span class="n">end</span><span class="o">=</span><span class="mi">8</span><span class="p">),</span>
        <span class="n">LiveInterval</span><span class="p">(</span><span class="s2">&quot;t3&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>  <span class="n">end</span><span class="o">=</span><span class="mi">12</span><span class="p">),</span>
        <span class="n">LiveInterval</span><span class="p">(</span><span class="s2">&quot;t4&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>  <span class="n">end</span><span class="o">=</span><span class="mi">14</span><span class="p">),</span>
        <span class="n">LiveInterval</span><span class="p">(</span><span class="s2">&quot;t5&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">9</span><span class="p">,</span>  <span class="n">end</span><span class="o">=</span><span class="mi">16</span><span class="p">),</span>
        <span class="n">LiveInterval</span><span class="p">(</span><span class="s2">&quot;t6&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">18</span><span class="p">),</span>
        <span class="n">LiveInterval</span><span class="p">(</span><span class="s2">&quot;t7&quot;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">20</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Live intervals:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">iv</span><span class="o">.</span><span class="n">vreg</span><span class="si">}</span><span class="s2">: [</span><span class="si">{</span><span class="n">iv</span><span class="o">.</span><span class="n">start</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">iv</span><span class="o">.</span><span class="n">end</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

    <span class="c1"># Allocate with 3 physical registers</span>
    <span class="n">allocator</span> <span class="o">=</span> <span class="n">LinearScanAllocator</span><span class="p">(</span><span class="n">num_physical_regs</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">allocator</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Allocation with </span><span class="si">{</span><span class="n">allocator</span><span class="o">.</span><span class="n">k</span><span class="si">}</span><span class="s2"> registers:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
        <span class="n">status</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">iv</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">iv</span><span class="o">.</span><span class="n">preg</span> <span class="o">==</span> <span class="s2">&quot;SPILL&quot;</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">+=</span> <span class="s2">&quot; (SPILLED)&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">status</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">allocator</span><span class="o">.</span><span class="n">spilled</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Spilled variables: &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">vreg</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">allocator</span><span class="o">.</span><span class="n">spilled</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Visualize</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Timeline visualization:&quot;</span><span class="p">)</span>
    <span class="n">max_time</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">iv</span><span class="o">.</span><span class="n">end</span> <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Time: &quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">t</span><span class="si">:</span><span class="s2">2d</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">intervals</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">iv</span><span class="o">.</span><span class="n">vreg</span><span class="si">:</span><span class="s2">4s</span><span class="si">}</span><span class="s2">: &quot;</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_time</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">iv</span><span class="o">.</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">t</span> <span class="o">&lt;=</span> <span class="n">iv</span><span class="o">.</span><span class="n">end</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">iv</span><span class="o">.</span><span class="n">preg</span> <span class="o">==</span> <span class="s2">&quot;SPILL&quot;</span><span class="p">:</span>
                    <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot; S&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">line</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">iv</span><span class="o">.</span><span class="n">preg</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>  <span class="c1"># Just the number</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">+=</span> <span class="s2">&quot; .&quot;</span>
        <span class="n">line</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;  (</span><span class="si">{</span><span class="n">iv</span><span class="o">.</span><span class="n">preg</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo_linear_scan</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="4-instruction-scheduling">4. Instruction Scheduling<a class="header-link" href="#4-instruction-scheduling" title="Permanent link">&para;</a></h2>
<h3 id="41-the-problem">4.1 The Problem<a class="header-link" href="#41-the-problem" title="Permanent link">&para;</a></h3>
<p>Modern processors are <strong>pipelined</strong>: different stages of instruction execution overlap. However, <strong>data hazards</strong> can cause <strong>pipeline stalls</strong> when an instruction depends on the result of a previous instruction that has not yet completed.</p>
<p><strong>Example stall</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="k">LOAD</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">R2</span><span class="o">]</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">takes</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">cycles</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">complete</span>
<span class="k">ADD</span><span class="w">  </span><span class="n">R3</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">R4</span><span class="w">   </span><span class="p">;</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">wait</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">R1</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">pipeline</span><span class="w"> </span><span class="n">stall</span><span class="w"> </span><span class="p">(</span><span class="mi">3</span><span class="w"> </span><span class="n">wasted</span><span class="w"> </span><span class="n">cycles</span><span class="p">)</span>
</code></pre></div>

<p><strong>After scheduling</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="k">LOAD</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">R2</span><span class="o">]</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">issue</span><span class="w"> </span><span class="k">load</span>
<span class="k">ADD</span><span class="w">  </span><span class="n">R5</span><span class="p">,</span><span class="w"> </span><span class="n">R6</span><span class="p">,</span><span class="w"> </span><span class="n">R7</span><span class="w">   </span><span class="p">;</span><span class="w"> </span><span class="n">independent</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">fills</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">gap</span>
<span class="n">SUB</span><span class="w">  </span><span class="n">R8</span><span class="p">,</span><span class="w"> </span><span class="n">R9</span><span class="p">,</span><span class="w"> </span><span class="n">R10</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">another</span><span class="w"> </span><span class="n">independent</span><span class="w"> </span><span class="n">instruction</span>
<span class="n">MOV</span><span class="w">  </span><span class="n">R11</span><span class="p">,</span><span class="w"> </span><span class="n">R12</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">yet</span><span class="w"> </span><span class="n">another</span>
<span class="k">ADD</span><span class="w">  </span><span class="n">R3</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">R4</span><span class="w">   </span><span class="p">;</span><span class="w"> </span><span class="n">R1</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">now</span><span class="w"> </span><span class="n">ready</span><span class="p">,</span><span class="w"> </span><span class="k">no</span><span class="w"> </span><span class="n">stall</span>
</code></pre></div>

<h3 id="42-list-scheduling">4.2 List Scheduling<a class="header-link" href="#42-list-scheduling" title="Permanent link">&para;</a></h3>
<p><strong>List scheduling</strong> is the most common instruction scheduling algorithm. It operates on a single basic block.</p>
<p><strong>Input</strong>: A <strong>dependency DAG</strong> where:
- Nodes are instructions
- Edges represent data dependencies (read-after-write, write-after-read, write-after-write)
- Edge weights represent the latency of the source instruction</p>
<p><strong>Algorithm</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="k">function</span><span class="w"> </span><span class="nf">list_schedule</span><span class="p">(</span>DAG, num_functional_units<span class="p">):</span>
<span class="w">    </span><span class="n">ready</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">instructions</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="nb">predecessors</span>
<span class="w">    </span><span class="n">schedule</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[]</span>
<span class="w">    </span><span class="n">cycle</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span>

<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">ready</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="nb">empty</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">pending</span><span class="w"> </span><span class="n">instructions</span><span class="w"> </span><span class="nb">exist</span><span class="p">:</span>
<span class="w">        </span>#<span class="w"> </span><span class="n">Select</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">ready</span><span class="w"> </span><span class="n">instructions</span><span class="w"> </span><span class="p">(</span><span class="n">priority</span><span class="o">-</span><span class="n">based</span><span class="p">)</span>
<span class="w">        </span><span class="n">available</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">instructions</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">ready</span><span class="w"> </span><span class="n">whose</span><span class="w"> </span><span class="n">operands</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">available</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">functional</span><span class="w"> </span><span class="n">unit</span><span class="p">:</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="n">available</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="nb">empty</span><span class="p">:</span>
<span class="w">                </span><span class="n">instr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="n">highest</span><span class="o">-</span><span class="n">priority</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">available</span>
<span class="w">                </span><span class="n">issue</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">cycle</span>
<span class="w">                </span><span class="n">schedule</span><span class="p">[</span><span class="n">cycle</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">instr</span>
<span class="w">                </span><span class="nb">remove</span><span class="w"> </span><span class="n">instr</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">ready</span>

<span class="w">        </span><span class="n">cycle</span><span class="w"> </span><span class="o">+</span><span class="p">=</span><span class="w"> </span><span class="mi">1</span>

<span class="w">        </span>#<span class="w"> </span><span class="n">Check</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nb">any</span><span class="w"> </span><span class="n">pending</span><span class="w"> </span><span class="n">instructions</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">completed</span>
<span class="w">        </span>#<span class="w"> </span><span class="n">Add</span><span class="w"> </span><span class="n">their</span><span class="w"> </span><span class="nb">successors</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">ready</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="nb">all</span><span class="w"> </span><span class="nb">predecessors</span><span class="w"> </span><span class="n">are</span><span class="w"> </span><span class="n">done</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">schedule</span>
</code></pre></div>

<p><strong>Priority heuristics</strong> (which instruction to schedule first):
- <strong>Critical path length</strong>: Prefer instructions on the longest path to any sink
- <strong>Number of successors</strong>: Prefer instructions with more dependent successors
- <strong>Latency</strong>: Prefer instructions with higher latency (start them sooner)</p>
<h3 id="43-example-list-scheduling">4.3 Example: List Scheduling<a class="header-link" href="#43-example-list-scheduling" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="nl">Instructions</span><span class="p">:</span>
<span class="w">  </span><span class="nl">I1</span><span class="p">:</span><span class="w"> </span><span class="k">LOAD</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">addr1</span><span class="o">]</span><span class="w">   </span><span class="p">;</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="mi">4</span>
<span class="w">  </span><span class="nl">I2</span><span class="p">:</span><span class="w"> </span><span class="k">LOAD</span><span class="w"> </span><span class="n">R2</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">addr2</span><span class="o">]</span><span class="w">   </span><span class="p">;</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="mi">4</span>
<span class="w">  </span><span class="nl">I3</span><span class="p">:</span><span class="w"> </span><span class="k">ADD</span><span class="w">  </span><span class="n">R3</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">R2</span><span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">depends</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">I1</span><span class="p">,</span><span class="w"> </span><span class="n">I2</span>
<span class="w">  </span><span class="nl">I4</span><span class="p">:</span><span class="w"> </span><span class="n">MUL</span><span class="w">  </span><span class="n">R4</span><span class="p">,</span><span class="w"> </span><span class="n">R3</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">depends</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">I3</span><span class="p">,</span><span class="w"> </span><span class="n">I1</span>
<span class="w">  </span><span class="nl">I5</span><span class="p">:</span><span class="w"> </span><span class="n">STORE</span><span class="w"> </span><span class="n">R4</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">addr3</span><span class="o">]</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">depends</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">I4</span>

<span class="n">Dependency</span><span class="w"> </span><span class="nl">DAG</span><span class="p">:</span>
<span class="w">  </span><span class="n">I1</span><span class="w"> </span><span class="err">‚îÄ‚îÄ</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="err">‚îÄ‚îÄ‚ñ∂</span><span class="w"> </span><span class="n">I3</span>
<span class="w">  </span><span class="n">I2</span><span class="w"> </span><span class="err">‚îÄ‚îÄ</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="err">‚îÄ‚îÄ‚ñ∂</span><span class="w"> </span><span class="n">I3</span>
<span class="w">  </span><span class="n">I3</span><span class="w"> </span><span class="err">‚îÄ‚îÄ</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="err">‚îÄ‚îÄ‚ñ∂</span><span class="w"> </span><span class="n">I4</span>
<span class="w">  </span><span class="n">I1</span><span class="w"> </span><span class="err">‚îÄ‚îÄ</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="err">‚îÄ‚îÄ‚ñ∂</span><span class="w"> </span><span class="n">I4</span>
<span class="w">  </span><span class="n">I4</span><span class="w"> </span><span class="err">‚îÄ‚îÄ</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="err">‚îÄ‚îÄ‚ñ∂</span><span class="w"> </span><span class="n">I5</span>

<span class="n">Unscheduled</span><span class="w"> </span><span class="p">(</span><span class="ow">all</span><span class="w"> </span><span class="n">instructions</span><span class="w"> </span><span class="n">sequentially</span><span class="p">)</span><span class="err">:</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span><span class="w"> </span><span class="n">I1</span><span class="w"> </span><span class="p">(</span><span class="k">LOAD</span><span class="p">)</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">1</span><span class="o">-</span><span class="mi">3</span><span class="err">:</span><span class="w"> </span><span class="n">stall</span><span class="w"> </span><span class="p">(</span><span class="n">waiting</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">I1</span><span class="p">)</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">4</span><span class="err">:</span><span class="w"> </span><span class="n">I2</span><span class="w"> </span><span class="p">(</span><span class="k">LOAD</span><span class="p">)</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">5</span><span class="o">-</span><span class="mi">7</span><span class="err">:</span><span class="w"> </span><span class="n">stall</span><span class="w"> </span><span class="p">(</span><span class="n">waiting</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">I2</span><span class="p">)</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">8</span><span class="err">:</span><span class="w"> </span><span class="n">I3</span><span class="w"> </span><span class="p">(</span><span class="k">ADD</span><span class="p">)</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">9</span><span class="err">:</span><span class="w"> </span><span class="n">I4</span><span class="w"> </span><span class="p">(</span><span class="n">MUL</span><span class="p">)</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">10</span><span class="o">-</span><span class="mi">11</span><span class="err">:</span><span class="w"> </span><span class="n">stall</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">12</span><span class="err">:</span><span class="w"> </span><span class="n">I5</span><span class="w"> </span><span class="p">(</span><span class="n">STORE</span><span class="p">)</span>
<span class="w">  </span><span class="nl">Total</span><span class="p">:</span><span class="w"> </span><span class="mi">13</span><span class="w"> </span><span class="n">cycles</span>

<span class="n">Scheduled</span><span class="w"> </span><span class="p">(</span><span class="n">list</span><span class="w"> </span><span class="n">scheduling</span><span class="p">)</span><span class="err">:</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">0</span><span class="err">:</span><span class="w"> </span><span class="n">I1</span><span class="w"> </span><span class="p">(</span><span class="k">LOAD</span><span class="w"> </span><span class="n">R1</span><span class="p">)</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">I2</span><span class="w"> </span><span class="p">(</span><span class="k">LOAD</span><span class="w"> </span><span class="n">R2</span><span class="p">)</span><span class="w">    </span><span class="err">‚Üê</span><span class="w"> </span><span class="n">issued</span><span class="w"> </span><span class="n">during</span><span class="w"> </span><span class="n">I1</span><span class="err">&#39;</span><span class="n">s</span><span class="w"> </span><span class="n">latency</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">4</span><span class="err">:</span><span class="w"> </span><span class="n">I3</span><span class="w"> </span><span class="p">(</span><span class="k">ADD</span><span class="w"> </span><span class="n">R3</span><span class="p">)</span><span class="w">     </span><span class="err">‚Üê</span><span class="w"> </span><span class="k">both</span><span class="w"> </span><span class="n">I1</span><span class="p">,</span><span class="w"> </span><span class="n">I2</span><span class="w"> </span><span class="n">ready</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">5</span><span class="err">:</span><span class="w"> </span><span class="n">I4</span><span class="w"> </span><span class="p">(</span><span class="n">MUL</span><span class="w"> </span><span class="n">R4</span><span class="p">)</span><span class="w">     </span><span class="err">‚Üê</span><span class="w"> </span><span class="n">I3</span><span class="w"> </span><span class="n">ready</span>
<span class="w">  </span><span class="k">Cycle</span><span class="w"> </span><span class="mi">8</span><span class="err">:</span><span class="w"> </span><span class="n">I5</span><span class="w"> </span><span class="p">(</span><span class="n">STORE</span><span class="w"> </span><span class="n">R4</span><span class="p">)</span><span class="w">   </span><span class="err">‚Üê</span><span class="w"> </span><span class="n">I4</span><span class="w"> </span><span class="n">ready</span>
<span class="w">  </span><span class="nl">Total</span><span class="p">:</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="n">cycles</span><span class="w"> </span><span class="p">(</span><span class="n">saved</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="n">cycles</span><span class="p">)</span>
</code></pre></div>

<h3 id="44-software-pipelining-overview">4.4 Software Pipelining (Overview)<a class="header-link" href="#44-software-pipelining-overview" title="Permanent link">&para;</a></h3>
<p><strong>Software pipelining</strong> is a loop optimization technique that overlaps iterations of a loop, similar to how hardware pipelining overlaps instruction stages.</p>
<p><strong>Idea</strong>: Instead of completing iteration $i$ before starting iteration $i+1$, begin iteration $i+1$ while iteration $i$ is still in progress:</p>
<div class="highlight"><pre><span></span><code>Without software pipelining:     With software pipelining:
  Iter 1: LOAD-ADD-STORE         Cycle 0: LOAD[1]
  Iter 2: LOAD-ADD-STORE         Cycle 1: LOAD[2], ADD[1]
  Iter 3: LOAD-ADD-STORE         Cycle 2: LOAD[3], ADD[2], STORE[1]
                                  Cycle 3: LOAD[4], ADD[3], STORE[2]
                                  ...
</code></pre></div>

<p>The steady-state of the software pipeline executes parts of multiple iterations simultaneously, keeping all functional units busy.</p>
<p>Software pipelining is most commonly implemented using <strong>modulo scheduling</strong>, which finds a schedule for one iteration such that repeating it with a fixed <strong>initiation interval</strong> (II) produces a valid overlapping schedule.</p>
<hr />
<h2 id="5-peephole-optimization">5. Peephole Optimization<a class="header-link" href="#5-peephole-optimization" title="Permanent link">&para;</a></h2>
<h3 id="51-what-is-peephole-optimization">5.1 What Is Peephole Optimization?<a class="header-link" href="#51-what-is-peephole-optimization" title="Permanent link">&para;</a></h3>
<p><strong>Peephole optimization</strong> examines a small window (the "peephole") of consecutive instructions and replaces them with faster or shorter equivalents. It is applied after code generation as a final cleanup pass.</p>
<h3 id="52-common-peephole-optimizations">5.2 Common Peephole Optimizations<a class="header-link" href="#52-common-peephole-optimizations" title="Permanent link">&para;</a></h3>
<h4 id="redundant-loadstore-elimination">Redundant Load/Store Elimination<a class="header-link" href="#redundant-loadstore-elimination" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="k">Before</span><span class="err">:</span><span class="w">                  </span><span class="k">After</span><span class="err">:</span>
<span class="w">  </span><span class="n">STORE</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">addr</span><span class="o">]</span><span class="w">       </span><span class="n">STORE</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">addr</span><span class="o">]</span>
<span class="w">  </span><span class="k">LOAD</span><span class="w">  </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">addr</span><span class="o">]</span><span class="w">       </span><span class="p">(</span><span class="k">load</span><span class="w"> </span><span class="n">eliminated</span><span class="w"> </span><span class="c1">-- R1 already has the value)</span>
</code></pre></div>

<h4 id="redundant-moves">Redundant Moves<a class="header-link" href="#redundant-moves" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">Before</span><span class="o">:</span><span class="w">                  </span><span class="n">After</span><span class="o">:</span>
<span class="w">  </span><span class="n">MOV</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="w">             </span><span class="o">(</span><span class="n">eliminated</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">R1</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="n">or</span>
<span class="w">  </span><span class="n">MOV</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="n">R1</span><span class="w">              </span><span class="n">second</span><span class="w"> </span><span class="n">move</span><span class="w"> </span><span class="n">eliminated</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">sufficient</span><span class="o">)</span>
</code></pre></div>

<h4 id="strength-reduction">Strength Reduction<a class="header-link" href="#strength-reduction" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">Before</span><span class="o">:</span><span class="w">                  </span><span class="n">After</span><span class="o">:</span>
<span class="w">  </span><span class="n">MUL</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="err">#</span><span class="mi">2</span><span class="w">         </span><span class="n">SHL</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="err">#</span><span class="mi">1</span><span class="w">    </span><span class="o">(</span><span class="n">shift</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">cheaper</span><span class="o">)</span>
<span class="w">  </span><span class="n">MUL</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="err">#</span><span class="mi">8</span><span class="w">         </span><span class="n">SHL</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="err">#</span><span class="mi">3</span>
<span class="w">  </span><span class="n">DIV</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="err">#</span><span class="mi">4</span><span class="w">         </span><span class="n">SHR</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="err">#</span><span class="mi">2</span><span class="w">    </span><span class="o">(</span><span class="k">for</span><span class="w"> </span><span class="n">unsigned</span><span class="o">)</span>
</code></pre></div>

<h4 id="algebraic-simplification">Algebraic Simplification<a class="header-link" href="#algebraic-simplification" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">Before</span><span class="o">:</span><span class="w">                  </span><span class="n">After</span><span class="o">:</span>
<span class="w">  </span><span class="n">ADD</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="err">#</span><span class="mi">0</span><span class="w">         </span><span class="n">MOV</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="w">         </span><span class="o">(</span><span class="n">or</span><span class="w"> </span><span class="n">eliminated</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">R1</span><span class="o">==</span><span class="n">R2</span><span class="o">)</span>
<span class="w">  </span><span class="n">MUL</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="err">#</span><span class="mi">1</span><span class="w">         </span><span class="n">MOV</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span>
<span class="w">  </span><span class="n">MUL</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="err">#</span><span class="mi">0</span><span class="w">         </span><span class="n">MOVI</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="err">#</span><span class="mi">0</span>
<span class="w">  </span><span class="n">SUB</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="err">#</span><span class="mi">0</span><span class="w">         </span><span class="n">MOV</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span>
</code></pre></div>

<h4 id="branch-optimization">Branch Optimization<a class="header-link" href="#branch-optimization" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">Before</span><span class="o">:</span><span class="w">                  </span><span class="n">After</span><span class="o">:</span>
<span class="w">  </span><span class="n">JMP</span><span class="w"> </span><span class="n">L1</span><span class="w">                 </span><span class="n">JMP</span><span class="w"> </span><span class="n">L2</span><span class="w">             </span><span class="o">(</span><span class="n">jump</span><span class="o">-</span><span class="n">to</span><span class="o">-</span><span class="n">jump</span><span class="w"> </span><span class="n">elimination</span><span class="o">)</span>
<span class="w">  </span><span class="o">...</span>
<span class="n">L1</span><span class="o">:</span><span class="w"> </span><span class="n">JMP</span><span class="w"> </span><span class="n">L2</span>

<span class="n">Before</span><span class="o">:</span><span class="w">                  </span><span class="n">After</span><span class="o">:</span>
<span class="w">  </span><span class="n">BEQ</span><span class="w"> </span><span class="n">L1</span><span class="w">                 </span><span class="n">BNE</span><span class="w"> </span><span class="n">L2</span><span class="w">             </span><span class="o">(</span><span class="n">branch</span><span class="o">-</span><span class="n">over</span><span class="o">-</span><span class="n">jump</span><span class="w"> </span><span class="n">elimination</span><span class="o">)</span>
<span class="w">  </span><span class="n">JMP</span><span class="w"> </span><span class="n">L2</span><span class="w">                 </span><span class="o">...</span>
<span class="n">L1</span><span class="o">:</span><span class="w"> </span><span class="o">...</span><span class="w">                  </span><span class="n">L2</span><span class="o">:</span><span class="w"> </span><span class="o">...</span>
</code></pre></div>

<h4 id="unreachable-code-elimination">Unreachable Code Elimination<a class="header-link" href="#unreachable-code-elimination" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">Before</span><span class="o">:</span><span class="w">                  </span><span class="n">After</span><span class="o">:</span>
<span class="w">  </span><span class="n">JMP</span><span class="w"> </span><span class="n">L1</span><span class="w">                 </span><span class="n">JMP</span><span class="w"> </span><span class="n">L1</span>
<span class="w">  </span><span class="n">ADD</span><span class="w"> </span><span class="n">R1</span><span class="o">,</span><span class="w"> </span><span class="n">R2</span><span class="o">,</span><span class="w"> </span><span class="n">R3</span><span class="w">         </span><span class="o">(</span><span class="n">unreachable</span><span class="o">,</span><span class="w"> </span><span class="n">eliminated</span><span class="o">)</span>
<span class="w">  </span><span class="n">MOV</span><span class="w"> </span><span class="n">R4</span><span class="o">,</span><span class="w"> </span><span class="n">R5</span><span class="w">             </span><span class="o">(</span><span class="n">unreachable</span><span class="o">,</span><span class="w"> </span><span class="n">eliminated</span><span class="o">)</span>
<span class="n">L1</span><span class="o">:</span><span class="w"> </span><span class="o">...</span><span class="w">                  </span><span class="n">L1</span><span class="o">:</span><span class="w"> </span><span class="o">...</span>
</code></pre></div>

<h3 id="53-python-implementation-peephole-optimizer">5.3 Python Implementation: Peephole Optimizer<a class="header-link" href="#53-python-implementation-peephole-optimizer" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;Peephole optimizer for a simple instruction set.&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Instruction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A machine instruction for peephole optimization.&quot;&quot;&quot;</span>
    <span class="n">text</span><span class="p">:</span> <span class="nb">str</span>       <span class="c1"># Full instruction text</span>
    <span class="n">opcode</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">operands</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>  <span class="c1"># If this is a label</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">operands</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">text</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">label</span> <span class="o">=</span> <span class="n">text</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="s2">&quot;LABEL&quot;</span>
            <span class="k">return</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parts</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">opcode</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">operands</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">label</span><span class="si">}</span><span class="s2">:&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">text</span>


<span class="k">class</span><span class="w"> </span><span class="nc">PeepholeOptimizer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply peephole optimizations to a list of instructions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instructions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span><span class="n">Instruction</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">instr</span><span class="p">)</span> <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Track if any optimization was applied</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_passes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run peephole optimizations until no more changes occur.&quot;&quot;&quot;</span>
        <span class="n">pass_num</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="ow">and</span> <span class="n">pass_num</span> <span class="o">&lt;</span> <span class="n">max_passes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">pass_num</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_redundant_moves</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_redundant_load_after_store</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_strength_reduction</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_algebraic_simplification</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_jump_to_jump</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_unreachable_code</span><span class="p">()</span>
            <span class="c1"># Remove None entries</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span> <span class="k">if</span> <span class="n">i</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>

        <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_redundant_moves</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove MOV Rx, Rx (move to self).&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instr</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;MOV&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_redundant_load_after_store</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove LOAD Rx, [addr] immediately after STORE Rx, [addr].&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">nxt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">curr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">nxt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">curr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;STORE&quot;</span> <span class="ow">and</span> <span class="n">nxt</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;LOAD&quot;</span><span class="p">:</span>
                <span class="c1"># Check if same register and same address</span>
                <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">curr</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">nxt</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span>
                    <span class="ow">and</span> <span class="n">curr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nxt</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="ow">and</span> <span class="n">curr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">nxt</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_strength_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replace MUL/DIV by power of 2 with shifts.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;MUL&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">imm</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">imm</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">imm</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">shift</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">new_text</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  SHL </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, #</span><span class="si">{</span><span class="n">shift</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Instruction</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">new_text</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;DIV&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">imm</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">imm</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
                    <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">imm</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
                    <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">shift</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">new_text</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  SHR </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, #</span><span class="si">{</span><span class="n">shift</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Instruction</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">new_text</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_algebraic_simplification</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simplify ADD x, y, #0 ‚Üí MOV x, y, etc.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;ADD&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;#0&quot;</span><span class="p">:</span>
                    <span class="n">new_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;  MOV </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Instruction</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">new_text</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;MUL&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;#1&quot;</span><span class="p">:</span>
                    <span class="n">new_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;  MOV </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Instruction</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">new_text</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;#0&quot;</span><span class="p">:</span>
                    <span class="n">new_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;  MOVI </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, #0&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Instruction</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">new_text</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;SUB&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;#0&quot;</span><span class="p">:</span>
                    <span class="n">new_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;  MOV </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Instruction</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">new_text</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_jump_to_jump</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replace JMP L1 where L1: JMP L2 with JMP L2.&quot;&quot;&quot;</span>
        <span class="c1"># Build label -&gt; index map</span>
        <span class="n">label_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instr</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;LABEL&quot;</span><span class="p">:</span>
                <span class="n">label_map</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;JMP&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">target</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">label_map</span><span class="p">:</span>
                    <span class="n">target_idx</span> <span class="o">=</span> <span class="n">label_map</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
                    <span class="c1"># Find the next non-label instruction after the target</span>
                    <span class="n">j</span> <span class="o">=</span> <span class="n">target_idx</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">)</span>
                           <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                           <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;LABEL&quot;</span><span class="p">):</span>
                        <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">)</span>
                        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="s2">&quot;JMP&quot;</span><span class="p">):</span>
                        <span class="n">new_target</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">new_target</span> <span class="o">!=</span> <span class="n">target</span><span class="p">:</span>
                            <span class="n">new_text</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;  JMP </span><span class="si">{</span><span class="n">new_target</span><span class="si">}</span><span class="s2">&quot;</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Instruction</span><span class="p">(</span><span class="n">text</span><span class="o">=</span><span class="n">new_text</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_unreachable_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove instructions between an unconditional jump and the next label.&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="n">instr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">instr</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;JMP&quot;</span><span class="p">,</span> <span class="s2">&quot;RET&quot;</span><span class="p">):</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">)</span>
                       <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                       <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">opcode</span> <span class="o">!=</span> <span class="s2">&quot;LABEL&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_peephole</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate peephole optimization.&quot;&quot;&quot;</span>
    <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;  MOVI R1, #5&quot;</span><span class="p">,</span>
        <span class="s2">&quot;  MOVI R2, #10&quot;</span><span class="p">,</span>
        <span class="s2">&quot;  ADD  R3, R1, R2&quot;</span><span class="p">,</span>
        <span class="s2">&quot;  MOV  R3, R3&quot;</span><span class="p">,</span>           <span class="c1"># Redundant self-move</span>
        <span class="s2">&quot;  MUL  R4, R3, #8&quot;</span><span class="p">,</span>       <span class="c1"># Strength reduction: * 8 ‚Üí &lt;&lt; 3</span>
        <span class="s2">&quot;  ADD  R5, R4, #0&quot;</span><span class="p">,</span>       <span class="c1"># Algebraic: + 0 ‚Üí move</span>
        <span class="s2">&quot;  STORE R5, [R6]&quot;</span><span class="p">,</span>
        <span class="s2">&quot;  LOAD  R5, [R6]&quot;</span><span class="p">,</span>        <span class="c1"># Redundant load after store</span>
        <span class="s2">&quot;  MUL  R7, R5, #1&quot;</span><span class="p">,</span>       <span class="c1"># Algebraic: * 1 ‚Üí move</span>
        <span class="s2">&quot;  MUL  R8, R5, #0&quot;</span><span class="p">,</span>       <span class="c1"># Algebraic: * 0 ‚Üí 0</span>
        <span class="s2">&quot;  DIV  R9, R3, #4&quot;</span><span class="p">,</span>       <span class="c1"># Strength reduction: / 4 ‚Üí &gt;&gt; 2</span>
        <span class="s2">&quot;  JMP  L1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;  ADD  R10, R1, R2&quot;</span><span class="p">,</span>      <span class="c1"># Unreachable code</span>
        <span class="s2">&quot;  SUB  R11, R3, R4&quot;</span><span class="p">,</span>      <span class="c1"># Unreachable code</span>
        <span class="s2">&quot;L1:&quot;</span><span class="p">,</span>
        <span class="s2">&quot;  JMP  L2&quot;</span><span class="p">,</span>               <span class="c1"># Jump-to-jump target</span>
        <span class="s2">&quot;L2:&quot;</span><span class="p">,</span>
        <span class="s2">&quot;  SUB  R12, R1, #0&quot;</span><span class="p">,</span>      <span class="c1"># Algebraic: - 0 ‚Üí move</span>
        <span class="s2">&quot;  RET&quot;</span><span class="p">,</span>
    <span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Before Peephole Optimization ===&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">instr</span><span class="p">)</span>

    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">PeepholeOptimizer</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>
    <span class="n">optimized</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== After Peephole Optimization ===&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">optimized</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">instr</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo_peephole</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="6-code-generation-for-language-constructs">6. Code Generation for Language Constructs<a class="header-link" href="#6-code-generation-for-language-constructs" title="Permanent link">&para;</a></h2>
<h3 id="61-expressions">6.1 Expressions<a class="header-link" href="#61-expressions" title="Permanent link">&para;</a></h3>
<p>Generating code for arithmetic expressions follows the structure of the expression tree. For a binary operation $a \;\text{op}\; b$:</p>
<div class="highlight"><pre><span></span><code>generate(a)         ‚Üí result in R1
generate(b)         ‚Üí result in R2
OP R3, R1, R2       ‚Üí R3 = R1 op R2
</code></pre></div>

<p>For deeply nested expressions, we need to manage registers carefully. The <strong>Sethi-Ullman numbering</strong> algorithm computes the minimum number of registers needed to evaluate an expression tree.</p>
<p><strong>Sethi-Ullman numbering</strong>:
- A leaf that is a left child: label = 1
- A leaf that is a right child: label = 0
- An interior node with children labeled $l_1$ and $l_2$:</p>
<p>$$\text{label}(n) = \begin{cases} \max(l_1, l_2) & \text{if } l_1 \neq l_2 \\ l_1 + 1 & \text{if } l_1 = l_2 \end{cases}$$</p>
<p>The label at the root gives the minimum number of registers needed.</p>
<h3 id="62-control-flow">6.2 Control Flow<a class="header-link" href="#62-control-flow" title="Permanent link">&para;</a></h3>
<h4 id="if-else">If-Else<a class="header-link" href="#if-else" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">then_body</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">else_body</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Generated code:</p>
<div class="highlight"><pre><span></span><code>    &lt;evaluate condition into R1&gt;
    CMP R1, #0
    BEQ else_label
    &lt;then_body code&gt;
    JMP end_label
else_label:
    &lt;else_body code&gt;
end_label:
</code></pre></div>

<h4 id="while-loop">While Loop<a class="header-link" href="#while-loop" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">condition</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">body</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>Generated code:</p>
<div class="highlight"><pre><span></span><code>loop_start:
    &lt;evaluate condition into R1&gt;
    CMP R1, #0
    BEQ loop_end
    &lt;body code&gt;
    JMP loop_start
loop_end:
</code></pre></div>

<h4 id="for-loop">For Loop<a class="header-link" href="#for-loop" title="Permanent link">&para;</a></h4>
<p>A for loop is typically desugared into a while loop:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">init</span><span class="p">;</span><span class="w"> </span><span class="n">condition</span><span class="p">;</span><span class="w"> </span><span class="n">step</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">body</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
</code></pre></div>

<p>Becomes:</p>
<div class="highlight"><pre><span></span><code>    &lt;init code&gt;
loop_start:
    &lt;evaluate condition&gt;
    BEQ loop_end
    &lt;body code&gt;
    &lt;step code&gt;
    JMP loop_start
loop_end:
</code></pre></div>

<h4 id="short-circuit-boolean-evaluation">Short-Circuit Boolean Evaluation<a class="header-link" href="#short-circuit-boolean-evaluation" title="Permanent link">&para;</a></h4>
<p>For <code>a &amp;&amp; b</code>:</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="o">&lt;</span><span class="nt">evaluate</span><span class="w"> </span><span class="nt">a</span><span class="o">&gt;</span>
<span class="w">    </span><span class="nt">CMP</span><span class="w"> </span><span class="nt">R1</span><span class="o">,</span><span class="w"> </span><span class="p">#</span><span class="nn">0</span>
<span class="w">    </span><span class="nt">BEQ</span><span class="w"> </span><span class="nt">false_label</span><span class="w">     </span><span class="o">;</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">false</span><span class="o">,</span><span class="w"> </span><span class="nt">skip</span><span class="w"> </span><span class="nt">b</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nt">evaluate</span><span class="w"> </span><span class="nt">b</span><span class="o">&gt;</span>
<span class="w">    </span><span class="nt">CMP</span><span class="w"> </span><span class="nt">R2</span><span class="o">,</span><span class="w"> </span><span class="p">#</span><span class="nn">0</span>
<span class="w">    </span><span class="nt">BEQ</span><span class="w"> </span><span class="nt">false_label</span><span class="w">     </span><span class="o">;</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">b</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">false</span>
<span class="w">    </span><span class="nt">MOVI</span><span class="w"> </span><span class="nt">R3</span><span class="o">,</span><span class="w"> </span><span class="p">#</span><span class="nn">1</span><span class="w">          </span><span class="o">;</span><span class="w"> </span><span class="nt">result</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">true</span>
<span class="w">    </span><span class="nt">JMP</span><span class="w"> </span><span class="nt">end_label</span>
<span class="nt">false_label</span><span class="o">:</span>
<span class="w">    </span><span class="nt">MOVI</span><span class="w"> </span><span class="nt">R3</span><span class="o">,</span><span class="w"> </span><span class="p">#</span><span class="nn">0</span><span class="w">          </span><span class="o">;</span><span class="w"> </span><span class="nt">result</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">false</span>
<span class="nt">end_label</span><span class="o">:</span>
</code></pre></div>

<p>For <code>a || b</code>:</p>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="o">&lt;</span><span class="nt">evaluate</span><span class="w"> </span><span class="nt">a</span><span class="o">&gt;</span>
<span class="w">    </span><span class="nt">CMP</span><span class="w"> </span><span class="nt">R1</span><span class="o">,</span><span class="w"> </span><span class="p">#</span><span class="nn">0</span>
<span class="w">    </span><span class="nt">BNE</span><span class="w"> </span><span class="nt">true_label</span><span class="w">       </span><span class="o">;</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">a</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">true</span><span class="o">,</span><span class="w"> </span><span class="nt">skip</span><span class="w"> </span><span class="nt">b</span>
<span class="w">    </span><span class="o">&lt;</span><span class="nt">evaluate</span><span class="w"> </span><span class="nt">b</span><span class="o">&gt;</span>
<span class="w">    </span><span class="nt">CMP</span><span class="w"> </span><span class="nt">R2</span><span class="o">,</span><span class="w"> </span><span class="p">#</span><span class="nn">0</span>
<span class="w">    </span><span class="nt">BNE</span><span class="w"> </span><span class="nt">true_label</span><span class="w">       </span><span class="o">;</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">b</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">true</span>
<span class="w">    </span><span class="nt">MOVI</span><span class="w"> </span><span class="nt">R3</span><span class="o">,</span><span class="w"> </span><span class="p">#</span><span class="nn">0</span><span class="w">           </span><span class="o">;</span><span class="w"> </span><span class="nt">result</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">false</span>
<span class="w">    </span><span class="nt">JMP</span><span class="w"> </span><span class="nt">end_label</span>
<span class="nt">true_label</span><span class="o">:</span>
<span class="w">    </span><span class="nt">MOVI</span><span class="w"> </span><span class="nt">R3</span><span class="o">,</span><span class="w"> </span><span class="p">#</span><span class="nn">1</span><span class="w">           </span><span class="o">;</span><span class="w"> </span><span class="nt">result</span><span class="w"> </span><span class="nt">is</span><span class="w"> </span><span class="nt">true</span>
<span class="nt">end_label</span><span class="o">:</span>
</code></pre></div>

<h3 id="63-function-calls">6.3 Function Calls<a class="header-link" href="#63-function-calls" title="Permanent link">&para;</a></h3>
<p>Generating code for a function call involves:</p>
<div class="highlight"><pre><span></span><code><span class="p">;</span><span class="w"> </span><span class="n">Caller</span><span class="o">-</span><span class="n">saved</span><span class="w"> </span><span class="n">registers</span>
<span class="n">PUSH</span><span class="w"> </span><span class="n">R_caller_saved1</span>
<span class="n">PUSH</span><span class="w"> </span><span class="n">R_caller_saved2</span>

<span class="p">;</span><span class="w"> </span><span class="n">Arguments</span><span class="w"> </span><span class="p">(</span><span class="n">System</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="nl">AMD64:</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="mh">6</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">registers</span><span class="p">)</span>
<span class="n">MOV</span><span class="w"> </span><span class="n">RDI</span><span class="p">,</span><span class="w"> </span><span class="n">arg1</span>
<span class="n">MOV</span><span class="w"> </span><span class="n">RSI</span><span class="p">,</span><span class="w"> </span><span class="n">arg2</span>
<span class="n">MOV</span><span class="w"> </span><span class="n">RDX</span><span class="p">,</span><span class="w"> </span><span class="n">arg3</span>
<span class="p">;</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="n">push</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mh">6</span><span class="w"> </span><span class="n">args</span>

<span class="p">;</span><span class="w"> </span><span class="n">Call</span>
<span class="n">CALL</span><span class="w"> </span><span class="n">function_label</span>

<span class="p">;</span><span class="w"> </span><span class="n">Return</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">RAX</span>
<span class="n">MOV</span><span class="w"> </span><span class="n">result</span><span class="p">,</span><span class="w"> </span><span class="n">RAX</span>

<span class="p">;</span><span class="w"> </span><span class="n">Restore</span><span class="w"> </span><span class="n">caller</span><span class="o">-</span><span class="n">saved</span><span class="w"> </span><span class="n">registers</span>
<span class="n">POP</span><span class="w"> </span><span class="n">R_caller_saved2</span>
<span class="n">POP</span><span class="w"> </span><span class="n">R_caller_saved1</span>
</code></pre></div>

<hr />
<h2 id="7-stack-machine-code-generator">7. Stack Machine Code Generator<a class="header-link" href="#7-stack-machine-code-generator" title="Permanent link">&para;</a></h2>
<h3 id="71-what-is-a-stack-machine">7.1 What Is a Stack Machine?<a class="header-link" href="#71-what-is-a-stack-machine" title="Permanent link">&para;</a></h3>
<p>A <strong>stack machine</strong> uses an operand stack instead of registers. Instructions implicitly operate on the top of the stack:</p>
<div class="highlight"><pre><span></span><code><span class="nt">PUSH</span><span class="w"> </span><span class="nt">5</span><span class="w">        </span><span class="o">;</span><span class="w"> </span><span class="nt">stack</span><span class="o">:</span><span class="w"> </span><span class="cp">[</span><span class="mi">5</span><span class="cp">]</span>
<span class="nt">PUSH</span><span class="w"> </span><span class="nt">3</span><span class="w">        </span><span class="o">;</span><span class="w"> </span><span class="nt">stack</span><span class="o">:</span><span class="w"> </span><span class="cp">[</span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="cp">]</span>
<span class="nt">ADD</span><span class="w">           </span><span class="o">;</span><span class="w"> </span><span class="nt">stack</span><span class="o">:</span><span class="w"> </span><span class="cp">[</span><span class="mi">8</span><span class="cp">]</span><span class="w">       </span><span class="o">(</span><span class="nt">pop</span><span class="w"> </span><span class="nt">two</span><span class="o">,</span><span class="w"> </span><span class="nt">push</span><span class="w"> </span><span class="nt">sum</span><span class="o">)</span>
<span class="nt">PUSH</span><span class="w"> </span><span class="nt">2</span><span class="w">        </span><span class="o">;</span><span class="w"> </span><span class="nt">stack</span><span class="o">:</span><span class="w"> </span><span class="cp">[</span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="cp">]</span>
<span class="nt">MUL</span><span class="w">           </span><span class="o">;</span><span class="w"> </span><span class="nt">stack</span><span class="o">:</span><span class="w"> </span><span class="cp">[</span><span class="mi">16</span><span class="cp">]</span><span class="w">      </span><span class="o">(</span><span class="nt">pop</span><span class="w"> </span><span class="nt">two</span><span class="o">,</span><span class="w"> </span><span class="nt">push</span><span class="w"> </span><span class="nt">product</span><span class="o">)</span>
</code></pre></div>

<p>Stack machines are simpler to generate code for because there is no register allocation problem. Examples: JVM bytecode, .NET CIL, Python bytecode, WebAssembly (partially).</p>
<h3 id="72-stack-machine-instruction-set">7.2 Stack Machine Instruction Set<a class="header-link" href="#72-stack-machine-instruction-set" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">Stack</span><span class="w"> </span><span class="n">operations</span><span class="p">:</span>
<span class="w">    </span><span class="n">PUSH</span><span class="w"> </span><span class="o">&lt;</span><span class="n">value</span><span class="o">&gt;</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">Push</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">onto</span><span class="w"> </span><span class="n">stack</span>
<span class="w">    </span><span class="n">LOAD</span><span class="w"> </span><span class="o">&lt;</span><span class="k">var</span><span class="o">&gt;</span><span class="w">       </span><span class="p">;</span><span class="w"> </span><span class="n">Push</span><span class="w"> </span><span class="n">variable</span><span class="s1">&#39;s value onto stack</span>
<span class="w">    </span><span class="n">STORE</span><span class="w"> </span><span class="o">&lt;</span><span class="k">var</span><span class="o">&gt;</span><span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">Pop</span><span class="w"> </span><span class="n">value</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">store</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">variable</span>
<span class="w">    </span><span class="n">POP</span><span class="w">              </span><span class="p">;</span><span class="w"> </span><span class="n">Discard</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">stack</span>
<span class="w">    </span><span class="n">DUP</span><span class="w">              </span><span class="p">;</span><span class="w"> </span><span class="n">Duplicate</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">stack</span>

<span class="n">Arithmetic</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">operands</span><span class="p">,</span><span class="w"> </span><span class="n">push</span><span class="w"> </span><span class="n">result</span><span class="p">):</span>
<span class="w">    </span><span class="n">ADD</span><span class="p">,</span><span class="w"> </span><span class="n">SUB</span><span class="p">,</span><span class="w"> </span><span class="n">MUL</span><span class="p">,</span><span class="w"> </span><span class="n">DIV</span><span class="p">,</span><span class="w"> </span><span class="n">MOD</span><span class="p">,</span><span class="w"> </span><span class="n">NEG</span>

<span class="n">Comparison</span><span class="w"> </span><span class="p">(</span><span class="n">pop</span><span class="w"> </span><span class="n">two</span><span class="p">,</span><span class="w"> </span><span class="n">push</span><span class="w"> </span><span class="n">boolean</span><span class="p">):</span>
<span class="w">    </span><span class="n">EQ</span><span class="p">,</span><span class="w"> </span><span class="n">NE</span><span class="p">,</span><span class="w"> </span><span class="n">LT</span><span class="p">,</span><span class="w"> </span><span class="n">GT</span><span class="p">,</span><span class="w"> </span><span class="n">LE</span><span class="p">,</span><span class="w"> </span><span class="n">GE</span>

<span class="n">Logic</span><span class="p">:</span>
<span class="w">    </span><span class="n">AND</span><span class="p">,</span><span class="w"> </span><span class="n">OR</span><span class="p">,</span><span class="w"> </span><span class="n">NOT</span>

<span class="n">Control</span><span class="w"> </span><span class="n">flow</span><span class="p">:</span>
<span class="w">    </span><span class="n">LABEL</span><span class="w"> </span><span class="o">&lt;</span><span class="n">name</span><span class="o">&gt;</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">Define</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">label</span>
<span class="w">    </span><span class="n">JMP</span><span class="w"> </span><span class="o">&lt;</span><span class="n">label</span><span class="o">&gt;</span><span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">Unconditional</span><span class="w"> </span><span class="n">jump</span>
<span class="w">    </span><span class="n">JMPF</span><span class="w"> </span><span class="o">&lt;</span><span class="n">label</span><span class="o">&gt;</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">Jump</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="bp">false</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="w">    </span><span class="n">JMPT</span><span class="w"> </span><span class="o">&lt;</span><span class="n">label</span><span class="o">&gt;</span><span class="w">     </span><span class="p">;</span><span class="w"> </span><span class="n">Jump</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="bp">true</span><span class="w"> </span><span class="p">(</span><span class="n">non</span><span class="o">-</span><span class="mi">0</span><span class="p">)</span>

<span class="n">Functions</span><span class="p">:</span>
<span class="w">    </span><span class="n">CALL</span><span class="w"> </span><span class="o">&lt;</span><span class="k">func</span><span class="o">&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">nargs</span><span class="o">&gt;</span><span class="w">  </span><span class="p">;</span><span class="w"> </span><span class="n">Call</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">arguments</span>
<span class="w">    </span><span class="n">RET</span><span class="w">                  </span><span class="p">;</span><span class="w"> </span><span class="n">Return</span><span class="w"> </span><span class="p">(</span><span class="n">top</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">stack</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">value</span><span class="p">)</span>

<span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="p">:</span>
<span class="w">    </span><span class="n">PRINT</span><span class="w">            </span><span class="p">;</span><span class="w"> </span><span class="n">Pop</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="nb">print</span><span class="w"> </span><span class="n">top</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">stack</span>
<span class="w">    </span><span class="n">READ</span><span class="w">             </span><span class="p">;</span><span class="w"> </span><span class="n">Read</span><span class="w"> </span><span class="n">input</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">push</span><span class="w"> </span><span class="n">onto</span><span class="w"> </span><span class="n">stack</span>
</code></pre></div>

<h3 id="73-complete-stack-machine-implementation">7.3 Complete Stack Machine Implementation<a class="header-link" href="#73-complete-stack-machine-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Complete code generator and virtual machine for a stack-based target.</span>

<span class="sd">Compiles a simple language to stack machine bytecode and executes it.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Union</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Part 1: Source Language AST</span>
<span class="c1"># ============================================================</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NumLit</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">int</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BoolLit</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">VarRef</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BinaryExpr</span><span class="p">:</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">left</span><span class="p">:</span> <span class="s1">&#39;Expression&#39;</span>
    <span class="n">right</span><span class="p">:</span> <span class="s1">&#39;Expression&#39;</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">UnaryExpr</span><span class="p">:</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">operand</span><span class="p">:</span> <span class="s1">&#39;Expression&#39;</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">CallExpr</span><span class="p">:</span>
    <span class="n">func</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">args</span><span class="p">:</span> <span class="nb">list</span>

<span class="n">Expression</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">NumLit</span><span class="p">,</span> <span class="n">BoolLit</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">,</span> <span class="n">UnaryExpr</span><span class="p">,</span> <span class="n">CallExpr</span><span class="p">]</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AssignStmt</span><span class="p">:</span>
    <span class="n">target</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Expression</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">PrintStmt</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Expression</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">IfStmt</span><span class="p">:</span>
    <span class="n">condition</span><span class="p">:</span> <span class="n">Expression</span>
    <span class="n">then_body</span><span class="p">:</span> <span class="nb">list</span>
    <span class="n">else_body</span><span class="p">:</span> <span class="nb">list</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">WhileStmt</span><span class="p">:</span>
    <span class="n">condition</span><span class="p">:</span> <span class="n">Expression</span>
    <span class="n">body</span><span class="p">:</span> <span class="nb">list</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ReturnStmt</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Expression</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FuncDef</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">params</span><span class="p">:</span> <span class="nb">list</span>  <span class="c1"># list of parameter names</span>
    <span class="n">body</span><span class="p">:</span> <span class="nb">list</span>    <span class="c1"># list of statements</span>

<span class="n">Statement</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="n">AssignStmt</span><span class="p">,</span> <span class="n">PrintStmt</span><span class="p">,</span> <span class="n">IfStmt</span><span class="p">,</span> <span class="n">WhileStmt</span><span class="p">,</span> <span class="n">ReturnStmt</span><span class="p">]</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Part 2: Stack Machine Bytecode</span>
<span class="c1"># ============================================================</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Opcode</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">PUSH</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">LOAD</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">STORE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">POP</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">DUP</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">ADD</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">SUB</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">MUL</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">DIV</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">MOD</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">NEG</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">EQ</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">NE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">LT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">GT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">LE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">GE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">AND</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">OR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">NOT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">JMP</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">JMPF</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">JMPT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">CALL</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">RET</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">PRINT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">LABEL</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">HALT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BytecodeInstr</span><span class="p">:</span>
    <span class="n">opcode</span><span class="p">:</span> <span class="n">Opcode</span>
    <span class="n">operand</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">operand2</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">opcode</span><span class="o">.</span><span class="n">name</span><span class="si">:</span><span class="s2">8s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operand2</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">operand2</span><span class="p">))</span>
        <span class="k">return</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Part 3: Code Generator</span>
<span class="c1"># ============================================================</span>

<span class="k">class</span><span class="w"> </span><span class="nc">CodeGenerator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate stack machine bytecode from AST.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">BytecodeInstr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label_counter</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># func name -&gt; code address</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">new_label</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_label_counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_label_counter</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opcode</span><span class="p">:</span> <span class="n">Opcode</span><span class="p">,</span> <span class="n">operand</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">operand2</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">BytecodeInstr</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">operand2</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">generate_program</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate code for a complete program.</span>
<span class="sd">        Program is a list of function definitions and statements.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Separate functions from top-level statements</span>
        <span class="n">functions</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">program</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">FuncDef</span><span class="p">)]</span>
        <span class="n">statements</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span> <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">program</span>
                      <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">FuncDef</span><span class="p">)]</span>

        <span class="c1"># Jump over function definitions to main code</span>
        <span class="n">main_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_label</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">JMP</span><span class="p">,</span> <span class="n">main_label</span><span class="p">)</span>

        <span class="c1"># Generate code for functions</span>
        <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">functions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_function</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>

        <span class="c1"># Generate main code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">LABEL</span><span class="p">,</span> <span class="n">main_label</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">statements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_stmt</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">HALT</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">FuncDef</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate code for a function definition.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span><span class="p">[</span><span class="n">func</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">LABEL</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;func_</span><span class="si">{</span><span class="n">func</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Function body</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">func</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_stmt</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

        <span class="c1"># Implicit return 0 if no explicit return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">PUSH</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">RET</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate code for a statement.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">AssignStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">STORE</span><span class="p">,</span> <span class="n">stmt</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">PrintStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">PRINT</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">IfStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_if</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">WhileStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_while</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">ReturnStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">RET</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown statement type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate code for an expression (result pushed on stack).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">NumLit</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">PUSH</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BoolLit</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">PUSH</span><span class="p">,</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">value</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">LOAD</span><span class="p">,</span> <span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="n">op_map</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">SUB</span><span class="p">,</span>
                <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">DIV</span><span class="p">,</span>
                <span class="s1">&#39;%&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">MOD</span><span class="p">,</span>
                <span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">EQ</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">NE</span><span class="p">,</span>
                <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">LT</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
                <span class="s1">&#39;&lt;=&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">LE</span><span class="p">,</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span>
                <span class="s1">&#39;and&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">AND</span><span class="p">,</span> <span class="s1">&#39;or&#39;</span><span class="p">:</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">OR</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="n">op_map</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">op_map</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown operator: </span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">UnaryExpr</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">NEG</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;not&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">NOT</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">CallExpr</span><span class="p">):</span>
            <span class="c1"># Push arguments in order</span>
            <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_generate_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">CALL</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;func_</span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">func</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_if</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">IfStmt</span><span class="p">):</span>
        <span class="n">else_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_label</span><span class="p">()</span>
        <span class="n">end_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_label</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_generate_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">JMPF</span><span class="p">,</span> <span class="n">else_label</span><span class="p">)</span>

        <span class="c1"># Then body</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">then_body</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_stmt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">JMP</span><span class="p">,</span> <span class="n">end_label</span><span class="p">)</span>

        <span class="c1"># Else body</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">LABEL</span><span class="p">,</span> <span class="n">else_label</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_body</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_stmt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">LABEL</span><span class="p">,</span> <span class="n">end_label</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_while</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">:</span> <span class="n">WhileStmt</span><span class="p">):</span>
        <span class="n">loop_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_label</span><span class="p">()</span>
        <span class="n">end_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new_label</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">LABEL</span><span class="p">,</span> <span class="n">loop_label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_generate_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">JMPF</span><span class="p">,</span> <span class="n">end_label</span><span class="p">)</span>

        <span class="c1"># Body</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_generate_stmt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">JMP</span><span class="p">,</span> <span class="n">loop_label</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">Opcode</span><span class="o">.</span><span class="n">LABEL</span><span class="p">,</span> <span class="n">end_label</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_code</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pretty-print the generated bytecode.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="p">):</span>
            <span class="n">label_marker</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">LABEL</span><span class="p">:</span>
                <span class="n">label_marker</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">operand</span><span class="si">}</span><span class="s2">:&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">label_marker</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  [</span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">instr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Part 4: Stack Machine Virtual Machine</span>
<span class="c1"># ============================================================</span>

<span class="k">class</span><span class="w"> </span><span class="nc">StackMachineVM</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Execute stack machine bytecode.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">BytecodeInstr</span><span class="p">],</span>
                 <span class="n">functions</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="n">functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>          <span class="c1"># Operand stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_stack</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="p">[]</span>     <span class="c1"># Return addresses + saved state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span>                    <span class="c1"># Program counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># Captured output</span>

        <span class="c1"># Resolve labels to addresses</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">LABEL</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">operand</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trace</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute the bytecode program.&quot;&quot;&quot;</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="p">):</span>
            <span class="n">instr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">trace</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">!=</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">LABEL</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  PC=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">instr</span><span class="si">}</span><span class="s2">  &quot;</span>
                      <span class="sa">f</span><span class="s2">&quot;stack=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">HALT</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">LABEL</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">PUSH</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">LOAD</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">operand</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">STORE</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">operand</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">POP</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">DUP</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

            <span class="c1"># Arithmetic</span>
            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">SUB</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">MUL</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">DIV</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">//</span> <span class="n">b</span> <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">MOD</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">b</span> <span class="k">if</span> <span class="n">b</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">NEG</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>

            <span class="c1"># Comparison</span>
            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">EQ</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">NE</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">LT</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">GT</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">LE</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">GE</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Logic</span>
            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">AND</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">OR</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="ow">or</span> <span class="n">b</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">NOT</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span> <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Control flow</span>
            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">JMP</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">operand</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">JMPF</span><span class="p">:</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">cond</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">operand</span><span class="p">]</span>
                    <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">JMPT</span><span class="p">:</span>
                <span class="n">cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">cond</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">operand</span><span class="p">]</span>
                    <span class="k">continue</span>

            <span class="c1"># Functions</span>
            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">CALL</span><span class="p">:</span>
                <span class="n">func_label</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">operand</span>
                <span class="n">nargs</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">operand2</span>

                <span class="c1"># Save state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">call_stack</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;return_pc&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s1">&#39;saved_vars&#39;</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">),</span>
                <span class="p">})</span>

                <span class="c1"># Pop arguments and bind to params</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nargs</span><span class="p">):</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>

                <span class="c1"># Jump to function</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">label_map</span><span class="p">[</span><span class="n">func_label</span><span class="p">]</span>

                <span class="c1"># Bind arguments (simplified: use positional names)</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">arg_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;__arg</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">arg_val</span>

                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">RET</span><span class="p">:</span>
                <span class="n">ret_val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_stack</span><span class="p">:</span>
                    <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">variables</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="s1">&#39;saved_vars&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">frame</span><span class="p">[</span><span class="s1">&#39;return_pc&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ret_val</span><span class="p">)</span>
                    <span class="k">break</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">opcode</span> <span class="o">==</span> <span class="n">Opcode</span><span class="o">.</span><span class="n">PRINT</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  OUTPUT: </span><span class="si">{</span><span class="n">val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Part 5: Examples</span>
<span class="c1"># ============================================================</span>

<span class="k">def</span><span class="w"> </span><span class="nf">demo_fibonacci</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compile and run:</span>
<span class="sd">        n = 10</span>
<span class="sd">        a = 0</span>
<span class="sd">        b = 1</span>
<span class="sd">        i = 0</span>
<span class="sd">        while (i &lt; n) {</span>
<span class="sd">            print a</span>
<span class="sd">            temp = a + b</span>
<span class="sd">            a = b</span>
<span class="sd">            b = temp</span>
<span class="sd">            i = i + 1</span>
<span class="sd">        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stack Machine: Fibonacci Sequence (first 10)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

    <span class="n">program</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span>
        <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
        <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
        <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
        <span class="n">WhileStmt</span><span class="p">(</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span><span class="s2">&quot;&lt;&quot;</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">),</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">)),</span>
            <span class="n">body</span><span class="o">=</span><span class="p">[</span>
                <span class="n">PrintStmt</span><span class="p">(</span><span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">)),</span>
                <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">))),</span>
                <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)),</span>
                <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;temp&quot;</span><span class="p">)),</span>
                <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">),</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">1</span><span class="p">))),</span>
            <span class="p">]</span>
        <span class="p">),</span>
    <span class="p">]</span>

    <span class="c1"># Generate code</span>
    <span class="n">gen</span> <span class="o">=</span> <span class="n">CodeGenerator</span><span class="p">()</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">generate_program</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Generated Bytecode ---&quot;</span><span class="p">)</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">print_code</span><span class="p">()</span>

    <span class="c1"># Execute</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Execution ---&quot;</span><span class="p">)</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="n">StackMachineVM</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>
    <span class="n">vm</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Fibonacci output: </span><span class="si">{</span><span class="n">vm</span><span class="o">.</span><span class="n">output</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_factorial</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compile and run:</span>
<span class="sd">        result = 1</span>
<span class="sd">        n = 7</span>
<span class="sd">        while (n &gt; 0) {</span>
<span class="sd">            result = result * n</span>
<span class="sd">            n = n - 1</span>
<span class="sd">        }</span>
<span class="sd">        print result</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stack Machine: Factorial of 7&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

    <span class="n">program</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
        <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">7</span><span class="p">)),</span>
        <span class="n">WhileStmt</span><span class="p">(</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">),</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
            <span class="n">body</span><span class="o">=</span><span class="p">[</span>
                <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span>
                    <span class="n">BinaryExpr</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">),</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">))),</span>
                <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">,</span>
                    <span class="n">BinaryExpr</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">),</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">1</span><span class="p">))),</span>
            <span class="p">]</span>
        <span class="p">),</span>
        <span class="n">PrintStmt</span><span class="p">(</span><span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">)),</span>
    <span class="p">]</span>

    <span class="n">gen</span> <span class="o">=</span> <span class="n">CodeGenerator</span><span class="p">()</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">generate_program</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Generated Bytecode ---&quot;</span><span class="p">)</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">print_code</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Execution ---&quot;</span><span class="p">)</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="n">StackMachineVM</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>
    <span class="n">vm</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">7! = </span><span class="si">{</span><span class="n">vm</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_conditionals</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compile and run:</span>
<span class="sd">        x = 15</span>
<span class="sd">        if (x &gt; 10) {</span>
<span class="sd">            if (x &gt; 20) {</span>
<span class="sd">                print 3</span>
<span class="sd">            } else {</span>
<span class="sd">                print 2</span>
<span class="sd">            }</span>
<span class="sd">        } else {</span>
<span class="sd">            print 1</span>
<span class="sd">        }</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Stack Machine: Nested If-Else&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">60</span><span class="p">)</span>

    <span class="n">program</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">AssignStmt</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">15</span><span class="p">)),</span>
        <span class="n">IfStmt</span><span class="p">(</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span>
            <span class="n">then_body</span><span class="o">=</span><span class="p">[</span>
                <span class="n">IfStmt</span><span class="p">(</span>
                    <span class="n">condition</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span><span class="s2">&quot;&gt;&quot;</span><span class="p">,</span> <span class="n">VarRef</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="n">NumLit</span><span class="p">(</span><span class="mi">20</span><span class="p">)),</span>
                    <span class="n">then_body</span><span class="o">=</span><span class="p">[</span><span class="n">PrintStmt</span><span class="p">(</span><span class="n">NumLit</span><span class="p">(</span><span class="mi">3</span><span class="p">))],</span>
                    <span class="n">else_body</span><span class="o">=</span><span class="p">[</span><span class="n">PrintStmt</span><span class="p">(</span><span class="n">NumLit</span><span class="p">(</span><span class="mi">2</span><span class="p">))],</span>
                <span class="p">)</span>
            <span class="p">],</span>
            <span class="n">else_body</span><span class="o">=</span><span class="p">[</span><span class="n">PrintStmt</span><span class="p">(</span><span class="n">NumLit</span><span class="p">(</span><span class="mi">1</span><span class="p">))],</span>
        <span class="p">),</span>
    <span class="p">]</span>

    <span class="n">gen</span> <span class="o">=</span> <span class="n">CodeGenerator</span><span class="p">()</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">generate_program</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Generated Bytecode ---&quot;</span><span class="p">)</span>
    <span class="n">gen</span><span class="o">.</span><span class="n">print_code</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Execution ---&quot;</span><span class="p">)</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="n">StackMachineVM</span><span class="p">(</span><span class="n">gen</span><span class="o">.</span><span class="n">code</span><span class="p">,</span> <span class="n">gen</span><span class="o">.</span><span class="n">functions</span><span class="p">)</span>
    <span class="n">vm</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Expected: 2, Got: </span><span class="si">{</span><span class="n">vm</span><span class="o">.</span><span class="n">output</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo_fibonacci</span><span class="p">()</span>
    <span class="n">demo_factorial</span><span class="p">()</span>
    <span class="n">demo_conditionals</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="8-machine-dependent-optimization">8. Machine-Dependent Optimization<a class="header-link" href="#8-machine-dependent-optimization" title="Permanent link">&para;</a></h2>
<h3 id="81-utilizing-special-instructions">8.1 Utilizing Special Instructions<a class="header-link" href="#81-utilizing-special-instructions" title="Permanent link">&para;</a></h3>
<p>Many processors have specialized instructions that the code generator can exploit:</p>
<table>
<thead>
<tr>
<th>Optimization</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td>Multiply-accumulate</td>
<td><code>MADD Rd, Rs1, Rs2, Rs3</code> ($Rd = Rs1 + Rs2 \times Rs3$)</td>
</tr>
<tr>
<td>Count leading zeros</td>
<td><code>CLZ Rd, Rs</code> (useful for log2)</td>
</tr>
<tr>
<td>Byte swap</td>
<td><code>REV Rd, Rs</code> (endianness conversion)</td>
</tr>
<tr>
<td>Conditional move</td>
<td><code>CMOV Rd, Rs, cond</code> (avoids branch)</td>
</tr>
<tr>
<td>SIMD</td>
<td><code>VADD.4S V0, V1, V2</code> (4 additions in parallel)</td>
</tr>
</tbody>
</table>
<h3 id="82-addressing-mode-selection">8.2 Addressing Mode Selection<a class="header-link" href="#82-addressing-mode-selection" title="Permanent link">&para;</a></h3>
<p>Complex addressing modes can reduce instruction count:</p>
<div class="highlight"><pre><span></span><code><span class="p">;</span><span class="w"> </span><span class="k">Without</span><span class="err">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="n">instructions</span>
<span class="n">MOV</span><span class="w">  </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">R_base</span>
<span class="k">ADD</span><span class="w">  </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">R_index</span><span class="p">,</span><span class="w"> </span><span class="n">LSL</span><span class="w"> </span><span class="n">#2</span><span class="w">    </span><span class="p">;</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span>
<span class="k">LOAD</span><span class="w"> </span><span class="n">R2</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">R1</span><span class="o">]</span>

<span class="p">;</span><span class="w"> </span><span class="k">With</span><span class="w"> </span><span class="n">indexed</span><span class="w"> </span><span class="nl">addressing</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">instruction</span>
<span class="k">LOAD</span><span class="w"> </span><span class="n">R2</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">R_base, R_index, LSL #2</span><span class="o">]</span>
</code></pre></div>

<h3 id="83-conditional-execution-arm">8.3 Conditional Execution (ARM)<a class="header-link" href="#83-conditional-execution-arm" title="Permanent link">&para;</a></h3>
<p>ARM architectures support predicated execution, where instructions execute only if a condition flag is set:</p>
<div class="highlight"><pre><span></span><code><span class="o">;</span><span class="w"> </span><span class="nt">Standard</span><span class="w"> </span><span class="nt">if-else</span><span class="o">:</span>
<span class="nt">CMP</span><span class="w"> </span><span class="nt">R0</span><span class="o">,</span><span class="w"> </span><span class="p">#</span><span class="nn">0</span>
<span class="nt">BEQ</span><span class="w"> </span><span class="nt">else</span>
<span class="nt">ADD</span><span class="w"> </span><span class="nt">R1</span><span class="o">,</span><span class="w"> </span><span class="nt">R2</span><span class="o">,</span><span class="w"> </span><span class="nt">R3</span><span class="w">      </span><span class="o">;</span><span class="w"> </span><span class="nt">then</span><span class="w"> </span><span class="nt">branch</span>
<span class="nt">B</span><span class="w">   </span><span class="nt">endif</span>
<span class="nt">else</span><span class="o">:</span>
<span class="nt">SUB</span><span class="w"> </span><span class="nt">R1</span><span class="o">,</span><span class="w"> </span><span class="nt">R2</span><span class="o">,</span><span class="w"> </span><span class="nt">R3</span><span class="w">      </span><span class="o">;</span><span class="w"> </span><span class="nt">else</span><span class="w"> </span><span class="nt">branch</span>
<span class="nt">endif</span><span class="o">:</span>

<span class="o">;</span><span class="w"> </span><span class="nt">Predicated</span><span class="w"> </span><span class="o">(</span><span class="nt">no</span><span class="w"> </span><span class="nt">branches</span><span class="o">,</span><span class="w"> </span><span class="nt">no</span><span class="w"> </span><span class="nt">pipeline</span><span class="w"> </span><span class="nt">stalls</span><span class="o">):</span>
<span class="nt">CMP</span><span class="w"> </span><span class="nt">R0</span><span class="o">,</span><span class="w"> </span><span class="p">#</span><span class="nn">0</span>
<span class="nt">ADDNE</span><span class="w"> </span><span class="nt">R1</span><span class="o">,</span><span class="w"> </span><span class="nt">R2</span><span class="o">,</span><span class="w"> </span><span class="nt">R3</span><span class="w">    </span><span class="o">;</span><span class="w"> </span><span class="nt">execute</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">NE</span><span class="w"> </span><span class="o">(</span><span class="nt">not</span><span class="w"> </span><span class="nt">equal</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="nt">0</span><span class="o">)</span>
<span class="nt">SUBEQ</span><span class="w"> </span><span class="nt">R1</span><span class="o">,</span><span class="w"> </span><span class="nt">R2</span><span class="o">,</span><span class="w"> </span><span class="nt">R3</span><span class="w">    </span><span class="o">;</span><span class="w"> </span><span class="nt">execute</span><span class="w"> </span><span class="nt">if</span><span class="w"> </span><span class="nt">EQ</span><span class="w"> </span><span class="o">(</span><span class="nt">equal</span><span class="w"> </span><span class="nt">to</span><span class="w"> </span><span class="nt">0</span><span class="o">)</span>
</code></pre></div>

<h3 id="84-branch-prediction-hints">8.4 Branch Prediction Hints<a class="header-link" href="#84-branch-prediction-hints" title="Permanent link">&para;</a></h3>
<p>Some architectures allow the compiler to hint at likely branch directions:</p>
<div class="highlight"><pre><span></span><code><span class="o">;</span><span class="w"> </span><span class="nt">x86</span><span class="w"> </span><span class="nt">branch</span><span class="w"> </span><span class="nt">hints</span><span class="w"> </span><span class="o">(</span><span class="nt">via</span><span class="w"> </span><span class="nt">instruction</span><span class="w"> </span><span class="nt">prefix</span><span class="o">)</span>
<span class="o">;</span><span class="w"> </span><span class="nt">Prefix</span><span class="w"> </span><span class="nt">0x3E</span><span class="o">:</span><span class="w"> </span><span class="nt">branch</span><span class="w"> </span><span class="nt">likely</span><span class="w"> </span><span class="nt">taken</span>
<span class="o">;</span><span class="w"> </span><span class="nt">Prefix</span><span class="w"> </span><span class="nt">0x2E</span><span class="o">:</span><span class="w"> </span><span class="nt">branch</span><span class="w"> </span><span class="nt">likely</span><span class="w"> </span><span class="nt">not</span><span class="w"> </span><span class="nt">taken</span>

<span class="o">;</span><span class="w"> </span><span class="nt">GCC</span><span class="w"> </span><span class="nt">built-in</span><span class="o">:</span>
<span class="nt">if</span><span class="w"> </span><span class="o">(</span><span class="nt">__builtin_expect</span><span class="o">(</span><span class="nt">error_condition</span><span class="o">,</span><span class="w"> </span><span class="nt">0</span><span class="o">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">//</span><span class="w"> </span><span class="err">unlikely</span><span class="w"> </span><span class="err">path</span>
<span class="w">    </span><span class="err">handle_error()</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<hr />
<h2 id="9-summary">9. Summary<a class="header-link" href="#9-summary" title="Permanent link">&para;</a></h2>
<p>In this lesson, we covered the major phases of code generation:</p>
<ol>
<li>
<p><strong>Target machine model</strong>: We defined a simple RISC-like instruction set with multiple addressing modes and instruction costs that guide code generation decisions.</p>
</li>
<li>
<p><strong>Instruction selection</strong> maps IR trees to machine instructions. <strong>Tree pattern matching</strong> with tiles provides a systematic approach. The <strong>Maximal Munch</strong> algorithm greedily selects the largest matching tile at each node.</p>
</li>
<li>
<p><strong>Register allocation</strong> assigns physical registers to virtual registers. <strong>Graph coloring</strong> provides optimal allocation but is expensive. <strong>Linear scan</strong> offers a fast alternative suitable for JIT compilers. Spilling moves overflow variables to memory.</p>
</li>
<li>
<p><strong>Instruction scheduling</strong> reorders instructions to minimize pipeline stalls. <strong>List scheduling</strong> uses dependency DAGs and priority heuristics. <strong>Software pipelining</strong> overlaps loop iterations.</p>
</li>
<li>
<p><strong>Peephole optimization</strong> applies local transformations to small windows of instructions: strength reduction, redundant code elimination, algebraic simplification, and branch optimization.</p>
</li>
<li>
<p><strong>Code generation for language constructs</strong> follows predictable patterns: expressions use post-order traversal, control flow uses conditional branches and labels, and function calls follow calling conventions.</p>
</li>
<li>
<p>A <strong>stack machine</strong> provides a simple code generation target where all operations use an implicit stack, eliminating the need for register allocation.</p>
</li>
</ol>
<hr />
<h2 id="exercises">Exercises<a class="header-link" href="#exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-maximal-munch">Exercise 1: Maximal Munch<a class="header-link" href="#exercise-1-maximal-munch" title="Permanent link">&para;</a></h3>
<p>Given the following IR tree, apply the Maximal Munch algorithm to select instructions. Show each step and the final instruction sequence.</p>
<div class="highlight"><pre><span></span><code>        STORE
       /     \
      +       MEM
     / \       |
    FP  #-8   +
             / \
            <span class="k">*</span>   #4
           / \
          i   #4
</code></pre></div>

<p>Available tiles: register, constant, ADD, ADDI, MUL, SHL (shift left for power-of-2 multiply), LOAD with indexed addressing, STORE with indexed addressing.</p>
<h3 id="exercise-2-register-allocation">Exercise 2: Register Allocation<a class="header-link" href="#exercise-2-register-allocation" title="Permanent link">&para;</a></h3>
<p>Given the following live intervals and 3 physical registers, perform linear scan register allocation. Which variable(s) get spilled?</p>
<div class="highlight"><pre><span></span><code>a: [1, 15]
b: [2, 10]
c: [3, 12]
d: [5, 8]
e: [7, 20]
f: [13, 18]
</code></pre></div>

<h3 id="exercise-3-instruction-scheduling">Exercise 3: Instruction Scheduling<a class="header-link" href="#exercise-3-instruction-scheduling" title="Permanent link">&para;</a></h3>
<p>Schedule the following instructions for a machine with 1 ALU unit and 1 load/store unit. Load latency is 3 cycles, ALU latency is 1 cycle.</p>
<div class="highlight"><pre><span></span><code><span class="nl">I1</span><span class="p">:</span><span class="w"> </span><span class="k">LOAD</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">addr1</span><span class="o">]</span><span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="n">unit</span><span class="p">,</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="mi">3</span>
<span class="nl">I2</span><span class="p">:</span><span class="w"> </span><span class="k">LOAD</span><span class="w"> </span><span class="n">R2</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">addr2</span><span class="o">]</span><span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="n">unit</span><span class="p">,</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="mi">3</span>
<span class="nl">I3</span><span class="p">:</span><span class="w"> </span><span class="k">ADD</span><span class="w">  </span><span class="n">R3</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">R2</span><span class="w">       </span><span class="p">;</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">ALU</span><span class="p">,</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">depends</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">I1</span><span class="p">,</span><span class="w"> </span><span class="n">I2</span>
<span class="nl">I4</span><span class="p">:</span><span class="w"> </span><span class="k">LOAD</span><span class="w"> </span><span class="n">R4</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">addr3</span><span class="o">]</span><span class="w">      </span><span class="p">;</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="k">load</span><span class="w"> </span><span class="n">unit</span><span class="p">,</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="mi">3</span>
<span class="nl">I5</span><span class="p">:</span><span class="w"> </span><span class="n">MUL</span><span class="w">  </span><span class="n">R5</span><span class="p">,</span><span class="w"> </span><span class="n">R3</span><span class="p">,</span><span class="w"> </span><span class="n">R4</span><span class="w">       </span><span class="p">;</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">ALU</span><span class="p">,</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="n">depends</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">I3</span><span class="p">,</span><span class="w"> </span><span class="n">I4</span>
<span class="nl">I6</span><span class="p">:</span><span class="w"> </span><span class="k">ADD</span><span class="w">  </span><span class="n">R6</span><span class="p">,</span><span class="w"> </span><span class="n">R5</span><span class="p">,</span><span class="w"> </span><span class="n">#1</span><span class="w">       </span><span class="p">;</span><span class="w"> </span><span class="n">uses</span><span class="w"> </span><span class="n">ALU</span><span class="p">,</span><span class="w"> </span><span class="n">latency</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">depends</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">I5</span>
</code></pre></div>

<p>What is the minimum number of cycles? Draw the schedule.</p>
<h3 id="exercise-4-peephole-optimization">Exercise 4: Peephole Optimization<a class="header-link" href="#exercise-4-peephole-optimization" title="Permanent link">&para;</a></h3>
<p>Apply peephole optimizations to the following code. Show the result after each pass.</p>
<div class="highlight"><pre><span></span><code><span class="w">  </span><span class="n">MOVI</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">#10</span>
<span class="w">  </span><span class="k">ADD</span><span class="w">  </span><span class="n">R2</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">#0</span>
<span class="w">  </span><span class="n">MUL</span><span class="w">  </span><span class="n">R3</span><span class="p">,</span><span class="w"> </span><span class="n">R2</span><span class="p">,</span><span class="w"> </span><span class="n">#16</span>
<span class="w">  </span><span class="n">MOV</span><span class="w">  </span><span class="n">R4</span><span class="p">,</span><span class="w"> </span><span class="n">R4</span>
<span class="w">  </span><span class="n">STORE</span><span class="w"> </span><span class="n">R3</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">R5</span><span class="o">]</span>
<span class="w">  </span><span class="k">LOAD</span><span class="w">  </span><span class="n">R3</span><span class="p">,</span><span class="w"> </span><span class="o">[</span><span class="n">R5</span><span class="o">]</span>
<span class="w">  </span><span class="n">MUL</span><span class="w">  </span><span class="n">R6</span><span class="p">,</span><span class="w"> </span><span class="n">R3</span><span class="p">,</span><span class="w"> </span><span class="n">#1</span>
<span class="w">  </span><span class="n">DIV</span><span class="w">  </span><span class="n">R7</span><span class="p">,</span><span class="w"> </span><span class="n">R6</span><span class="p">,</span><span class="w"> </span><span class="n">#8</span>
<span class="w">  </span><span class="n">JMP</span><span class="w">  </span><span class="n">L1</span>
<span class="w">  </span><span class="k">ADD</span><span class="w">  </span><span class="n">R8</span><span class="p">,</span><span class="w"> </span><span class="n">R1</span><span class="p">,</span><span class="w"> </span><span class="n">R2</span>
<span class="nl">L1</span><span class="p">:</span>
<span class="w">  </span><span class="n">JMP</span><span class="w">  </span><span class="n">L2</span>
<span class="nl">L2</span><span class="p">:</span>
<span class="w">  </span><span class="n">RET</span>
</code></pre></div>

<h3 id="exercise-5-stack-machine">Exercise 5: Stack Machine<a class="header-link" href="#exercise-5-stack-machine" title="Permanent link">&para;</a></h3>
<p>Hand-compile the following expression into stack machine bytecode and trace the stack contents after each instruction:</p>
<div class="highlight"><pre><span></span><code>result = (3 + 4) * (10 - 2) / (1 + 1)
</code></pre></div>

<h3 id="exercise-6-implementation-challenge">Exercise 6: Implementation Challenge<a class="header-link" href="#exercise-6-implementation-challenge" title="Permanent link">&para;</a></h3>
<p>Extend the stack machine code generator and VM to support:
1. <strong>Arrays</strong>: <code>ALLOC n</code> (allocate array of size n), <code>ALOAD</code> (load from array), <code>ASTORE</code> (store to array)
2. <strong>For loops</strong>: Implement <code>for i = start to end { body }</code> as a source-level construct</p>
<p>Test with a program that allocates an array, fills it with squares, and prints the contents.</p>
<hr />
<p><a href="./10_Runtime_Environments.md">Previous: 10_Runtime_Environments.md</a> | <a href="./12_Optimization_Local_and_Global.md">Next: 12_Optimization_Local_and_Global.md</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/10_Runtime_Environments.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 10: Runtime Environments</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/12_Optimization_Local_and_Global.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 12: Optimization -- Local and Global</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}