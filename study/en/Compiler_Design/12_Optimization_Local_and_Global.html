{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 12: Optimization -- Local and Global - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">ğŸ </span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">ğŸ’»</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        í•œêµ­ì–´
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">â˜€ï¸</span>
                    <span class="theme-icon dark">ğŸŒ™</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Lesson 12: Optimization -- Local and Global</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 12: Optimization -- Local and Global</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/11_Code_Generation.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 11: Code Generation</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/13_Loop_Optimization.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Loop Optimization</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#learning-objectives">Learning Objectives</a></li>
<li><a href="#1-optimization-overview">1. Optimization Overview</a><ul>
<li><a href="#11-what-is-an-optimization">1.1 What Is an Optimization?</a></li>
<li><a href="#12-the-three-requirements">1.2 The Three Requirements</a></li>
<li><a href="#13-classification-of-optimizations">1.3 Classification of Optimizations</a></li>
<li><a href="#14-when-optimizations-are-applied">1.4 When Optimizations Are Applied</a></li>
<li><a href="#15-the-phase-ordering-problem">1.5 The Phase-Ordering Problem</a></li>
</ul>
</li>
<li><a href="#2-local-optimizations">2. Local Optimizations</a><ul>
<li><a href="#21-constant-folding">2.1 Constant Folding</a></li>
<li><a href="#22-constant-propagation">2.2 Constant Propagation</a></li>
<li><a href="#23-algebraic-simplification">2.3 Algebraic Simplification</a></li>
<li><a href="#24-strength-reduction-local">2.4 Strength Reduction (Local)</a></li>
<li><a href="#25-dead-code-elimination-local">2.5 Dead Code Elimination (Local)</a></li>
<li><a href="#26-common-subexpression-elimination-cse">2.6 Common Subexpression Elimination (CSE)</a></li>
<li><a href="#27-copy-propagation">2.7 Copy Propagation</a></li>
<li><a href="#28-local-value-numbering">2.8 Local Value Numbering</a></li>
<li><a href="#29-python-implementation-local-optimizer">2.9 Python Implementation: Local Optimizer</a></li>
</ul>
</li>
<li><a href="#3-global-data-flow-analysis">3. Global Data Flow Analysis</a><ul>
<li><a href="#31-why-global-analysis">3.1 Why Global Analysis?</a></li>
<li><a href="#32-the-four-classic-analyses">3.2 The Four Classic Analyses</a></li>
<li><a href="#33-reaching-definitions">3.3 Reaching Definitions</a><ul>
<li><a href="#data-flow-equations">Data Flow Equations</a></li>
<li><a href="#example">Example</a></li>
</ul>
</li>
<li><a href="#34-available-expressions">3.4 Available Expressions</a><ul>
<li><a href="#data-flow-equations_1">Data Flow Equations</a></li>
</ul>
</li>
<li><a href="#35-live-variables">3.5 Live Variables</a><ul>
<li><a href="#data-flow-equations_2">Data Flow Equations</a></li>
</ul>
</li>
<li><a href="#36-very-busy-expressions">3.6 Very Busy Expressions</a><ul>
<li><a href="#data-flow-equations_3">Data Flow Equations</a></li>
</ul>
</li>
<li><a href="#37-summary-of-the-four-analyses">3.7 Summary of the Four Analyses</a></li>
</ul>
</li>
<li><a href="#4-data-flow-analysis-framework">4. Data Flow Analysis Framework</a><ul>
<li><a href="#41-lattice-theory-basics">4.1 Lattice Theory Basics</a><ul>
<li><a href="#lattice-for-reaching-definitions">Lattice for Reaching Definitions</a></li>
<li><a href="#general-framework">General Framework</a></li>
</ul>
</li>
<li><a href="#42-transfer-functions">4.2 Transfer Functions</a></li>
<li><a href="#43-meet-over-paths-mop-solution">4.3 Meet-Over-Paths (MOP) Solution</a></li>
<li><a href="#44-fixed-point-iteration">4.4 Fixed-Point Iteration</a></li>
<li><a href="#45-worklist-algorithm">4.5 Worklist Algorithm</a></li>
</ul>
</li>
<li><a href="#5-python-implementation-data-flow-analysis">5. Python Implementation: Data Flow Analysis</a></li>
<li><a href="#6-applying-analysis-results-to-optimization">6. Applying Analysis Results to Optimization</a><ul>
<li><a href="#61-global-constant-propagation">6.1 Global Constant Propagation</a></li>
<li><a href="#62-global-dead-code-elimination">6.2 Global Dead Code Elimination</a></li>
<li><a href="#63-global-common-subexpression-elimination">6.3 Global Common Subexpression Elimination</a></li>
<li><a href="#64-code-hoisting">6.4 Code Hoisting</a></li>
</ul>
</li>
<li><a href="#7-advanced-topics">7. Advanced Topics</a><ul>
<li><a href="#71-iterative-analysis-ordering">7.1 Iterative Analysis Ordering</a></li>
<li><a href="#72-ssa-based-analysis">7.2 SSA-Based Analysis</a></li>
<li><a href="#73-interprocedural-analysis">7.3 Interprocedural Analysis</a></li>
<li><a href="#74-widening-and-narrowing">7.4 Widening and Narrowing</a></li>
</ul>
</li>
<li><a href="#8-combining-optimizations-a-complete-pass">8. Combining Optimizations: A Complete Pass</a></li>
<li><a href="#9-summary">9. Summary</a></li>
<li><a href="#exercises">Exercises</a><ul>
<li><a href="#exercise-1-local-optimization">Exercise 1: Local Optimization</a></li>
<li><a href="#exercise-2-reaching-definitions">Exercise 2: Reaching Definitions</a></li>
<li><a href="#exercise-3-live-variables">Exercise 3: Live Variables</a></li>
<li><a href="#exercise-4-available-expressions">Exercise 4: Available Expressions</a></li>
<li><a href="#exercise-5-worklist-algorithm-trace">Exercise 5: Worklist Algorithm Trace</a></li>
<li><a href="#exercise-6-implementation-challenge">Exercise 6: Implementation Challenge</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-12-optimization-local-and-global">Lesson 12: Optimization -- Local and Global<a class="header-link" href="#lesson-12-optimization-local-and-global" title="Permanent link">&para;</a></h1>
<h2 id="learning-objectives">Learning Objectives<a class="header-link" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<p>After completing this lesson, you will be able to:</p>
<ol>
<li><strong>Explain</strong> the principles of compiler optimization: safety, profitability, and opportunity</li>
<li><strong>Apply</strong> local optimizations within a single basic block (constant folding, CSE, copy propagation, dead code elimination, strength reduction)</li>
<li><strong>Formulate</strong> global data flow analyses (reaching definitions, available expressions, live variables, very busy expressions)</li>
<li><strong>Describe</strong> the mathematical framework of data flow analysis using lattices and fixed-point iteration</li>
<li><strong>Implement</strong> the worklist algorithm for iterative data flow analysis</li>
<li><strong>Build</strong> a complete data flow analysis engine in Python</li>
</ol>
<hr />
<h2 id="1-optimization-overview">1. Optimization Overview<a class="header-link" href="#1-optimization-overview" title="Permanent link">&para;</a></h2>
<h3 id="11-what-is-an-optimization">1.1 What Is an Optimization?<a class="header-link" href="#11-what-is-an-optimization" title="Permanent link">&para;</a></h3>
<p>In compiler terminology, an <strong>optimization</strong> is a program transformation that preserves the observable behavior of the program while improving some metric -- typically execution speed, code size, or energy consumption.</p>
<p>The term "optimization" is somewhat misleading: compilers rarely find the truly <em>optimal</em> code. More accurately, compilers perform <strong>code improvement</strong>.</p>
<h3 id="12-the-three-requirements">1.2 The Three Requirements<a class="header-link" href="#12-the-three-requirements" title="Permanent link">&para;</a></h3>
<p>Every optimization must satisfy three criteria:</p>
<ol>
<li>
<p><strong>Safety (Correctness)</strong>: The transformation must not change the observable behavior of the program. A safe transformation produces the same outputs for all possible inputs.</p>
</li>
<li>
<p><strong>Profitability</strong>: The transformation should actually improve the code. A transformation that increases register pressure and causes more spills may make the code slower despite reducing instruction count.</p>
</li>
<li>
<p><strong>Opportunity</strong>: The pattern targeted by the optimization must actually occur in the code. The compiler must <strong>detect</strong> the opportunity before applying the transformation.</p>
</li>
</ol>
<h3 id="13-classification-of-optimizations">1.3 Classification of Optimizations<a class="header-link" href="#13-classification-of-optimizations" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Scope</th>
<th>Description</th>
<th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Local</strong></td>
<td>Within a single basic block</td>
<td>Constant folding, CSE, copy propagation</td>
</tr>
<tr>
<td><strong>Global</strong> (intraprocedural)</td>
<td>Across basic blocks within one function</td>
<td>Loop-invariant code motion, global CSE</td>
</tr>
<tr>
<td><strong>Interprocedural</strong></td>
<td>Across function boundaries</td>
<td>Inlining, interprocedural constant propagation</td>
</tr>
<tr>
<td><strong>Machine-dependent</strong></td>
<td>Exploit target machine features</td>
<td>Instruction scheduling, peephole optimization</td>
</tr>
<tr>
<td><strong>Machine-independent</strong></td>
<td>Apply to any target</td>
<td>Most IR-level optimizations</td>
</tr>
</tbody>
</table>
<h3 id="14-when-optimizations-are-applied">1.4 When Optimizations Are Applied<a class="header-link" href="#14-when-optimizations-are-applied" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">Source</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="p">[</span><span class="n">Front</span><span class="w"> </span><span class="n">End</span><span class="p">]</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">IR</span>
<span class="w">                        </span><span class="err">â”‚</span>
<span class="w">                        </span><span class="err">â–¼</span>
<span class="w">         </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="n">Machine</span><span class="o">-</span><span class="n">Independent</span><span class="w"> </span><span class="n">Optimizations</span><span class="w"> </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="p">(</span><span class="n">operate</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">IR</span><span class="p">)</span><span class="w">                   </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">Constant</span><span class="w"> </span><span class="n">propagation</span><span class="w">            </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">Dead</span><span class="w"> </span><span class="n">code</span><span class="w"> </span><span class="n">elimination</span><span class="w">           </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="n">optimizations</span><span class="w">              </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">Inlining</span><span class="w">                        </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="w">                        </span><span class="err">â”‚</span>
<span class="w">                        </span><span class="err">â–¼</span>
<span class="w">         </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="n">Code</span><span class="w"> </span><span class="n">Generation</span><span class="w">                   </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="p">(</span><span class="n">instruction</span><span class="w"> </span><span class="n">selection</span><span class="p">,</span><span class="w"> </span><span class="n">reg</span><span class="w"> </span><span class="n">alloc</span><span class="p">)</span><span class="w"> </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="w">                        </span><span class="err">â”‚</span>
<span class="w">                        </span><span class="err">â–¼</span>
<span class="w">         </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="n">Machine</span><span class="o">-</span><span class="n">Dependent</span><span class="w"> </span><span class="n">Optimizations</span><span class="w">   </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="p">(</span><span class="n">operate</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="n">code</span><span class="p">)</span><span class="w">         </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">Peephole</span><span class="w"> </span><span class="n">optimization</span><span class="w">           </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â”‚</span><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">Instruction</span><span class="w"> </span><span class="n">scheduling</span><span class="w">          </span><span class="err">â”‚</span>
<span class="w">         </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="w">                        </span><span class="err">â”‚</span>
<span class="w">                        </span><span class="err">â–¼</span>
<span class="w">                    </span><span class="n">Machine</span><span class="w"> </span><span class="n">Code</span>
</code></pre></div>

<h3 id="15-the-phase-ordering-problem">1.5 The Phase-Ordering Problem<a class="header-link" href="#15-the-phase-ordering-problem" title="Permanent link">&para;</a></h3>
<p>Optimizations interact: one optimization may create opportunities for another, or undo the work of a previous one. The order in which optimizations are applied matters, and finding the best order is undecidable in general.</p>
<p>Practical compilers use carefully tuned sequences (e.g., GCC's <code>-O2</code> enables about 60 optimization passes in a specific order).</p>
<hr />
<h2 id="2-local-optimizations">2. Local Optimizations<a class="header-link" href="#2-local-optimizations" title="Permanent link">&para;</a></h2>
<p>Local optimizations operate within a <strong>single basic block</strong> -- a straight-line sequence of instructions with no branches in or out (except at the beginning and end). Because there is only one execution path through a basic block, these optimizations require no data flow analysis.</p>
<h3 id="21-constant-folding">2.1 Constant Folding<a class="header-link" href="#21-constant-folding" title="Permanent link">&para;</a></h3>
<p><strong>Constant folding</strong> evaluates constant expressions at compile time rather than at runtime.</p>
<p><strong>Before</strong>:</p>
<div class="highlight"><pre><span></span><code>t1 = 3 + 4
t2 = t1 * 2
</code></pre></div>

<p><strong>After</strong>:</p>
<div class="highlight"><pre><span></span><code>t1 = 7
t2 = 14
</code></pre></div>

<p><strong>Rules</strong>: The compiler can fold an expression $e_1 \;\text{op}\; e_2$ if both $e_1$ and $e_2$ are constants. This applies recursively.</p>
<p><strong>Caution</strong>: The compiler must respect the target machine's arithmetic semantics:
- Integer overflow behavior (signed vs unsigned)
- Floating-point rounding modes
- Division by zero handling</p>
<h3 id="22-constant-propagation">2.2 Constant Propagation<a class="header-link" href="#22-constant-propagation" title="Permanent link">&para;</a></h3>
<p><strong>Constant propagation</strong> replaces uses of a variable with its constant value when the variable is known to be constant.</p>
<p><strong>Before</strong>:</p>
<div class="highlight"><pre><span></span><code>x = 5
y = x + 3
z = x * y
</code></pre></div>

<p><strong>After</strong> (propagation + folding):</p>
<div class="highlight"><pre><span></span><code>x = 5
y = 8       // 5 + 3
z = 40      // 5 * 8
</code></pre></div>

<p>The combination of constant propagation and constant folding is very powerful -- each enables the other in a cascade.</p>
<h3 id="23-algebraic-simplification">2.3 Algebraic Simplification<a class="header-link" href="#23-algebraic-simplification" title="Permanent link">&para;</a></h3>
<p><strong>Algebraic simplification</strong> applies mathematical identities to simplify expressions:</p>
<table>
<thead>
<tr>
<th>Original</th>
<th>Simplified</th>
<th>Identity</th>
</tr>
</thead>
<tbody>
<tr>
<td>$x + 0$</td>
<td>$x$</td>
<td>Additive identity</td>
</tr>
<tr>
<td>$x - 0$</td>
<td>$x$</td>
<td>Additive identity</td>
</tr>
<tr>
<td>$x \times 1$</td>
<td>$x$</td>
<td>Multiplicative identity</td>
</tr>
<tr>
<td>$x \times 0$</td>
<td>$0$</td>
<td>Zero property</td>
</tr>
<tr>
<td>$x / 1$</td>
<td>$x$</td>
<td>Division identity</td>
</tr>
<tr>
<td>$x - x$</td>
<td>$0$</td>
<td>Self-subtraction</td>
</tr>
<tr>
<td>$x / x$</td>
<td>$1$</td>
<td>Self-division (when $x \neq 0$)</td>
</tr>
<tr>
<td>$-(-x)$</td>
<td>$x$</td>
<td>Double negation</td>
</tr>
<tr>
<td>$x + x$</td>
<td>$2 \times x$</td>
<td>(or left shift by 1)</td>
</tr>
</tbody>
</table>
<p><strong>For booleans</strong>:</p>
<table>
<thead>
<tr>
<th>Original</th>
<th>Simplified</th>
</tr>
</thead>
<tbody>
<tr>
<td>$x \land \text{true}$</td>
<td>$x$</td>
</tr>
<tr>
<td>$x \land \text{false}$</td>
<td>$\text{false}$</td>
</tr>
<tr>
<td>$x \lor \text{true}$</td>
<td>$\text{true}$</td>
</tr>
<tr>
<td>$x \lor \text{false}$</td>
<td>$x$</td>
</tr>
<tr>
<td>$\lnot(\lnot x)$</td>
<td>$x$</td>
</tr>
</tbody>
</table>
<h3 id="24-strength-reduction-local">2.4 Strength Reduction (Local)<a class="header-link" href="#24-strength-reduction-local" title="Permanent link">&para;</a></h3>
<p><strong>Strength reduction</strong> replaces expensive operations with cheaper equivalents:</p>
<table>
<thead>
<tr>
<th>Expensive</th>
<th>Cheap</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>$x \times 2^n$</td>
<td>$x \ll n$</td>
<td>Always valid for integers</td>
</tr>
<tr>
<td>$x / 2^n$</td>
<td>$x \gg n$</td>
<td>Unsigned integers</td>
</tr>
<tr>
<td>$x \% 2^n$</td>
<td>$x \;\&\; (2^n - 1)$</td>
<td>Unsigned integers</td>
</tr>
<tr>
<td>$x \times 3$</td>
<td>$(x \ll 1) + x$</td>
<td>When shift+add is cheaper</td>
</tr>
<tr>
<td>$x \times 5$</td>
<td>$(x \ll 2) + x$</td>
<td>When shift+add is cheaper</td>
</tr>
<tr>
<td>$x \times 15$</td>
<td>$(x \ll 4) - x$</td>
<td>When shift-sub is cheaper</td>
</tr>
</tbody>
</table>
<p><strong>Example</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">Before</span><span class="o">:</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span>
<span class="n">After</span><span class="o">:</span><span class="w">  </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">2</span>
</code></pre></div>

<h3 id="25-dead-code-elimination-local">2.5 Dead Code Elimination (Local)<a class="header-link" href="#25-dead-code-elimination-local" title="Permanent link">&para;</a></h3>
<p><strong>Dead code</strong> is code whose results are never used. Eliminating it reduces code size and may improve cache behavior.</p>
<p><strong>Before</strong>:</p>
<div class="highlight"><pre><span></span><code>t1 = a + b      // t1 is used
t2 = c * d      // t2 is NEVER used later
t3 = t1 - 5     // t3 is used
</code></pre></div>

<p><strong>After</strong>:</p>
<div class="highlight"><pre><span></span><code>t1 = a + b
t3 = t1 - 5
</code></pre></div>

<p>In a basic block, a definition is dead if the variable is not used before it is redefined or before the end of the block (and is not live out of the block).</p>
<h3 id="26-common-subexpression-elimination-cse">2.6 Common Subexpression Elimination (CSE)<a class="header-link" href="#26-common-subexpression-elimination-cse" title="Permanent link">&para;</a></h3>
<p><strong>CSE</strong> identifies expressions that are computed more than once and replaces redundant computations with references to the first computation.</p>
<p><strong>Before</strong>:</p>
<div class="highlight"><pre><span></span><code>t1 = a + b
t2 = a + b      // Same expression as t1
t3 = t1 * t2
</code></pre></div>

<p><strong>After</strong>:</p>
<div class="highlight"><pre><span></span><code>t1 = a + b
t2 = t1          // Reuse t1&#39;s value
t3 = t1 * t1
</code></pre></div>

<p><strong>Safety condition</strong>: Neither <code>a</code> nor <code>b</code> must be redefined between the first computation and the redundant one.</p>
<p>CSE within a basic block can be efficiently implemented using <strong>value numbering</strong> (see below) or DAG construction (covered in Lesson 9).</p>
<h3 id="27-copy-propagation">2.7 Copy Propagation<a class="header-link" href="#27-copy-propagation" title="Permanent link">&para;</a></h3>
<p><strong>Copy propagation</strong> replaces uses of a variable that was assigned by a copy (<code>x = y</code>) with the original variable.</p>
<p><strong>Before</strong>:</p>
<div class="highlight"><pre><span></span><code>t1 = a + b
t2 = t1          // copy
t3 = t2 * c      // uses t2 (which is really t1)
</code></pre></div>

<p><strong>After</strong>:</p>
<div class="highlight"><pre><span></span><code>t1 = a + b
t2 = t1           // copy (may become dead)
t3 = t1 * c       // replaced t2 with t1
</code></pre></div>

<p>After copy propagation, the copy <code>t2 = t1</code> may become dead code and can be eliminated.</p>
<h3 id="28-local-value-numbering">2.8 Local Value Numbering<a class="header-link" href="#28-local-value-numbering" title="Permanent link">&para;</a></h3>
<p><strong>Local value numbering</strong> is a systematic method for performing CSE, constant folding, and algebraic simplification in a single pass over a basic block.</p>
<p><strong>Idea</strong>: Assign a <strong>value number</strong> to each computed value. Two expressions get the same value number if they compute the same value.</p>
<p><strong>Algorithm</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">hash_table</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{}</span><span class="w">  </span><span class="err">#</span><span class="w"> </span><span class="n">Maps</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">vn1</span><span class="p">,</span><span class="w"> </span><span class="n">vn2</span><span class="p">)</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="n">number</span>
<span class="n">var_to_vn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{}</span><span class="w">   </span><span class="err">#</span><span class="w"> </span><span class="n">Maps</span><span class="w"> </span><span class="k">variable</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="n">number</span>
<span class="n">next_vn</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>

<span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="ss">&quot;x = y op z&quot;</span><span class="err">:</span>
<span class="w">    </span><span class="n">vn_y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">var_to_vn</span><span class="o">[</span><span class="n">y</span><span class="o">]</span>
<span class="w">    </span><span class="n">vn_z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">var_to_vn</span><span class="o">[</span><span class="n">z</span><span class="o">]</span>

<span class="w">    </span><span class="k">key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">op</span><span class="p">,</span><span class="w"> </span><span class="n">vn_y</span><span class="p">,</span><span class="w"> </span><span class="n">vn_z</span><span class="p">)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">hash_table</span><span class="p">:</span>
<span class="w">        </span><span class="n">vn_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hash_table</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="w">   </span><span class="err">#</span><span class="w"> </span><span class="n">Same</span><span class="w"> </span><span class="k">value</span><span class="w"> </span><span class="n">already</span><span class="w"> </span><span class="n">computed</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nf">Replace</span><span class="w"> </span><span class="n">instruction</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">representative</span>
<span class="w">    </span><span class="k">else</span><span class="err">:</span>
<span class="w">        </span><span class="n">vn_x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">next_vn</span><span class="o">++</span>
<span class="w">        </span><span class="n">hash_table</span><span class="o">[</span><span class="n">key</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vn_x</span>

<span class="w">    </span><span class="n">var_to_vn</span><span class="o">[</span><span class="n">x</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">vn_x</span>
</code></pre></div>

<h3 id="29-python-implementation-local-optimizer">2.9 Python Implementation: Local Optimizer<a class="header-link" href="#29-python-implementation-local-optimizer" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Local optimizations within a single basic block.</span>
<span class="sd">Implements constant folding, constant propagation, algebraic</span>
<span class="sd">simplification, strength reduction, CSE, copy propagation,</span>
<span class="sd">and dead code elimination.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">operator</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">TAC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Three-address code instruction.&quot;&quot;&quot;</span>
    <span class="n">result</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">str</span>           <span class="c1"># &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;copy&#39;, &#39;nop&#39;</span>
    <span class="n">arg1</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">arg2</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;nop&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;// NOP (eliminated)&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">is_constant</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if a string represents an integer constant.&quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span><span class="w"> </span><span class="nf">const_val</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the integer value of a constant string.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LocalOptimizer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs local optimizations on a basic block (list of TAC instructions).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instructions</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">TAC</span><span class="p">],</span> <span class="n">live_out</span><span class="p">:</span> <span class="nb">set</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">instructions</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">live_out</span> <span class="o">=</span> <span class="n">live_out</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Variables live at exit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_passes</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">TAC</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run all local optimizations until convergence.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_passes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constant_folding</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">constant_propagation</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">algebraic_simplification</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strength_reduction</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">copy_propagation</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">common_subexpression_elimination</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dead_code_elimination</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">changed</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># Remove NOP instructions</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span> <span class="k">if</span> <span class="n">i</span><span class="o">.</span><span class="n">op</span> <span class="o">!=</span> <span class="s2">&quot;nop&quot;</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">constant_folding</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Evaluate constant expressions at compile time.&quot;&quot;&quot;</span>
        <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">add</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span>
            <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mul</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">floordiv</span><span class="p">,</span>
            <span class="s1">&#39;%&#39;</span><span class="p">:</span> <span class="n">operator</span><span class="o">.</span><span class="n">mod</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="n">ops</span> <span class="ow">and</span> <span class="n">is_constant</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span> \
               <span class="ow">and</span> <span class="n">is_constant</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">const_val</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">const_val</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>  <span class="c1"># Cannot fold division by zero</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">ops</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">op</span><span class="p">](</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">result</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">constant_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replace variable uses with constant values when known.&quot;&quot;&quot;</span>
        <span class="n">constants</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># var -&gt; constant value</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="c1"># Check if this defines a constant</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span> <span class="ow">and</span> <span class="n">is_constant</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">):</span>
                <span class="n">constants</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">result</span><span class="p">]</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span>

            <span class="c1"># Replace uses with constants</span>
            <span class="n">new_arg1</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span>
            <span class="n">new_arg2</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span>

            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">in</span> <span class="n">constants</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">!=</span> <span class="s2">&quot;copy&quot;</span><span class="p">:</span>
                <span class="n">new_arg1</span> <span class="o">=</span> <span class="n">constants</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">in</span> <span class="n">constants</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span><span class="p">:</span>
                <span class="n">new_arg1</span> <span class="o">=</span> <span class="n">constants</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span> <span class="ow">in</span> <span class="n">constants</span><span class="p">:</span>
                <span class="n">new_arg2</span> <span class="o">=</span> <span class="n">constants</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">new_arg1</span> <span class="o">!=</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">or</span> <span class="n">new_arg2</span> <span class="o">!=</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span><span class="p">,</span>
                                           <span class="n">new_arg1</span><span class="p">,</span> <span class="n">new_arg2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># If this instruction redefines a variable, invalidate it</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">result</span> <span class="ow">in</span> <span class="n">constants</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">!=</span> <span class="s2">&quot;copy&quot;</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">constants</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">result</span><span class="p">]</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">result</span> <span class="ow">in</span> <span class="n">constants</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span>
                  <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_constant</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">)):</span>
                <span class="k">del</span> <span class="n">constants</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">result</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">algebraic_simplification</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply algebraic identities.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">result</span>
            <span class="n">new_instr</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="c1"># x + 0 = x, 0 + x = x</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                    <span class="n">new_instr</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                    <span class="n">new_instr</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>

            <span class="c1"># x - 0 = x</span>
            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                    <span class="n">new_instr</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                <span class="c1"># x - x = 0</span>
                <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="o">==</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
                    <span class="n">new_instr</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>

            <span class="c1"># x * 1 = x, 1 * x = x, x * 0 = 0</span>
            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                    <span class="n">new_instr</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                    <span class="n">new_instr</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span> <span class="ow">or</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="o">==</span> <span class="s1">&#39;0&#39;</span><span class="p">:</span>
                    <span class="n">new_instr</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">)</span>

            <span class="c1"># x / 1 = x</span>
            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span><span class="p">:</span>
                    <span class="n">new_instr</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                <span class="c1"># x / x = 1 (assume x != 0)</span>
                <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="o">==</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
                    <span class="n">new_instr</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">new_instr</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_instr</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">strength_reduction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replace expensive operations with cheaper ones.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span> <span class="ow">and</span> <span class="n">is_constant</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">const_val</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">shift</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span>
                        <span class="n">instr</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;&lt;&lt;&quot;</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">elif</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;/&#39;</span> <span class="ow">and</span> <span class="n">is_constant</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">):</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">const_val</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="p">(</span><span class="n">val</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">val</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">shift</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">bit_length</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span>
                        <span class="n">instr</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;&gt;&gt;&quot;</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy_propagation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Replace uses of copied variables with the source.&quot;&quot;&quot;</span>
        <span class="n">copies</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># target -&gt; source</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="c1"># Record copies</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_constant</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">):</span>
                <span class="n">copies</span><span class="p">[</span><span class="n">instr</span><span class="o">.</span><span class="n">result</span><span class="p">]</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span>

            <span class="c1"># Propagate copies in uses</span>
            <span class="n">new_arg1</span> <span class="o">=</span> <span class="n">copies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
            <span class="n">new_arg2</span> <span class="o">=</span> <span class="n">copies</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">new_arg1</span> <span class="o">!=</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">or</span> <span class="n">new_arg2</span> <span class="o">!=</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span><span class="p">,</span>
                                           <span class="n">new_arg1</span><span class="p">,</span> <span class="n">new_arg2</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># Invalidate if source is redefined</span>
            <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">source</span> <span class="ow">in</span> <span class="n">copies</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="n">instr</span><span class="o">.</span><span class="n">result</span> <span class="ow">or</span> <span class="n">target</span> <span class="o">==</span> <span class="n">instr</span><span class="o">.</span><span class="n">result</span><span class="p">:</span>
                    <span class="n">to_remove</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">instr</span><span class="o">.</span><span class="n">result</span> <span class="ow">or</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">!=</span> <span class="s2">&quot;copy&quot;</span><span class="p">:</span>
                    <span class="n">copies</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">common_subexpression_elimination</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Eliminate redundant computations using value numbering.&quot;&quot;&quot;</span>
        <span class="c1"># (op, arg1, arg2) -&gt; result variable</span>
        <span class="n">computed</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="s1">&#39;%&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;&gt;&gt;&#39;</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>

                <span class="c1"># Check commutative operators</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">):</span>
                    <span class="n">comm_key</span> <span class="o">=</span> <span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">,</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">comm_key</span> <span class="ow">in</span> <span class="n">computed</span><span class="p">:</span>
                        <span class="n">key</span> <span class="o">=</span> <span class="n">comm_key</span>

                <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">computed</span><span class="p">:</span>
                    <span class="c1"># Replace with copy from previous computation</span>
                    <span class="n">prev_result</span> <span class="o">=</span> <span class="n">computed</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span>
                        <span class="n">instr</span><span class="o">.</span><span class="n">result</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="n">prev_result</span>
                    <span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">computed</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">result</span>

                <span class="c1"># Invalidate entries if arg is redefined</span>
                <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">computed</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                             <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">result</span> <span class="ow">in</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
                    <span class="k">del</span> <span class="n">computed</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">dead_code_elimination</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove instructions whose results are never used.&quot;&quot;&quot;</span>
        <span class="c1"># Find all used variables (scan backward)</span>
        <span class="n">used</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">live_out</span><span class="p">)</span>

        <span class="c1"># Scan backward to find used variables</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;nop&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_constant</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">):</span>
                <span class="n">used</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_constant</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">):</span>
                <span class="n">used</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">)</span>

        <span class="c1"># Mark instructions as dead if result is not used</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">instr</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;nop&quot;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">result</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">used</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">result</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">live_out</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;nop&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_local_optimizations</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate local optimizations on a basic block.&quot;&quot;&quot;</span>

    <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;t1&quot;</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">),</span>         <span class="c1"># t1 = 5</span>
        <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;t2&quot;</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">),</span>         <span class="c1"># t2 = 3</span>
        <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;t3&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;t1&quot;</span><span class="p">,</span> <span class="s2">&quot;t2&quot;</span><span class="p">),</span>     <span class="c1"># t3 = t1 + t2 â†’ fold to 8</span>
        <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;t4&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;t3&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">),</span>      <span class="c1"># t4 = t3 * 0 â†’ simplify to 0</span>
        <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;t5&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">),</span>       <span class="c1"># t5 = a + b</span>
        <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;t6&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">),</span>       <span class="c1"># t6 = a + b  (CSE)</span>
        <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;t7&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;t5&quot;</span><span class="p">,</span> <span class="s2">&quot;t6&quot;</span><span class="p">),</span>     <span class="c1"># t7 = t5 * t6 â†’ t5 * t5</span>
        <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;t8&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;t7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">),</span>      <span class="c1"># t8 = t7 * 8 â†’ strength reduce</span>
        <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;t9&quot;</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="s2">&quot;t8&quot;</span><span class="p">),</span>        <span class="c1"># t9 = t8 (copy)</span>
        <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;t10&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;t9&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">),</span>     <span class="c1"># t10 = t9 + 0 â†’ simplify</span>
        <span class="n">TAC</span><span class="p">(</span><span class="s2">&quot;unused&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;t1&quot;</span><span class="p">,</span> <span class="s2">&quot;t2&quot;</span><span class="p">),</span> <span class="c1"># dead code (unused not live-out)</span>
    <span class="p">]</span>

    <span class="n">live_out</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;t8&quot;</span><span class="p">,</span> <span class="s2">&quot;t10&quot;</span><span class="p">}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Before Optimization ===&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">instructions</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">instr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">optimizer</span> <span class="o">=</span> <span class="n">LocalOptimizer</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">live_out</span><span class="p">)</span>
    <span class="n">optimized</span> <span class="o">=</span> <span class="n">optimizer</span><span class="o">.</span><span class="n">optimize</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== After Optimization ===&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">optimized</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">instr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo_local_optimizations</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="3-global-data-flow-analysis">3. Global Data Flow Analysis<a class="header-link" href="#3-global-data-flow-analysis" title="Permanent link">&para;</a></h2>
<h3 id="31-why-global-analysis">3.1 Why Global Analysis?<a class="header-link" href="#31-why-global-analysis" title="Permanent link">&para;</a></h3>
<p>Local optimizations are limited to a single basic block. To optimize across block boundaries, we need <strong>global</strong> (intraprocedural) analysis that reasons about the flow of data through the entire control flow graph.</p>
<p><strong>Example</strong>: To determine if a variable has a constant value at a particular point, we must consider all paths that could reach that point -- this requires analyzing the entire CFG.</p>
<h3 id="32-the-four-classic-analyses">3.2 The Four Classic Analyses<a class="header-link" href="#32-the-four-classic-analyses" title="Permanent link">&para;</a></h3>
<p>The four foundational data flow analyses differ in what they track and in which direction information flows:</p>
<table>
<thead>
<tr>
<th>Analysis</th>
<th>Direction</th>
<th>Flow Meets At</th>
<th>Question</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Reaching Definitions</strong></td>
<td>Forward</td>
<td>Join points ($\cup$)</td>
<td>Which definitions of $x$ could reach this point?</td>
</tr>
<tr>
<td><strong>Available Expressions</strong></td>
<td>Forward</td>
<td>Join points ($\cap$)</td>
<td>Which expressions are guaranteed to have been computed?</td>
</tr>
<tr>
<td><strong>Live Variables</strong></td>
<td>Backward</td>
<td>Join points ($\cup$)</td>
<td>Which variables might be used before being redefined?</td>
</tr>
<tr>
<td><strong>Very Busy Expressions</strong></td>
<td>Backward</td>
<td>Join points ($\cap$)</td>
<td>Which expressions will definitely be evaluated on all paths?</td>
</tr>
</tbody>
</table>
<h3 id="33-reaching-definitions">3.3 Reaching Definitions<a class="header-link" href="#33-reaching-definitions" title="Permanent link">&para;</a></h3>
<p>A <strong>definition</strong> is an instruction that assigns a value to a variable (e.g., <code>d: x = ...</code>).</p>
<p>Definition $d$ of variable $x$ <strong>reaches</strong> point $p$ if:
- There is a path from $d$ to $p$, and
- $x$ is not redefined along that path</p>
<p><strong>Use</strong>: Constant propagation (if only one reaching definition exists and it assigns a constant, we can propagate it).</p>
<h4 id="data-flow-equations">Data Flow Equations<a class="header-link" href="#data-flow-equations" title="Permanent link">&para;</a></h4>
<p>For each basic block $B$:</p>
<p>$$\text{Out}(B) = \text{Gen}(B) \cup (\text{In}(B) - \text{Kill}(B))$$</p>
<p>$$\text{In}(B) = \bigcup_{P \in \text{pred}(B)} \text{Out}(P)$$</p>
<p>where:
- $\text{Gen}(B)$ = definitions generated in $B$ that survive to the end of $B$
- $\text{Kill}(B)$ = definitions killed by $B$ (definitions of variables that $B$ redefines)</p>
<p><strong>Direction</strong>: Forward (information flows from predecessors to successors)</p>
<p><strong>Meet operator</strong>: Union ($\cup$) -- a definition reaches a point if it reaches via <em>any</em> path</p>
<p><strong>Initialization</strong>: $\text{Out}(B) = \text{Gen}(B)$ for all blocks; $\text{In}(\text{entry}) = \emptyset$</p>
<h4 id="example">Example<a class="header-link" href="#example" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code><span class="n">B1</span><span class="o">:</span><span class="w"> </span><span class="n">d1</span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span>
<span class="w">    </span><span class="n">d2</span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="err">â†’</span><span class="w"> </span><span class="n">B2</span>

<span class="n">B2</span><span class="o">:</span><span class="w"> </span><span class="n">d3</span><span class="o">:</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">B3</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">B4</span>

<span class="n">B3</span><span class="o">:</span><span class="w"> </span><span class="n">d4</span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">d5</span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span>
<span class="w">    </span><span class="err">â†’</span><span class="w"> </span><span class="n">B2</span>

<span class="n">B4</span><span class="o">:</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">z</span>
</code></pre></div>

<p><strong>Gen and Kill sets</strong>:</p>
<table>
<thead>
<tr>
<th>Block</th>
<th>Gen</th>
<th>Kill</th>
</tr>
</thead>
<tbody>
<tr>
<td>B1</td>
<td>{d1, d2}</td>
<td>{d4, d5} (other defs of x, y)</td>
</tr>
<tr>
<td>B2</td>
<td>{d3}</td>
<td>{} (no other defs of z)</td>
</tr>
<tr>
<td>B3</td>
<td>{d4, d5}</td>
<td>{d1, d2} (other defs of x, y)</td>
</tr>
<tr>
<td>B4</td>
<td>{}</td>
<td>{}</td>
</tr>
</tbody>
</table>
<p><strong>Iteration</strong>:</p>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>In(B1)</th>
<th>Out(B1)</th>
<th>In(B2)</th>
<th>Out(B2)</th>
<th>In(B3)</th>
<th>Out(B3)</th>
<th>In(B4)</th>
<th>Out(B4)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Init</td>
<td>{}</td>
<td>{d1,d2}</td>
<td>{}</td>
<td>{d3}</td>
<td>{}</td>
<td>{d4,d5}</td>
<td>{}</td>
<td>{}</td>
</tr>
<tr>
<td>1</td>
<td>{}</td>
<td>{d1,d2}</td>
<td>{d1,d2,d4,d5}</td>
<td>{d1,d2,d3,d4,d5}</td>
<td>{d1,d2,d3,d4,d5}</td>
<td>{d3,d4,d5}</td>
<td>{d1,d2,d3,d4,d5}</td>
<td>{d1,d2,d3,d4,d5}</td>
</tr>
<tr>
<td>2</td>
<td>{}</td>
<td>{d1,d2}</td>
<td>{d1,d2,d3,d4,d5}</td>
<td>{d1,d2,d3,d4,d5}</td>
<td>{d1,d2,d3,d4,d5}</td>
<td>{d3,d4,d5}</td>
<td>{d1,d2,d3,d4,d5}</td>
<td>{d1,d2,d3,d4,d5}</td>
</tr>
</tbody>
</table>
<p>At B2, both $d_1$ and $d_4$ define $x$, so we cannot propagate a single constant for $x$.</p>
<h3 id="34-available-expressions">3.4 Available Expressions<a class="header-link" href="#34-available-expressions" title="Permanent link">&para;</a></h3>
<p>An expression $e$ is <strong>available</strong> at point $p$ if:
- On <strong>every</strong> path from the entry to $p$, $e$ is computed, and
- None of $e$'s operands are redefined after the last computation of $e$</p>
<p><strong>Use</strong>: Global common subexpression elimination. If $e$ is available at $p$ and $p$ computes $e$, we can replace $p$'s computation with the previously computed value.</p>
<h4 id="data-flow-equations_1">Data Flow Equations<a class="header-link" href="#data-flow-equations_1" title="Permanent link">&para;</a></h4>
<p>$$\text{Out}(B) = \text{Gen}(B) \cup (\text{In}(B) - \text{Kill}(B))$$</p>
<p>$$\text{In}(B) = \bigcap_{P \in \text{pred}(B)} \text{Out}(P)$$</p>
<p><strong>Direction</strong>: Forward</p>
<p><strong>Meet operator</strong>: Intersection ($\cap$) -- an expression is available only if it is available on <em>every</em> path</p>
<p><strong>Initialization</strong>: $\text{Out}(\text{entry}) = \emptyset$; $\text{Out}(B) = U$ (all expressions) for $B \neq \text{entry}$</p>
<p>The use of intersection is crucial: an expression is available only if it has been computed along <em>all</em> incoming paths. This is a "must" analysis (must be true on all paths), in contrast to reaching definitions which is a "may" analysis.</p>
<h3 id="35-live-variables">3.5 Live Variables<a class="header-link" href="#35-live-variables" title="Permanent link">&para;</a></h3>
<p>A variable $v$ is <strong>live</strong> at point $p$ if:
- There is a path from $p$ to a use of $v$, and
- $v$ is not redefined along that path</p>
<p><strong>Use</strong>: Register allocation (live variables need registers), dead code elimination (a definition is dead if the variable is not live after it).</p>
<h4 id="data-flow-equations_2">Data Flow Equations<a class="header-link" href="#data-flow-equations_2" title="Permanent link">&para;</a></h4>
<p>$$\text{In}(B) = \text{Use}(B) \cup (\text{Out}(B) - \text{Def}(B))$$</p>
<p>$$\text{Out}(B) = \bigcup_{S \in \text{succ}(B)} \text{In}(S)$$</p>
<p>where:
- $\text{Use}(B)$ = variables used in $B$ before being defined in $B$
- $\text{Def}(B)$ = variables defined in $B$</p>
<p><strong>Direction</strong>: Backward (information flows from successors to predecessors)</p>
<p><strong>Meet operator</strong>: Union ($\cup$) -- a variable is live if it is needed on <em>any</em> path forward</p>
<p><strong>Initialization</strong>: $\text{In}(B) = \emptyset$ for all blocks; $\text{Out}(\text{exit}) = \emptyset$ (or the set of variables whose values are needed after the function returns)</p>
<h3 id="36-very-busy-expressions">3.6 Very Busy Expressions<a class="header-link" href="#36-very-busy-expressions" title="Permanent link">&para;</a></h3>
<p>An expression $e$ is <strong>very busy</strong> at point $p$ if:
- On <strong>every</strong> path from $p$ to the exit, $e$ is evaluated before any of its operands are redefined</p>
<p><strong>Use</strong>: Code hoisting -- if $e$ is very busy at $p$, we can safely move the computation of $e$ to $p$ (earlier), potentially reducing code size.</p>
<h4 id="data-flow-equations_3">Data Flow Equations<a class="header-link" href="#data-flow-equations_3" title="Permanent link">&para;</a></h4>
<p>$$\text{In}(B) = \text{Gen}(B) \cup (\text{Out}(B) - \text{Kill}(B))$$</p>
<p>$$\text{Out}(B) = \bigcap_{S \in \text{succ}(B)} \text{In}(S)$$</p>
<p><strong>Direction</strong>: Backward</p>
<p><strong>Meet operator</strong>: Intersection ($\cap$) -- an expression is very busy only if it is evaluated on <em>every</em> path</p>
<h3 id="37-summary-of-the-four-analyses">3.7 Summary of the Four Analyses<a class="header-link" href="#37-summary-of-the-four-analyses" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th></th>
<th>Reaching Defs</th>
<th>Available Exprs</th>
<th>Live Vars</th>
<th>Very Busy Exprs</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Domain</strong></td>
<td>Sets of definitions</td>
<td>Sets of expressions</td>
<td>Sets of variables</td>
<td>Sets of expressions</td>
</tr>
<tr>
<td><strong>Direction</strong></td>
<td>Forward</td>
<td>Forward</td>
<td>Backward</td>
<td>Backward</td>
</tr>
<tr>
<td><strong>Meet</strong></td>
<td>$\cup$ (may)</td>
<td>$\cap$ (must)</td>
<td>$\cup$ (may)</td>
<td>$\cap$ (must)</td>
</tr>
<tr>
<td><strong>Transfer</strong></td>
<td>$\text{Gen} \cup (\text{In} - \text{Kill})$</td>
<td>$\text{Gen} \cup (\text{In} - \text{Kill})$</td>
<td>$\text{Use} \cup (\text{Out} - \text{Def})$</td>
<td>$\text{Gen} \cup (\text{Out} - \text{Kill})$</td>
</tr>
<tr>
<td><strong>Init (boundary)</strong></td>
<td>$\text{Out}(\text{entry}) = \emptyset$</td>
<td>$\text{Out}(\text{entry}) = \emptyset$</td>
<td>$\text{In}(\text{exit}) = \emptyset$</td>
<td>$\text{In}(\text{exit}) = \emptyset$</td>
</tr>
<tr>
<td><strong>Init (others)</strong></td>
<td>$\emptyset$</td>
<td>$U$ (all exprs)</td>
<td>$\emptyset$</td>
<td>$U$ (all exprs)</td>
</tr>
<tr>
<td><strong>Use</strong></td>
<td>Constant prop.</td>
<td>Global CSE</td>
<td>Reg. alloc., DCE</td>
<td>Code hoisting</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="4-data-flow-analysis-framework">4. Data Flow Analysis Framework<a class="header-link" href="#4-data-flow-analysis-framework" title="Permanent link">&para;</a></h2>
<h3 id="41-lattice-theory-basics">4.1 Lattice Theory Basics<a class="header-link" href="#41-lattice-theory-basics" title="Permanent link">&para;</a></h3>
<p>Data flow analyses can be unified under a mathematical framework based on <strong>lattice theory</strong>.</p>
<p><strong>Definition</strong>: A <strong>lattice</strong> $(L, \sqsubseteq)$ is a partially ordered set where every pair of elements has a <strong>meet</strong> ($\sqcap$, greatest lower bound) and a <strong>join</strong> ($\sqcup$, least upper bound).</p>
<p>For data flow analysis, we typically use <strong>complete lattices</strong> where every subset has a meet and join. Key elements:</p>
<ul>
<li>$\top$ (top): The greatest element -- represents "no information yet" or "all possibilities"</li>
<li>$\bot$ (bottom): The least element -- represents "unreachable" or "contradiction"</li>
</ul>
<h4 id="lattice-for-reaching-definitions">Lattice for Reaching Definitions<a class="header-link" href="#lattice-for-reaching-definitions" title="Permanent link">&para;</a></h4>
<p>The lattice is the <strong>powerset</strong> of all definitions, ordered by subset inclusion:</p>
<p>$$L = 2^{\text{Defs}}, \quad A \sqsubseteq B \iff A \subseteq B$$</p>
<ul>
<li>$\top = \text{Defs}$ (all definitions -- universal set)</li>
<li>$\bot = \emptyset$ (no definitions)</li>
<li>Meet ($\sqcap$) = Union ($\cup$) since we use a may-analysis (any path)</li>
</ul>
<p>Wait -- in the standard formulation, the convention depends on the direction of the lattice. Let us be careful.</p>
<p>For a <strong>may analysis</strong> (like reaching definitions), the lattice goes from $\bot = \emptyset$ (no information) upward, and the meet is $\cup$ (union). We start with the most optimistic value ($\bot = \emptyset$: "nothing reaches here") and add information until reaching a fixed point.</p>
<p>For a <strong>must analysis</strong> (like available expressions), the lattice goes from $\top = U$ (all expressions available) downward, and the meet is $\cap$ (intersection). We start with the most optimistic value ($\top = U$: "everything is available") and remove information until reaching a fixed point.</p>
<h4 id="general-framework">General Framework<a class="header-link" href="#general-framework" title="Permanent link">&para;</a></h4>
<p>A data flow analysis is defined by:</p>
<ol>
<li>A <strong>lattice</strong> $(L, \sqsubseteq)$ with meet $\sqcap$</li>
<li>A <strong>transfer function</strong> $f_B : L \to L$ for each block $B$</li>
<li>A <strong>direction</strong> (forward or backward)</li>
<li>A <strong>boundary condition</strong> (initial value at entry/exit)</li>
<li>An <strong>initial value</strong> for all other blocks</li>
</ol>
<p>The solution is the <strong>greatest fixed point</strong> of the system of equations.</p>
<h3 id="42-transfer-functions">4.2 Transfer Functions<a class="header-link" href="#42-transfer-functions" title="Permanent link">&para;</a></h3>
<p>A transfer function $f_B$ describes how information changes as it passes through block $B$. Most data flow analyses use transfer functions of the form:</p>
<p>$$f_B(X) = \text{Gen}(B) \cup (X - \text{Kill}(B))$$</p>
<p>This is a <strong>monotone</strong> function: if $X \sqsubseteq Y$, then $f_B(X) \sqsubseteq f_B(Y)$.</p>
<p><strong>Monotonicity is essential</strong>: it guarantees that the iterative algorithm converges.</p>
<h3 id="43-meet-over-paths-mop-solution">4.3 Meet-Over-Paths (MOP) Solution<a class="header-link" href="#43-meet-over-paths-mop-solution" title="Permanent link">&para;</a></h3>
<p>The <strong>ideal</strong> solution is the <strong>Meet-Over-All-Paths</strong> (MOP) solution. For a forward analysis, the MOP solution at the entry of block $B$ is:</p>
<p>$$\text{MOP}(B) = \bigsqcap_{\text{path } p : \text{entry} \to B} f_p(\text{boundary\_value})$$</p>
<p>where $f_p$ is the composition of transfer functions along path $p$.</p>
<p>Computing MOP directly is generally undecidable (there may be infinitely many paths due to loops). Instead, we compute the <strong>Maximum Fixed Point</strong> (MFP), which is guaranteed to be at least as conservative as MOP (i.e., $\text{MFP} \sqsubseteq \text{MOP}$ in the appropriate order).</p>
<p>For transfer functions of the form $f(X) = \text{Gen} \cup (X - \text{Kill})$ (which are <strong>distributive</strong>), MFP = MOP exactly.</p>
<h3 id="44-fixed-point-iteration">4.4 Fixed-Point Iteration<a class="header-link" href="#44-fixed-point-iteration" title="Permanent link">&para;</a></h3>
<p><strong>Theorem (Tarski)</strong>: If $f$ is a monotone function on a complete lattice, then $f$ has a least fixed point, which can be obtained by iterating from $\bot$:</p>
<p>$$\bot, f(\bot), f^2(\bot), \ldots$$</p>
<p>For data flow analysis, we simultaneously iterate over all blocks until no values change:</p>
<div class="highlight"><pre><span></span><code><span class="n">Algorithm</span><span class="o">:</span><span class="w"> </span><span class="n">Iterative</span><span class="w"> </span><span class="n">Data</span><span class="w"> </span><span class="n">Flow</span><span class="w"> </span><span class="n">Analysis</span><span class="w"> </span><span class="o">(</span><span class="n">Forward</span><span class="o">)</span>

<span class="n">Initialize</span><span class="o">:</span>
<span class="w">    </span><span class="n">Out</span><span class="o">(</span><span class="n">entry</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boundary_value</span>
<span class="w">    </span><span class="n">Out</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_value</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="err">â‰ </span><span class="w"> </span><span class="n">entry</span>

<span class="n">Repeat</span><span class="o">:</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">(</span><span class="k">in</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">order</span><span class="o">):</span>
<span class="w">        </span><span class="n">In</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Meet</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">predecessors</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">Out</span><span class="o">(</span><span class="n">P</span><span class="o">)</span>
<span class="w">        </span><span class="n">Out</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f_B</span><span class="o">(</span><span class="n">In</span><span class="o">(</span><span class="n">B</span><span class="o">))</span>
<span class="n">until</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">Out</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">changed</span>
</code></pre></div>

<p><strong>Convergence</strong>: Guaranteed because:
1. The lattice has finite height (finite number of definitions/expressions)
2. Transfer functions are monotone
3. Each iteration moves values in one direction (up or down in the lattice)</p>
<p><strong>Worst-case iterations</strong>: At most $h \times |V|$ where $h$ is the lattice height and $|V|$ is the number of CFG nodes. In practice, 2--3 iterations usually suffice.</p>
<h3 id="45-worklist-algorithm">4.5 Worklist Algorithm<a class="header-link" href="#45-worklist-algorithm" title="Permanent link">&para;</a></h3>
<p>The naive iterative algorithm repeatedly scans all blocks even when most have not changed. The <strong>worklist algorithm</strong> processes only blocks whose inputs have changed:</p>
<div class="highlight"><pre><span></span><code><span class="n">Algorithm</span><span class="o">:</span><span class="w"> </span><span class="n">Worklist</span><span class="w"> </span><span class="n">Data</span><span class="w"> </span><span class="n">Flow</span><span class="w"> </span><span class="n">Analysis</span><span class="w"> </span><span class="o">(</span><span class="n">Forward</span><span class="o">)</span>

<span class="n">Initialize</span><span class="o">:</span>
<span class="w">    </span><span class="n">Out</span><span class="o">(</span><span class="n">entry</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">boundary_value</span>
<span class="w">    </span><span class="n">Out</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">initial_value</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="err">â‰ </span><span class="w"> </span><span class="n">entry</span>
<span class="w">    </span><span class="n">worklist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">blocks</span><span class="w"> </span><span class="n">except</span><span class="w"> </span><span class="n">entry</span>

<span class="n">While</span><span class="w"> </span><span class="n">worklist</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">empty</span><span class="o">:</span>
<span class="w">    </span><span class="n">Remove</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">worklist</span>
<span class="w">    </span><span class="n">In</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Meet</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">predecessors</span><span class="w"> </span><span class="n">P</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">Out</span><span class="o">(</span><span class="n">P</span><span class="o">)</span>
<span class="w">    </span><span class="n">new_out</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f_B</span><span class="o">(</span><span class="n">In</span><span class="o">(</span><span class="n">B</span><span class="o">))</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">new_out</span><span class="w"> </span><span class="err">â‰ </span><span class="w"> </span><span class="n">Out</span><span class="o">(</span><span class="n">B</span><span class="o">):</span>
<span class="w">        </span><span class="n">Out</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new_out</span>
<span class="w">        </span><span class="n">Add</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">successors</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">worklist</span>
</code></pre></div>

<p><strong>Efficiency</strong>: The worklist algorithm avoids redundant work. Using reverse postorder for forward analyses (or postorder for backward analyses) as the initial worklist order improves convergence.</p>
<hr />
<h2 id="5-python-implementation-data-flow-analysis">5. Python Implementation: Data Flow Analysis<a class="header-link" href="#5-python-implementation-data-flow-analysis" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Generic Data Flow Analysis Framework.</span>

<span class="sd">Implements the worklist algorithm for forward and backward analyses.</span>
<span class="sd">Includes implementations of all four classic analyses.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">defaultdict</span><span class="p">,</span> <span class="n">deque</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">ABC</span><span class="p">,</span> <span class="n">abstractmethod</span>


<span class="c1"># ============================================================</span>
<span class="c1"># CFG Data Structures</span>
<span class="c1"># ============================================================</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Instruction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A three-address code instruction.&quot;&quot;&quot;</span>
    <span class="n">index</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">result</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">arg1</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">arg2</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">defined_var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variable defined by this instruction.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;goto&quot;</span><span class="p">,</span> <span class="s2">&quot;iffalse&quot;</span><span class="p">,</span>
                                                        <span class="s2">&quot;iftrue&quot;</span><span class="p">,</span> <span class="s2">&quot;label&quot;</span><span class="p">,</span>
                                                        <span class="s2">&quot;return&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">result</span>
        <span class="k">return</span> <span class="s2">&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">used_vars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Variables used by this instruction.&quot;&quot;&quot;</span>
        <span class="n">used</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">arg</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">arg</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;L&quot;</span><span class="p">)</span> \
               <span class="ow">and</span> <span class="ow">not</span> <span class="n">arg</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
                <span class="n">used</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">used</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;label&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="si">}</span><span class="s2">:&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;copy&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;goto&quot;</span><span class="p">,</span> <span class="s2">&quot;iffalse&quot;</span><span class="p">,</span> <span class="s2">&quot;iftrue&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s2">&quot;return&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;return </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">result</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BasicBlock</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A basic block in the CFG.&quot;&quot;&quot;</span>
    <span class="nb">id</span><span class="p">:</span> <span class="nb">int</span>
    <span class="n">instructions</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">successors</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">predecessors</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;B</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">instr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CFG</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Control flow graph.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">BasicBlock</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">block</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="n">block</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">to_id</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">to_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">from_id</span><span class="p">]</span><span class="o">.</span><span class="n">successors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">from_id</span><span class="p">]</span><span class="o">.</span><span class="n">successors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_id</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">from_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">to_id</span><span class="p">]</span><span class="o">.</span><span class="n">predecessors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">to_id</span><span class="p">]</span><span class="o">.</span><span class="n">predecessors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">from_id</span><span class="p">)</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Data Flow Analysis Framework</span>
<span class="c1"># ============================================================</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Direction</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">FORWARD</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">BACKWARD</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">MeetOp</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">UNION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>        <span class="c1"># May analysis</span>
    <span class="n">INTERSECTION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>  <span class="c1"># Must analysis</span>


<span class="k">class</span><span class="w"> </span><span class="nc">DataFlowAnalysis</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for data flow analyses.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">:</span> <span class="n">CFG</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span> <span class="n">Direction</span><span class="p">,</span> <span class="n">meet_op</span><span class="p">:</span> <span class="n">MeetOp</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span> <span class="o">=</span> <span class="n">cfg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">meet_op</span> <span class="o">=</span> <span class="n">meet_op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">in_sets</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_sets</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the Gen set for a block.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the Kill set for a block.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the universal set for must-analyses.&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">boundary_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the boundary value (for entry/exit block).&quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">meet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sets</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">set</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the meet operator to a list of sets.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sets</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meet_op</span> <span class="o">==</span> <span class="n">MeetOp</span><span class="o">.</span><span class="n">UNION</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">()</span>

        <span class="n">result</span> <span class="o">=</span> <span class="n">sets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sets</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meet_op</span> <span class="o">==</span> <span class="n">MeetOp</span><span class="o">.</span><span class="n">UNION</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">|</span> <span class="n">s</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">result</span> <span class="o">=</span> <span class="n">result</span> <span class="o">&amp;</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">transfer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">,</span> <span class="n">input_set</span><span class="p">:</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the transfer function: Gen âˆª (input - Kill).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">input_set</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">initial_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial value for non-boundary blocks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">meet_op</span> <span class="o">==</span> <span class="n">MeetOp</span><span class="o">.</span><span class="n">UNION</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>       <span class="c1"># Most optimistic for may-analyses</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">universe</span><span class="p">()</span>  <span class="c1"># Most optimistic for must-analyses</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solve the data flow equations using the worklist algorithm.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">block_ids</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="n">Direction</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solve_forward</span><span class="p">(</span><span class="n">block_ids</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_solve_backward</span><span class="p">(</span><span class="n">block_ids</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_solve_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_ids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Forward worklist algorithm.&quot;&quot;&quot;</span>
        <span class="n">entry_id</span> <span class="o">=</span> <span class="n">block_ids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Initialize</span>
        <span class="k">for</span> <span class="n">bid</span> <span class="ow">in</span> <span class="n">block_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">bid</span> <span class="o">==</span> <span class="n">entry_id</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_value</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span><span class="p">()</span>

        <span class="c1"># Worklist (use reverse postorder for efficiency)</span>
        <span class="n">worklist</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">block_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>  <span class="c1"># Exclude entry initially</span>
        <span class="n">in_worklist</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">worklist</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
            <span class="n">bid</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">in_worklist</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">bid</span><span class="p">)</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span>

            <span class="c1"># Compute In</span>
            <span class="n">pred_outs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">out_sets</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">predecessors</span><span class="p">]</span>
            <span class="n">new_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meet</span><span class="p">(</span><span class="n">pred_outs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_in</span>

            <span class="c1"># Compute Out via transfer function</span>
            <span class="n">new_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">new_in</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">new_out</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">out_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_out</span>
                <span class="k">for</span> <span class="n">succ</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">successors</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">succ</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_worklist</span><span class="p">:</span>
                        <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">succ</span><span class="p">)</span>
                        <span class="n">in_worklist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">succ</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_solve_backward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block_ids</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Backward worklist algorithm.&quot;&quot;&quot;</span>
        <span class="c1"># Find exit blocks (no successors)</span>
        <span class="n">exit_ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">bid</span> <span class="k">for</span> <span class="n">bid</span> <span class="ow">in</span> <span class="n">block_ids</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span><span class="o">.</span><span class="n">successors</span><span class="p">]</span>

        <span class="c1"># Initialize</span>
        <span class="k">for</span> <span class="n">bid</span> <span class="ow">in</span> <span class="n">block_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">bid</span> <span class="ow">in</span> <span class="n">exit_ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">in_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boundary_value</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">in_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">initial_value</span><span class="p">()</span>

        <span class="c1"># Worklist</span>
        <span class="n">worklist</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">bid</span> <span class="k">for</span> <span class="n">bid</span> <span class="ow">in</span> <span class="n">block_ids</span> <span class="k">if</span> <span class="n">bid</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">exit_ids</span><span class="p">)</span>
        <span class="n">in_worklist</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">worklist</span><span class="p">)</span>

        <span class="c1"># Also add exit blocks to process their predecessors</span>
        <span class="k">for</span> <span class="n">eid</span> <span class="ow">in</span> <span class="n">exit_ids</span><span class="p">:</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_sets</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">in_sets</span><span class="p">[</span><span class="n">eid</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_sets</span><span class="p">[</span><span class="n">eid</span><span class="p">])</span>

        <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
            <span class="n">bid</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
            <span class="n">in_worklist</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">bid</span><span class="p">)</span>
            <span class="n">block</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span>

            <span class="c1"># Compute Out from successors</span>
            <span class="n">succ_ins</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">in_sets</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">successors</span><span class="p">]</span>
            <span class="n">new_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">meet</span><span class="p">(</span><span class="n">succ_ins</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">out_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_out</span>

            <span class="c1"># Compute In via transfer function</span>
            <span class="n">new_in</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transfer</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">new_out</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">new_in</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">in_sets</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_in</span>
                <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">predecessors</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">pred</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">in_worklist</span><span class="p">:</span>
                        <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
                        <span class="n">in_worklist</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_results</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">analysis_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pretty-print the analysis results.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== </span><span class="si">{</span><span class="n">analysis_name</span><span class="si">}</span><span class="s2"> ===&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">bid</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="n">in_s</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">in_sets</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bid</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span>
            <span class="n">out_s</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">out_sets</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">bid</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  B</span><span class="si">{</span><span class="n">bid</span><span class="si">}</span><span class="s2">: In = </span><span class="se">{{</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">in_s</span><span class="p">)</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;       Out = </span><span class="se">{{</span><span class="si">{</span><span class="s1">&#39;, &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">out_s</span><span class="p">)</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Concrete Analyses</span>
<span class="c1"># ============================================================</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ReachingDefinitions</span><span class="p">(</span><span class="n">DataFlowAnalysis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reaching Definitions analysis.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">:</span> <span class="n">CFG</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">,</span> <span class="n">MeetOp</span><span class="o">.</span><span class="n">UNION</span><span class="p">)</span>
        <span class="c1"># Pre-compute all definitions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_defs</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">set</span><span class="p">]</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>  <span class="c1"># var -&gt; {def labels}</span>
        <span class="k">for</span> <span class="n">bid</span><span class="p">,</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
                <span class="n">dvar</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">defined_var</span>
                <span class="k">if</span> <span class="n">dvar</span><span class="p">:</span>
                    <span class="n">def_label</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;d</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">dvar</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_defs</span><span class="p">[</span><span class="n">dvar</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">def_label</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="n">gen_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">killed_in_block</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Track vars defined in this block</span>
        <span class="c1"># Process in order; last def of each var survives</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">defined_var</span>
            <span class="k">if</span> <span class="n">dvar</span><span class="p">:</span>
                <span class="c1"># Kill previous defs of this var in this block</span>
                <span class="n">gen_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">gen_set</span>
                           <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;:</span><span class="si">{</span><span class="n">dvar</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)}</span>
                <span class="n">gen_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;d</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">:</span><span class="si">{</span><span class="n">dvar</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gen_set</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="n">kill_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">defined_var</span>
            <span class="k">if</span> <span class="n">dvar</span><span class="p">:</span>
                <span class="c1"># Kill all other defs of this var</span>
                <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_defs</span><span class="p">[</span><span class="n">dvar</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">d</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;d</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">):</span>
                        <span class="n">kill_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kill_set</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">all_defs</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_defs</span> <span class="k">else</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">boundary_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">LiveVariables</span><span class="p">(</span><span class="n">DataFlowAnalysis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Live Variables analysis.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">:</span> <span class="n">CFG</span><span class="p">,</span> <span class="n">exit_live</span><span class="p">:</span> <span class="nb">set</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">BACKWARD</span><span class="p">,</span> <span class="n">MeetOp</span><span class="o">.</span><span class="n">UNION</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">exit_live</span> <span class="o">=</span> <span class="n">exit_live</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Use set: variables used before being defined in this block.&quot;&quot;&quot;</span>
        <span class="n">use_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">defined</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
            <span class="c1"># Uses that haven&#39;t been defined yet in this block</span>
            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">instr</span><span class="o">.</span><span class="n">used_vars</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">defined</span><span class="p">:</span>
                    <span class="n">use_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="c1"># Definition</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">defined_var</span>
            <span class="k">if</span> <span class="n">dvar</span><span class="p">:</span>
                <span class="n">defined</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dvar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">use_set</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Def set: variables defined in this block.&quot;&quot;&quot;</span>
        <span class="n">def_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">defined_var</span>
            <span class="k">if</span> <span class="n">dvar</span><span class="p">:</span>
                <span class="n">def_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dvar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">def_set</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="n">all_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
                <span class="n">all_vars</span> <span class="o">|=</span> <span class="n">instr</span><span class="o">.</span><span class="n">used_vars</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">defined_var</span><span class="p">:</span>
                    <span class="n">all_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">instr</span><span class="o">.</span><span class="n">defined_var</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">all_vars</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">boundary_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_live</span>


<span class="k">class</span><span class="w"> </span><span class="nc">AvailableExpressions</span><span class="p">(</span><span class="n">DataFlowAnalysis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Available Expressions analysis.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">:</span> <span class="n">CFG</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">FORWARD</span><span class="p">,</span> <span class="n">MeetOp</span><span class="o">.</span><span class="n">INTERSECTION</span><span class="p">)</span>
        <span class="c1"># Collect all expressions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_exprs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_exprs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="n">gen_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">killed_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Variables defined so far</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
            <span class="c1"># Add expression if operands haven&#39;t been killed</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">killed_vars</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">killed_vars</span><span class="p">:</span>
                    <span class="n">gen_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="c1"># Kill expressions involving the defined variable</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">defined_var</span>
            <span class="k">if</span> <span class="n">dvar</span><span class="p">:</span>
                <span class="n">gen_set</span> <span class="o">=</span> <span class="p">{</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">gen_set</span>
                           <span class="k">if</span> <span class="n">dvar</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">e</span><span class="o">.</span><span class="n">split</span><span class="p">()}</span>
                <span class="n">killed_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dvar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gen_set</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="n">kill_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">defined_var</span>
            <span class="k">if</span> <span class="n">dvar</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_exprs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
                        <span class="n">kill_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kill_set</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_exprs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">boundary_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>


<span class="k">class</span><span class="w"> </span><span class="nc">VeryBusyExpressions</span><span class="p">(</span><span class="n">DataFlowAnalysis</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Very Busy Expressions analysis.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cfg</span><span class="p">:</span> <span class="n">CFG</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">Direction</span><span class="o">.</span><span class="n">BACKWARD</span><span class="p">,</span> <span class="n">MeetOp</span><span class="o">.</span><span class="n">INTERSECTION</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">all_exprs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">all_exprs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">gen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Expressions computed in this block before any operand is redefined.&quot;&quot;&quot;</span>
        <span class="n">gen_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">killed_vars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
            <span class="c1"># Check if this computes an expression with unkilled operands</span>
            <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="p">:</span>
                <span class="n">expr</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">arg1</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">arg2</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">if</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">killed_vars</span> <span class="ow">and</span> <span class="n">instr</span><span class="o">.</span><span class="n">arg2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">killed_vars</span><span class="p">:</span>
                    <span class="n">gen_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="c1"># Track defined variables</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">defined_var</span>
            <span class="k">if</span> <span class="n">dvar</span><span class="p">:</span>
                <span class="n">killed_vars</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dvar</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gen_set</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">kill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">:</span> <span class="n">BasicBlock</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="n">kill_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
            <span class="n">dvar</span> <span class="o">=</span> <span class="n">instr</span><span class="o">.</span><span class="n">defined_var</span>
            <span class="k">if</span> <span class="n">dvar</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">expr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">all_exprs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">dvar</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">split</span><span class="p">():</span>
                        <span class="n">kill_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kill_set</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">universe</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">all_exprs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">boundary_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>


<span class="c1"># ============================================================</span>
<span class="c1"># Example</span>
<span class="c1"># ============================================================</span>

<span class="k">def</span><span class="w"> </span><span class="nf">build_example_cfg</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">CFG</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build example CFG:</span>

<span class="sd">    B0: d0: x = 5</span>
<span class="sd">        d1: y = 1</span>

<span class="sd">    B1: d2: z = x + y</span>
<span class="sd">        if z &lt; 10 goto B2</span>

<span class="sd">    B2: d3: x = x + 1</span>
<span class="sd">        d4: y = y * 2</span>
<span class="sd">        goto B1</span>

<span class="sd">    B3: d5: w = x + y</span>
<span class="sd">        return w</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cfg</span> <span class="o">=</span> <span class="n">CFG</span><span class="p">()</span>

    <span class="n">b0</span> <span class="o">=</span> <span class="n">BasicBlock</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">instructions</span><span class="o">=</span><span class="p">[</span>
        <span class="n">Instruction</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">),</span>
        <span class="n">Instruction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;copy&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">),</span>
    <span class="p">])</span>

    <span class="n">b1</span> <span class="o">=</span> <span class="n">BasicBlock</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">instructions</span><span class="o">=</span><span class="p">[</span>
        <span class="n">Instruction</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">),</span>
        <span class="n">Instruction</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;iffalse&quot;</span><span class="p">,</span> <span class="s2">&quot;z &lt; 10&quot;</span><span class="p">,</span> <span class="n">result</span><span class="o">=</span><span class="s2">&quot;B3&quot;</span><span class="p">),</span>
    <span class="p">])</span>

    <span class="n">b2</span> <span class="o">=</span> <span class="n">BasicBlock</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">instructions</span><span class="o">=</span><span class="p">[</span>
        <span class="n">Instruction</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">),</span>
        <span class="n">Instruction</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">),</span>
    <span class="p">])</span>

    <span class="n">b3</span> <span class="o">=</span> <span class="n">BasicBlock</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">instructions</span><span class="o">=</span><span class="p">[</span>
        <span class="n">Instruction</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">),</span>
        <span class="n">Instruction</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;return&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">),</span>
    <span class="p">])</span>

    <span class="n">cfg</span><span class="o">.</span><span class="n">add_block</span><span class="p">(</span><span class="n">b0</span><span class="p">)</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">add_block</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">add_block</span><span class="p">(</span><span class="n">b2</span><span class="p">)</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">add_block</span><span class="p">(</span><span class="n">b3</span><span class="p">)</span>

    <span class="n">cfg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># z &lt; 10</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># z &gt;= 10</span>
    <span class="n">cfg</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># loop back</span>

    <span class="k">return</span> <span class="n">cfg</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demo_all_analyses</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run all four data flow analyses on the example CFG.&quot;&quot;&quot;</span>
    <span class="n">cfg</span> <span class="o">=</span> <span class="n">build_example_cfg</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Control Flow Graph ===&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bid</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">B</span><span class="si">{</span><span class="n">bid</span><span class="si">}</span><span class="s2">: (pred=</span><span class="si">{</span><span class="n">block</span><span class="o">.</span><span class="n">predecessors</span><span class="si">}</span><span class="s2">, succ=</span><span class="si">{</span><span class="n">block</span><span class="o">.</span><span class="n">successors</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">instructions</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  d</span><span class="si">{</span><span class="n">instr</span><span class="o">.</span><span class="n">index</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">instr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># 1. Reaching Definitions</span>
    <span class="n">rd</span> <span class="o">=</span> <span class="n">ReachingDefinitions</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
    <span class="n">rd</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">rd</span><span class="o">.</span><span class="n">print_results</span><span class="p">(</span><span class="s2">&quot;Reaching Definitions&quot;</span><span class="p">)</span>

    <span class="c1"># 2. Live Variables</span>
    <span class="n">lv</span> <span class="o">=</span> <span class="n">LiveVariables</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">exit_live</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;w&quot;</span><span class="p">})</span>
    <span class="n">lv</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">lv</span><span class="o">.</span><span class="n">print_results</span><span class="p">(</span><span class="s2">&quot;Live Variables&quot;</span><span class="p">)</span>

    <span class="c1"># 3. Available Expressions</span>
    <span class="n">ae</span> <span class="o">=</span> <span class="n">AvailableExpressions</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
    <span class="n">ae</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">ae</span><span class="o">.</span><span class="n">print_results</span><span class="p">(</span><span class="s2">&quot;Available Expressions&quot;</span><span class="p">)</span>

    <span class="c1"># 4. Very Busy Expressions</span>
    <span class="n">vb</span> <span class="o">=</span> <span class="n">VeryBusyExpressions</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
    <span class="n">vb</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
    <span class="n">vb</span><span class="o">.</span><span class="n">print_results</span><span class="p">(</span><span class="s2">&quot;Very Busy Expressions&quot;</span><span class="p">)</span>

    <span class="c1"># Print Gen/Kill sets for each analysis</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Gen/Kill Sets ===&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">bid</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
        <span class="n">block</span> <span class="o">=</span> <span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="p">[</span><span class="n">bid</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">B</span><span class="si">{</span><span class="n">bid</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  RD:  Gen=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">rd</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">block</span><span class="p">))</span><span class="si">}</span><span class="s2">, Kill=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">rd</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="n">block</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  LV:  Use=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">lv</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">block</span><span class="p">))</span><span class="si">}</span><span class="s2">, Def=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">lv</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="n">block</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  AE:  Gen=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ae</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">block</span><span class="p">))</span><span class="si">}</span><span class="s2">, Kill=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">ae</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="n">block</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  VBE: Gen=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">vb</span><span class="o">.</span><span class="n">gen</span><span class="p">(</span><span class="n">block</span><span class="p">))</span><span class="si">}</span><span class="s2">, Kill=</span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">vb</span><span class="o">.</span><span class="n">kill</span><span class="p">(</span><span class="n">block</span><span class="p">))</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">demo_all_analyses</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="6-applying-analysis-results-to-optimization">6. Applying Analysis Results to Optimization<a class="header-link" href="#6-applying-analysis-results-to-optimization" title="Permanent link">&para;</a></h2>
<h3 id="61-global-constant-propagation">6.1 Global Constant Propagation<a class="header-link" href="#61-global-constant-propagation" title="Permanent link">&para;</a></h3>
<p>Using <strong>reaching definitions</strong>, we can perform global constant propagation:</p>
<div class="highlight"><pre><span></span><code><span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">use</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">point</span><span class="w"> </span><span class="n">p</span><span class="p">:</span>
<span class="w">    </span><span class="n">Let</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">reaching</span><span class="w"> </span><span class="n">definitions</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">p</span>
<span class="w">    </span><span class="n">If</span><span class="w"> </span><span class="o">|</span><span class="n">D</span><span class="o">|</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">definition</span><span class="w"> </span><span class="n">assigns</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">constant</span><span class="w"> </span><span class="n">c</span><span class="p">:</span>
<span class="w">        </span><span class="n">Replace</span><span class="w"> </span><span class="n">v</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">p</span>
</code></pre></div>

<p><strong>Example</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">B1</span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="w">         </span><span class="c1">// d1</span>

<span class="n">B2</span><span class="o">:</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">     </span><span class="c1">// Reaching defs of x: {d1}</span>
<span class="w">                   </span><span class="c1">// d1 assigns constant 5</span>
<span class="w">                   </span><span class="c1">// â†’ y = 5 + 1 â†’ y = 6</span>
</code></pre></div>

<h3 id="62-global-dead-code-elimination">6.2 Global Dead Code Elimination<a class="header-link" href="#62-global-dead-code-elimination" title="Permanent link">&para;</a></h3>
<p>Using <strong>live variables</strong>, we eliminate definitions of variables that are not live after the definition:</p>
<div class="highlight"><pre><span></span><code><span class="k">For</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="nv">definition</span><span class="w"> </span><span class="nv">d</span>:<span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">expr</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">point</span><span class="w"> </span><span class="nv">p</span>:
<span class="w">    </span><span class="k">If</span><span class="w"> </span><span class="nv">v</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">NOT</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">LiveOut</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">point</span><span class="w"> </span><span class="nv">p</span>:
<span class="w">        </span><span class="nv">Remove</span><span class="w"> </span><span class="nv">d</span><span class="w"> </span><span class="ss">(</span><span class="nv">it</span><span class="err">&#39;s dead code)</span>
</code></pre></div>

<h3 id="63-global-common-subexpression-elimination">6.3 Global Common Subexpression Elimination<a class="header-link" href="#63-global-common-subexpression-elimination" title="Permanent link">&para;</a></h3>
<p>Using <strong>available expressions</strong>, we eliminate redundant computations:</p>
<div class="highlight"><pre><span></span><code><span class="k">For</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="nv">computation</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">point</span><span class="w"> </span><span class="nv">p</span>:
<span class="w">    </span><span class="k">If</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">Available</span><span class="w"> </span><span class="nv">set</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">p</span>:
<span class="w">        </span><span class="nv">Replace</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">computation</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">reference</span><span class="w"> </span><span class="nv">to</span>
<span class="w">        </span><span class="nv">the</span><span class="w"> </span><span class="nv">previously</span><span class="w"> </span><span class="nv">computed</span><span class="w"> </span><span class="nv">value</span>

<span class="nv">Note</span>:<span class="w"> </span><span class="nv">We</span><span class="w"> </span><span class="nv">need</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">insert</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">temporary</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">original</span><span class="w"> </span><span class="nv">computation</span>
<span class="w">      </span><span class="nv">to</span><span class="w"> </span><span class="nv">store</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">value</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">later</span><span class="w"> </span><span class="nv">use</span>.
</code></pre></div>

<p><strong>Before</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">B1</span><span class="o">:</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">      </span><span class="c1">// computes a + b</span>
<span class="w">    </span><span class="o">...</span>

<span class="n">B2</span><span class="o">:</span><span class="w"> </span><span class="o">...</span><span class="w">              </span><span class="c1">// no redefinition of a or b</span>

<span class="n">B3</span><span class="o">:</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">      </span><span class="c1">// a + b is available here (from B1)</span>
</code></pre></div>

<p><strong>After</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">B1</span><span class="o">:</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">      </span><span class="c1">// a + b stored in t1</span>
<span class="w">    </span><span class="o">...</span>

<span class="n">B3</span><span class="o">:</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t1</span><span class="w">         </span><span class="c1">// reuse previously computed value</span>
</code></pre></div>

<h3 id="64-code-hoisting">6.4 Code Hoisting<a class="header-link" href="#64-code-hoisting" title="Permanent link">&para;</a></h3>
<p>Using <strong>very busy expressions</strong>, we hoist computations to earlier points:</p>
<div class="highlight"><pre><span></span><code><span class="k">If</span><span class="w"> </span><span class="nv">expression</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">very</span><span class="w"> </span><span class="nv">busy</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">entry</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">block</span><span class="w"> </span><span class="nv">B</span>:
<span class="w">    </span><span class="nv">Compute</span><span class="w"> </span><span class="nv">e</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">entry</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="ss">(</span><span class="nv">or</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="k">end</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">B</span><span class="err">&#39;s predecessors)</span>
<span class="err">    Store the result in a temporary</span>
<span class="err">    Replace all subsequent computations of e with the temporary</span>
</code></pre></div>

<p><strong>Before</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">B1</span><span class="o">:</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="n">cond</span><span class="o">)</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="n">B2</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="n">B3</span>

<span class="n">B2</span><span class="o">:</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">      </span><span class="c1">// a + b computed on this path</span>
<span class="w">    </span><span class="o">...</span>

<span class="n">B3</span><span class="o">:</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">      </span><span class="c1">// a + b computed on this path too</span>
<span class="w">    </span><span class="o">...</span>
</code></pre></div>

<p>If <code>a + b</code> is very busy at the exit of B1 (evaluated on all paths), we can hoist:</p>
<p><strong>After</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">B1</span><span class="o">:</span><span class="w"> </span><span class="n">t0</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">      </span><span class="c1">// hoisted</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="n">cond</span><span class="o">)</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="n">B2</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="n">B3</span>

<span class="n">B2</span><span class="o">:</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t0</span><span class="w">         </span><span class="c1">// reuse</span>
<span class="w">    </span><span class="o">...</span>

<span class="n">B3</span><span class="o">:</span><span class="w"> </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t0</span><span class="w">         </span><span class="c1">// reuse</span>
<span class="w">    </span><span class="o">...</span>
</code></pre></div>

<hr />
<h2 id="7-advanced-topics">7. Advanced Topics<a class="header-link" href="#7-advanced-topics" title="Permanent link">&para;</a></h2>
<h3 id="71-iterative-analysis-ordering">7.1 Iterative Analysis Ordering<a class="header-link" href="#71-iterative-analysis-ordering" title="Permanent link">&para;</a></h3>
<p>The order in which blocks are processed affects the number of iterations:</p>
<table>
<thead>
<tr>
<th>Direction</th>
<th>Best ordering</th>
<th>Why</th>
</tr>
</thead>
<tbody>
<tr>
<td>Forward</td>
<td>Reverse postorder</td>
<td>Ensures predecessors are processed before successors (except back edges)</td>
</tr>
<tr>
<td>Backward</td>
<td>Postorder</td>
<td>Ensures successors are processed before predecessors (except back edges)</td>
</tr>
</tbody>
</table>
<p>Using the optimal ordering, most analyses converge in 2--3 passes (one pass handles the acyclic part, additional passes handle loops).</p>
<h3 id="72-ssa-based-analysis">7.2 SSA-Based Analysis<a class="header-link" href="#72-ssa-based-analysis" title="Permanent link">&para;</a></h3>
<p>In SSA form, many data flow analyses become simpler:</p>
<ul>
<li><strong>Reaching definitions</strong>: Trivial -- each variable has exactly one definition</li>
<li><strong>Def-use chains</strong>: Immediately available from SSA structure</li>
<li><strong>Constant propagation</strong>: Sparse conditional constant propagation (SCCP) operates directly on SSA</li>
</ul>
<h3 id="73-interprocedural-analysis">7.3 Interprocedural Analysis<a class="header-link" href="#73-interprocedural-analysis" title="Permanent link">&para;</a></h3>
<p>Extending analyses across function boundaries requires:</p>
<ol>
<li><strong>Call graph construction</strong>: Which functions call which?</li>
<li><strong>Context sensitivity</strong>: Distinguishing different calling contexts</li>
<li><strong>Summary functions</strong>: Computing the effect of a function call without analyzing its body each time</li>
</ol>
<p>Interprocedural analysis enables:
- Global constant propagation across function calls
- Alias analysis (which pointers might point to the same memory?)
- Escape analysis (does an object escape its creating function?)</p>
<h3 id="74-widening-and-narrowing">7.4 Widening and Narrowing<a class="header-link" href="#74-widening-and-narrowing" title="Permanent link">&para;</a></h3>
<p>For analyses over infinite lattices (e.g., numerical ranges), iteration may not converge. <strong>Widening</strong> accelerates convergence by jumping to higher lattice elements:</p>
<p>$$X_{n+1} = X_n \nabla f(X_n)$$</p>
<p>where $\nabla$ is the widening operator. After convergence, <strong>narrowing</strong> refines the result:</p>
<p>$$X_{n+1} = X_n \Delta f(X_n)$$</p>
<p>This is used in abstract interpretation frameworks like those behind the AstrÃ©e static analyzer.</p>
<hr />
<h2 id="8-combining-optimizations-a-complete-pass">8. Combining Optimizations: A Complete Pass<a class="header-link" href="#8-combining-optimizations-a-complete-pass" title="Permanent link">&para;</a></h2>
<p>Here is how a compiler might chain local and global optimizations:</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Example optimization pipeline combining local and global passes.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">optimization_pipeline</span><span class="p">(</span><span class="n">cfg</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Run a sequence of optimization passes on a CFG.</span>

<span class="sd">    Pipeline:</span>
<span class="sd">    1. Global constant propagation (using reaching definitions)</span>
<span class="sd">    2. Local constant folding (within each block)</span>
<span class="sd">    3. Global CSE (using available expressions)</span>
<span class="sd">    4. Local copy propagation (within each block)</span>
<span class="sd">    5. Global DCE (using live variables)</span>
<span class="sd">    6. Local algebraic simplification</span>
<span class="sd">    7. Repeat if anything changed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">iteration</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">iteration</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Optimization Pass </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>

        <span class="c1"># 1. Global: Reaching definitions â†’ constant propagation</span>
        <span class="n">rd</span> <span class="o">=</span> <span class="n">ReachingDefinitions</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
        <span class="n">rd</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">apply_global_constant_propagation</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">rd</span><span class="p">):</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Applied global constant propagation&quot;</span><span class="p">)</span>

        <span class="c1"># 2. Local: Constant folding in each block</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">apply_local_constant_folding</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Applied constant folding in B</span><span class="si">{</span><span class="n">block</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># 3. Global: Available expressions â†’ CSE</span>
        <span class="n">ae</span> <span class="o">=</span> <span class="n">AvailableExpressions</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
        <span class="n">ae</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">apply_global_cse</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">ae</span><span class="p">):</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Applied global CSE&quot;</span><span class="p">)</span>

        <span class="c1"># 4. Local: Copy propagation in each block</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">apply_local_copy_propagation</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Applied copy propagation in B</span><span class="si">{</span><span class="n">block</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># 5. Global: Live variables â†’ DCE</span>
        <span class="n">lv</span> <span class="o">=</span> <span class="n">LiveVariables</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
        <span class="n">lv</span><span class="o">.</span><span class="n">solve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">apply_global_dce</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">lv</span><span class="p">):</span>
            <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Applied global DCE&quot;</span><span class="p">)</span>

        <span class="c1"># 6. Local: Algebraic simplification</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">cfg</span><span class="o">.</span><span class="n">blocks</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">apply_local_algebraic_simplification</span><span class="p">(</span><span class="n">block</span><span class="p">):</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Applied algebraic simplification in B</span><span class="si">{</span><span class="n">block</span><span class="o">.</span><span class="n">id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Optimization converged after </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2"> iterations&quot;</span><span class="p">)</span>
</code></pre></div>

<p>Note: The functions <code>apply_global_constant_propagation</code>, etc., would implement the transformations described in Section 6, using the analysis results to determine where to apply changes. The above code shows the overall structure of an optimization pipeline.</p>
<hr />
<h2 id="9-summary">9. Summary<a class="header-link" href="#9-summary" title="Permanent link">&para;</a></h2>
<p>In this lesson, we covered the theory and practice of compiler optimization:</p>
<ol>
<li>
<p><strong>Optimization principles</strong>: Every optimization must be safe (preserves semantics), profitable (improves the code), and must detect opportunities to apply.</p>
</li>
<li>
<p><strong>Local optimizations</strong> operate within a single basic block and include:</p>
</li>
<li><strong>Constant folding</strong>: Evaluate constant expressions at compile time</li>
<li><strong>Constant propagation</strong>: Replace variables with their constant values</li>
<li><strong>Algebraic simplification</strong>: Apply mathematical identities</li>
<li><strong>Strength reduction</strong>: Replace expensive operations with cheaper ones</li>
<li><strong>CSE</strong>: Eliminate redundant computations</li>
<li><strong>Copy propagation</strong>: Replace copies with original values</li>
<li>
<p><strong>Dead code elimination</strong>: Remove unused computations</p>
</li>
<li>
<p><strong>Global data flow analysis</strong> reasons about information flow across the entire CFG:</p>
</li>
<li><strong>Reaching definitions</strong> (forward, union): Which definitions reach a point?</li>
<li><strong>Available expressions</strong> (forward, intersection): Which expressions are computed on all paths?</li>
<li><strong>Live variables</strong> (backward, union): Which variables are needed later?</li>
<li>
<p><strong>Very busy expressions</strong> (backward, intersection): Which expressions are evaluated on all paths?</p>
</li>
<li>
<p><strong>The data flow framework</strong> unifies all analyses using lattice theory, monotone transfer functions, and fixed-point iteration. The <strong>worklist algorithm</strong> provides an efficient implementation.</p>
</li>
<li>
<p>Analysis results enable global optimizations: global constant propagation, global CSE, global DCE, and code hoisting.</p>
</li>
</ol>
<p>These techniques form the core of the "middle end" of a compiler, transforming the IR to produce faster, smaller code before the back end generates machine instructions.</p>
<hr />
<h2 id="exercises">Exercises<a class="header-link" href="#exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-local-optimization">Exercise 1: Local Optimization<a class="header-link" href="#exercise-1-local-optimization" title="Permanent link">&para;</a></h3>
<p>Apply all local optimizations (in the order: constant propagation, constant folding, algebraic simplification, copy propagation, dead code elimination) to the following basic block. Show the result after each pass.</p>
<div class="highlight"><pre><span></span><code>t1 = 4
t2 = 8
t3 = t1 <span class="gs">* t2</span>
<span class="gs">t4 = t3 + 0</span>
<span class="gs">t5 = t4</span>
<span class="gs">t6 = t5 *</span> 1
t7 = t6 / 2
t8 = t7 + t7
unused = t1 + t2
result = t8
</code></pre></div>

<p>Assume <code>result</code> is live out.</p>
<h3 id="exercise-2-reaching-definitions">Exercise 2: Reaching Definitions<a class="header-link" href="#exercise-2-reaching-definitions" title="Permanent link">&para;</a></h3>
<p>Compute the reaching definitions for each block in the following CFG. Show the Gen, Kill, In, and Out sets.</p>
<div class="highlight"><pre><span></span><code><span class="n">B0</span><span class="o">:</span><span class="w"> </span><span class="n">d0</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">d1</span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>

<span class="n">B1</span><span class="o">:</span><span class="w"> </span><span class="n">d2</span><span class="o">:</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="n">B3</span>

<span class="n">B2</span><span class="o">:</span><span class="w"> </span><span class="n">d3</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">d4</span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">goto</span><span class="w"> </span><span class="n">B1</span>

<span class="n">B3</span><span class="o">:</span><span class="w"> </span><span class="n">d5</span><span class="o">:</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">d</span>
</code></pre></div>

<h3 id="exercise-3-live-variables">Exercise 3: Live Variables<a class="header-link" href="#exercise-3-live-variables" title="Permanent link">&para;</a></h3>
<p>Compute the live variables at the entry and exit of each block for the CFG in Exercise 2. Assume <code>d</code> is live at the exit of B3.</p>
<h3 id="exercise-4-available-expressions">Exercise 4: Available Expressions<a class="header-link" href="#exercise-4-available-expressions" title="Permanent link">&para;</a></h3>
<p>For the following CFG, compute the available expressions at each block entry:</p>
<div class="highlight"><pre><span></span><code><span class="n">B0</span><span class="o">:</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="w">    </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span>

<span class="n">B1</span><span class="o">:</span><span class="w"> </span><span class="n">t3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">      </span><span class="o">(</span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="w"> </span><span class="n">available</span><span class="w"> </span><span class="n">here</span><span class="o">?)</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="n">t3</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="n">B2</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="n">B3</span>

<span class="n">B2</span><span class="o">:</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="w">        </span><span class="o">(</span><span class="n">kills</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="o">)</span>
<span class="w">    </span><span class="n">t4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span>
<span class="w">    </span><span class="n">goto</span><span class="w"> </span><span class="n">B4</span>

<span class="n">B3</span><span class="o">:</span><span class="w"> </span><span class="n">t5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="w">    </span><span class="n">t6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span>
<span class="w">    </span><span class="n">goto</span><span class="w"> </span><span class="n">B4</span>

<span class="n">B4</span><span class="o">:</span><span class="w"> </span><span class="n">t7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">       </span><span class="o">(</span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="o">+</span><span class="n">b</span><span class="w"> </span><span class="n">available</span><span class="w"> </span><span class="n">here</span><span class="o">?)</span>
<span class="w">    </span><span class="n">t8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">d</span><span class="w">       </span><span class="o">(</span><span class="k">is</span><span class="w"> </span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="w"> </span><span class="n">available</span><span class="w"> </span><span class="n">here</span><span class="o">?)</span>
</code></pre></div>

<h3 id="exercise-5-worklist-algorithm-trace">Exercise 5: Worklist Algorithm Trace<a class="header-link" href="#exercise-5-worklist-algorithm-trace" title="Permanent link">&para;</a></h3>
<p>Trace the execution of the worklist algorithm for the live variables analysis on the following CFG. Show the worklist contents, and the In/Out sets at each step.</p>
<div class="highlight"><pre><span></span><code><span class="n">B0</span><span class="o">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read</span><span class="o">()</span>
<span class="w">    </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">read</span><span class="o">()</span>

<span class="n">B1</span><span class="o">:</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="o">(</span><span class="n">x</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="o">)</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="n">B2</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="n">B3</span>

<span class="n">B2</span><span class="o">:</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">y</span>
<span class="w">    </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="n">goto</span><span class="w"> </span><span class="n">B1</span>

<span class="n">B3</span><span class="o">:</span><span class="w"> </span><span class="n">print</span><span class="w"> </span><span class="n">z</span>
</code></pre></div>

<h3 id="exercise-6-implementation-challenge">Exercise 6: Implementation Challenge<a class="header-link" href="#exercise-6-implementation-challenge" title="Permanent link">&para;</a></h3>
<p>Extend the data flow analysis framework to implement:</p>
<ol>
<li>
<p><strong>Constant propagation analysis</strong>: A forward analysis where the lattice element for each variable is one of {$\top$, constant $c$, $\bot$}. The meet of two different constants is $\bot$.</p>
</li>
<li>
<p><strong>Copy propagation analysis</strong>: Determine which copies <code>x = y</code> are still valid (not killed) at each program point.</p>
</li>
</ol>
<p>Test both analyses on the CFG from Exercise 2 and show how they enable further optimization.</p>
<hr />
<p><a href="./11_Code_Generation.md">Previous: 11_Code_Generation.md</a> | <a href="./13_Loop_Optimization.md">Next: 13_Loop_Optimization.md</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/11_Code_Generation.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 11: Code Generation</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/13_Loop_Optimization.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Loop Optimization</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">â†‘</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}