{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Loop Optimization - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">ğŸ </span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">ğŸ’»</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        í•œêµ­ì–´
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">â˜€ï¸</span>
                    <span class="theme-icon dark">ğŸŒ™</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Loop Optimization</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Loop Optimization</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/12_Optimization_Local_and_Global.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 12: Optimization -- Local and Global</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/14_Garbage_Collection.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Garbage Collection</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#1-why-loop-optimization-matters">1. Why Loop Optimization Matters</a><ul>
<li><a href="#the-optimization-landscape">The Optimization Landscape</a></li>
</ul>
</li>
<li><a href="#2-dominators-and-dominator-trees">2. Dominators and Dominator Trees</a><ul>
<li><a href="#21-dominance">2.1 Dominance</a></li>
<li><a href="#22-computing-dominators">2.2 Computing Dominators</a></li>
<li><a href="#23-the-dominator-tree">2.3 The Dominator Tree</a></li>
<li><a href="#24-the-cooper-harvey-kennedy-algorithm">2.4 The Cooper-Harvey-Kennedy Algorithm</a></li>
<li><a href="#25-dominance-frontiers">2.5 Dominance Frontiers</a></li>
</ul>
</li>
<li><a href="#3-detecting-natural-loops">3. Detecting Natural Loops</a><ul>
<li><a href="#31-back-edges">3.1 Back Edges</a></li>
<li><a href="#32-natural-loops">3.2 Natural Loops</a></li>
<li><a href="#33-loop-nesting-and-the-loop-tree">3.3 Loop Nesting and the Loop Tree</a></li>
<li><a href="#34-preheader-insertion">3.4 Preheader Insertion</a></li>
</ul>
</li>
<li><a href="#4-loop-invariant-code-motion-licm">4. Loop-Invariant Code Motion (LICM)</a><ul>
<li><a href="#41-identifying-loop-invariant-computations">4.1 Identifying Loop-Invariant Computations</a></li>
<li><a href="#42-conditions-for-safe-code-motion">4.2 Conditions for Safe Code Motion</a></li>
<li><a href="#43-licm-in-practice">4.3 LICM in Practice</a></li>
</ul>
</li>
<li><a href="#5-induction-variable-analysis">5. Induction Variable Analysis</a><ul>
<li><a href="#51-basic-induction-variables">5.1 Basic Induction Variables</a></li>
<li><a href="#52-derived-induction-variables">5.2 Derived Induction Variables</a></li>
</ul>
</li>
<li><a href="#6-strength-reduction">6. Strength Reduction</a><ul>
<li><a href="#61-the-idea">6.1 The Idea</a></li>
<li><a href="#62-the-allen-cocke-kennedy-algorithm">6.2 The Allen-Cocke-Kennedy Algorithm</a></li>
<li><a href="#63-linear-test-replacement">6.3 Linear Test Replacement</a></li>
</ul>
</li>
<li><a href="#7-loop-unrolling">7. Loop Unrolling</a><ul>
<li><a href="#71-full-unrolling">7.1 Full Unrolling</a></li>
<li><a href="#72-partial-unrolling">7.2 Partial Unrolling</a></li>
<li><a href="#73-unrolling-and-software-pipelining">7.3 Unrolling and Software Pipelining</a></li>
<li><a href="#74-implementation-considerations">7.4 Implementation Considerations</a></li>
</ul>
</li>
<li><a href="#8-loop-fusion-and-fission">8. Loop Fusion and Fission</a><ul>
<li><a href="#81-loop-fusion-jamming">8.1 Loop Fusion (Jamming)</a></li>
<li><a href="#82-loop-fission-distribution">8.2 Loop Fission (Distribution)</a></li>
</ul>
</li>
<li><a href="#9-loop-tiling-blocking">9. Loop Tiling (Blocking)</a><ul>
<li><a href="#91-the-cache-problem">9.1 The Cache Problem</a></li>
<li><a href="#92-tiling-transformation">9.2 Tiling Transformation</a></li>
<li><a href="#93-choosing-the-tile-size">9.3 Choosing the Tile Size</a></li>
<li><a href="#94-multi-level-tiling">9.4 Multi-Level Tiling</a></li>
</ul>
</li>
<li><a href="#10-loop-interchange">10. Loop Interchange</a><ul>
<li><a href="#101-motivation">10.1 Motivation</a></li>
<li><a href="#102-legality-of-loop-interchange">10.2 Legality of Loop Interchange</a></li>
</ul>
</li>
<li><a href="#11-vectorization">11. Vectorization</a><ul>
<li><a href="#111-simd-overview">11.1 SIMD Overview</a></li>
<li><a href="#112-auto-vectorization">11.2 Auto-Vectorization</a></li>
<li><a href="#113-vectorization-with-numpy">11.3 Vectorization with NumPy</a></li>
<li><a href="#114-strip-mining">11.4 Strip Mining</a></li>
<li><a href="#115-alignment-and-peeling">11.5 Alignment and Peeling</a></li>
</ul>
</li>
<li><a href="#12-the-polyhedral-model">12. The Polyhedral Model</a><ul>
<li><a href="#121-overview">12.1 Overview</a></li>
<li><a href="#122-iteration-domains">12.2 Iteration Domains</a></li>
<li><a href="#123-access-functions">12.3 Access Functions</a></li>
<li><a href="#124-dependence-polyhedra">12.4 Dependence Polyhedra</a></li>
<li><a href="#125-schedule-and-transformation">12.5 Schedule and Transformation</a></li>
<li><a href="#126-tools">12.6 Tools</a></li>
</ul>
</li>
<li><a href="#13-loop-parallelization">13. Loop Parallelization</a><ul>
<li><a href="#131-dependence-free-loops">13.1 Dependence-Free Loops</a></li>
<li><a href="#132-types-of-dependencies">13.2 Types of Dependencies</a></li>
<li><a href="#133-reduction-parallelization">13.3 Reduction Parallelization</a></li>
<li><a href="#134-doall-doacross-and-dopipe">13.4 DOALL, DOACROSS, and DOPIPE</a></li>
<li><a href="#135-openmp-style-parallelization">13.5 OpenMP-Style Parallelization</a></li>
<li><a href="#136-compiler-analysis-for-parallelization">13.6 Compiler Analysis for Parallelization</a></li>
</ul>
</li>
<li><a href="#14-summary">14. Summary</a></li>
<li><a href="#15-exercises">15. Exercises</a><ul>
<li><a href="#exercise-1-dominator-computation">Exercise 1: Dominator Computation</a></li>
<li><a href="#exercise-2-loop-invariant-code-motion">Exercise 2: Loop-Invariant Code Motion</a></li>
<li><a href="#exercise-3-strength-reduction">Exercise 3: Strength Reduction</a></li>
<li><a href="#exercise-4-loop-tiling">Exercise 4: Loop Tiling</a></li>
<li><a href="#exercise-5-vectorization-analysis">Exercise 5: Vectorization Analysis</a></li>
<li><a href="#exercise-6-polyhedral-transformation">Exercise 6: Polyhedral Transformation</a></li>
</ul>
</li>
<li><a href="#16-references">16. References</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="loop-optimization">Loop Optimization<a class="header-link" href="#loop-optimization" title="Permanent link">&para;</a></h1>
<p><strong>Previous</strong>: <a href="./12_Optimization_Local_and_Global.md">12. Optimization -- Local and Global</a> | <strong>Next</strong>: <a href="./14_Garbage_Collection.md">14. Garbage Collection</a></p>
<hr />
<p>Programs spend the vast majority of their execution time inside loops. A rule of thumb (sometimes called the 90/10 rule) states that 90% of execution time is spent in 10% of the code -- and that 10% is almost always inside loops. Because of this, loop optimization is the single most impactful category of compiler optimization. A loop that executes a million times amplifies any improvement by a factor of a million.</p>
<p>This lesson covers the full spectrum of loop optimizations: from detecting loops in the control flow graph, to classical transformations like loop-invariant code motion and strength reduction, all the way to modern techniques like vectorization and the polyhedral model.</p>
<p><strong>Difficulty</strong>: â­â­â­â­</p>
<p><strong>Prerequisites</strong>: <a href="./09_Intermediate_Representations.md">09. Intermediate Representations</a>, <a href="./12_Optimization_Local_and_Global.md">12. Optimization -- Local and Global</a></p>
<p><strong>Learning Objectives</strong>:
- Identify natural loops using dominance analysis and back edges
- Construct dominator trees and compute dominance frontiers
- Apply loop-invariant code motion (LICM) to hoist computations out of loops
- Recognize and optimize induction variables through strength reduction
- Understand loop unrolling and its trade-offs
- Apply loop transformations: fusion, fission, interchange, tiling
- Explain the basics of vectorization and the polyhedral model
- Reason about loop parallelization opportunities</p>
<hr />
<h2 id="table-of-contents">Table of Contents<a class="header-link" href="#table-of-contents" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#1-why-loop-optimization-matters">Why Loop Optimization Matters</a></li>
<li><a href="#2-dominators-and-dominator-trees">Dominators and Dominator Trees</a></li>
<li><a href="#3-detecting-natural-loops">Detecting Natural Loops</a></li>
<li><a href="#4-loop-invariant-code-motion-licm">Loop-Invariant Code Motion (LICM)</a></li>
<li><a href="#5-induction-variable-analysis">Induction Variable Analysis</a></li>
<li><a href="#6-strength-reduction">Strength Reduction</a></li>
<li><a href="#7-loop-unrolling">Loop Unrolling</a></li>
<li><a href="#8-loop-fusion-and-fission">Loop Fusion and Fission</a></li>
<li><a href="#9-loop-tiling-blocking">Loop Tiling (Blocking)</a></li>
<li><a href="#10-loop-interchange">Loop Interchange</a></li>
<li><a href="#11-vectorization">Vectorization</a></li>
<li><a href="#12-the-polyhedral-model">The Polyhedral Model</a></li>
<li><a href="#13-loop-parallelization">Loop Parallelization</a></li>
<li><a href="#14-summary">Summary</a></li>
<li><a href="#15-exercises">Exercises</a></li>
<li><a href="#16-references">References</a></li>
</ol>
<hr />
<h2 id="1-why-loop-optimization-matters">1. Why Loop Optimization Matters<a class="header-link" href="#1-why-loop-optimization-matters" title="Permanent link">&para;</a></h2>
<p>Consider a simple loop:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Before optimization</span>
<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1_000_000</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>        <span class="c1"># Invariant: same result every iteration</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span>
</code></pre></div>

<p>The expression <code>a * b + c</code> is recomputed one million times, even though it never changes. Moving it out of the loop gives:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># After optimization</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span> <span class="o">+</span> <span class="n">c</span>            <span class="c1"># Computed once</span>
<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1_000_000</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span>
</code></pre></div>

<p>This eliminates 999,999 redundant multiplications and additions. Multiply such savings across nested loops, and the impact is enormous.</p>
<h3 id="the-optimization-landscape">The Optimization Landscape<a class="header-link" href="#the-optimization-landscape" title="Permanent link">&para;</a></h3>
<p>Loop optimizations fall into several categories:</p>
<div class="highlight"><pre><span></span><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚<span class="w">                    </span><span class="k">Loop</span><span class="w"> </span><span class="nv">Optimizations</span><span class="w">                            </span>â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚<span class="w">  </span><span class="nv">Reduce</span><span class="w"> </span><span class="nv">Work</span><span class="w">        </span>â”‚<span class="w">  </span><span class="nv">Improve</span><span class="w"> </span><span class="nv">Locality</span><span class="w">    </span>â”‚<span class="w">  </span><span class="nv">Exploit</span><span class="w"> </span><span class="nv">Hardware</span><span class="w">  </span>â”‚
â”‚<span class="w">                     </span>â”‚<span class="w">                      </span>â”‚<span class="w">                    </span>â”‚
â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="nv">LICM</span><span class="w">             </span>â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="k">Loop</span><span class="w"> </span><span class="nv">tiling</span><span class="w">       </span>â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="nv">Vectorization</span><span class="w">   </span>â”‚
â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="nv">Strength</span><span class="w">         </span>â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="k">Loop</span><span class="w"> </span><span class="nv">interchange</span><span class="w">  </span>â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="nv">Parallelization</span><span class="w"> </span>â”‚
â”‚<span class="w">    </span><span class="nv">reduction</span><span class="w">        </span>â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="k">Loop</span><span class="w"> </span><span class="nv">fusion</span><span class="w">       </span>â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="nv">Software</span><span class="w">        </span>â”‚
â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="nv">Dead</span><span class="w"> </span><span class="nv">code</span><span class="w"> </span><span class="nv">in</span><span class="w">     </span>â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="nv">Data</span><span class="w"> </span><span class="nv">prefetching</span><span class="w">  </span>â”‚<span class="w">    </span><span class="nv">pipelining</span><span class="w">      </span>â”‚
â”‚<span class="w">    </span><span class="nv">loops</span><span class="w">            </span>â”‚<span class="w">                      </span>â”‚<span class="w">                    </span>â”‚
â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="k">Loop</span><span class="w"> </span><span class="nv">unrolling</span><span class="w">   </span>â”‚<span class="w">                      </span>â”‚<span class="w">                    </span>â”‚
â”‚<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="k">Loop</span><span class="w"> </span><span class="nv">unswitching</span><span class="w"> </span>â”‚<span class="w">                      </span>â”‚<span class="w">                    </span>â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></div>

<p>Before we can optimize loops, we need to find them. That requires understanding dominators.</p>
<hr />
<h2 id="2-dominators-and-dominator-trees">2. Dominators and Dominator Trees<a class="header-link" href="#2-dominators-and-dominator-trees" title="Permanent link">&para;</a></h2>
<h3 id="21-dominance">2.1 Dominance<a class="header-link" href="#21-dominance" title="Permanent link">&para;</a></h3>
<p>Given a control flow graph (CFG) with entry node $\text{entry}$, we say that node $d$ <strong>dominates</strong> node $n$ (written $d \;\text{dom}\; n$) if every path from $\text{entry}$ to $n$ must pass through $d$.</p>
<p>Key properties:</p>
<ul>
<li><strong>Reflexivity</strong>: Every node dominates itself: $n \;\text{dom}\; n$.</li>
<li><strong>Transitivity</strong>: If $a \;\text{dom}\; b$ and $b \;\text{dom}\; c$, then $a \;\text{dom}\; c$.</li>
<li><strong>Antisymmetry</strong>: If $a \;\text{dom}\; b$ and $b \;\text{dom}\; a$, then $a = b$.</li>
</ul>
<p>The <strong>immediate dominator</strong> of $n$ (written $\text{idom}(n)$) is the closest strict dominator of $n$: the dominator $d \neq n$ such that every other dominator of $n$ also dominates $d$.</p>
<h3 id="22-computing-dominators">2.2 Computing Dominators<a class="header-link" href="#22-computing-dominators" title="Permanent link">&para;</a></h3>
<p>The classic iterative algorithm starts by initializing every node's dominator set to contain all nodes, then repeatedly refines by intersection:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compute_dominators</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="n">entry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute dominator sets for each node in a CFG.</span>

<span class="sd">    cfg: dict mapping node -&gt; list of predecessor nodes</span>
<span class="sd">    entry: the entry node of the CFG</span>
<span class="sd">    Returns: dict mapping node -&gt; set of dominator nodes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">all_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">cfg</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">dom</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># Initialize</span>
    <span class="n">dom</span><span class="p">[</span><span class="n">entry</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">entry</span><span class="p">}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">entry</span><span class="p">:</span>
            <span class="n">dom</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">)</span>  <span class="c1"># Start with all nodes</span>

    <span class="c1"># Iterate until fixed point</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">entry</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">predecessors</span> <span class="o">=</span> <span class="n">cfg</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">predecessors</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># New dom set = intersection of all predecessors&#39; dom sets, plus self</span>
            <span class="n">new_dom</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">dom</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">predecessors</span><span class="p">))</span>
            <span class="n">new_dom</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">new_dom</span> <span class="o">!=</span> <span class="n">dom</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">dom</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_dom</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">dom</span>
</code></pre></div>

<p><strong>Example</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="nl">CFG</span><span class="p">:</span>
<span class="w">    </span><span class="n">entry</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">D</span>
<span class="w">                  </span><span class="o">^</span><span class="w">         </span><span class="o">|</span>
<span class="w">                  </span><span class="o">|</span><span class="w">         </span><span class="o">|</span>
<span class="w">                  </span><span class="o">+</span><span class="c1">----E----+</span>

<span class="nl">Predecessors</span><span class="p">:</span>
<span class="w">  </span><span class="nl">entry</span><span class="p">:</span><span class="w"> </span><span class="err">[]</span>
<span class="w">  </span><span class="nl">A</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="n">entry</span><span class="o">]</span>
<span class="w">  </span><span class="nl">B</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="n">A, E</span><span class="o">]</span>
<span class="w">  </span><span class="nl">C</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="n">B</span><span class="o">]</span>
<span class="w">  </span><span class="nl">D</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="n">C</span><span class="o">]</span>
<span class="w">  </span><span class="nl">E</span><span class="p">:</span><span class="w"> </span><span class="o">[</span><span class="n">D</span><span class="o">]</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="n">cfg</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;entry&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;entry&#39;</span><span class="p">],</span>
    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span>
    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">],</span>
    <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">],</span>
    <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">],</span>
<span class="p">}</span>

<span class="n">dom</span> <span class="o">=</span> <span class="n">compute_dominators</span><span class="p">(</span><span class="n">cfg</span><span class="p">,</span> <span class="s1">&#39;entry&#39;</span><span class="p">)</span>

<span class="c1"># Result:</span>
<span class="c1"># dom[&#39;entry&#39;] = {&#39;entry&#39;}</span>
<span class="c1"># dom[&#39;A&#39;]     = {&#39;entry&#39;, &#39;A&#39;}</span>
<span class="c1"># dom[&#39;B&#39;]     = {&#39;entry&#39;, &#39;A&#39;, &#39;B&#39;}</span>
<span class="c1"># dom[&#39;C&#39;]     = {&#39;entry&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;}</span>
<span class="c1"># dom[&#39;D&#39;]     = {&#39;entry&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;}</span>
<span class="c1"># dom[&#39;E&#39;]     = {&#39;entry&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;}</span>
</code></pre></div>

<h3 id="23-the-dominator-tree">2.3 The Dominator Tree<a class="header-link" href="#23-the-dominator-tree" title="Permanent link">&para;</a></h3>
<p>The dominator tree represents the immediate dominance relation. Each node's parent in the tree is its immediate dominator.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">build_dominator_tree</span><span class="p">(</span><span class="n">dom</span><span class="p">,</span> <span class="n">entry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build the dominator tree from dominator sets.</span>

<span class="sd">    Returns: dict mapping node -&gt; immediate dominator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">idom</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">dom</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">==</span> <span class="n">entry</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="c1"># Immediate dominator is the closest strict dominator</span>
        <span class="n">strict_doms</span> <span class="o">=</span> <span class="n">dom</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">-</span> <span class="p">{</span><span class="n">node</span><span class="p">}</span>
        <span class="c1"># idom is the one that is dominated by all others</span>
        <span class="c1"># (i.e., has the largest dominator set among strict dominators)</span>
        <span class="n">idom_node</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">strict_doms</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">d</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">dom</span><span class="p">[</span><span class="n">d</span><span class="p">]))</span>
        <span class="n">idom</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">idom_node</span>
    <span class="k">return</span> <span class="n">idom</span>


<span class="k">def</span><span class="w"> </span><span class="nf">print_dominator_tree</span><span class="p">(</span><span class="n">idom</span><span class="p">,</span> <span class="n">entry</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Print the dominator tree.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">*</span> <span class="n">indent</span> <span class="o">+</span> <span class="n">entry</span><span class="p">)</span>
    <span class="n">children</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">idom</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">d</span> <span class="o">==</span> <span class="n">entry</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">children</span><span class="p">):</span>
        <span class="n">print_dominator_tree</span><span class="p">(</span><span class="n">idom</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">indent</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p>For the example above:</p>
<div class="highlight"><pre><span></span><code>Dominator Tree:
entry
  A
    B
      C
        D
          E
</code></pre></div>

<h3 id="24-the-cooper-harvey-kennedy-algorithm">2.4 The Cooper-Harvey-Kennedy Algorithm<a class="header-link" href="#24-the-cooper-harvey-kennedy-algorithm" title="Permanent link">&para;</a></h3>
<p>The most widely used algorithm in practice is the Cooper-Harvey-Kennedy (CHK) algorithm, which computes dominators in near-linear time using a reverse postorder traversal:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compute_rpo</span><span class="p">(</span><span class="n">cfg_successors</span><span class="p">,</span> <span class="n">entry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compute reverse postorder of CFG nodes.&quot;&quot;&quot;</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">postorder</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">succ</span> <span class="ow">in</span> <span class="n">cfg_successors</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="n">succ</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">dfs</span><span class="p">(</span><span class="n">succ</span><span class="p">)</span>
        <span class="n">postorder</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="n">dfs</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span>
    <span class="n">postorder</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">postorder</span>


<span class="k">def</span><span class="w"> </span><span class="nf">intersect</span><span class="p">(</span><span class="n">idom</span><span class="p">,</span> <span class="n">rpo_number</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find common dominator using the finger-moving technique.&quot;&quot;&quot;</span>
    <span class="n">finger1</span> <span class="o">=</span> <span class="n">b1</span>
    <span class="n">finger2</span> <span class="o">=</span> <span class="n">b2</span>
    <span class="k">while</span> <span class="n">finger1</span> <span class="o">!=</span> <span class="n">finger2</span><span class="p">:</span>
        <span class="k">while</span> <span class="n">rpo_number</span><span class="p">[</span><span class="n">finger1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rpo_number</span><span class="p">[</span><span class="n">finger2</span><span class="p">]:</span>
            <span class="n">finger1</span> <span class="o">=</span> <span class="n">idom</span><span class="p">[</span><span class="n">finger1</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">rpo_number</span><span class="p">[</span><span class="n">finger2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">rpo_number</span><span class="p">[</span><span class="n">finger1</span><span class="p">]:</span>
            <span class="n">finger2</span> <span class="o">=</span> <span class="n">idom</span><span class="p">[</span><span class="n">finger2</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">finger1</span>


<span class="k">def</span><span class="w"> </span><span class="nf">compute_idom_chk</span><span class="p">(</span><span class="n">cfg_preds</span><span class="p">,</span> <span class="n">cfg_succs</span><span class="p">,</span> <span class="n">entry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cooper-Harvey-Kennedy dominator algorithm.</span>

<span class="sd">    cfg_preds: dict node -&gt; list of predecessors</span>
<span class="sd">    cfg_succs: dict node -&gt; list of successors</span>
<span class="sd">    entry: entry node</span>
<span class="sd">    Returns: dict node -&gt; immediate dominator</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rpo</span> <span class="o">=</span> <span class="n">compute_rpo</span><span class="p">(</span><span class="n">cfg_succs</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span>
    <span class="n">rpo_number</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rpo</span><span class="p">)}</span>

    <span class="n">idom</span> <span class="o">=</span> <span class="p">{</span><span class="n">entry</span><span class="p">:</span> <span class="n">entry</span><span class="p">}</span>

    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">rpo</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">entry</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">preds</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">cfg_preds</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">idom</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">preds</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">new_idom</span> <span class="o">=</span> <span class="n">preds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">preds</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">new_idom</span> <span class="o">=</span> <span class="n">intersect</span><span class="p">(</span><span class="n">idom</span><span class="p">,</span> <span class="n">rpo_number</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">new_idom</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">idom</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">!=</span> <span class="n">new_idom</span><span class="p">:</span>
                <span class="n">idom</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_idom</span>
                <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">idom</span>
</code></pre></div>

<h3 id="25-dominance-frontiers">2.5 Dominance Frontiers<a class="header-link" href="#25-dominance-frontiers" title="Permanent link">&para;</a></h3>
<p>The <strong>dominance frontier</strong> of a node $n$ is the set of nodes where $n$'s dominance just "stops" -- the first nodes that $n$ does not strictly dominate but that have a predecessor dominated by $n$.</p>
<p>$$DF(n) = \{ y \mid \exists\, x \in \text{pred}(y) : n \;\text{dom}\; x \land n \not\text{sdom}\; y \}$$</p>
<p>where $\text{sdom}$ means "strictly dominates" (dominates and is not equal to).</p>
<p>Dominance frontiers are crucial for placing $\phi$-functions when constructing SSA form (covered in Lesson 9).</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">compute_dominance_frontiers</span><span class="p">(</span><span class="n">cfg_preds</span><span class="p">,</span> <span class="n">idom</span><span class="p">,</span> <span class="n">all_nodes</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute dominance frontiers for all nodes.</span>

<span class="sd">    Returns: dict mapping node -&gt; set of nodes in its dominance frontier</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">df</span> <span class="o">=</span> <span class="p">{</span><span class="n">n</span><span class="p">:</span> <span class="nb">set</span><span class="p">()</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">:</span>
        <span class="n">preds</span> <span class="o">=</span> <span class="n">cfg_preds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># Join point</span>
            <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">preds</span><span class="p">:</span>
                <span class="n">runner</span> <span class="o">=</span> <span class="n">pred</span>
                <span class="k">while</span> <span class="n">runner</span> <span class="o">!=</span> <span class="n">idom</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="n">df</span><span class="p">[</span><span class="n">runner</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="n">runner</span> <span class="o">=</span> <span class="n">idom</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">runner</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">df</span>
</code></pre></div>

<hr />
<h2 id="3-detecting-natural-loops">3. Detecting Natural Loops<a class="header-link" href="#3-detecting-natural-loops" title="Permanent link">&para;</a></h2>
<h3 id="31-back-edges">3.1 Back Edges<a class="header-link" href="#31-back-edges" title="Permanent link">&para;</a></h3>
<p>A <strong>back edge</strong> in a CFG is an edge $n \to h$ where $h$ dominates $n$. Back edges indicate the presence of loops.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_back_edges</span><span class="p">(</span><span class="n">cfg_succs</span><span class="p">,</span> <span class="n">idom_sets</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find all back edges in the CFG.</span>

<span class="sd">    cfg_succs: dict node -&gt; list of successors</span>
<span class="sd">    idom_sets: dict node -&gt; set of all dominators of that node</span>
<span class="sd">    Returns: list of (tail, head) tuples</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">back_edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">cfg_succs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">succ</span> <span class="ow">in</span> <span class="n">cfg_succs</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">succ</span> <span class="ow">in</span> <span class="n">idom_sets</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">set</span><span class="p">()):</span>
                <span class="c1"># succ dominates node, so node -&gt; succ is a back edge</span>
                <span class="n">back_edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">succ</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">back_edges</span>
</code></pre></div>

<h3 id="32-natural-loops">3.2 Natural Loops<a class="header-link" href="#32-natural-loops" title="Permanent link">&para;</a></h3>
<p>Given a back edge $n \to h$, the <strong>natural loop</strong> consists of the <strong>header</strong> $h$ and all nodes that can reach $n$ without going through $h$.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_natural_loop</span><span class="p">(</span><span class="n">back_edge_tail</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">cfg_preds</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find the natural loop for a back edge tail -&gt; header.</span>

<span class="sd">    Returns: set of nodes in the loop (including header)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">loop</span> <span class="o">=</span> <span class="p">{</span><span class="n">header</span><span class="p">}</span>
    <span class="n">worklist</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">back_edge_tail</span> <span class="o">!=</span> <span class="n">header</span><span class="p">:</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">back_edge_tail</span><span class="p">)</span>
        <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">back_edge_tail</span><span class="p">)</span>

    <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">cfg_preds</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="n">pred</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">:</span>
                <span class="n">loop</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>
                <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pred</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">loop</span>
</code></pre></div>

<p><strong>Example -- Detecting loops in a CFG</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Example CFG with two loops</span>
<span class="c1">#</span>
<span class="c1">#  entry -&gt; A -&gt; B -&gt; C -&gt; D -&gt; exit</span>
<span class="c1">#                ^    |</span>
<span class="c1">#                |    v</span>
<span class="c1">#                +--- E</span>
<span class="c1">#           and D -&gt; B (outer loop)</span>

<span class="n">cfg_succs</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;entry&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">],</span>
    <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">],</span>
    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">],</span>
    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span>
    <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;exit&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span>  <span class="c1"># D-&gt;B is a back edge (B dom D)</span>
    <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">],</span>           <span class="c1"># E-&gt;B is a back edge (B dom E)</span>
    <span class="s1">&#39;exit&#39;</span><span class="p">:</span> <span class="p">[],</span>
<span class="p">}</span>

<span class="n">cfg_preds</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;entry&#39;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;entry&#39;</span><span class="p">],</span>
    <span class="s1">&#39;B&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">],</span>
    <span class="s1">&#39;C&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">],</span>
    <span class="s1">&#39;D&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">],</span>
    <span class="s1">&#39;E&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">],</span>
    <span class="s1">&#39;exit&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">],</span>
<span class="p">}</span>

<span class="c1"># After computing dominators, we find:</span>
<span class="c1"># Back edges: (D, B) and (E, B)</span>
<span class="c1"># Natural loop for D-&gt;B: {B, C, D, E}</span>
<span class="c1"># Natural loop for E-&gt;B: {B, C, E}</span>
</code></pre></div>

<h3 id="33-loop-nesting-and-the-loop-tree">3.3 Loop Nesting and the Loop Tree<a class="header-link" href="#33-loop-nesting-and-the-loop-tree" title="Permanent link">&para;</a></h3>
<p>Loops can be nested. The <strong>loop tree</strong> (or <strong>loop forest</strong>) organizes loops by nesting:</p>
<div class="highlight"><pre><span></span><code><span class="n">Loop</span><span class="w"> </span><span class="n">Tree</span><span class="o">:</span>
<span class="w">  </span><span class="n">Function</span>
<span class="w">  </span><span class="err">â”œâ”€â”€</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="n">L1</span><span class="w"> </span><span class="p">(</span><span class="n">header</span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="p">})</span>
<span class="w">  </span><span class="err">â”‚</span><span class="w">   </span><span class="err">â””â”€â”€</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="n">L2</span><span class="w"> </span><span class="p">(</span><span class="n">header</span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="o">:</span><span class="w"> </span><span class="p">{</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="p">})</span><span class="w">  </span><span class="p">[</span><span class="n">inner</span><span class="w"> </span><span class="n">loop</span><span class="p">]</span>
<span class="w">  </span><span class="err">â””â”€â”€</span><span class="w"> </span><span class="p">(</span><span class="n">no</span><span class="w"> </span><span class="n">more</span><span class="w"> </span><span class="n">top</span><span class="o">-</span><span class="n">level</span><span class="w"> </span><span class="n">loops</span><span class="p">)</span>
</code></pre></div>

<p>When two loops share a header, they may be merged into one loop if their bodies overlap.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Loop</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a natural loop in the CFG.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">back_edges</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">header</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>           <span class="c1"># Set of nodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">back_edges</span> <span class="o">=</span> <span class="n">back_edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="kc">None</span>         <span class="c1"># Enclosing loop</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>         <span class="c1"># Nested loops</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>             <span class="c1"># Nesting depth (0 = outermost)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Loop(header=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">header</span><span class="si">}</span><span class="s2">, body=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">body</span><span class="si">}</span><span class="s2">, depth=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">depth</span><span class="si">}</span><span class="s2">)&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">build_loop_tree</span><span class="p">(</span><span class="n">loops</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a loop nesting tree from a list of loops.</span>

<span class="sd">    Loops are sorted by body size; smaller loops are children of larger ones.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">sorted_loops</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">loops</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="o">.</span><span class="n">body</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">inner</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sorted_loops</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">outer</span> <span class="ow">in</span> <span class="n">sorted_loops</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="k">if</span> <span class="n">inner</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">outer</span><span class="o">.</span><span class="n">body</span><span class="p">):</span>
                <span class="n">inner</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">outer</span>
                <span class="n">outer</span><span class="o">.</span><span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>
                <span class="k">break</span>

    <span class="c1"># Compute depths</span>
    <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">sorted_loops</span><span class="p">:</span>
        <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">loop</span>
        <span class="k">while</span> <span class="n">current</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">current</span> <span class="o">=</span> <span class="n">current</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">loop</span><span class="o">.</span><span class="n">depth</span> <span class="o">=</span> <span class="n">depth</span>

    <span class="c1"># Return top-level loops (those with no parent)</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">l</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">sorted_loops</span> <span class="k">if</span> <span class="n">l</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">]</span>
</code></pre></div>

<h3 id="34-preheader-insertion">3.4 Preheader Insertion<a class="header-link" href="#34-preheader-insertion" title="Permanent link">&para;</a></h3>
<p>Many loop optimizations need a place to put code that should execute exactly once before the loop. The <strong>preheader</strong> is a dedicated block inserted between the loop's non-back-edge predecessors and the header:</p>
<div class="highlight"><pre><span></span><code><span class="n">Before</span><span class="o">:</span><span class="w">                       </span><span class="n">After</span><span class="o">:</span>

<span class="w">  </span><span class="n">A</span><span class="w"> </span><span class="err">â”€â”€â”</span><span class="w">                        </span><span class="n">A</span><span class="w"> </span><span class="err">â”€â”€â”</span>
<span class="w">       </span><span class="err">â”œâ”€â”€â–¶</span><span class="w"> </span><span class="n">Header</span><span class="w">                  </span><span class="err">â”œâ”€â”€â–¶</span><span class="w"> </span><span class="n">Preheader</span><span class="w"> </span><span class="err">â”€â”€â–¶</span><span class="w"> </span><span class="n">Header</span>
<span class="w">  </span><span class="n">B</span><span class="w"> </span><span class="err">â”€â”€â”˜</span><span class="w">     </span><span class="err">â–²</span><span class="w">                  </span><span class="n">B</span><span class="w"> </span><span class="err">â”€â”€â”˜</span><span class="w">                   </span><span class="err">â–²</span>
<span class="w">             </span><span class="err">â”‚</span><span class="w">                                          </span><span class="err">â”‚</span>
<span class="w">         </span><span class="n">back</span><span class="w"> </span><span class="n">edge</span><span class="w">                                  </span><span class="n">back</span><span class="w"> </span><span class="n">edge</span>
<span class="w">             </span><span class="err">â”‚</span><span class="w">                                          </span><span class="err">â”‚</span>
<span class="w">           </span><span class="n">Latch</span><span class="w">                                      </span><span class="n">Latch</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">insert_preheader</span><span class="p">(</span><span class="n">cfg_preds</span><span class="p">,</span> <span class="n">cfg_succs</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">loop_body</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Insert a preheader block for a loop.</span>

<span class="sd">    Modifies cfg_preds and cfg_succs in place.</span>
<span class="sd">    Returns the name of the new preheader node.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">preheader</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;pre_</span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># Find non-back-edge predecessors of header</span>
    <span class="n">external_preds</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">cfg_preds</span><span class="p">[</span><span class="n">header</span><span class="p">]</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loop_body</span><span class="p">]</span>

    <span class="c1"># Redirect external predecessors to preheader</span>
    <span class="n">cfg_preds</span><span class="p">[</span><span class="n">preheader</span><span class="p">]</span> <span class="o">=</span> <span class="n">external_preds</span>
    <span class="n">cfg_succs</span><span class="p">[</span><span class="n">preheader</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">header</span><span class="p">]</span>

    <span class="c1"># Update header&#39;s predecessors</span>
    <span class="n">cfg_preds</span><span class="p">[</span><span class="n">header</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">cfg_preds</span><span class="p">[</span><span class="n">header</span><span class="p">]</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">loop_body</span><span class="p">]</span>
    <span class="n">cfg_preds</span><span class="p">[</span><span class="n">header</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">preheader</span><span class="p">)</span>

    <span class="c1"># Update external predecessors&#39; successors</span>
    <span class="k">for</span> <span class="n">pred</span> <span class="ow">in</span> <span class="n">external_preds</span><span class="p">:</span>
        <span class="n">cfg_succs</span><span class="p">[</span><span class="n">pred</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">preheader</span> <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">header</span> <span class="k">else</span> <span class="n">s</span>
                           <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">cfg_succs</span><span class="p">[</span><span class="n">pred</span><span class="p">]]</span>

    <span class="k">return</span> <span class="n">preheader</span>
</code></pre></div>

<hr />
<h2 id="4-loop-invariant-code-motion-licm">4. Loop-Invariant Code Motion (LICM)<a class="header-link" href="#4-loop-invariant-code-motion-licm" title="Permanent link">&para;</a></h2>
<h3 id="41-identifying-loop-invariant-computations">4.1 Identifying Loop-Invariant Computations<a class="header-link" href="#41-identifying-loop-invariant-computations" title="Permanent link">&para;</a></h3>
<p>A computation inside a loop is <strong>loop-invariant</strong> if its result does not change across iterations. Formally, an instruction <code>x = op(a, b)</code> is loop-invariant if:</p>
<ol>
<li>All operands are either constants, or</li>
<li>All definitions of each operand that reach this instruction are outside the loop, or</li>
<li>There is exactly one reaching definition for each operand, and that definition is itself loop-invariant</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">find_loop_invariant_instructions</span><span class="p">(</span><span class="n">loop_body</span><span class="p">,</span> <span class="n">instructions</span><span class="p">,</span> <span class="n">reaching_defs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Find all loop-invariant instructions.</span>

<span class="sd">    loop_body: set of basic blocks in the loop</span>
<span class="sd">    instructions: dict block -&gt; list of (target, op, operands)</span>
<span class="sd">    reaching_defs: dict (block, var) -&gt; set of defining blocks</span>

<span class="sd">    Returns: set of loop-invariant instructions (block, index)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Collect all variables defined inside the loop</span>
    <span class="n">loop_defs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">loop_body</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">operands</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instructions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="p">[])):</span>
            <span class="n">loop_defs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="n">invariant</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">while</span> <span class="n">changed</span><span class="p">:</span>
        <span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">block</span> <span class="ow">in</span> <span class="n">loop_body</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">operands</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instructions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="p">[])):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span> <span class="ow">in</span> <span class="n">invariant</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Check if all operands are loop-invariant</span>
                <span class="n">all_invariant</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">operand</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">operand</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">loop_defs</span><span class="p">:</span>
                        <span class="c1"># Defined outside the loop -- invariant</span>
                        <span class="k">continue</span>

                    <span class="c1"># Check if operand has a single reaching def that is invariant</span>
                    <span class="n">defs</span> <span class="o">=</span> <span class="n">reaching_defs</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">block</span><span class="p">,</span> <span class="n">operand</span><span class="p">),</span> <span class="nb">set</span><span class="p">())</span>
                    <span class="n">loop_local_defs</span> <span class="o">=</span> <span class="n">defs</span> <span class="o">&amp;</span> <span class="n">loop_body</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">loop_local_defs</span><span class="p">:</span>
                        <span class="k">continue</span>  <span class="c1"># All defs outside loop</span>

                    <span class="c1"># Must have exactly one loop-local def, and it must be invariant</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loop_local_defs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">all_invariant</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>

                    <span class="n">def_block</span> <span class="o">=</span> <span class="n">loop_local_defs</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                    <span class="c1"># Find the instruction index in def_block</span>
                    <span class="n">found_invariant</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">for</span> <span class="n">di</span><span class="p">,</span> <span class="p">(</span><span class="n">dt</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">instructions</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">def_block</span><span class="p">,</span> <span class="p">[])):</span>
                        <span class="k">if</span> <span class="n">dt</span> <span class="o">==</span> <span class="n">operand</span> <span class="ow">and</span> <span class="p">(</span><span class="n">def_block</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="ow">in</span> <span class="n">invariant</span><span class="p">:</span>
                            <span class="n">found_invariant</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="k">break</span>

                    <span class="k">if</span> <span class="ow">not</span> <span class="n">found_invariant</span><span class="p">:</span>
                        <span class="n">all_invariant</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">break</span>

                <span class="k">if</span> <span class="n">all_invariant</span><span class="p">:</span>
                    <span class="n">invariant</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">block</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span>
                    <span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">invariant</span>
</code></pre></div>

<h3 id="42-conditions-for-safe-code-motion">4.2 Conditions for Safe Code Motion<a class="header-link" href="#42-conditions-for-safe-code-motion" title="Permanent link">&para;</a></h3>
<p>Not every loop-invariant instruction can be safely moved to the preheader. The instruction <code>s: x = op(a, b)</code> can be hoisted if:</p>
<ol>
<li><strong>Dominance condition</strong>: The block containing $s$ dominates all exits of the loop (the instruction would have executed anyway on every iteration that reaches an exit).</li>
<li><strong>Uniqueness condition</strong>: No other definition of $x$ exists in the loop.</li>
<li><strong>Liveness condition</strong>: The variable $x$ is not live at any definition of $x$ in the loop (no other use of a different definition of $x$).</li>
</ol>
<p>Alternatively, if the instruction has no side effects and its result is only used inside the loop, we can always speculatively hoist it (at worst we compute something unused).</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">can_hoist</span><span class="p">(</span><span class="n">instr_block</span><span class="p">,</span> <span class="n">instr_target</span><span class="p">,</span> <span class="n">loop_body</span><span class="p">,</span> <span class="n">loop_exits</span><span class="p">,</span> <span class="n">dom_sets</span><span class="p">,</span>
              <span class="n">all_defs_in_loop</span><span class="p">,</span> <span class="n">live_at_defs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if a loop-invariant instruction can be safely hoisted.</span>

<span class="sd">    instr_block: the block containing the instruction</span>
<span class="sd">    instr_target: the variable being defined</span>
<span class="sd">    loop_body: set of blocks in the loop</span>
<span class="sd">    loop_exits: set of blocks that are loop exits</span>
<span class="sd">    dom_sets: dict block -&gt; set of blocks it dominates</span>
<span class="sd">    all_defs_in_loop: dict variable -&gt; set of defining blocks in loop</span>
<span class="sd">    live_at_defs: dict (block, variable) -&gt; bool</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Condition 1: Block dominates all loop exits</span>
    <span class="k">for</span> <span class="n">exit_block</span> <span class="ow">in</span> <span class="n">loop_exits</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exit_block</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dom_sets</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">instr_block</span><span class="p">,</span> <span class="nb">set</span><span class="p">()):</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Condition 2: Unique definition in loop</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_defs_in_loop</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">instr_target</span><span class="p">,</span> <span class="nb">set</span><span class="p">()))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Condition 3: No interference with other defs</span>
    <span class="k">for</span> <span class="n">def_block</span> <span class="ow">in</span> <span class="n">all_defs_in_loop</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">instr_target</span><span class="p">,</span> <span class="nb">set</span><span class="p">()):</span>
        <span class="k">if</span> <span class="n">def_block</span> <span class="o">!=</span> <span class="n">instr_block</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">live_at_defs</span><span class="o">.</span><span class="n">get</span><span class="p">((</span><span class="n">def_block</span><span class="p">,</span> <span class="n">instr_target</span><span class="p">),</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>
</code></pre></div>

<h3 id="43-licm-in-practice">4.3 LICM in Practice<a class="header-link" href="#43-licm-in-practice" title="Permanent link">&para;</a></h3>
<p>Here is a complete example demonstrating LICM on a simple loop:</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SimpleInstruction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a three-address instruction.&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">operands</span><span class="p">,</span> <span class="n">is_side_effect</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">target</span> <span class="o">=</span> <span class="n">target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operands</span> <span class="o">=</span> <span class="n">operands</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_side_effect</span> <span class="o">=</span> <span class="n">is_side_effect</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;copy&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">target</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">operands</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_licm</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Demonstrate LICM on a simple loop.</span>

<span class="sd">    Original code:</span>
<span class="sd">        i = 0</span>
<span class="sd">        while i &lt; n:</span>
<span class="sd">            x = a * b        # invariant</span>
<span class="sd">            y = x + c        # invariant (depends on x which is invariant)</span>
<span class="sd">            arr[i] = y + i</span>
<span class="sd">            i = i + 1</span>

<span class="sd">    After LICM:</span>
<span class="sd">        x = a * b            # hoisted</span>
<span class="sd">        y = x + c            # hoisted</span>
<span class="sd">        i = 0</span>
<span class="sd">        while i &lt; n:</span>
<span class="sd">            arr[i] = y + i</span>
<span class="sd">            i = i + 1</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Before LICM ===&quot;</span><span class="p">)</span>
    <span class="n">preheader</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">SimpleInstruction</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;copy&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;0&#39;</span><span class="p">]),</span>
    <span class="p">]</span>
    <span class="n">loop_body</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">SimpleInstruction</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">]),</span>
        <span class="n">SimpleInstruction</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;c&#39;</span><span class="p">]),</span>
        <span class="n">SimpleInstruction</span><span class="p">(</span><span class="s1">&#39;t1&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">]),</span>
        <span class="n">SimpleInstruction</span><span class="p">(</span><span class="s1">&#39;arr[i]&#39;</span><span class="p">,</span> <span class="s1">&#39;store&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;t1&#39;</span><span class="p">]),</span>
        <span class="n">SimpleInstruction</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]),</span>
    <span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Preheader:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">preheader</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">instr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loop body:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">loop_body</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">instr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Identify invariant instructions</span>
    <span class="c1"># x = a * b  -- a, b not defined in loop -&gt; invariant</span>
    <span class="c1"># y = x + c  -- x is invariant, c not defined in loop -&gt; invariant</span>
    <span class="c1"># t1, arr[i], i are NOT invariant (depend on i which changes)</span>

    <span class="n">hoisted</span> <span class="o">=</span> <span class="p">[</span><span class="n">loop_body</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loop_body</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="n">remaining</span> <span class="o">=</span> <span class="n">loop_body</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== After LICM ===&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Preheader:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">preheader</span> <span class="o">+</span> <span class="n">hoisted</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">instr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loop body:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">instr</span> <span class="ow">in</span> <span class="n">remaining</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">instr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">demonstrate_licm</span><span class="p">()</span>
</code></pre></div>

<p>Output:</p>
<div class="highlight"><pre><span></span><code><span class="o">===</span><span class="w"> </span><span class="k">Before</span><span class="w"> </span><span class="n">LICM</span><span class="w"> </span><span class="o">===</span>
<span class="nl">Preheader</span><span class="p">:</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">Loop</span><span class="w"> </span><span class="nl">body</span><span class="p">:</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span>
<span class="w">  </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>

<span class="o">===</span><span class="w"> </span><span class="k">After</span><span class="w"> </span><span class="n">LICM</span><span class="w"> </span><span class="o">===</span>
<span class="nl">Preheader</span><span class="p">:</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">b</span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">c</span>
<span class="n">Loop</span><span class="w"> </span><span class="nl">body</span><span class="p">:</span>
<span class="w">  </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">i</span>
<span class="w">  </span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">store</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>

<hr />
<h2 id="5-induction-variable-analysis">5. Induction Variable Analysis<a class="header-link" href="#5-induction-variable-analysis" title="Permanent link">&para;</a></h2>
<h3 id="51-basic-induction-variables">5.1 Basic Induction Variables<a class="header-link" href="#51-basic-induction-variables" title="Permanent link">&para;</a></h3>
<p>A <strong>basic induction variable</strong> (BIV) is a variable $i$ whose only definitions inside the loop have the form:</p>
<p>$$i = i + c \quad \text{or} \quad i = i - c$$</p>
<p>where $c$ is a loop-invariant quantity. The canonical example is a loop counter.</p>
<h3 id="52-derived-induction-variables">5.2 Derived Induction Variables<a class="header-link" href="#52-derived-induction-variables" title="Permanent link">&para;</a></h3>
<p>A <strong>derived induction variable</strong> (DIV) $j$ is a variable defined as a linear function of a basic induction variable:</p>
<p>$$j = a \cdot i + b$$</p>
<p>where $a$ and $b$ are loop-invariant. We write the <strong>induction triple</strong> as $(i, a, b)$, meaning $j = a \cdot i + b$.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">InductionVariable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents an induction variable as a triple (base_iv, multiplier, offset).&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">base_iv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">multiplier</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_iv</span> <span class="o">=</span> <span class="n">base_iv</span> <span class="ow">or</span> <span class="n">name</span>  <span class="c1"># Basic IV it derives from</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">multiplier</span> <span class="o">=</span> <span class="n">multiplier</span>     <span class="c1"># a in j = a*i + b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span>             <span class="c1"># b in j = a*i + b</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_basic</span> <span class="o">=</span> <span class="p">(</span><span class="n">base_iv</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">base_iv</span> <span class="o">==</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">value_at</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i_value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the value of this IV when the base IV has value i_value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">multiplier</span> <span class="o">*</span> <span class="n">i_value</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_basic</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;BIV(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;DIV(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">multiplier</span><span class="si">}</span><span class="s2">*</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_iv</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">offset</span><span class="si">}</span><span class="s2">)&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">detect_induction_variables</span><span class="p">(</span><span class="n">loop_instructions</span><span class="p">,</span> <span class="n">loop_invariants</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detect basic and derived induction variables in a loop.</span>

<span class="sd">    loop_instructions: list of (target, op, operands)</span>
<span class="sd">    loop_invariants: set of variable names that are loop-invariant</span>

<span class="sd">    Returns: dict name -&gt; InductionVariable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Phase 1: Find basic induction variables</span>
    <span class="c1"># A variable i is a BIV if its only definition is i = i +/- c (c invariant)</span>
    <span class="n">definitions</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># var -&gt; list of (op, operands)</span>
    <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">operands</span> <span class="ow">in</span> <span class="n">loop_instructions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">definitions</span><span class="p">:</span>
            <span class="n">definitions</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">definitions</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">op</span><span class="p">,</span> <span class="n">operands</span><span class="p">))</span>

    <span class="n">bivs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">defs</span> <span class="ow">in</span> <span class="n">definitions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">defs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">op</span><span class="p">,</span> <span class="n">operands</span> <span class="o">=</span> <span class="n">defs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">operands</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">operands</span> <span class="k">if</span> <span class="n">o</span> <span class="o">!=</span> <span class="n">var</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">loop_invariants</span> <span class="ow">or</span>
                                         <span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()):</span>
                    <span class="n">step</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="k">else</span> <span class="o">-</span><span class="nb">int</span><span class="p">(</span><span class="n">other</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="n">bivs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">InductionVariable</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">multiplier</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">bivs</span><span class="p">[</span><span class="n">var</span><span class="p">]</span><span class="o">.</span><span class="n">step</span> <span class="o">=</span> <span class="n">step</span>

    <span class="c1"># Phase 2: Find derived induction variables</span>
    <span class="c1"># j = a * i + b where i is BIV and a, b are loop-invariant</span>
    <span class="n">divs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">target</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">operands</span> <span class="ow">in</span> <span class="n">loop_instructions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">bivs</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;*&#39;</span><span class="p">:</span>
            <span class="c1"># Check if one operand is a BIV and the other is invariant</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">operands</span><span class="p">):</span>
                <span class="n">other_idx</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">bivs</span> <span class="ow">and</span> <span class="p">(</span><span class="n">operands</span><span class="p">[</span><span class="n">other_idx</span><span class="p">]</span> <span class="ow">in</span> <span class="n">loop_invariants</span> <span class="ow">or</span>
                                   <span class="n">operands</span><span class="p">[</span><span class="n">other_idx</span><span class="p">]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()):</span>
                    <span class="n">mult</span> <span class="o">=</span> <span class="n">operands</span><span class="p">[</span><span class="n">other_idx</span><span class="p">]</span>
                    <span class="n">divs</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">InductionVariable</span><span class="p">(</span>
                        <span class="n">target</span><span class="p">,</span> <span class="n">base_iv</span><span class="o">=</span><span class="n">o</span><span class="p">,</span>
                        <span class="n">multiplier</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">mult</span><span class="p">),</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span>
                    <span class="p">)</span>

        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
            <span class="c1"># Check if one operand is a DIV/BIV and the other is invariant</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">operands</span><span class="p">):</span>
                <span class="n">other_idx</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span>
                <span class="k">if</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">bivs</span> <span class="ow">and</span> <span class="p">(</span><span class="n">operands</span><span class="p">[</span><span class="n">other_idx</span><span class="p">]</span> <span class="ow">in</span> <span class="n">loop_invariants</span> <span class="ow">or</span>
                                   <span class="n">operands</span><span class="p">[</span><span class="n">other_idx</span><span class="p">]</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">isdigit</span><span class="p">()):</span>
                    <span class="n">off</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">operands</span><span class="p">[</span><span class="n">other_idx</span><span class="p">])</span>
                    <span class="n">divs</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span> <span class="n">InductionVariable</span><span class="p">(</span>
                        <span class="n">target</span><span class="p">,</span> <span class="n">base_iv</span><span class="o">=</span><span class="n">o</span><span class="p">,</span>
                        <span class="n">multiplier</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">off</span>
                    <span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">bivs</span><span class="p">)</span>
    <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">divs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="c1"># Example</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Induction Variable Detection ===&quot;</span><span class="p">)</span>
<span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">]),</span>        <span class="c1"># i = i + 1  (BIV)</span>
    <span class="p">(</span><span class="s1">&#39;t1&#39;</span><span class="p">,</span> <span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">]),</span>       <span class="c1"># t1 = 4*i   (DIV: base=i, mult=4, off=0)</span>
    <span class="p">(</span><span class="s1">&#39;t2&#39;</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;t1&#39;</span><span class="p">,</span> <span class="s1">&#39;base&#39;</span><span class="p">]),</span>   <span class="c1"># t2 = t1 + base (not simple IV -- base is invariant</span>
                                   <span class="c1">#   but t1 is a DIV, so t2 = 4*i + base)</span>
    <span class="p">(</span><span class="s1">&#39;arr_t2&#39;</span><span class="p">,</span> <span class="s1">&#39;load&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;t2&#39;</span><span class="p">]),</span>    <span class="c1"># memory load</span>
<span class="p">]</span>

<span class="n">invariants</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;base&#39;</span><span class="p">,</span> <span class="s1">&#39;4&#39;</span><span class="p">,</span> <span class="s1">&#39;1&#39;</span><span class="p">}</span>

<span class="n">ivs</span> <span class="o">=</span> <span class="n">detect_induction_variables</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">invariants</span><span class="p">)</span>
<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">iv</span> <span class="ow">in</span> <span class="n">ivs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">iv</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="6-strength-reduction">6. Strength Reduction<a class="header-link" href="#6-strength-reduction" title="Permanent link">&para;</a></h2>
<h3 id="61-the-idea">6.1 The Idea<a class="header-link" href="#61-the-idea" title="Permanent link">&para;</a></h3>
<p>Strength reduction replaces expensive operations (like multiplication) with cheaper ones (like addition) by exploiting the regular progression of induction variables.</p>
<p>If $j = a \cdot i + b$ and $i$ increments by $s$ each iteration, then:</p>
<p>$$j_{\text{new}} = j_{\text{old}} + a \cdot s$$</p>
<p>Instead of computing $a \cdot i$ every iteration, we compute $j = j + a \cdot s$ -- replacing a multiplication with an addition.</p>
<h3 id="62-the-allen-cocke-kennedy-algorithm">6.2 The Allen-Cocke-Kennedy Algorithm<a class="header-link" href="#62-the-allen-cocke-kennedy-algorithm" title="Permanent link">&para;</a></h3>
<p>The classic strength reduction algorithm works as follows:</p>
<ol>
<li>Find all basic induction variables and their steps</li>
<li>Find all derived induction variables</li>
<li>For each DIV $j = a \cdot i + b$:</li>
<li>Create a new variable $j'$</li>
<li>Initialize $j' = a \cdot i_0 + b$ in the preheader</li>
<li>At each increment of $i$ by $s$, add $j' = j' + a \cdot s$</li>
<li>Replace uses of $j$ with $j'$</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">strength_reduce</span><span class="p">(</span><span class="n">loop_code</span><span class="p">,</span> <span class="n">preheader_code</span><span class="p">,</span> <span class="n">bivs</span><span class="p">,</span> <span class="n">divs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply strength reduction to derived induction variables.</span>

<span class="sd">    Demonstrates the transformation on a simple example.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Before Strength Reduction ===&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Preheader:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">preheader_code</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loop body:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">loop_code</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">new_preheader</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">preheader_code</span><span class="p">)</span>
    <span class="n">new_loop</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># For each derived IV, create strength-reduced version</span>
    <span class="n">reduced</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># original var -&gt; new var</span>

    <span class="k">for</span> <span class="n">div_name</span><span class="p">,</span> <span class="n">div_info</span> <span class="ow">in</span> <span class="n">divs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">div_info</span><span class="p">[</span><span class="s1">&#39;base_iv&#39;</span><span class="p">]</span>
        <span class="n">mult</span> <span class="o">=</span> <span class="n">div_info</span><span class="p">[</span><span class="s1">&#39;multiplier&#39;</span><span class="p">]</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">div_info</span><span class="p">[</span><span class="s1">&#39;offset&#39;</span><span class="p">]</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">bivs</span><span class="p">[</span><span class="n">base</span><span class="p">][</span><span class="s1">&#39;step&#39;</span><span class="p">]</span>

        <span class="n">new_var</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">div_name</span><span class="si">}</span><span class="s2">_sr&quot;</span>
        <span class="n">reduced</span><span class="p">[</span><span class="n">div_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_var</span>

        <span class="c1"># Initialize in preheader: new_var = mult * base_init + offset</span>
        <span class="n">init_val</span> <span class="o">=</span> <span class="n">mult</span> <span class="o">*</span> <span class="n">bivs</span><span class="p">[</span><span class="n">base</span><span class="p">][</span><span class="s1">&#39;init&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">offset</span>
        <span class="n">new_preheader</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_var</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">init_val</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Increment in loop: new_var = new_var + mult * step</span>
        <span class="n">increment</span> <span class="o">=</span> <span class="n">mult</span> <span class="o">*</span> <span class="n">step</span>
        <span class="n">new_loop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_var</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">new_var</span><span class="si">}</span><span class="s2"> + </span><span class="si">{</span><span class="n">increment</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Copy non-reduced instructions</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">loop_code</span><span class="p">:</span>
        <span class="c1"># Replace references to reduced variables</span>
        <span class="n">replaced</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">orig</span><span class="p">,</span> <span class="n">new</span> <span class="ow">in</span> <span class="n">reduced</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">orig</span><span class="si">}</span><span class="s2"> =&quot;</span><span class="p">):</span>
                <span class="n">replaced</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Skip original computation</span>
                <span class="k">break</span>
            <span class="k">if</span> <span class="n">orig</span> <span class="ow">in</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">orig</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">replaced</span><span class="p">:</span>
            <span class="n">new_loop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== After Strength Reduction ===&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Preheader:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">new_preheader</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loop body:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">new_loop</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="c1"># Example: Array indexing</span>
<span class="c1">#   for i in range(n):</span>
<span class="c1">#       addr = base + i * 4    # addr is a DIV of i</span>
<span class="c1">#       arr[addr] = 0</span>

<span class="n">strength_reduce</span><span class="p">(</span>
    <span class="n">loop_code</span><span class="o">=</span><span class="p">[</span>
        <span class="s2">&quot;t1 = i * 4&quot;</span><span class="p">,</span>          <span class="c1"># DIV: t1 = 4*i</span>
        <span class="s2">&quot;addr = t1 + base&quot;</span><span class="p">,</span>    <span class="c1"># addr = 4*i + base (also a DIV)</span>
        <span class="s2">&quot;store 0, addr&quot;</span><span class="p">,</span>
        <span class="s2">&quot;i = i + 1&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">preheader_code</span><span class="o">=</span><span class="p">[</span>
        <span class="s2">&quot;i = 0&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">bivs</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;init&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;step&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
    <span class="p">},</span>
    <span class="n">divs</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">&#39;t1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;base_iv&#39;</span><span class="p">:</span> <span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="s1">&#39;multiplier&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;offset&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span>
    <span class="p">}</span>
<span class="p">)</span>
</code></pre></div>

<p>Output:</p>
<div class="highlight"><pre><span></span><code><span class="o">==</span><span class="p">=</span><span class="w"> </span><span class="nx">Before</span><span class="w"> </span><span class="nx">Strength</span><span class="w"> </span><span class="nx">Reduction</span><span class="w"> </span><span class="o">==</span><span class="p">=</span>
<span class="nx">Preheader</span><span class="p">:</span>
<span class="w">  </span><span class="nx">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span>
<span class="nx">Loop</span><span class="w"> </span><span class="nx">body</span><span class="p">:</span>
<span class="w">  </span><span class="nx">t1</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">4</span>
<span class="w">  </span><span class="kd">addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">t1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kd">base</span>
<span class="w">  </span><span class="nx">store</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kd">addr</span>
<span class="w">  </span><span class="nx">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>

<span class="o">==</span><span class="p">=</span><span class="w"> </span><span class="nx">After</span><span class="w"> </span><span class="nx">Strength</span><span class="w"> </span><span class="nx">Reduction</span><span class="w"> </span><span class="o">==</span><span class="p">=</span>
<span class="nx">Preheader</span><span class="p">:</span>
<span class="w">  </span><span class="nx">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">  </span><span class="nx">t1_sr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span>
<span class="nx">Loop</span><span class="w"> </span><span class="nx">body</span><span class="p">:</span>
<span class="w">  </span><span class="nx">t1_sr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">t1_sr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span>
<span class="w">  </span><span class="kd">addr</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">t1_sr</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kd">base</span>
<span class="w">  </span><span class="nx">store</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="kd">addr</span>
<span class="w">  </span><span class="nx">i</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>

<p>The multiplication <code>i * 4</code> has been replaced by the addition <code>t1_sr + 4</code>.</p>
<h3 id="63-linear-test-replacement">6.3 Linear Test Replacement<a class="header-link" href="#63-linear-test-replacement" title="Permanent link">&para;</a></h3>
<p>After strength reduction, the original basic induction variable may only be used in the loop's exit test. We can replace the test with one based on the strength-reduced variable:</p>
<div class="highlight"><pre><span></span><code><span class="n">Before</span><span class="o">:</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="n">loop</span><span class="w">     </span><span class="n">After</span><span class="o">:</span><span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">t1_sr</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">4</span><span class="o">*</span><span class="n">n</span><span class="w"> </span><span class="n">goto</span><span class="w"> </span><span class="n">loop</span>
</code></pre></div>

<p>This may allow dead code elimination to remove the original BIV entirely.</p>
<hr />
<h2 id="7-loop-unrolling">7. Loop Unrolling<a class="header-link" href="#7-loop-unrolling" title="Permanent link">&para;</a></h2>
<h3 id="71-full-unrolling">7.1 Full Unrolling<a class="header-link" href="#71-full-unrolling" title="Permanent link">&para;</a></h3>
<p>When the trip count (number of iterations) is known at compile time and is small, the loop can be completely replaced by sequential code:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_full_unrolling</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Full unrolling: replace loop with sequential statements.&quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Before Full Unrolling ===&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    sum = 0</span>
<span class="s2">    for i in range(4):</span>
<span class="s2">        sum += arr[i]</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== After Full Unrolling ===&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    sum = 0</span>
<span class="s2">    sum += arr[0]</span>
<span class="s2">    sum += arr[1]</span>
<span class="s2">    sum += arr[2]</span>
<span class="s2">    sum += arr[3]</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

<span class="n">demonstrate_full_unrolling</span><span class="p">()</span>
</code></pre></div>

<p>Benefits:
- Eliminates loop overhead (branch, counter increment, comparison)
- Enables further optimizations (constant folding on indices, instruction scheduling)</p>
<p>Cost:
- Increases code size
- Only practical for small, known trip counts</p>
<h3 id="72-partial-unrolling">7.2 Partial Unrolling<a class="header-link" href="#72-partial-unrolling" title="Permanent link">&para;</a></h3>
<p>More commonly, loops are <strong>partially unrolled</strong> by a factor $k$: each iteration of the new loop does $k$ iterations' worth of work.</p>
<p>For a loop with trip count $n$ and unroll factor $k$:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_partial_unrolling</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Partial unrolling by factor k.</span>

<span class="sd">    Original: for i in range(n): body(i)</span>
<span class="sd">    Unrolled:</span>
<span class="sd">        for i in range(0, n - n%k, k):</span>
<span class="sd">            body(i)</span>
<span class="sd">            body(i+1)</span>
<span class="sd">            body(i+2)</span>
<span class="sd">            body(i+3)</span>
<span class="sd">        # Cleanup loop for remainder</span>
<span class="sd">        for i in range(n - n%k, n):</span>
<span class="sd">            body(i)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;=== Partial Unrolling (factor </span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">) ===&quot;</span><span class="p">)</span>

    <span class="c1"># Original loop</span>
    <span class="n">total_orig</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">iterations_orig</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">total_orig</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span>
        <span class="n">iterations_orig</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Unrolled loop</span>
    <span class="n">total_unrolled</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">iterations_unrolled</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">main_limit</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="n">k</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">main_limit</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="n">total_unrolled</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span>
        <span class="n">total_unrolled</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">total_unrolled</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">total_unrolled</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">iterations_unrolled</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Cleanup</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">main_limit</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
        <span class="n">total_unrolled</span> <span class="o">+=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">i</span>
        <span class="n">iterations_unrolled</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original:  </span><span class="si">{</span><span class="n">iterations_orig</span><span class="si">}</span><span class="s2"> loop iterations, sum = </span><span class="si">{</span><span class="n">total_orig</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unrolled:  </span><span class="si">{</span><span class="n">iterations_unrolled</span><span class="si">}</span><span class="s2"> loop iterations, sum = </span><span class="si">{</span><span class="n">total_unrolled</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Results match: </span><span class="si">{</span><span class="n">total_orig</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">total_unrolled</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Branch reduction: </span><span class="si">{</span><span class="n">iterations_orig</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">iterations_unrolled</span><span class="si">}</span><span class="s2"> fewer branches&quot;</span><span class="p">)</span>

<span class="n">demonstrate_partial_unrolling</span><span class="p">()</span>
</code></pre></div>

<h3 id="73-unrolling-and-software-pipelining">7.3 Unrolling and Software Pipelining<a class="header-link" href="#73-unrolling-and-software-pipelining" title="Permanent link">&para;</a></h3>
<p>Unrolling enables <strong>software pipelining</strong> -- overlapping operations from different iterations to hide latency. On a processor with a 3-cycle multiply and 1-cycle add:</p>
<div class="highlight"><pre><span></span><code><span class="n">Iteration</span><span class="o">:</span><span class="w">   </span><span class="n">Body</span><span class="w"> </span><span class="mi">1</span><span class="w">      </span><span class="n">Body</span><span class="w"> </span><span class="mi">2</span><span class="w">      </span><span class="n">Body</span><span class="w"> </span><span class="mi">3</span><span class="w">      </span><span class="n">Body</span><span class="w"> </span><span class="mi">4</span>
<span class="n">Cycle</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w">     </span><span class="n">MUL</span><span class="w"> </span><span class="n">a1</span><span class="w">      </span><span class="o">---</span><span class="w">         </span><span class="o">---</span><span class="w">         </span><span class="o">---</span>
<span class="n">Cycle</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w">     </span><span class="o">---</span><span class="w">          </span><span class="n">MUL</span><span class="w"> </span><span class="n">a2</span><span class="w">     </span><span class="o">---</span><span class="w">         </span><span class="o">---</span>
<span class="n">Cycle</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w">     </span><span class="o">---</span><span class="w">          </span><span class="o">---</span><span class="w">         </span><span class="n">MUL</span><span class="w"> </span><span class="n">a3</span><span class="w">     </span><span class="o">---</span>
<span class="n">Cycle</span><span class="w"> </span><span class="mi">4</span><span class="o">:</span><span class="w">     </span><span class="n">ADD</span><span class="w"> </span><span class="n">r1</span><span class="w">       </span><span class="o">---</span><span class="w">         </span><span class="o">---</span><span class="w">         </span><span class="n">MUL</span><span class="w"> </span><span class="n">a4</span>
<span class="n">Cycle</span><span class="w"> </span><span class="mi">5</span><span class="o">:</span><span class="w">     </span><span class="o">---</span><span class="w">          </span><span class="n">ADD</span><span class="w"> </span><span class="n">r2</span><span class="w">     </span><span class="o">---</span><span class="w">         </span><span class="o">---</span>
<span class="o">...</span>
</code></pre></div>

<p>Without unrolling, there would be bubbles (stalls) while waiting for the multiply to complete.</p>
<h3 id="74-implementation-considerations">7.4 Implementation Considerations<a class="header-link" href="#74-implementation-considerations" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">unroll_loop</span><span class="p">(</span><span class="n">original_body</span><span class="p">,</span> <span class="n">trip_count</span><span class="p">,</span> <span class="n">unroll_factor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate an unrolled loop.</span>

<span class="sd">    original_body: function(i) -&gt; list of instructions</span>
<span class="sd">    trip_count: number of iterations (may be symbolic)</span>
<span class="sd">    unroll_factor: k</span>

<span class="sd">    Returns: (main_loop, cleanup_loop)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">trip_count</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">trip_count</span> <span class="o">&lt;=</span> <span class="n">unroll_factor</span><span class="p">:</span>
        <span class="c1"># Full unroll</span>
        <span class="n">full_body</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">trip_count</span><span class="p">):</span>
            <span class="n">full_body</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">original_body</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">full_body</span><span class="p">,</span> <span class="p">[]</span>

    <span class="c1"># Partial unroll</span>
    <span class="n">main_body</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">unroll_factor</span><span class="p">):</span>
        <span class="n">main_body</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">original_body</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;i+</span><span class="si">{</span><span class="n">offset</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;i&quot;</span><span class="p">))</span>

    <span class="n">cleanup_body</span> <span class="o">=</span> <span class="n">original_body</span><span class="p">(</span><span class="s2">&quot;i&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">main_body</span><span class="p">,</span> <span class="n">cleanup_body</span>


<span class="c1"># Decision heuristics</span>
<span class="k">def</span><span class="w"> </span><span class="nf">should_unroll</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">unroll_factor</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Heuristic: decide whether to unroll a loop.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Don&#39;t unroll loops with function calls (code bloat)</span>
    <span class="k">if</span> <span class="n">loop</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;has_calls&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Don&#39;t unroll loops with many instructions (code bloat)</span>
    <span class="k">if</span> <span class="n">loop</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;body_size&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">20</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Don&#39;t unroll deeply nested inner loops (already many iterations)</span>
    <span class="k">if</span> <span class="n">loop</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;nesting_depth&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="c1"># Unroll small inner loops</span>
    <span class="k">if</span> <span class="n">loop</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;is_innermost&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="n">loop</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;body_size&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="kc">False</span>
</code></pre></div>

<hr />
<h2 id="8-loop-fusion-and-fission">8. Loop Fusion and Fission<a class="header-link" href="#8-loop-fusion-and-fission" title="Permanent link">&para;</a></h2>
<h3 id="81-loop-fusion-jamming">8.1 Loop Fusion (Jamming)<a class="header-link" href="#81-loop-fusion-jamming" title="Permanent link">&para;</a></h3>
<p>Loop fusion combines two adjacent loops with the same iteration space into one:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_loop_fusion</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Show loop fusion combining two loops into one.&quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">1_000_000</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>

    <span class="c1"># Before fusion: two separate loops</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Before Fusion (Two Loops) ===&quot;</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">time_separate</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time: </span><span class="si">{</span><span class="n">time_separate</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

    <span class="c1"># After fusion: one loop</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== After Fusion (Single Loop) ===&quot;</span><span class="p">)</span>
    <span class="n">b2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">c2</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">b2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="n">c2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="n">time_fused</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time: </span><span class="si">{</span><span class="n">time_fused</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Speedup: </span><span class="si">{</span><span class="n">time_separate</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">time_fused</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">x&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Results correct: </span><span class="si">{</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b2</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">c2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># demonstrate_loop_fusion()  # Uncomment to run</span>
</code></pre></div>

<p><strong>Benefits of fusion</strong>:
- Reduces loop overhead (one loop instead of two)
- Improves data locality (array <code>a</code> is accessed once instead of twice)
- Enables further optimizations (common subexpression elimination across merged bodies)</p>
<p><strong>Legality</strong>: Fusion is legal when there are no data dependencies between the two loops that would be violated by combining them. Specifically, there must be no <strong>fusion-preventing dependency</strong> -- a dependency where an element produced in loop 2 iteration $i$ is consumed by loop 1 iteration $j > i$.</p>
<h3 id="82-loop-fission-distribution">8.2 Loop Fission (Distribution)<a class="header-link" href="#82-loop-fission-distribution" title="Permanent link">&para;</a></h3>
<p>Loop fission is the inverse: splitting one loop into multiple loops.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_loop_fission</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Show loop fission splitting one loop into two.&quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Before Fission (Single Loop) ===&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    for i in range(n):</span>
<span class="s2">        b[i] = a[i] * 2        # Vectorizable</span>
<span class="s2">        c[i] = c[i-1] + b[i]   # Sequential dependency</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== After Fission (Two Loops) ===&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    # Loop 1: vectorizable</span>
<span class="s2">    for i in range(n):</span>
<span class="s2">        b[i] = a[i] * 2</span>

<span class="s2">    # Loop 2: sequential</span>
<span class="s2">    for i in range(n):</span>
<span class="s2">        c[i] = c[i-1] + b[i]</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loop 1 can now be vectorized independently!&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loop 2 carries a dependency that prevents vectorization.&quot;</span><span class="p">)</span>

<span class="n">demonstrate_loop_fission</span><span class="p">()</span>
</code></pre></div>

<p><strong>Benefits of fission</strong>:
- Enables vectorization of one part even if another has dependencies
- Improves cache behavior when each loop accesses different data
- Simplifies analysis for further optimization</p>
<hr />
<h2 id="9-loop-tiling-blocking">9. Loop Tiling (Blocking)<a class="header-link" href="#9-loop-tiling-blocking" title="Permanent link">&para;</a></h2>
<h3 id="91-the-cache-problem">9.1 The Cache Problem<a class="header-link" href="#91-the-cache-problem" title="Permanent link">&para;</a></h3>
<p>When processing a large 2D array column by column, adjacent accesses in memory are far apart (stride $= n$, the row size). This causes <strong>cache thrashing</strong>.</p>
<h3 id="92-tiling-transformation">9.2 Tiling Transformation<a class="header-link" href="#92-tiling-transformation" title="Permanent link">&para;</a></h3>
<p>Loop tiling breaks iterations into small blocks ("tiles") that fit in cache:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_loop_tiling</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Demonstrate the effect of loop tiling on matrix multiplication.</span>

<span class="sd">    Standard: O(n^3) with poor cache behavior</span>
<span class="sd">    Tiled: O(n^3) same work, but much better cache locality</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">random</span>
    <span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

    <span class="c1"># Create matrices</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="p">[[</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># Standard matrix multiply (ijk order)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;=== Matrix Multiply </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> ===&quot;</span><span class="p">)</span>
    <span class="n">C1</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">total</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">total</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
            <span class="n">C1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span>
    <span class="n">time_standard</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Standard (ijk): </span><span class="si">{</span><span class="n">time_standard</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

    <span class="c1"># Tiled matrix multiply</span>
    <span class="n">TILE</span> <span class="o">=</span> <span class="mi">32</span>  <span class="c1"># Tile size -- should fit in L1 cache</span>
    <span class="n">C2</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">TILE</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">jj</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">TILE</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">kk</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">TILE</span><span class="p">):</span>
                <span class="c1"># Multiply tile</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">ii</span> <span class="o">+</span> <span class="n">TILE</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">jj</span> <span class="o">+</span> <span class="n">TILE</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
                        <span class="n">total</span> <span class="o">=</span> <span class="n">C2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">kk</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">kk</span> <span class="o">+</span> <span class="n">TILE</span><span class="p">,</span> <span class="n">n</span><span class="p">)):</span>
                            <span class="n">total</span> <span class="o">+=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">*</span> <span class="n">B</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="n">C2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">total</span>
    <span class="n">time_tiled</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Tiled (tile=</span><span class="si">{</span><span class="n">TILE</span><span class="si">}</span><span class="s2">): </span><span class="si">{</span><span class="n">time_tiled</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Speedup: </span><span class="si">{</span><span class="n">time_standard</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">time_tiled</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">x&quot;</span><span class="p">)</span>

    <span class="c1"># Verify correctness</span>
    <span class="n">max_diff</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">C1</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">-</span> <span class="n">C2</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Max difference: </span><span class="si">{</span><span class="n">max_diff</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># demonstrate_loop_tiling(500)  # Uncomment to run (may take a while)</span>
</code></pre></div>

<h3 id="93-choosing-the-tile-size">9.3 Choosing the Tile Size<a class="header-link" href="#93-choosing-the-tile-size" title="Permanent link">&para;</a></h3>
<p>The tile size $T$ should be chosen so that the working set fits in cache. For matrix multiplication, the tiles of $A$, $B$, and $C$ accessed are each $T \times T$, so we need:</p>
<p>$$3 \cdot T^2 \cdot \text{sizeof(element)} \leq \text{L1 cache size}$$</p>
<p>For an L1 cache of 32 KB with 8-byte doubles:</p>
<p>$$T \leq \sqrt{\frac{32768}{3 \times 8}} = \sqrt{1365} \approx 36$$</p>
<p>A common choice is $T = 32$.</p>
<h3 id="94-multi-level-tiling">9.4 Multi-Level Tiling<a class="header-link" href="#94-multi-level-tiling" title="Permanent link">&para;</a></h3>
<p>For machines with multiple cache levels (L1, L2, L3), we can apply tiling at multiple levels:</p>
<div class="highlight"><pre><span></span><code><span class="nl">Original</span><span class="p">:</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="err">:</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="err">:</span>
<span class="w">          </span><span class="n">C</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">A</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">k</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">B</span><span class="o">[</span><span class="n">k</span><span class="o">][</span><span class="n">j</span><span class="o">]</span>

<span class="n">Two</span><span class="o">-</span><span class="k">level</span><span class="w"> </span><span class="nl">tiled</span><span class="p">:</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="n">ii</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="p">)</span><span class="err">:</span><span class="w">          </span><span class="err">#</span><span class="w"> </span><span class="n">L2</span><span class="w"> </span><span class="n">tile</span>
<span class="w">      </span><span class="k">for</span><span class="w"> </span><span class="n">jj</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="p">)</span><span class="err">:</span>
<span class="w">          </span><span class="k">for</span><span class="w"> </span><span class="n">kk</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">T2</span><span class="p">)</span><span class="err">:</span>
<span class="w">              </span><span class="k">for</span><span class="w"> </span><span class="n">iii</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span><span class="w"> </span><span class="n">ii</span><span class="o">+</span><span class="n">T2</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p">)</span><span class="err">:</span><span class="w">    </span><span class="err">#</span><span class="w"> </span><span class="n">L1</span><span class="w"> </span><span class="n">tile</span>
<span class="w">                  </span><span class="k">for</span><span class="w"> </span><span class="n">jjj</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">jj</span><span class="p">,</span><span class="w"> </span><span class="n">jj</span><span class="o">+</span><span class="n">T2</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p">)</span><span class="err">:</span>
<span class="w">                      </span><span class="k">for</span><span class="w"> </span><span class="n">kkk</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="k">range</span><span class="p">(</span><span class="n">kk</span><span class="p">,</span><span class="w"> </span><span class="n">kk</span><span class="o">+</span><span class="n">T2</span><span class="p">,</span><span class="w"> </span><span class="n">T1</span><span class="p">)</span><span class="err">:</span>
<span class="w">                          </span><span class="err">#</span><span class="w"> </span><span class="n">Micro</span><span class="o">-</span><span class="n">kernel</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">T1</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="n">T1</span><span class="w"> </span><span class="n">tile</span>
<span class="w">                          </span><span class="p">...</span>
</code></pre></div>

<hr />
<h2 id="10-loop-interchange">10. Loop Interchange<a class="header-link" href="#10-loop-interchange" title="Permanent link">&para;</a></h2>
<h3 id="101-motivation">10.1 Motivation<a class="header-link" href="#101-motivation" title="Permanent link">&para;</a></h3>
<p>Loop interchange swaps the order of two nested loops to improve memory access patterns.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_loop_interchange</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Show how loop interchange improves cache behavior.</span>

<span class="sd">    Row-major arrays: A[i][j] is stored next to A[i][j+1] in memory.</span>
<span class="sd">    Accessing A[i][j] with j as the inner loop gives stride-1 access (good).</span>
<span class="sd">    Accessing with i as the inner loop gives stride-n access (bad).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">time</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">2000</span>

    <span class="c1"># Create a 2D array (list of lists in Python, simulating row-major)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

    <span class="c1"># Bad order: column-major traversal (i inner, j outer)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;=== Loop Interchange Demo (</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">x</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">) ===&quot;</span><span class="p">)</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>          <span class="c1"># Outer</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>      <span class="c1"># Inner -- stride-n access to A[i][j]</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span>
    <span class="n">time_bad</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Column-major (j outer, i inner): </span><span class="si">{</span><span class="n">time_bad</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>

    <span class="c1"># Good order: row-major traversal (j inner, i outer)</span>
    <span class="n">A</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>          <span class="c1"># Outer</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>      <span class="c1"># Inner -- stride-1 access to A[i][j]</span>
            <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="n">j</span>
    <span class="n">time_good</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Row-major (i outer, j inner): </span><span class="si">{</span><span class="n">time_good</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Speedup: </span><span class="si">{</span><span class="n">time_bad</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">time_good</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">x&quot;</span><span class="p">)</span>

<span class="c1"># demonstrate_loop_interchange()  # Uncomment to run</span>
</code></pre></div>

<h3 id="102-legality-of-loop-interchange">10.2 Legality of Loop Interchange<a class="header-link" href="#102-legality-of-loop-interchange" title="Permanent link">&para;</a></h3>
<p>Loop interchange is legal only when it does not violate data dependencies. Given a dependency with distance vector $(d_1, d_2)$ for loops $i$ and $j$:</p>
<ul>
<li>The interchange is legal if the resulting distance vector $(d_2, d_1)$ is <strong>lexicographically positive</strong> (the leftmost non-zero component is positive).</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">can_interchange</span><span class="p">(</span><span class="n">distance_vectors</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if loop interchange is legal given dependency distance vectors.</span>

<span class="sd">    A distance vector (d1, d2) becomes (d2, d1) after interchange.</span>
<span class="sd">    All resulting vectors must be lexicographically positive.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">d1</span><span class="p">,</span> <span class="n">d2</span> <span class="ow">in</span> <span class="n">distance_vectors</span><span class="p">:</span>
        <span class="c1"># After interchange: (d2, d1)</span>
        <span class="n">new_vec</span> <span class="o">=</span> <span class="p">(</span><span class="n">d2</span><span class="p">,</span> <span class="n">d1</span><span class="p">)</span>

        <span class="c1"># Check lexicographic positivity</span>
        <span class="k">if</span> <span class="n">new_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">new_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">new_vec</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>


<span class="c1"># Examples</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dependency (1, 0):&quot;</span><span class="p">,</span> <span class="n">can_interchange</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]))</span>   <span class="c1"># True: becomes (0, 1)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dependency (0, 1):&quot;</span><span class="p">,</span> <span class="n">can_interchange</span><span class="p">([(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]))</span>   <span class="c1"># True: becomes (1, 0)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dependency (1, -1):&quot;</span><span class="p">,</span> <span class="n">can_interchange</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]))</span> <span class="c1"># False: becomes (-1, 1)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Dependency (1, 1):&quot;</span><span class="p">,</span> <span class="n">can_interchange</span><span class="p">([(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]))</span>   <span class="c1"># True: becomes (1, 1)</span>
</code></pre></div>

<hr />
<h2 id="11-vectorization">11. Vectorization<a class="header-link" href="#11-vectorization" title="Permanent link">&para;</a></h2>
<h3 id="111-simd-overview">11.1 SIMD Overview<a class="header-link" href="#111-simd-overview" title="Permanent link">&para;</a></h3>
<p><strong>SIMD</strong> (Single Instruction, Multiple Data) instructions process multiple data elements simultaneously. Modern CPUs have SIMD units (SSE, AVX, AVX-512 on x86; NEON on ARM) that can operate on 128, 256, or 512 bits at once.</p>
<div class="highlight"><pre><span></span><code><span class="n">Scalar</span><span class="o">:</span><span class="w">                    </span><span class="n">SIMD</span><span class="w"> </span><span class="o">(</span><span class="mi">4</span><span class="o">-</span><span class="n">wide</span><span class="o">):</span>
<span class="w">  </span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span><span class="w">        </span><span class="n">a</span><span class="o">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">4</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">4</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">[</span><span class="mi">0</span><span class="o">:</span><span class="mi">4</span><span class="o">]</span>
<span class="w">  </span><span class="n">a</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span><span class="w">        </span><span class="o">(</span><span class="n">single</span><span class="w"> </span><span class="n">instruction</span><span class="o">)</span>
<span class="w">  </span><span class="n">a</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">[</span><span class="mi">2</span><span class="o">]</span>
<span class="w">  </span><span class="n">a</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="o">[</span><span class="mi">3</span><span class="o">]</span>
<span class="w">  </span><span class="o">(</span><span class="mi">4</span><span class="w"> </span><span class="n">instructions</span><span class="o">)</span>
</code></pre></div>

<p>With 256-bit AVX and 32-bit floats, one instruction processes $256 / 32 = 8$ elements.</p>
<h3 id="112-auto-vectorization">11.2 Auto-Vectorization<a class="header-link" href="#112-auto-vectorization" title="Permanent link">&para;</a></h3>
<p>Compilers attempt to automatically vectorize loops. The key requirement is <strong>no loop-carried dependencies</strong> -- each iteration must be independent.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vectorization_analysis</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Analyze loops for vectorizability.&quot;&quot;&quot;</span>

    <span class="n">examples</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Simple element-wise&#39;</span><span class="p">,</span>
            <span class="s1">&#39;code&#39;</span><span class="p">:</span> <span class="s1">&#39;c[i] = a[i] + b[i]&#39;</span><span class="p">,</span>
            <span class="s1">&#39;vectorizable&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;reason&#39;</span><span class="p">:</span> <span class="s1">&#39;No loop-carried dependency&#39;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Reduction&#39;</span><span class="p">,</span>
            <span class="s1">&#39;code&#39;</span><span class="p">:</span> <span class="s1">&#39;sum += a[i]&#39;</span><span class="p">,</span>
            <span class="s1">&#39;vectorizable&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;reason&#39;</span><span class="p">:</span> <span class="s1">&#39;Reduction pattern -- compiler uses horizontal add&#39;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Prefix sum&#39;</span><span class="p">,</span>
            <span class="s1">&#39;code&#39;</span><span class="p">:</span> <span class="s1">&#39;a[i] = a[i-1] + b[i]&#39;</span><span class="p">,</span>
            <span class="s1">&#39;vectorizable&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;reason&#39;</span><span class="p">:</span> <span class="s1">&#39;Loop-carried dependency: a[i] depends on a[i-1]&#39;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Conditional&#39;</span><span class="p">,</span>
            <span class="s1">&#39;code&#39;</span><span class="p">:</span> <span class="s1">&#39;if a[i] &gt; 0: b[i] = a[i]&#39;</span><span class="p">,</span>
            <span class="s1">&#39;vectorizable&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;reason&#39;</span><span class="p">:</span> <span class="s1">&#39;Predicated execution with masking&#39;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Indirect access&#39;</span><span class="p">,</span>
            <span class="s1">&#39;code&#39;</span><span class="p">:</span> <span class="s1">&#39;b[idx[i]] = a[i]&#39;</span><span class="p">,</span>
            <span class="s1">&#39;vectorizable&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>  <span class="c1"># Usually</span>
            <span class="s1">&#39;reason&#39;</span><span class="p">:</span> <span class="s1">&#39;Scatter -- possible with AVX-512 but slow&#39;</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;Function call&#39;</span><span class="p">,</span>
            <span class="s1">&#39;code&#39;</span><span class="p">:</span> <span class="s1">&#39;b[i] = expensive_func(a[i])&#39;</span><span class="p">,</span>
            <span class="s1">&#39;vectorizable&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;reason&#39;</span><span class="p">:</span> <span class="s1">&#39;Function calls prevent vectorization (unless intrinsic)&#39;</span>
        <span class="p">},</span>
    <span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Vectorization Analysis ===&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
        <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;YES&quot;</span> <span class="k">if</span> <span class="n">ex</span><span class="p">[</span><span class="s1">&#39;vectorizable&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="s2">&quot;NO&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">ex</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">ex</span><span class="p">[</span><span class="s1">&#39;code&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Vectorizable: </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;    Reason: </span><span class="si">{</span><span class="n">ex</span><span class="p">[</span><span class="s1">&#39;reason&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">vectorization_analysis</span><span class="p">()</span>
</code></pre></div>

<h3 id="113-vectorization-with-numpy">11.3 Vectorization with NumPy<a class="header-link" href="#113-vectorization-with-numpy" title="Permanent link">&para;</a></h3>
<p>In Python, NumPy provides vectorized operations that leverage SIMD under the hood:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

<span class="k">def</span><span class="w"> </span><span class="nf">numpy_vectorization_demo</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate NumPy vectorization vs pure Python loops.&quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">10_000_000</span>

    <span class="c1"># Pure Python</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">b</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">c_python</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>
    <span class="n">time_python</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="c1"># NumPy vectorized</span>
    <span class="n">a_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
    <span class="n">b_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">c_np</span> <span class="o">=</span> <span class="n">a_np</span> <span class="o">+</span> <span class="n">b_np</span>  <span class="c1"># Single vectorized operation</span>
    <span class="n">time_numpy</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Python loop: </span><span class="si">{</span><span class="n">time_python</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;NumPy vectorized: </span><span class="si">{</span><span class="n">time_numpy</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Speedup: </span><span class="si">{</span><span class="n">time_python</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">time_numpy</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">x&quot;</span><span class="p">)</span>

<span class="c1"># numpy_vectorization_demo()  # Uncomment to run</span>
</code></pre></div>

<h3 id="114-strip-mining">11.4 Strip Mining<a class="header-link" href="#114-strip-mining" title="Permanent link">&para;</a></h3>
<p>Strip mining transforms a loop to make the vector length explicit, preparing it for SIMD:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">strip_mine</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">vector_length</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Strip mine a loop for vectorization.</span>

<span class="sd">    Before: for i in range(n): body(i)</span>
<span class="sd">    After:  for i in range(0, n, VL):</span>
<span class="sd">                for ii in range(i, min(i+VL, n)):</span>
<span class="sd">                    body(ii)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;=== Strip Mining (VL=</span><span class="si">{</span><span class="n">vector_length</span><span class="si">}</span><span class="s2">) ===&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Original: for i in range(</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">): body(i)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Strip-mined:&quot;</span><span class="p">)</span>

    <span class="n">iteration_count</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector_length</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">vector_length</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">vec_indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Vector op: body(</span><span class="si">{</span><span class="n">vec_indices</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="n">iteration_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Outer iterations: </span><span class="si">{</span><span class="n">iteration_count</span><span class="si">}</span><span class="s2"> (was </span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

<span class="n">strip_mine</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
</code></pre></div>

<p>Output:</p>
<div class="highlight"><pre><span></span><code><span class="o">===</span><span class="w"> </span><span class="nv">Strip</span><span class="w"> </span><span class="nv">Mining</span><span class="w"> </span><span class="ss">(</span><span class="nv">VL</span><span class="o">=</span><span class="mi">4</span><span class="ss">)</span><span class="w"> </span><span class="o">===</span>
<span class="nv">Original</span>:<span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">range</span><span class="ss">(</span><span class="mi">14</span><span class="ss">)</span>:<span class="w"> </span><span class="nv">body</span><span class="ss">(</span><span class="nv">i</span><span class="ss">)</span>
<span class="nv">Strip</span><span class="o">-</span><span class="nv">mined</span>:
<span class="w">  </span><span class="nv">Vector</span><span class="w"> </span><span class="nv">op</span>:<span class="w"> </span><span class="nv">body</span><span class="ss">(</span>[<span class="mi">0</span>,<span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">3</span>]<span class="ss">)</span>
<span class="w">  </span><span class="nv">Vector</span><span class="w"> </span><span class="nv">op</span>:<span class="w"> </span><span class="nv">body</span><span class="ss">(</span>[<span class="mi">4</span>,<span class="w"> </span><span class="mi">5</span>,<span class="w"> </span><span class="mi">6</span>,<span class="w"> </span><span class="mi">7</span>]<span class="ss">)</span>
<span class="w">  </span><span class="nv">Vector</span><span class="w"> </span><span class="nv">op</span>:<span class="w"> </span><span class="nv">body</span><span class="ss">(</span>[<span class="mi">8</span>,<span class="w"> </span><span class="mi">9</span>,<span class="w"> </span><span class="mi">10</span>,<span class="w"> </span><span class="mi">11</span>]<span class="ss">)</span>
<span class="w">  </span><span class="nv">Vector</span><span class="w"> </span><span class="nv">op</span>:<span class="w"> </span><span class="nv">body</span><span class="ss">(</span>[<span class="mi">12</span>,<span class="w"> </span><span class="mi">13</span>]<span class="ss">)</span>
<span class="nv">Outer</span><span class="w"> </span><span class="nv">iterations</span>:<span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="ss">(</span><span class="nv">was</span><span class="w"> </span><span class="mi">14</span><span class="ss">)</span>
</code></pre></div>

<h3 id="115-alignment-and-peeling">11.5 Alignment and Peeling<a class="header-link" href="#115-alignment-and-peeling" title="Permanent link">&para;</a></h3>
<p>SIMD instructions often require data to be aligned to specific boundaries (16-byte for SSE, 32-byte for AVX). <strong>Loop peeling</strong> handles the first few iterations (until alignment is reached) as scalar operations:</p>
<div class="highlight"><pre><span></span><code><span class="nv">Peeled</span><span class="w"> </span><span class="nv">iterations</span>:<span class="w">      </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>,<span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="ss">(</span><span class="nv">scalar</span>,<span class="w"> </span><span class="k">until</span><span class="w"> </span><span class="nv">aligned</span><span class="ss">)</span>
<span class="nv">Main</span><span class="w"> </span><span class="nv">vectorized</span><span class="w"> </span><span class="k">loop</span>:<span class="w">   </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>,<span class="w"> </span><span class="mi">3</span>,<span class="w"> </span><span class="mi">4</span>,<span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">6</span>,<span class="w"> </span><span class="mi">7</span>,<span class="w"> </span><span class="mi">8</span>,<span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="o">|</span><span class="w"> </span>...<span class="w">  </span><span class="ss">(</span><span class="nv">SIMD</span><span class="ss">)</span>
<span class="nv">Cleanup</span><span class="w"> </span><span class="nv">iterations</span>:<span class="w">     </span><span class="nv">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">n</span><span class="o">-</span><span class="mi">2</span>,<span class="w"> </span><span class="nv">n</span><span class="o">-</span><span class="mi">1</span><span class="w">  </span><span class="ss">(</span><span class="nv">scalar</span>,<span class="w"> </span><span class="nv">remainder</span><span class="ss">)</span>
</code></pre></div>

<hr />
<h2 id="12-the-polyhedral-model">12. The Polyhedral Model<a class="header-link" href="#12-the-polyhedral-model" title="Permanent link">&para;</a></h2>
<h3 id="121-overview">12.1 Overview<a class="header-link" href="#121-overview" title="Permanent link">&para;</a></h3>
<p>The <strong>polyhedral model</strong> (also called the <strong>polytope model</strong>) is a powerful mathematical framework for loop nest optimization. It represents loop iterations as integer points in a polyhedron and loop transformations as affine functions on these points.</p>
<h3 id="122-iteration-domains">12.2 Iteration Domains<a class="header-link" href="#122-iteration-domains" title="Permanent link">&para;</a></h3>
<p>Consider a doubly nested loop:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">B</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</code></pre></div>

<p>The <strong>iteration domain</strong> is the set of all $(i, j)$ pairs that execute:</p>
<p>$$\mathcal{D} = \{ (i, j) \in \mathbb{Z}^2 \mid 0 \leq i < N, \; 0 \leq j < M \}$$</p>
<p>This is a 2D rectangular polyhedron (a polytope).</p>
<h3 id="123-access-functions">12.3 Access Functions<a class="header-link" href="#123-access-functions" title="Permanent link">&para;</a></h3>
<p>Each memory access is described by an <strong>access function</strong> -- an affine mapping from iteration coordinates to array indices:</p>
<ul>
<li><code>A[i][j]</code>: access function $f_A(i, j) = (i, j)$</li>
<li><code>B[i][j-1]</code>: access function $f_{B1}(i, j) = (i, j-1)$</li>
<li><code>B[i-1][j]</code>: access function $f_{B2}(i, j) = (i-1, j)$</li>
</ul>
<h3 id="124-dependence-polyhedra">12.4 Dependence Polyhedra<a class="header-link" href="#124-dependence-polyhedra" title="Permanent link">&para;</a></h3>
<p>Dependencies between statement instances are captured by <strong>dependence polyhedra</strong>. A dependency from iteration $(i_1, j_1)$ to $(i_2, j_2)$ exists when they access the same memory location and the source executes before the sink.</p>
<p>For the read <code>B[i][j-1]</code> and the write that produced it:</p>
<p>$$i_2 = i_1, \quad j_2 - 1 = j_1 \implies j_2 = j_1 + 1$$</p>
<p>The dependency is $(i, j) \to (i, j+1)$ with distance vector $(0, 1)$.</p>
<h3 id="125-schedule-and-transformation">12.5 Schedule and Transformation<a class="header-link" href="#125-schedule-and-transformation" title="Permanent link">&para;</a></h3>
<p>A <strong>schedule</strong> maps each iteration point to a time step. A valid schedule must respect all dependencies. The schedule is often represented as an affine function:</p>
<p>$$\theta(i, j) = \alpha_1 i + \alpha_2 j + \alpha_0$$</p>
<p>The polyhedral model can find optimal schedules by solving an integer linear program (ILP).</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">polyhedral_example</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple demonstration of polyhedral iteration domain and scheduling.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Polyhedral Model Example ===&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Iteration domain: 0 &lt;= i &lt; </span><span class="si">{</span><span class="n">N</span><span class="si">}</span><span class="s2">, 0 &lt;= j &lt; </span><span class="si">{</span><span class="n">M</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Statement: A[i][j] = B[i][j-1] + B[i-1][j]&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dependencies: (0,1) and (1,0)&quot;</span><span class="p">)</span>

    <span class="c1"># Original schedule: theta(i,j) = (i, j) -- lexicographic order</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Original schedule (row by row):&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  t=</span><span class="si">{</span><span class="n">i</span><span class="o">*</span><span class="n">M</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">j</span><span class="si">}</span><span class="s2">: S(</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="c1"># Skewed schedule: theta(i,j) = (i+j, j) -- enables wavefront parallelism</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Skewed schedule (wavefront):&quot;</span><span class="p">)</span>
    <span class="n">schedule</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="n">time</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span>
            <span class="n">schedule</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">time</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span>

    <span class="n">schedule</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">schedule</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  t=</span><span class="si">{</span><span class="n">time</span><span class="si">}</span><span class="s2">: S(</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">,</span><span class="si">{</span><span class="n">j</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Wavefront parallelism:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Iterations on the same diagonal (same i+j) can execute in parallel!&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">wave</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span> <span class="o">+</span> <span class="n">M</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">parallel</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span><span class="p">,</span> <span class="n">wave</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">wave</span> <span class="o">-</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">M</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Wave </span><span class="si">{</span><span class="n">wave</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">parallel</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">polyhedral_example</span><span class="p">()</span>
</code></pre></div>

<h3 id="126-tools">12.6 Tools<a class="header-link" href="#126-tools" title="Permanent link">&para;</a></h3>
<p>Real polyhedral optimizers include:
- <strong>ISL</strong> (Integer Set Library): The mathematical foundation
- <strong>Pluto</strong>: Automatic parallelizer and locality optimizer
- <strong>Polly</strong>: LLVM's polyhedral optimizer pass
- <strong>PPCG</strong>: Polyhedral Parallel Code Generator (for GPUs)</p>
<hr />
<h2 id="13-loop-parallelization">13. Loop Parallelization<a class="header-link" href="#13-loop-parallelization" title="Permanent link">&para;</a></h2>
<h3 id="131-dependence-free-loops">13.1 Dependence-Free Loops<a class="header-link" href="#131-dependence-free-loops" title="Permanent link">&para;</a></h3>
<p>A loop is <strong>trivially parallelizable</strong> (also called "embarrassingly parallel") if there are no loop-carried dependencies:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Parallelizable: each iteration is independent</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># NOT parallelizable: iteration i depends on i-1</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
</code></pre></div>

<h3 id="132-types-of-dependencies">13.2 Types of Dependencies<a class="header-link" href="#132-types-of-dependencies" title="Permanent link">&para;</a></h3>
<p>Three types of loop-carried dependencies:</p>
<table>
<thead>
<tr>
<th>Type</th>
<th>Name</th>
<th>Example</th>
<th>Blocks Parallelization?</th>
</tr>
</thead>
<tbody>
<tr>
<td>RAW</td>
<td>True / Flow</td>
<td><code>a[i] = ...; ... = a[i-1]</code></td>
<td>Yes</td>
</tr>
<tr>
<td>WAR</td>
<td>Anti</td>
<td><code>... = a[i-1]; a[i] = ...</code></td>
<td>Renamable</td>
</tr>
<tr>
<td>WAW</td>
<td>Output</td>
<td><code>a[i] = ...; a[i] = ...</code></td>
<td>Renamable</td>
</tr>
</tbody>
</table>
<p>WAR and WAW dependencies can be eliminated by <strong>privatization</strong> (giving each thread its own copy) or renaming.</p>
<h3 id="133-reduction-parallelization">13.3 Reduction Parallelization<a class="header-link" href="#133-reduction-parallelization" title="Permanent link">&para;</a></h3>
<p>Reductions (sum, product, min, max) have a special pattern that allows parallel execution:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Sequential reduction</span>
<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">total</span> <span class="o">+=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>  <span class="c1"># RAW dependency on total</span>

<span class="c1"># Parallel reduction</span>
<span class="c1"># Each thread computes a partial sum, then combine</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">concurrent.futures</span><span class="w"> </span><span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

<span class="k">def</span><span class="w"> </span><span class="nf">parallel_sum</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parallel reduction using thread pool.&quot;&quot;&quot;</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">num_threads</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">num_threads</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">partial_sum</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>

    <span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="n">num_threads</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
        <span class="n">futures</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_threads</span><span class="p">):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">t</span> <span class="o">*</span> <span class="n">chunk_size</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
            <span class="n">futures</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">partial_sum</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>

        <span class="n">total</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">total</span>
</code></pre></div>

<h3 id="134-doall-doacross-and-dopipe">13.4 DOALL, DOACROSS, and DOPIPE<a class="header-link" href="#134-doall-doacross-and-dopipe" title="Permanent link">&para;</a></h3>
<p>Three parallelization strategies:</p>
<p><strong>DOALL</strong>: All iterations are independent -- run them all in parallel.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># DOALL parallelism</span>
<span class="c1"># for i in range(n):</span>
<span class="c1">#     c[i] = f(a[i])</span>
<span class="c1"># All iterations can execute simultaneously</span>
</code></pre></div>

<p><strong>DOACROSS</strong>: Iterations have dependencies, but can overlap execution with synchronization.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># DOACROSS parallelism</span>
<span class="c1"># for i in range(n):</span>
<span class="c1">#     a[i] = a[i-1] + b[i]    # depends on previous iteration</span>
<span class="c1">#     c[i] = expensive(a[i])   # expensive independent computation</span>
<span class="c1">#</span>
<span class="c1"># Thread 1 computes a[0], starts expensive(a[0])</span>
<span class="c1"># Thread 2 waits for a[0], then computes a[1], starts expensive(a[1])</span>
<span class="c1"># Overlap the expensive computation</span>
</code></pre></div>

<p><strong>DOPIPE</strong>: Pipeline parallelism -- each stage of computation runs on a different thread.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># DOPIPE parallelism</span>
<span class="c1"># Stage 1 (Thread 1): for i: a[i] = input[i] * 2</span>
<span class="c1"># Stage 2 (Thread 2): for i: b[i] = a[i] + offset  (wait for a[i] from Stage 1)</span>
<span class="c1"># Stage 3 (Thread 3): for i: output[i] = transform(b[i])</span>
</code></pre></div>

<h3 id="135-openmp-style-parallelization">13.5 OpenMP-Style Parallelization<a class="header-link" href="#135-openmp-style-parallelization" title="Permanent link">&para;</a></h3>
<p>Compilers that support OpenMP can parallelize loops with pragmas. The equivalent in Python:</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span>

<span class="k">def</span><span class="w"> </span><span class="nf">openmp_style_parallel</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate parallel loop execution (Python equivalent of OpenMP).&quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">os</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">1_000_000</span>
    <span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
    <span class="n">num_workers</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="ow">or</span> <span class="mi">4</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">process_chunk</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">args</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]]</span>

    <span class="n">chunk_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">num_workers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">num_workers</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="nb">min</span><span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span> <span class="n">a</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_workers</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="n">num_workers</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">process_chunk</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>

    <span class="c1"># Flatten results</span>
    <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">chunk_result</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
        <span class="n">c</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chunk_result</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processed </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="si">}</span><span class="s2"> elements using </span><span class="si">{</span><span class="n">num_workers</span><span class="si">}</span><span class="s2"> workers&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;First 5: </span><span class="si">{</span><span class="n">c</span><span class="p">[:</span><span class="mi">5</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Last 5: </span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="o">-</span><span class="mi">5</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># openmp_style_parallel()  # Uncomment to run</span>
</code></pre></div>

<h3 id="136-compiler-analysis-for-parallelization">13.6 Compiler Analysis for Parallelization<a class="header-link" href="#136-compiler-analysis-for-parallelization" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">analyze_parallelizability</span><span class="p">(</span><span class="n">loop_deps</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Analyze whether a loop can be parallelized and suggest strategy.</span>

<span class="sd">    loop_deps: list of dependency dicts with &#39;type&#39;, &#39;distance&#39;, &#39;variable&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">loop_deps</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;DOALL&quot;</span><span class="p">,</span> <span class="s2">&quot;No dependencies -- fully parallel&quot;</span>

    <span class="n">has_true_dep</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;RAW&#39;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">loop_deps</span><span class="p">)</span>
    <span class="n">has_reduction</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;is_reduction&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">loop_deps</span><span class="p">)</span>
    <span class="n">only_renamable</span> <span class="o">=</span> <span class="nb">all</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;WAR&#39;</span><span class="p">,</span> <span class="s1">&#39;WAW&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">loop_deps</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">has_reduction</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">has_true_dep</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;DOALL + Reduction&quot;</span><span class="p">,</span> <span class="s2">&quot;Reduction pattern detected -- use parallel reduction&quot;</span>

    <span class="k">if</span> <span class="n">only_renamable</span><span class="p">:</span>
        <span class="k">return</span> <span class="s2">&quot;DOALL (after privatization)&quot;</span><span class="p">,</span> <span class="s2">&quot;Only anti/output deps -- privatize variables&quot;</span>

    <span class="k">if</span> <span class="n">has_true_dep</span><span class="p">:</span>
        <span class="n">min_distance</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;distance&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">loop_deps</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;RAW&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_distance</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;DOACROSS&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;True dep with distance </span><span class="si">{</span><span class="n">min_distance</span><span class="si">}</span><span class="s2"> -- overlap possible&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;Sequential&quot;</span><span class="p">,</span> <span class="s2">&quot;True dependency with distance 1 -- cannot parallelize&quot;</span>

    <span class="k">return</span> <span class="s2">&quot;DOALL&quot;</span><span class="p">,</span> <span class="s2">&quot;Safe to parallelize&quot;</span>


<span class="c1"># Examples</span>
<span class="n">examples</span> <span class="o">=</span> <span class="p">[</span>
    <span class="p">(</span><span class="s2">&quot;c[i] = a[i] + b[i]&quot;</span><span class="p">,</span> <span class="p">[]),</span>
    <span class="p">(</span><span class="s2">&quot;sum += a[i]&quot;</span><span class="p">,</span> <span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;RAW&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="s1">&#39;sum&#39;</span><span class="p">,</span> <span class="s1">&#39;is_reduction&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}]),</span>
    <span class="p">(</span><span class="s2">&quot;a[i] = a[i-1] + 1&quot;</span><span class="p">,</span> <span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;RAW&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">}]),</span>
    <span class="p">(</span><span class="s2">&quot;a[i] = a[i-4] + 1&quot;</span><span class="p">,</span> <span class="p">[{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;RAW&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;variable&#39;</span><span class="p">:</span> <span class="s1">&#39;a&#39;</span><span class="p">}]),</span>
<span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Parallelizability Analysis ===&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">code</span><span class="p">,</span> <span class="n">deps</span> <span class="ow">in</span> <span class="n">examples</span><span class="p">:</span>
    <span class="n">strategy</span><span class="p">,</span> <span class="n">reason</span> <span class="o">=</span> <span class="n">analyze_parallelizability</span><span class="p">(</span><span class="n">deps</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  Code: </span><span class="si">{</span><span class="n">code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Strategy: </span><span class="si">{</span><span class="n">strategy</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Reason: </span><span class="si">{</span><span class="n">reason</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="14-summary">14. Summary<a class="header-link" href="#14-summary" title="Permanent link">&para;</a></h2>
<p>Loop optimization is the most impactful category of compiler optimization because programs spend the overwhelming majority of their time in loops. We covered:</p>
<table>
<thead>
<tr>
<th>Optimization</th>
<th>Effect</th>
<th>Key Requirement</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Dominator analysis</strong></td>
<td>Foundation for loop detection</td>
<td>CFG available</td>
</tr>
<tr>
<td><strong>Loop detection</strong></td>
<td>Identifies natural loops via back edges</td>
<td>Dominators computed</td>
</tr>
<tr>
<td><strong>LICM</strong></td>
<td>Hoists invariant code out of loops</td>
<td>Dominance + liveness</td>
</tr>
<tr>
<td><strong>Strength reduction</strong></td>
<td>Replaces multiply with add in IVs</td>
<td>Induction variable analysis</td>
</tr>
<tr>
<td><strong>Loop unrolling</strong></td>
<td>Reduces branch overhead, enables ILP</td>
<td>Trip count knowledge</td>
</tr>
<tr>
<td><strong>Loop fusion</strong></td>
<td>Improves locality, reduces overhead</td>
<td>No fusion-preventing deps</td>
</tr>
<tr>
<td><strong>Loop fission</strong></td>
<td>Enables vectorization of subloops</td>
<td>Dependency partitioning</td>
</tr>
<tr>
<td><strong>Loop tiling</strong></td>
<td>Fits working set in cache</td>
<td>Known bounds</td>
</tr>
<tr>
<td><strong>Loop interchange</strong></td>
<td>Matches access pattern to memory layout</td>
<td>Legal distance vectors</td>
</tr>
<tr>
<td><strong>Vectorization</strong></td>
<td>Exploits SIMD hardware</td>
<td>No loop-carried deps</td>
</tr>
<tr>
<td><strong>Polyhedral model</strong></td>
<td>Unified framework for all transforms</td>
<td>Affine loops</td>
</tr>
<tr>
<td><strong>Parallelization</strong></td>
<td>Exploits multiple cores</td>
<td>Dependency analysis</td>
</tr>
</tbody>
</table>
<p>The key insight unifying all these optimizations is <strong>dependency analysis</strong>: every transformation must preserve the original program's data dependencies. Understanding what computations depend on what -- and what can be safely reordered, hoisted, or parallelized -- is the foundation of all loop optimization.</p>
<hr />
<h2 id="15-exercises">15. Exercises<a class="header-link" href="#15-exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-dominator-computation">Exercise 1: Dominator Computation<a class="header-link" href="#exercise-1-dominator-computation" title="Permanent link">&para;</a></h3>
<p>Given the following CFG, compute the dominator sets for each node:</p>
<div class="highlight"><pre><span></span><code><span class="n">Entry</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">C</span>
<span class="w">         </span><span class="o">|</span><span class="w">         </span><span class="o">|</span>
<span class="w">         </span><span class="n">v</span><span class="w">         </span><span class="n">v</span>
<span class="w">         </span><span class="n">D</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">Exit</span>
<span class="w">              </span><span class="o">^</span>
<span class="w">              </span><span class="o">|</span>
<span class="w">              </span><span class="n">G</span><span class="w"> </span><span class="o">&lt;--</span><span class="w"> </span><span class="n">F</span>
</code></pre></div>

<p>Edges: Entry-&gt;A, A-&gt;B, A-&gt;D, B-&gt;C, C-&gt;F, D-&gt;E, E-&gt;F, F-&gt;Exit, F-&gt;G, G-&gt;E</p>
<p>(a) Compute the dominator set for each node.
(b) Draw the dominator tree.
(c) Identify all back edges and natural loops.</p>
<h3 id="exercise-2-loop-invariant-code-motion">Exercise 2: Loop-Invariant Code Motion<a class="header-link" href="#exercise-2-loop-invariant-code-motion" title="Permanent link">&para;</a></h3>
<p>Consider the following loop (in pseudo-code):</p>
<div class="highlight"><pre><span></span><code><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="k">while</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nl">n</span><span class="p">:</span>
<span class="w">    </span><span class="n">t1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span>
<span class="w">    </span><span class="n">t2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">c</span>
<span class="w">    </span><span class="n">t3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t2</span>
<span class="w">    </span><span class="n">t4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">t1</span>
<span class="w">    </span><span class="n">e</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">t4</span>
<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>

<p>(a) Identify all loop-invariant computations.
(b) Which invariant computations can be safely hoisted? Why or why not?
(c) Write the optimized code after applying LICM.</p>
<h3 id="exercise-3-strength-reduction">Exercise 3: Strength Reduction<a class="header-link" href="#exercise-3-strength-reduction" title="Permanent link">&para;</a></h3>
<p>Given the following loop:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">addr1</span> <span class="o">=</span> <span class="n">base1</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span>
    <span class="n">addr2</span> <span class="o">=</span> <span class="n">base2</span> <span class="o">+</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">12</span>
    <span class="n">mem</span><span class="p">[</span><span class="n">addr1</span><span class="p">]</span> <span class="o">=</span> <span class="n">mem</span><span class="p">[</span><span class="n">addr2</span><span class="p">]</span>
</code></pre></div>

<p>(a) Identify all basic and derived induction variables.
(b) Apply strength reduction. Show the resulting code.
(c) Apply linear test replacement to eliminate the original counter if possible.</p>
<h3 id="exercise-4-loop-tiling">Exercise 4: Loop Tiling<a class="header-link" href="#exercise-4-loop-tiling" title="Permanent link">&para;</a></h3>
<p>Consider a matrix transposition:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
        <span class="n">B</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
</code></pre></div>

<p>(a) Analyze the cache behavior of this code (assume row-major storage).
(b) Apply loop tiling with tile size $T = 32$. Write the tiled code.
(c) For an L1 cache of 32 KB and 8-byte elements, what is the optimal tile size?</p>
<h3 id="exercise-5-vectorization-analysis">Exercise 5: Vectorization Analysis<a class="header-link" href="#exercise-5-vectorization-analysis" title="Permanent link">&para;</a></h3>
<p>For each loop below, determine whether it can be vectorized. If not, explain why and suggest a transformation that might help:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># (a)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># (b)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

<span class="c1"># (c)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

<span class="c1"># (d)</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>

<h3 id="exercise-6-polyhedral-transformation">Exercise 6: Polyhedral Transformation<a class="header-link" href="#exercise-6-polyhedral-transformation" title="Permanent link">&para;</a></h3>
<p>Consider the following loop nest:</p>
<div class="highlight"><pre><span></span><code><span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
        <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+</span> <span class="n">A</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div>

<p>(a) Draw the iteration domain as a 2D grid.
(b) Identify all data dependencies and their distance vectors.
(c) Is loop interchange legal? Justify your answer.
(d) Propose a skewing transformation $\theta(i, j) = (i + j, j)$ and verify it respects dependencies.
(e) How does the skewed schedule enable wavefront parallelism?</p>
<hr />
<h2 id="16-references">16. References<a class="header-link" href="#16-references" title="Permanent link">&para;</a></h2>
<ol>
<li>Aho, A. V., Lam, M. S., Sethi, R., &amp; Ullman, J. D. (2006). <em>Compilers: Principles, Techniques, and Tools</em> (2nd ed.), Chapters 9-10.</li>
<li>Cooper, K. D., &amp; Torczon, L. (2011). <em>Engineering a Compiler</em> (2nd ed.), Chapters 8-10.</li>
<li>Muchnick, S. S. (1997). <em>Advanced Compiler Design and Implementation</em>, Chapters 14-18.</li>
<li>Allen, R., &amp; Kennedy, K. (2001). <em>Optimizing Compilers for Modern Architectures</em>.</li>
<li>Wolfe, M. (1996). <em>High Performance Compilers for Parallel Computing</em>.</li>
<li>Bondhugula, U., et al. (2008). "A Practical Automatic Polyhedral Parallelizer and Locality Optimizer." <em>PLDI</em>.</li>
<li>Cooper, K. D., Harvey, T. J., &amp; Kennedy, K. (2001). "A Simple, Fast Dominance Algorithm." <em>Software Practice and Experience</em>.</li>
</ol>
<hr />
<p><a href="./12_Optimization_Local_and_Global.md">Previous: 12. Optimization -- Local and Global</a> | <a href="./14_Garbage_Collection.md">Next: 14. Garbage Collection</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/12_Optimization_Local_and_Global.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 12: Optimization -- Local and Global</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/14_Garbage_Collection.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Garbage Collection</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">â†‘</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}