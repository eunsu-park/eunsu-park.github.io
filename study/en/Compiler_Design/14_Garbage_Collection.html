{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Garbage Collection - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">ğŸ </span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">ğŸ’»</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        í•œêµ­ì–´
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">â˜€ï¸</span>
                    <span class="theme-icon dark">ğŸŒ™</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Garbage Collection</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Garbage Collection</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/13_Loop_Optimization.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Loop Optimization</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/15_Interpreters_and_Virtual_Machines.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Interpreters and Virtual Machines</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#1-memory-management-overview">1. Memory Management Overview</a><ul>
<li><a href="#11-the-heap">1.1 The Heap</a></li>
<li><a href="#12-manual-memory-management">1.2 Manual Memory Management</a></li>
<li><a href="#13-automatic-memory-management">1.3 Automatic Memory Management</a></li>
<li><a href="#14-trade-offs-manual-vs-automatic">1.4 Trade-offs: Manual vs Automatic</a></li>
<li><a href="#15-conservative-vs-precise-gc">1.5 Conservative vs Precise GC</a></li>
</ul>
</li>
<li><a href="#2-reference-counting">2. Reference Counting</a><ul>
<li><a href="#21-basic-reference-counting">2.1 Basic Reference Counting</a></li>
<li><a href="#22-advantages-and-disadvantages">2.2 Advantages and Disadvantages</a></li>
<li><a href="#23-deferred-reference-counting">2.3 Deferred Reference Counting</a></li>
<li><a href="#24-coalesced-reference-counting">2.4 Coalesced Reference Counting</a></li>
</ul>
</li>
<li><a href="#3-cycle-detection">3. Cycle Detection</a><ul>
<li><a href="#31-the-cycle-problem">3.1 The Cycle Problem</a></li>
<li><a href="#32-trial-deletion-recycler-algorithm">3.2 Trial Deletion (Recycler Algorithm)</a></li>
</ul>
</li>
<li><a href="#4-mark-sweep-collection">4. Mark-Sweep Collection</a><ul>
<li><a href="#41-algorithm">4.1 Algorithm</a></li>
<li><a href="#42-free-list-management">4.2 Free List Management</a></li>
<li><a href="#43-mark-sweep-complexity">4.3 Mark-Sweep Complexity</a></li>
</ul>
</li>
<li><a href="#5-mark-compact-collection">5. Mark-Compact Collection</a><ul>
<li><a href="#51-motivation">5.1 Motivation</a></li>
<li><a href="#52-algorithm">5.2 Algorithm</a></li>
<li><a href="#53-trade-offs">5.3 Trade-offs</a></li>
</ul>
</li>
<li><a href="#6-copying-collectors">6. Copying Collectors</a><ul>
<li><a href="#61-semi-space-collector">6.1 Semi-Space Collector</a></li>
<li><a href="#62-cheneys-algorithm">6.2 Cheney's Algorithm</a></li>
<li><a href="#63-trade-offs-of-copying-collection">6.3 Trade-offs of Copying Collection</a></li>
</ul>
</li>
<li><a href="#7-generational-collection">7. Generational Collection</a><ul>
<li><a href="#71-the-generational-hypothesis">7.1 The Generational Hypothesis</a></li>
<li><a href="#72-generational-gc-design">7.2 Generational GC Design</a></li>
<li><a href="#73-write-barriers">7.3 Write Barriers</a></li>
<li><a href="#74-multi-generation-schemes">7.4 Multi-Generation Schemes</a></li>
</ul>
</li>
<li><a href="#8-incremental-and-concurrent-gc">8. Incremental and Concurrent GC</a><ul>
<li><a href="#81-the-pause-problem">8.1 The Pause Problem</a></li>
<li><a href="#82-incremental-collection">8.2 Incremental Collection</a></li>
<li><a href="#83-concurrent-collection">8.3 Concurrent Collection</a></li>
</ul>
</li>
<li><a href="#9-tri-color-marking">9. Tri-Color Marking</a><ul>
<li><a href="#91-the-tri-color-abstraction">9.1 The Tri-Color Abstraction</a></li>
<li><a href="#92-the-lost-object-problem">9.2 The Lost Object Problem</a></li>
<li><a href="#93-write-barrier-solutions">9.3 Write Barrier Solutions</a></li>
<li><a href="#94-yuasas-snapshot-at-the-beginning">9.4 Yuasa's Snapshot-at-the-Beginning</a></li>
</ul>
</li>
<li><a href="#10-gc-in-real-systems">10. GC in Real Systems</a><ul>
<li><a href="#101-jvm-garbage-collectors">10.1 JVM Garbage Collectors</a></li>
<li><a href="#102-go-garbage-collector">10.2 Go Garbage Collector</a></li>
<li><a href="#103-cpython-garbage-collector">10.3 CPython Garbage Collector</a></li>
<li><a href="#104-rust-ownership-instead-of-gc">10.4 Rust: Ownership Instead of GC</a></li>
<li><a href="#105-comparison">10.5 Comparison</a></li>
</ul>
</li>
<li><a href="#11-gc-tuning-and-metrics">11. GC Tuning and Metrics</a><ul>
<li><a href="#111-key-metrics">11.1 Key Metrics</a></li>
<li><a href="#112-the-gc-tuning-triangle">11.2 The GC Tuning Triangle</a></li>
<li><a href="#113-gc-tuning-example">11.3 GC Tuning Example</a></li>
<li><a href="#114-common-gc-tuning-strategies">11.4 Common GC Tuning Strategies</a></li>
</ul>
</li>
<li><a href="#12-summary">12. Summary</a></li>
<li><a href="#13-exercises">13. Exercises</a><ul>
<li><a href="#exercise-1-reference-counting-simulation">Exercise 1: Reference Counting Simulation</a></li>
<li><a href="#exercise-2-mark-sweep-implementation">Exercise 2: Mark-Sweep Implementation</a></li>
<li><a href="#exercise-3-copying-collector">Exercise 3: Copying Collector</a></li>
<li><a href="#exercise-4-generational-gc">Exercise 4: Generational GC</a></li>
<li><a href="#exercise-5-tri-color-marking-safety">Exercise 5: Tri-Color Marking Safety</a></li>
<li><a href="#exercise-6-gc-comparison">Exercise 6: GC Comparison</a></li>
</ul>
</li>
<li><a href="#14-references">14. References</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="garbage-collection">Garbage Collection<a class="header-link" href="#garbage-collection" title="Permanent link">&para;</a></h1>
<p><strong>Previous</strong>: <a href="./13_Loop_Optimization.md">13. Loop Optimization</a> | <strong>Next</strong>: <a href="./15_Interpreters_and_Virtual_Machines.md">15. Interpreters and Virtual Machines</a></p>
<hr />
<p>Memory management is one of the most fundamental challenges in programming language implementation. Every program allocates memory, and that memory must eventually be reclaimed. Manual memory management (as in C and C++) gives the programmer full control but is notoriously error-prone: dangling pointers, double frees, and memory leaks are among the most common and dangerous bugs in software history. Garbage collection (GC) automates this process, freeing the programmer from tracking object lifetimes -- at the cost of runtime overhead and reduced control.</p>
<p>This lesson covers the major garbage collection algorithms and their trade-offs, from the simplest reference counting scheme to sophisticated generational and concurrent collectors used in production systems.</p>
<p><strong>Difficulty</strong>: â­â­â­</p>
<p><strong>Prerequisites</strong>: <a href="./10_Runtime_Environments.md">10. Runtime Environments</a></p>
<p><strong>Learning Objectives</strong>:
- Compare manual and automatic memory management approaches
- Implement reference counting with cycle detection
- Understand tracing collectors: mark-sweep, mark-compact, and copying
- Explain generational GC and why it works (the generational hypothesis)
- Describe incremental and concurrent GC algorithms using tri-color marking
- Analyze GC strategies in real systems (JVM, Go, Python, Rust)
- Reason about GC tuning and performance trade-offs</p>
<hr />
<h2 id="table-of-contents">Table of Contents<a class="header-link" href="#table-of-contents" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#1-memory-management-overview">Memory Management Overview</a></li>
<li><a href="#2-reference-counting">Reference Counting</a></li>
<li><a href="#3-cycle-detection">Cycle Detection</a></li>
<li><a href="#4-mark-sweep-collection">Mark-Sweep Collection</a></li>
<li><a href="#5-mark-compact-collection">Mark-Compact Collection</a></li>
<li><a href="#6-copying-collectors">Copying Collectors</a></li>
<li><a href="#7-generational-collection">Generational Collection</a></li>
<li><a href="#8-incremental-and-concurrent-gc">Incremental and Concurrent GC</a></li>
<li><a href="#9-tri-color-marking">Tri-Color Marking</a></li>
<li><a href="#10-gc-in-real-systems">GC in Real Systems</a></li>
<li><a href="#11-gc-tuning-and-metrics">GC Tuning and Metrics</a></li>
<li><a href="#12-summary">Summary</a></li>
<li><a href="#13-exercises">Exercises</a></li>
<li><a href="#14-references">References</a></li>
</ol>
<hr />
<h2 id="1-memory-management-overview">1. Memory Management Overview<a class="header-link" href="#1-memory-management-overview" title="Permanent link">&para;</a></h2>
<h3 id="11-the-heap">1.1 The Heap<a class="header-link" href="#11-the-heap" title="Permanent link">&para;</a></h3>
<p>Dynamic memory allocation uses the <strong>heap</strong> -- a region of memory managed at runtime. Objects are allocated on the heap when their size or lifetime is not known at compile time.</p>
<div class="highlight"><pre><span></span><code><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="err">â”‚</span><span class="w">                  </span><span class="n">Stack</span><span class="w">                       </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="p">(</span><span class="n">automatic</span><span class="p">:</span><span class="w"> </span><span class="n">local</span><span class="w"> </span><span class="n">vars</span><span class="p">,</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">addresses</span><span class="p">)</span><span class="w">   </span><span class="err">â”‚</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">                    </span><span class="err">â†“</span><span class="w">                         </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">              </span><span class="p">(</span><span class="n">grows</span><span class="w"> </span><span class="n">down</span><span class="p">)</span><span class="w">                    </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">                                             </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">              </span><span class="p">(</span><span class="n">grows</span><span class="w"> </span><span class="n">up</span><span class="p">)</span><span class="w">                      </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">                    </span><span class="err">â†‘</span><span class="w">                         </span><span class="err">â”‚</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">                   </span><span class="n">Heap</span><span class="w">                       </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="p">(</span><span class="n">dynamic</span><span class="p">:</span><span class="w"> </span><span class="n">malloc</span><span class="o">/</span><span class="n">new</span><span class="p">,</span><span class="w"> </span><span class="n">managed</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">GC</span><span class="p">)</span><span class="w">        </span><span class="err">â”‚</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">              </span><span class="n">Static</span><span class="o">/</span><span class="n">Global</span><span class="w"> </span><span class="n">Data</span><span class="w">              </span><span class="err">â”‚</span>
<span class="err">â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤</span>
<span class="err">â”‚</span><span class="w">                  </span><span class="n">Code</span><span class="o">/</span><span class="n">Text</span><span class="w">                   </span><span class="err">â”‚</span>
<span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
</code></pre></div>

<h3 id="12-manual-memory-management">1.2 Manual Memory Management<a class="header-link" href="#12-manual-memory-management" title="Permanent link">&para;</a></h3>
<p>In languages like C, the programmer explicitly manages memory:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// C manual memory management</span>
<span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span><span class="w">  </span><span class="c1">// Allocate</span>
<span class="c1">// ... use arr ...</span>
<span class="n">free</span><span class="p">(</span><span class="n">arr</span><span class="p">);</span><span class="w">  </span><span class="c1">// Deallocate -- programmer&#39;s responsibility</span>
<span class="n">arr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w"> </span><span class="c1">// Avoid dangling pointer</span>
</code></pre></div>

<p>Common problems with manual memory management:</p>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Description</th>
<th>Consequence</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Memory leak</strong></td>
<td>Forgetting to call <code>free</code></td>
<td>Unbounded memory growth</td>
</tr>
<tr>
<td><strong>Dangling pointer</strong></td>
<td>Using memory after <code>free</code></td>
<td>Undefined behavior, crashes</td>
</tr>
<tr>
<td><strong>Double free</strong></td>
<td>Calling <code>free</code> twice</td>
<td>Heap corruption</td>
</tr>
<tr>
<td><strong>Buffer overflow</strong></td>
<td>Writing past allocation bounds</td>
<td>Security vulnerabilities</td>
</tr>
<tr>
<td><strong>Use-after-free</strong></td>
<td>Accessing freed memory</td>
<td>Data corruption</td>
</tr>
</tbody>
</table>
<h3 id="13-automatic-memory-management">1.3 Automatic Memory Management<a class="header-link" href="#13-automatic-memory-management" title="Permanent link">&para;</a></h3>
<p>Garbage collection automatically identifies and reclaims objects that are no longer reachable by the program. The key insight: <strong>an object is garbage if no sequence of pointer dereferences starting from the root set can reach it</strong>.</p>
<p>The <strong>root set</strong> consists of:
- Global variables
- Local variables on the stack
- CPU registers containing pointers
- Any other runtime-managed references</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">GCObject</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for garbage-collected objects.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Pointers to other objects</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">refs</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">]</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Object(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, refs=</span><span class="si">{</span><span class="n">refs</span><span class="si">}</span><span class="s2">)&quot;</span>


<span class="c1"># Example: reachability</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">GCObject</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">)</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">GCObject</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="n">GCObject</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">GCObject</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>    <span class="c1"># Unreachable -- garbage!</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">GCObject</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">)</span>

<span class="n">root</span><span class="o">.</span><span class="n">add_reference</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="n">a</span><span class="o">.</span><span class="n">add_reference</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
<span class="n">b</span><span class="o">.</span><span class="n">add_reference</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

<span class="c1"># Reachable from root: root -&gt; A -&gt; B -&gt; D</span>
<span class="c1"># Unreachable: C (garbage)</span>
</code></pre></div>

<h3 id="14-trade-offs-manual-vs-automatic">1.4 Trade-offs: Manual vs Automatic<a class="header-link" href="#14-trade-offs-manual-vs-automatic" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Manual</th>
<th>Reference Counting</th>
<th>Tracing GC</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Throughput</strong></td>
<td>Best (no GC overhead)</td>
<td>Good (incremental cost)</td>
<td>Good (amortized)</td>
</tr>
<tr>
<td><strong>Latency</strong></td>
<td>Predictable</td>
<td>Predictable</td>
<td>Pauses (unless concurrent)</td>
</tr>
<tr>
<td><strong>Memory overhead</strong></td>
<td>None</td>
<td>Per-object count</td>
<td>Metadata + copy space</td>
</tr>
<tr>
<td><strong>Safety</strong></td>
<td>Unsafe</td>
<td>Safe (except cycles)</td>
<td>Safe</td>
</tr>
<tr>
<td><strong>Programmer effort</strong></td>
<td>High</td>
<td>Low</td>
<td>Low</td>
</tr>
<tr>
<td><strong>Fragmentation</strong></td>
<td>Depends on allocator</td>
<td>Yes</td>
<td>Compact/copy fixes it</td>
</tr>
</tbody>
</table>
<h3 id="15-conservative-vs-precise-gc">1.5 Conservative vs Precise GC<a class="header-link" href="#15-conservative-vs-precise-gc" title="Permanent link">&para;</a></h3>
<p>A <strong>precise</strong> (or <strong>exact</strong>) GC knows exactly which values on the stack and in objects are pointers. This requires cooperation from the compiler (stack maps, type information).</p>
<p>A <strong>conservative</strong> GC treats any word on the stack that looks like a valid heap pointer as a potential pointer. This is simpler but may retain garbage (false pointers) and cannot move objects (since it might "fix up" a non-pointer value).</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_conservative_scan</span><span class="p">(</span><span class="n">stack_words</span><span class="p">,</span> <span class="n">heap_start</span><span class="p">,</span> <span class="n">heap_end</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate conservative stack scanning.</span>

<span class="sd">    Any value that looks like a heap address is treated as a pointer.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">potential_roots</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">word</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stack_words</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">heap_start</span> <span class="o">&lt;=</span> <span class="n">word</span> <span class="o">&lt;</span> <span class="n">heap_end</span><span class="p">:</span>
            <span class="n">potential_roots</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">word</span><span class="p">))</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Stack[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">] = 0x</span><span class="si">{</span><span class="n">word</span><span class="si">:</span><span class="s2">08x</span><span class="si">}</span><span class="s2"> -- potential pointer (in heap range)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Stack[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">] = 0x</span><span class="si">{</span><span class="n">word</span><span class="si">:</span><span class="s2">08x</span><span class="si">}</span><span class="s2"> -- not a pointer&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">potential_roots</span>


<span class="c1"># Example</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Conservative Stack Scan ===&quot;</span><span class="p">)</span>
<span class="n">stack</span> <span class="o">=</span> <span class="p">[</span>
    <span class="mh">0x00000042</span><span class="p">,</span>   <span class="c1"># Integer 66 -- not a pointer</span>
    <span class="mh">0x08001000</span><span class="p">,</span>   <span class="c1"># In heap range -- potential pointer!</span>
    <span class="mh">0x00000000</span><span class="p">,</span>   <span class="c1"># NULL -- not in heap</span>
    <span class="mh">0x08003000</span><span class="p">,</span>   <span class="c1"># In heap range -- potential pointer!</span>
    <span class="mh">0x0800CAFE</span><span class="p">,</span>   <span class="c1"># In heap range but actually an integer -- false positive!</span>
<span class="p">]</span>

<span class="n">roots</span> <span class="o">=</span> <span class="n">demonstrate_conservative_scan</span><span class="p">(</span><span class="n">stack</span><span class="p">,</span> <span class="mh">0x08000000</span><span class="p">,</span> <span class="mh">0x08100000</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Potential roots found: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Note: 0x0800CAFE might be a false positive (an integer that happens&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;to look like a heap address). Conservative GC cannot tell the difference.&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="2-reference-counting">2. Reference Counting<a class="header-link" href="#2-reference-counting" title="Permanent link">&para;</a></h2>
<h3 id="21-basic-reference-counting">2.1 Basic Reference Counting<a class="header-link" href="#21-basic-reference-counting" title="Permanent link">&para;</a></h3>
<p>The simplest form of automatic memory management: each object maintains a count of how many references point to it. When the count drops to zero, the object is immediately freed.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">RefCountedObject</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Object with reference counting.&quot;&quot;&quot;</span>

    <span class="n">_all_objects</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Track all allocated objects for debugging</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># field_name -&gt; RefCountedObject</span>
        <span class="n">RefCountedObject</span><span class="o">.</span><span class="n">_all_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">inc_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">dec_ref</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_free</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_free</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Free this object and decrement refs to children.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Freeing </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> (size=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="c1"># Decrement reference counts of all referenced objects</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">dec_ref</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="n">RefCountedObject</span><span class="o">.</span><span class="n">_all_objects</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_field</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field_name</span><span class="p">,</span> <span class="n">new_obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set a field to point to new_obj, updating ref counts.&quot;&quot;&quot;</span>
        <span class="c1"># Decrement old reference</span>
        <span class="n">old_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">old_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">old_obj</span><span class="o">.</span><span class="n">dec_ref</span><span class="p">()</span>

        <span class="c1"># Set new reference</span>
        <span class="k">if</span> <span class="n">new_obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_obj</span><span class="o">.</span><span class="n">inc_ref</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_obj</span>
        <span class="k">elif</span> <span class="n">field_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">references</span><span class="p">[</span><span class="n">field_name</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;RC(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, rc=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ref_count</span><span class="si">}</span><span class="s2">)&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_ref_counting</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate reference counting in action.&quot;&quot;&quot;</span>
    <span class="n">RefCountedObject</span><span class="o">.</span><span class="n">_all_objects</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Reference Counting Demo ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Create root (simulate stack reference)</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">inc_ref</span><span class="p">()</span>  <span class="c1"># Stack reference</span>

    <span class="c1"># Allocate objects</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>

    <span class="c1"># Build object graph: root -&gt; A -&gt; B, root -&gt; C</span>
    <span class="n">root</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">a</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Object graph: root -&gt; A -&gt; B, root -&gt; C&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objects: </span><span class="si">{</span><span class="n">RefCountedObject</span><span class="o">.</span><span class="n">_all_objects</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ref counts: root=</span><span class="si">{</span><span class="n">root</span><span class="o">.</span><span class="n">ref_count</span><span class="si">}</span><span class="s2">, A=</span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">ref_count</span><span class="si">}</span><span class="s2">, &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;B=</span><span class="si">{</span><span class="n">b</span><span class="o">.</span><span class="n">ref_count</span><span class="si">}</span><span class="s2">, C=</span><span class="si">{</span><span class="n">c</span><span class="o">.</span><span class="n">ref_count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Remove reference root -&gt; A</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Removing root -&gt; A...&quot;</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objects after removal: </span><span class="si">{</span><span class="n">RefCountedObject</span><span class="o">.</span><span class="n">_all_objects</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># A&#39;s ref count drops to 0, A is freed, which drops B&#39;s ref count to 0, B is freed</span>

    <span class="c1"># Remove reference root -&gt; C</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Removing root -&gt; C...&quot;</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objects after removal: </span><span class="si">{</span><span class="n">RefCountedObject</span><span class="o">.</span><span class="n">_all_objects</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">demonstrate_ref_counting</span><span class="p">()</span>
</code></pre></div>

<p>Output:</p>
<div class="highlight"><pre><span></span><code><span class="o">===</span><span class="w"> </span><span class="n">Reference</span><span class="w"> </span><span class="n">Counting</span><span class="w"> </span><span class="n">Demo</span><span class="w"> </span><span class="o">===</span>

<span class="n">Object</span><span class="w"> </span><span class="nf">graph</span><span class="o">:</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">C</span>
<span class="n">Objects</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">RC</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">rc</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">RC</span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">rc</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">RC</span><span class="p">(</span><span class="n">B</span><span class="p">,</span><span class="w"> </span><span class="n">rc</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">RC</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">rc</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
<span class="n">Ref</span><span class="w"> </span><span class="n">counts</span><span class="o">:</span><span class="w"> </span><span class="n">root</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">A</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">B</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="o">=</span><span class="mi">1</span>

<span class="n">Removing</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">A</span><span class="p">...</span>
<span class="w">  </span><span class="n">Freeing</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="n">Freeing</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Objects</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">removal</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">RC</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">rc</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span><span class="w"> </span><span class="n">RC</span><span class="p">(</span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">rc</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>

<span class="n">Removing</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">C</span><span class="p">...</span>
<span class="w">  </span><span class="n">Freeing</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Objects</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">removal</span><span class="o">:</span><span class="w"> </span><span class="p">[</span><span class="n">RC</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">rc</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
</code></pre></div>

<h3 id="22-advantages-and-disadvantages">2.2 Advantages and Disadvantages<a class="header-link" href="#22-advantages-and-disadvantages" title="Permanent link">&para;</a></h3>
<p><strong>Advantages</strong>:
- <strong>Immediate reclamation</strong>: Objects are freed as soon as they become garbage
- <strong>Incremental</strong>: Cost is spread across program execution (no pauses)
- <strong>Locality</strong>: Freed memory was recently used (likely in cache)
- <strong>Simplicity</strong>: Easy to understand and implement</p>
<p><strong>Disadvantages</strong>:
- <strong>Cycles</strong>: Cannot collect cyclic garbage (see Section 3)
- <strong>Space overhead</strong>: Every object needs a reference count field
- <strong>Time overhead</strong>: Every pointer assignment requires inc/dec operations
- <strong>Thread safety</strong>: Ref count updates need atomic operations in concurrent programs
- <strong>Cache unfriendly</strong>: Ref count updates dirty cache lines of unrelated objects</p>
<h3 id="23-deferred-reference-counting">2.3 Deferred Reference Counting<a class="header-link" href="#23-deferred-reference-counting" title="Permanent link">&para;</a></h3>
<p>To reduce the overhead of tracking stack references (which change very frequently), <strong>deferred reference counting</strong> only tracks heap-to-heap references. Stack references are handled by periodically scanning the stack.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DeferredRefCounting</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Deferred reference counting: only count heap-to-heap references.</span>
<span class="sd">    Stack references are ignored in ref counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heap_objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">zero_count_table</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Objects with rc=0 (potential garbage)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack_roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>       <span class="c1"># Current stack roots</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heap_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="c1"># Don&#39;t increment for stack reference</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">heap_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Record heap-to-heap pointer write.&quot;&quot;&quot;</span>
        <span class="n">source</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">stack_root_change</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">added</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">removed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Track stack root changes (deferred -- no ref count update).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">added</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack_roots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">added</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">removed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stack_roots</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">removed</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Periodic collection: scan stack roots to find true garbage.</span>
<span class="sd">        Objects with rc=0 that are NOT stack roots are garbage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Deferred RC Collection ---&quot;</span><span class="p">)</span>
        <span class="n">garbage</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap_objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">ref_count</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">obj</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack_roots</span><span class="p">:</span>
                <span class="n">garbage</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Garbage: </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">garbage</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heap_objects</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Freed: </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">garbage</span><span class="p">)</span>
</code></pre></div>

<h3 id="24-coalesced-reference-counting">2.4 Coalesced Reference Counting<a class="header-link" href="#24-coalesced-reference-counting" title="Permanent link">&para;</a></h3>
<p><strong>Coalesced reference counting</strong> buffers reference count updates and coalesces them before applying. If a pointer field is written multiple times between collections, only the net effect is recorded.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CoalescedRefCounting</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Coalesced reference counting: buffer ref count updates.</span>

<span class="sd">    Instead of updating counts on every pointer write, log</span>
<span class="sd">    the old and new values. At collection time, compute net changes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="p">{}</span>      <span class="c1"># name -&gt; object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_log</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># list of (old_target, new_target)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_pointer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source_field</span><span class="p">,</span> <span class="n">old_target</span><span class="p">,</span> <span class="n">new_target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Log a pointer update instead of immediately changing ref counts.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_log</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">old_target</span><span class="p">,</span> <span class="n">new_target</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">process_updates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Process buffered updates, computing net ref count changes.&quot;&quot;&quot;</span>
        <span class="c1"># Net changes per object</span>
        <span class="n">changes</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">old_target</span><span class="p">,</span> <span class="n">new_target</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">update_log</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">old_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">changes</span><span class="p">[</span><span class="n">old_target</span><span class="p">]</span> <span class="o">=</span> <span class="n">changes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">old_target</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">new_target</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">changes</span><span class="p">[</span><span class="n">new_target</span><span class="p">]</span> <span class="o">=</span> <span class="n">changes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">new_target</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Coalesced updates:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span><span class="p">,</span> <span class="n">delta</span> <span class="ow">in</span> <span class="n">changes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">delta</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="s1">&#39;+&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">delta</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="si">}{</span><span class="n">delta</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update_log</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">changes</span>
</code></pre></div>

<hr />
<h2 id="3-cycle-detection">3. Cycle Detection<a class="header-link" href="#3-cycle-detection" title="Permanent link">&para;</a></h2>
<h3 id="31-the-cycle-problem">3.1 The Cycle Problem<a class="header-link" href="#31-the-cycle-problem" title="Permanent link">&para;</a></h3>
<p>Reference counting cannot collect cycles: objects that reference each other but are not reachable from any root.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_cycle_leak</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Show how reference counting fails with cycles.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Cycle Leak Demo ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>

    <span class="c1"># Both referenced from stack</span>
    <span class="n">a</span><span class="o">.</span><span class="n">inc_ref</span><span class="p">()</span>  <span class="c1"># stack ref</span>
    <span class="n">b</span><span class="o">.</span><span class="n">inc_ref</span><span class="p">()</span>  <span class="c1"># stack ref</span>

    <span class="c1"># Create cycle: A -&gt; B -&gt; A</span>
    <span class="n">a</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>   <span class="c1"># A.ref=1(stack), B.ref=1(stack)+1(A)=2</span>
    <span class="n">b</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>   <span class="c1"># A.ref=1(stack)+1(B)=2, B.ref=2</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before removing stack refs: A.rc=</span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">ref_count</span><span class="si">}</span><span class="s2">, B.rc=</span><span class="si">{</span><span class="n">b</span><span class="o">.</span><span class="n">ref_count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Remove stack references</span>
    <span class="n">a</span><span class="o">.</span><span class="n">dec_ref</span><span class="p">()</span>  <span class="c1"># A.rc = 2-1 = 1</span>
    <span class="n">b</span><span class="o">.</span><span class="n">dec_ref</span><span class="p">()</span>  <span class="c1"># B.rc = 2-1 = 1</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After removing stack refs: A.rc=</span><span class="si">{</span><span class="n">a</span><span class="o">.</span><span class="n">ref_count</span><span class="si">}</span><span class="s2">, B.rc=</span><span class="si">{</span><span class="n">b</span><span class="o">.</span><span class="n">ref_count</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Neither is freed! Both have rc=1 due to the cycle.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;This is a memory leak.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># demonstrate_cycle_leak()</span>
</code></pre></div>

<h3 id="32-trial-deletion-recycler-algorithm">3.2 Trial Deletion (Recycler Algorithm)<a class="header-link" href="#32-trial-deletion-recycler-algorithm" title="Permanent link">&para;</a></h3>
<p>The trial deletion algorithm (used in CPython) identifies cycles by tentatively removing internal references:</p>
<ol>
<li>For each object in the candidate set, tentatively decrement the ref counts of all objects it references.</li>
<li>Objects whose ref count drops to zero (tentatively) are garbage.</li>
<li>Objects still reachable from external references survive.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CycleDetector</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cycle detector using trial deletion algorithm.</span>
<span class="sd">    Based on the approach used in CPython&#39;s gc module.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objects</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Objects that might be in cycles</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">track</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add an object to cycle detection tracking.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">collect_cycles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">root_set</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detect and collect cyclic garbage.</span>

<span class="sd">        Phase 1: Trial deletion -- tentatively decrement ref counts</span>
<span class="sd">                 for all internal references</span>
<span class="sd">        Phase 2: Scan -- objects with tentative rc &gt; 0 are reachable</span>
<span class="sd">                 (mark them and their transitive closure as alive)</span>
<span class="sd">        Phase 3: Collect -- remaining objects with tentative rc = 0 are garbage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Cycle Collection ===&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objects</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;No tracked objects.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># Phase 1: Compute tentative ref counts</span>
        <span class="n">tentative_rc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objects</span><span class="p">:</span>
            <span class="n">tentative_rc</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">ref_count</span>

        <span class="c1"># Subtract internal references</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objects</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">references</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tentative_rc</span><span class="p">:</span>
                    <span class="n">tentative_rc</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">ref</span><span class="p">)]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Phase 1 - Trial deletion (tentative ref counts):&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objects</span><span class="p">:</span>
            <span class="n">orig</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">ref_count</span>
            <span class="n">tent</span> <span class="o">=</span> <span class="n">tentative_rc</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: original_rc=</span><span class="si">{</span><span class="n">orig</span><span class="si">}</span><span class="s2">, tentative_rc=</span><span class="si">{</span><span class="n">tent</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Phase 2: Scan -- find objects reachable from roots or external refs</span>
        <span class="n">alive</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="c1"># Objects with tentative_rc &gt; 0 have external references</span>
        <span class="n">worklist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tentative_rc</span><span class="p">[</span><span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="n">alive</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

        <span class="c1"># Also add objects reachable from root set</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="n">root_set</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">alive</span><span class="p">:</span>
                <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="n">alive</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>

        <span class="c1"># Propagate reachability</span>
        <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">references</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">alive</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="ow">in</span> <span class="n">tentative_rc</span><span class="p">:</span>
                    <span class="n">alive</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>
                    <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Phase 2 - Reachability scan:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objects</span><span class="p">:</span>
            <span class="n">status</span> <span class="o">=</span> <span class="s2">&quot;ALIVE&quot;</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">alive</span> <span class="k">else</span> <span class="s2">&quot;GARBAGE&quot;</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Phase 3: Collect garbage</span>
        <span class="n">garbage</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objects</span>
                   <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">alive</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Phase 3 - Collection:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">garbage</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Collecting </span><span class="si">{</span><span class="n">obj</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tracked_objects</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">garbage</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_cycle_detection</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate cycle detection with trial deletion.&quot;&quot;&quot;</span>
    <span class="n">RefCountedObject</span><span class="o">.</span><span class="n">_all_objects</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Cycle Detection Demo ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">detector</span> <span class="o">=</span> <span class="n">CycleDetector</span><span class="p">()</span>

    <span class="c1"># Create objects</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">)</span>
    <span class="n">root</span><span class="o">.</span><span class="n">inc_ref</span><span class="p">()</span>  <span class="c1"># stack reference</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">)</span>  <span class="c1"># Not in cycle, reachable from root</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">)</span>  <span class="c1"># In cycle but unreachable</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">RefCountedObject</span><span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">)</span>  <span class="c1"># In cycle but unreachable</span>

    <span class="c1"># Build graph</span>
    <span class="n">root</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s2">&quot;child&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s2">&quot;next&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

    <span class="c1"># Create unreachable cycle: D &lt;-&gt; E</span>
    <span class="n">d</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s2">&quot;partner&quot;</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span>
    <span class="n">e</span><span class="o">.</span><span class="n">set_field</span><span class="p">(</span><span class="s2">&quot;partner&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="c1"># Track potentially cyclic objects</span>
    <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">]:</span>
        <span class="n">detector</span><span class="o">.</span><span class="n">track</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Object graph:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  root -&gt; C -&gt; A&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  D &lt;-&gt; E  (unreachable cycle)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="n">garbage</span> <span class="o">=</span> <span class="n">detector</span><span class="o">.</span><span class="n">collect_cycles</span><span class="p">(</span><span class="n">root_set</span><span class="o">=</span><span class="p">[</span><span class="n">root</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Garbage collected: </span><span class="si">{</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">name</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">g</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">garbage</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">demonstrate_cycle_detection</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="4-mark-sweep-collection">4. Mark-Sweep Collection<a class="header-link" href="#4-mark-sweep-collection" title="Permanent link">&para;</a></h2>
<h3 id="41-algorithm">4.1 Algorithm<a class="header-link" href="#41-algorithm" title="Permanent link">&para;</a></h3>
<p>Mark-sweep is the most fundamental tracing collector. It works in two phases:</p>
<ol>
<li><strong>Mark phase</strong>: Starting from the root set, traverse all reachable objects and mark them.</li>
<li><strong>Sweep phase</strong>: Scan the entire heap; any unmarked object is garbage and is freed.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">MarkSweepGC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mark-Sweep garbage collector implementation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heap_size</span><span class="o">=</span><span class="mi">1024</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span> <span class="o">=</span> <span class="n">heap_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">used</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="p">[]</span>       <span class="c1"># All allocated objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># Root references</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collections</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_freed</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Allocate a new object on the heap.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">used</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span><span class="p">:</span>
            <span class="c1"># Trigger GC</span>
            <span class="n">freed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">used</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Out of memory: need </span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2">, &quot;</span>
                                  <span class="sa">f</span><span class="s2">&quot;have </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">used</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span>
            <span class="s1">&#39;marked&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;references&#39;</span><span class="p">:</span> <span class="p">[],</span>  <span class="c1"># List of referenced objects</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">used</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add an object to the root set.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">remove_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove an object from the root set.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_reference</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a reference from source to target.&quot;&quot;&quot;</span>
        <span class="n">source</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Run mark-sweep collection.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collections</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- GC #</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Before: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">used</span><span class="si">}</span><span class="s2"> bytes used&quot;</span><span class="p">)</span>

        <span class="c1"># Mark phase</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mark</span><span class="p">()</span>

        <span class="c1"># Sweep phase</span>
        <span class="n">freed</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sweep</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;After: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">used</span><span class="si">}</span><span class="s2"> bytes used&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Freed: </span><span class="si">{</span><span class="n">freed</span><span class="si">}</span><span class="s2"> bytes&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_freed</span> <span class="o">+=</span> <span class="n">freed</span>
        <span class="k">return</span> <span class="n">freed</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_mark</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mark all reachable objects starting from the root set.&quot;&quot;&quot;</span>
        <span class="c1"># Clear all marks</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># DFS from roots</span>
        <span class="n">worklist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ref</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]:</span>
                    <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sweep the heap, freeing unmarked objects.&quot;&quot;&quot;</span>
        <span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">surviving</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]:</span>
                <span class="n">surviving</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">freed</span> <span class="o">+=</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">used</span> <span class="o">-=</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Swept: </span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> bytes)&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="n">surviving</span>
        <span class="k">return</span> <span class="n">freed</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print heap status.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Heap: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">used</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span><span class="si">}</span><span class="s2"> bytes used &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="mi">100</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">used</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Objects: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Roots: </span><span class="si">{</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">reachable</span> <span class="o">=</span> <span class="p">{</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]:</span>
                <span class="n">reachable</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Reachable: </span><span class="si">{</span><span class="n">reachable</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_mark_sweep</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Full demonstration of mark-sweep GC.&quot;&quot;&quot;</span>
    <span class="n">gc</span> <span class="o">=</span> <span class="n">MarkSweepGC</span><span class="p">(</span><span class="n">heap_size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Mark-Sweep GC Demo ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Allocate objects</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_root</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

    <span class="c1"># Build object graph</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_reference</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_reference</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_reference</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
    <span class="c1"># D and E are unreachable</span>

    <span class="n">gc</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>

    <span class="c1"># Run collection</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>

    <span class="c1"># Allocate more (into freed space)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_reference</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

    <span class="c1"># Remove root -&gt; B (makes B, F unreachable)</span>
    <span class="n">root</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">]</span>

    <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>

<span class="n">demonstrate_mark_sweep</span><span class="p">()</span>
</code></pre></div>

<h3 id="42-free-list-management">4.2 Free List Management<a class="header-link" href="#42-free-list-management" title="Permanent link">&para;</a></h3>
<p>After sweeping, freed memory blocks are placed on a <strong>free list</strong>. Future allocations search this list for a suitable block.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">FreeListAllocator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Free list memory allocator used with mark-sweep GC.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heap_size</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span> <span class="o">=</span> <span class="n">heap_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heap</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">heap_size</span><span class="p">)</span>
        <span class="c1"># Free list: list of (start, size) sorted by address</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">free_list</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="n">heap_size</span><span class="p">)]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allocated</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># start_addr -&gt; (size, name)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Allocate using first-fit strategy.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">block_size</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">block_size</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">:</span>
                <span class="c1"># Allocate from this block</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">allocated</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">block_size</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">:</span>
                    <span class="c1"># Shrink the free block</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">free_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">block_size</span> <span class="o">-</span> <span class="n">size</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># Remove the free block entirely</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">free_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">start</span>

        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># Out of memory</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">free</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">addr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Free a block and coalesce adjacent free blocks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">addr</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocated</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Address </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2"> not allocated&quot;</span><span class="p">)</span>

        <span class="n">size</span><span class="p">,</span> <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocated</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>

        <span class="c1"># Insert into free list (maintaining sorted order)</span>
        <span class="n">new_block</span> <span class="o">=</span> <span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="n">inserted</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_list</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">free_list</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">new_block</span><span class="p">)</span>
                <span class="n">inserted</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">inserted</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">free_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_block</span><span class="p">)</span>

        <span class="c1"># Coalesce adjacent free blocks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coalesce</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_coalesce</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge adjacent free blocks.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">free_list</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">merged</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">free_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">for</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">prev_start</span><span class="p">,</span> <span class="n">prev_size</span> <span class="o">=</span> <span class="n">merged</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">prev_start</span> <span class="o">+</span> <span class="n">prev_size</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
                <span class="c1"># Adjacent -- merge</span>
                <span class="n">merged</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">prev_start</span><span class="p">,</span> <span class="n">prev_size</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">merged</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">free_list</span> <span class="o">=</span> <span class="n">merged</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print heap layout.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Heap layout:&quot;</span><span class="p">)</span>
        <span class="c1"># Combine allocated and free blocks, sort by address</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">allocated</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">free_list</span><span class="p">:</span>
            <span class="n">blocks</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="s2">&quot;[FREE]&quot;</span><span class="p">))</span>
        <span class="n">blocks</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="n">bar</span> <span class="o">=</span> <span class="s2">&quot;#&quot;</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">addr</span><span class="si">:</span><span class="s2">4d</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">addr</span><span class="o">+</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="si">:</span><span class="s2">4d</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">label</span><span class="si">:</span><span class="s2">10s</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">bar</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">size</span><span class="si">}</span><span class="s2"> bytes)&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_free_list</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Show free list management and fragmentation.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Free List Allocator ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">alloc</span> <span class="o">=</span> <span class="n">FreeListAllocator</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>

    <span class="c1"># Allocate several blocks</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">alloc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">alloc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">alloc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">alloc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">alloc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

    <span class="n">alloc</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>

    <span class="c1"># Free B and D (creates fragmentation)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Freeing B and D...&quot;</span><span class="p">)</span>
    <span class="n">alloc</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
    <span class="n">alloc</span><span class="o">.</span><span class="n">free</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

    <span class="n">alloc</span><span class="o">.</span><span class="n">dump</span><span class="p">()</span>

    <span class="c1"># Try to allocate 25 bytes -- no single free block is large enough!</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Trying to allocate 25 bytes...&quot;</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">alloc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;F&quot;</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  FAILED: External fragmentation!&quot;</span><span class="p">)</span>
        <span class="n">total_free</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">size</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">size</span> <span class="ow">in</span> <span class="n">alloc</span><span class="o">.</span><span class="n">free_list</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Total free: </span><span class="si">{</span><span class="n">total_free</span><span class="si">}</span><span class="s2"> bytes, but no contiguous block &gt;= 25&quot;</span><span class="p">)</span>

<span class="n">demonstrate_free_list</span><span class="p">()</span>
</code></pre></div>

<h3 id="43-mark-sweep-complexity">4.3 Mark-Sweep Complexity<a class="header-link" href="#43-mark-sweep-complexity" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Time</strong>: $O(L + H)$ where $L$ is the number of live objects (mark phase) and $H$ is the heap size (sweep phase). Note the sweep must scan the entire heap.</li>
<li><strong>Space</strong>: One mark bit per object (can be stored in the object header).</li>
<li><strong>Pause time</strong>: Proportional to heap size (both mark and sweep phases must complete before the program resumes).</li>
</ul>
<hr />
<h2 id="5-mark-compact-collection">5. Mark-Compact Collection<a class="header-link" href="#5-mark-compact-collection" title="Permanent link">&para;</a></h2>
<h3 id="51-motivation">5.1 Motivation<a class="header-link" href="#51-motivation" title="Permanent link">&para;</a></h3>
<p>Mark-sweep leaves the heap fragmented: live objects are scattered among free blocks. <strong>Mark-compact</strong> eliminates fragmentation by sliding all live objects to one end of the heap.</p>
<div class="highlight"><pre><span></span><code><span class="k">Before</span><span class="w"> </span><span class="nl">compaction</span><span class="p">:</span>
<span class="w">  </span><span class="o">[</span><span class="n">A</span><span class="o">][</span><span class="n">FREE</span><span class="o">][</span><span class="n">B</span><span class="o">][</span><span class="n">FREE</span><span class="o">][</span><span class="n">FREE</span><span class="o">][</span><span class="n">C</span><span class="o">][</span><span class="n">D</span><span class="o">][</span><span class="n">FREE</span><span class="o">][</span><span class="n">E</span><span class="o">][</span><span class="n">FREE</span><span class="o">]</span>

<span class="k">After</span><span class="w"> </span><span class="nl">compaction</span><span class="p">:</span>
<span class="w">  </span><span class="o">[</span><span class="n">A</span><span class="o">][</span><span class="n">B</span><span class="o">][</span><span class="n">C</span><span class="o">][</span><span class="n">D</span><span class="o">][</span><span class="n">E</span><span class="o">][</span><span class="n">FREE FREE FREE FREE FREE...</span><span class="o">]</span>
</code></pre></div>

<h3 id="52-algorithm">5.2 Algorithm<a class="header-link" href="#52-algorithm" title="Permanent link">&para;</a></h3>
<p>Mark-compact works in three (or four) passes:</p>
<ol>
<li><strong>Mark</strong>: Same as mark-sweep -- mark all reachable objects.</li>
<li><strong>Compute forwarding addresses</strong>: Scan the heap, assigning each live object its new address (where it will move to).</li>
<li><strong>Update references</strong>: Scan all objects, replacing each pointer with its forwarding address.</li>
<li><strong>Compact</strong>: Move each object to its forwarding address.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">MarkCompactGC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mark-Compact garbage collector.</span>

<span class="sd">    Eliminates fragmentation by compacting live objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heap_size</span><span class="o">=</span><span class="mi">256</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span> <span class="o">=</span> <span class="n">heap_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># list of dicts with &#39;name&#39;, &#39;size&#39;, &#39;addr&#39;, &#39;references&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_addr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_addr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="s2">&quot;Out of memory after compaction&quot;</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span>
            <span class="s1">&#39;addr&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">next_addr</span><span class="p">,</span>
            <span class="s1">&#39;marked&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;forward&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>      <span class="c1"># Forwarding address</span>
            <span class="s1">&#39;references&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_addr</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Mark-Compact GC ---&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_print_heap</span><span class="p">(</span><span class="s2">&quot;Before&quot;</span><span class="p">)</span>

        <span class="c1"># Phase 1: Mark</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">worklist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]:</span>
                <span class="k">continue</span>
            <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">ref</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]:</span>
                    <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

        <span class="c1"># Phase 2: Compute forwarding addresses</span>
        <span class="n">compact_addr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]:</span>
                <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;forward&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">compact_addr</span>
                <span class="n">compact_addr</span> <span class="o">+=</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;forward&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Garbage: </span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> at addr </span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;addr&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Phase 3: Update references</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]:</span>
                <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">ref</span> <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]</span> <span class="k">if</span> <span class="n">ref</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]</span>
                <span class="p">]</span>

        <span class="c1"># Phase 4: Compact (move objects)</span>
        <span class="n">live_objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]:</span>
                <span class="n">old_addr</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;addr&#39;</span><span class="p">]</span>
                <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;addr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;forward&#39;</span><span class="p">]</span>
                <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;forward&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;marked&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">live_objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">old_addr</span> <span class="o">!=</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;addr&#39;</span><span class="p">]:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Moved </span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">old_addr</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;addr&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="n">live_objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">next_addr</span> <span class="o">=</span> <span class="n">compact_addr</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_print_heap</span><span class="p">(</span><span class="s2">&quot;After&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_print_heap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="n">bar</span> <span class="o">=</span> <span class="s2">&quot;#&quot;</span> <span class="o">*</span> <span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">refs</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]]</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  [</span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;addr&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">3d</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">5s</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">bar</span><span class="si">}</span><span class="s2"> &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;(size=</span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, refs=</span><span class="si">{</span><span class="n">refs</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Next free address: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">next_addr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Free space: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">next_addr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_mark_compact</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate mark-compact GC.&quot;&quot;&quot;</span>
    <span class="n">gc</span> <span class="o">=</span> <span class="n">MarkCompactGC</span><span class="p">(</span><span class="n">heap_size</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Mark-Compact GC Demo ===&quot;</span><span class="p">)</span>

    <span class="c1"># Allocate objects</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">root_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>

    <span class="c1"># root -&gt; A -&gt; C, root -&gt; E</span>
    <span class="n">root</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span>
    <span class="n">a</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>
    <span class="c1"># B and D are unreachable</span>

    <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

<span class="n">demonstrate_mark_compact</span><span class="p">()</span>
</code></pre></div>

<h3 id="53-trade-offs">5.3 Trade-offs<a class="header-link" href="#53-trade-offs" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Mark-Sweep</th>
<th>Mark-Compact</th>
</tr>
</thead>
<tbody>
<tr>
<td>Fragmentation</td>
<td>Yes</td>
<td>No</td>
</tr>
<tr>
<td>Allocation speed</td>
<td>Slow (free list search)</td>
<td>Fast (bump pointer)</td>
</tr>
<tr>
<td>Collection passes</td>
<td>2</td>
<td>3-4</td>
</tr>
<tr>
<td>Object movement</td>
<td>No</td>
<td>Yes (need to update all pointers)</td>
</tr>
<tr>
<td>Cache locality</td>
<td>Poor (scattered)</td>
<td>Good (compacted)</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6-copying-collectors">6. Copying Collectors<a class="header-link" href="#6-copying-collectors" title="Permanent link">&para;</a></h2>
<h3 id="61-semi-space-collector">6.1 Semi-Space Collector<a class="header-link" href="#61-semi-space-collector" title="Permanent link">&para;</a></h3>
<p>The <strong>semi-space</strong> copying collector divides the heap into two halves: <strong>from-space</strong> and <strong>to-space</strong>. Allocation happens in from-space using a bump pointer. During collection, live objects are copied to to-space, and the spaces are swapped.</p>
<div class="highlight"><pre><span></span><code><span class="k">Before</span><span class="w"> </span><span class="nl">collection</span><span class="p">:</span>
<span class="w">  </span><span class="k">From</span><span class="o">-</span><span class="nf">space</span><span class="err">:</span><span class="w"> </span><span class="o">[</span><span class="n">A</span><span class="o">][</span><span class="n">B</span><span class="o">][</span><span class="n">C</span><span class="o">][</span><span class="n">D</span><span class="o">][</span><span class="n">E</span><span class="o">]</span><span class="w">  </span><span class="p">(</span><span class="n">A</span><span class="p">,</span><span class="w"> </span><span class="n">C</span><span class="p">,</span><span class="w"> </span><span class="n">E</span><span class="w"> </span><span class="k">are</span><span class="w"> </span><span class="n">live</span><span class="p">)</span>
<span class="w">  </span><span class="k">To</span><span class="o">-</span><span class="nf">space</span><span class="err">:</span><span class="w">   </span><span class="o">[</span><span class="n">empty..........</span><span class="o">]</span>

<span class="k">After</span><span class="w"> </span><span class="nl">collection</span><span class="p">:</span>
<span class="w">  </span><span class="k">To</span><span class="o">-</span><span class="nf">space</span><span class="err">:</span><span class="w">   </span><span class="o">[</span><span class="n">A</span><span class="o">][</span><span class="n">C</span><span class="o">][</span><span class="n">E</span><span class="o">][</span><span class="n">free..</span><span class="o">]</span><span class="w">   </span><span class="p">(</span><span class="n">now</span><span class="w"> </span><span class="n">becomes</span><span class="w"> </span><span class="k">from</span><span class="o">-</span><span class="nf">space</span><span class="p">)</span>
<span class="w">  </span><span class="k">From</span><span class="o">-</span><span class="nf">space</span><span class="err">:</span><span class="w"> </span><span class="o">[</span><span class="n">abandoned.........</span><span class="o">]</span><span class="w">  </span><span class="p">(</span><span class="n">now</span><span class="w"> </span><span class="n">becomes</span><span class="w"> </span><span class="k">to</span><span class="o">-</span><span class="nf">space</span><span class="p">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SemiSpaceGC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Semi-space copying garbage collector.</span>

<span class="sd">    Key idea: Copy live objects from &#39;from-space&#39; to &#39;to-space&#39;,</span>
<span class="sd">    then swap the spaces.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heap_size</span><span class="o">=</span><span class="mi">256</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">space_size</span> <span class="o">=</span> <span class="n">heap_size</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="c1"># Each space is a list of objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_space</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_space</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_used</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collections</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">8</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Allocate in from-space using bump pointer.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_used</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">space_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">from_used</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">space_size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="s2">&quot;Out of memory&quot;</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span>
            <span class="s1">&#39;references&#39;</span><span class="p">:</span> <span class="p">[],</span>
            <span class="s1">&#39;forwarding&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># Points to copy in to-space</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_space</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_used</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Cheney&#39;s breadth-first copying collection.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collections</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Copying GC #</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">collections</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;From-space: </span><span class="si">{</span><span class="p">[</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">from_space</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">to_space</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">to_used</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">scan_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Copy roots</span>
        <span class="n">new_roots</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="p">:</span>
            <span class="n">copied</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
            <span class="n">new_roots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copied</span><span class="p">)</span>
            <span class="n">to_used</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>

        <span class="c1"># Cheney&#39;s scanning: breadth-first traversal</span>
        <span class="k">while</span> <span class="n">scan_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_space</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_space</span><span class="p">[</span><span class="n">scan_index</span><span class="p">]</span>
            <span class="n">new_refs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]:</span>
                <span class="n">copied_ref</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>
                <span class="n">new_refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copied_ref</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">copied_ref</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_space</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">to_space</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copied_ref</span><span class="p">)</span>
                    <span class="n">to_used</span> <span class="o">+=</span> <span class="n">copied_ref</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
            <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_refs</span>
            <span class="n">scan_index</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># Swap spaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_space</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_space</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_space</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_used</span> <span class="o">=</span> <span class="n">to_used</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span> <span class="o">=</span> <span class="n">new_roots</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;To-space (new from): </span><span class="si">{</span><span class="p">[</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">from_space</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Copied </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">from_space</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">from_used</span><span class="si">}</span><span class="s2"> bytes&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copy an object to to-space (if not already copied).</span>
<span class="sd">        Uses forwarding pointer to avoid duplicate copies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;forwarding&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;forwarding&#39;</span><span class="p">]</span>

        <span class="c1"># Create copy in to-space</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">],</span>
            <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">],</span>
            <span class="s1">&#39;references&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]),</span>  <span class="c1"># Will be updated</span>
            <span class="s1">&#39;forwarding&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="c1"># Set forwarding pointer in original</span>
        <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;forwarding&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">copy</span>

        <span class="c1"># Add to to-space</span>
        <span class="k">if</span> <span class="n">copy</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_space</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_space</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Copied: </span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">copy</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_copying_gc</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate semi-space copying GC.&quot;&quot;&quot;</span>
    <span class="n">gc</span> <span class="o">=</span> <span class="n">SemiSpaceGC</span><span class="p">(</span><span class="n">heap_size</span><span class="o">=</span><span class="mi">400</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Copying GC Demo ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">root</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">root_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>   <span class="c1"># Will be garbage</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;C&quot;</span><span class="p">,</span> <span class="mi">32</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;D&quot;</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>   <span class="c1"># Will be garbage</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;E&quot;</span><span class="p">,</span> <span class="mi">24</span><span class="p">)</span>

    <span class="c1"># root -&gt; A -&gt; C, root -&gt; E</span>
    <span class="n">root</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span> <span class="n">e</span><span class="p">]</span>
    <span class="n">a</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Allocated </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">from_space</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects, </span><span class="si">{</span><span class="n">gc</span><span class="o">.</span><span class="n">from_used</span><span class="si">}</span><span class="s2"> bytes&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Live: root, A, C, E  |  Garbage: B, D&quot;</span><span class="p">)</span>

    <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After GC: </span><span class="si">{</span><span class="n">gc</span><span class="o">.</span><span class="n">from_used</span><span class="si">}</span><span class="s2"> bytes in use &quot;</span>
          <span class="sa">f</span><span class="s2">&quot;(freed </span><span class="si">{</span><span class="mi">120</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">gc</span><span class="o">.</span><span class="n">from_used</span><span class="si">}</span><span class="s2"> bytes from B and D)&quot;</span><span class="p">)</span>

<span class="n">demonstrate_copying_gc</span><span class="p">()</span>
</code></pre></div>

<h3 id="62-cheneys-algorithm">6.2 Cheney's Algorithm<a class="header-link" href="#62-cheneys-algorithm" title="Permanent link">&para;</a></h3>
<p>The key insight of <strong>Cheney's algorithm</strong> (1970) is that breadth-first copying can be done using the to-space itself as the worklist queue, requiring <strong>no additional memory</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="k">To</span><span class="o">-</span><span class="nf">space</span><span class="err">:</span>
<span class="w">  </span><span class="o">[</span><span class="n">root</span><span class="o">][</span><span class="n">A</span><span class="o">]</span><span class="p">...</span><span class="o">[</span><span class="n">E</span><span class="o">]</span><span class="p">...</span><span class="o">[</span><span class="n">C</span><span class="o">]</span><span class="p">...</span>
<span class="w">   </span><span class="o">^</span><span class="n">scan</span><span class="w">      </span><span class="o">^</span><span class="k">free</span>

<span class="n">scan</span><span class="w"> </span><span class="nl">pointer</span><span class="p">:</span><span class="w"> </span><span class="k">next</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">process</span><span class="w"> </span><span class="p">(</span><span class="n">scan</span><span class="w"> </span><span class="n">its</span><span class="w"> </span><span class="k">references</span><span class="p">)</span>
<span class="k">free</span><span class="w"> </span><span class="nl">pointer</span><span class="p">:</span><span class="w"> </span><span class="k">next</span><span class="w"> </span><span class="k">free</span><span class="w"> </span><span class="n">location</span><span class="w"> </span><span class="p">(</span><span class="k">where</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">copy</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="k">next</span><span class="w"> </span><span class="k">object</span><span class="p">)</span>

<span class="k">When</span><span class="w"> </span><span class="n">scan</span><span class="w"> </span><span class="n">catches</span><span class="w"> </span><span class="n">up</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">free</span><span class="p">,</span><span class="w"> </span><span class="n">collection</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">complete</span><span class="p">.</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">cheneys_algorithm_detailed</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Detailed simulation of Cheney&#39;s algorithm showing scan/free pointers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Cheney&#39;s Algorithm Trace ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Simulate objects as (name, size, references)</span>
    <span class="n">objects</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;root&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span> <span class="s1">&#39;refs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;E&#39;</span><span class="p">]},</span>
        <span class="s1">&#39;A&#39;</span><span class="p">:</span>    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span> <span class="s1">&#39;refs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">]},</span>
        <span class="s1">&#39;B&#39;</span><span class="p">:</span>    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;refs&#39;</span><span class="p">:</span> <span class="p">[]},</span>          <span class="c1"># Garbage</span>
        <span class="s1">&#39;C&#39;</span><span class="p">:</span>    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">32</span><span class="p">,</span> <span class="s1">&#39;refs&#39;</span><span class="p">:</span> <span class="p">[]},</span>
        <span class="s1">&#39;D&#39;</span><span class="p">:</span>    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">16</span><span class="p">,</span> <span class="s1">&#39;refs&#39;</span><span class="p">:</span> <span class="p">[]},</span>          <span class="c1"># Garbage</span>
        <span class="s1">&#39;E&#39;</span><span class="p">:</span>    <span class="p">{</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="mi">24</span><span class="p">,</span> <span class="s1">&#39;refs&#39;</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]},</span>       <span class="c1"># Note: E -&gt; A</span>
    <span class="p">}</span>

    <span class="c1"># To-space: flat array with scan and free pointers</span>
    <span class="n">to_space</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">copied</span> <span class="o">=</span> <span class="p">{}</span>   <span class="c1"># old name -&gt; to-space index</span>
    <span class="n">scan</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">free</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">copy_object</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
        <span class="k">nonlocal</span> <span class="n">free</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">copied</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">copied</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">objects</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_space</span><span class="p">)</span>
        <span class="n">to_space</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span> <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">],</span> <span class="s1">&#39;refs&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">])})</span>
        <span class="n">copied</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span>
        <span class="n">free</span> <span class="o">+=</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Copy </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> to to-space[</span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">] (free=</span><span class="si">{</span><span class="n">free</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idx</span>

    <span class="c1"># Step 1: Copy root</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Step 1: Copy root to to-space&quot;</span><span class="p">)</span>
    <span class="n">copy_object</span><span class="p">(</span><span class="s1">&#39;root&#39;</span><span class="p">)</span>

    <span class="c1"># Step 2: Scan loop</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">scan_idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">scan_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_space</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">to_space</span><span class="p">[</span><span class="n">scan_idx</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Step </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2">: Scan </span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (scan_idx=</span><span class="si">{</span><span class="n">scan_idx</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

        <span class="n">new_refs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ref_name</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">]:</span>
            <span class="n">to_idx</span> <span class="o">=</span> <span class="n">copy_object</span><span class="p">(</span><span class="n">ref_name</span><span class="p">)</span>
            <span class="n">new_refs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">to_space</span><span class="p">[</span><span class="n">to_idx</span><span class="p">][</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>

        <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_refs</span>
        <span class="n">scan_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Done! scan=</span><span class="si">{</span><span class="n">scan_idx</span><span class="si">}</span><span class="s2">, to-space has </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">to_space</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;To-space contents:&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">to_space</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  [</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">] </span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> (size=</span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">, refs=</span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Garbage not copied: B, D&quot;</span><span class="p">)</span>

<span class="n">cheneys_algorithm_detailed</span><span class="p">()</span>
</code></pre></div>

<h3 id="63-trade-offs-of-copying-collection">6.3 Trade-offs of Copying Collection<a class="header-link" href="#63-trade-offs-of-copying-collection" title="Permanent link">&para;</a></h3>
<p><strong>Advantages</strong>:
- Fast allocation (bump pointer -- just increment a counter)
- No fragmentation (objects are compacted during copy)
- Collection time proportional to live data only (dead objects are simply abandoned)
- Improves cache locality (objects copied in traversal order)</p>
<p><strong>Disadvantages</strong>:
- Wastes half the heap (only one semi-space is usable at a time)
- Must copy every live object every collection (expensive if most data is long-lived)
- Must update all pointers to moved objects</p>
<p><strong>Key complexity</strong>: Collection time is $O(L)$ where $L$ is the size of live data, compared to $O(L + H)$ for mark-sweep ($H$ = total heap size).</p>
<hr />
<h2 id="7-generational-collection">7. Generational Collection<a class="header-link" href="#7-generational-collection" title="Permanent link">&para;</a></h2>
<h3 id="71-the-generational-hypothesis">7.1 The Generational Hypothesis<a class="header-link" href="#71-the-generational-hypothesis" title="Permanent link">&para;</a></h3>
<p>The <strong>generational hypothesis</strong> (also called the "infant mortality" or "weak generational hypothesis") states:</p>
<blockquote>
<p>Most objects die young.</p>
</blockquote>
<p>Empirical studies across many languages consistently show that the majority of allocations become garbage very quickly. This distribution typically follows a "bathtub curve":</p>
<div class="highlight"><pre><span></span><code><span class="n">Object</span><span class="w"> </span><span class="n">Survival</span><span class="w"> </span><span class="n">Rate</span>
<span class="w">     </span><span class="o">^</span>
<span class="mi">100</span><span class="o">%</span><span class="w"> </span><span class="o">|*</span>
<span class="w">     </span><span class="o">|</span><span class="w">  </span><span class="o">*</span>
<span class="w">     </span><span class="o">|</span><span class="w">    </span><span class="o">*</span>
<span class="w">     </span><span class="o">|</span><span class="w">      </span><span class="o">**</span>
<span class="w">     </span><span class="o">|</span><span class="w">         </span><span class="o">****</span>
<span class="w">     </span><span class="o">|</span><span class="w">              </span><span class="o">********************</span><span class="w">  </span><span class="p">(</span><span class="n">long</span><span class="o">-</span><span class="n">lived</span><span class="w"> </span><span class="n">objects</span><span class="p">)</span>
<span class="w">     </span><span class="o">+------------------------------------&gt;</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">Age</span>
<span class="w">       </span><span class="n">Young</span><span class="w">                    </span><span class="n">Old</span>
</code></pre></div>

<h3 id="72-generational-gc-design">7.2 Generational GC Design<a class="header-link" href="#72-generational-gc-design" title="Permanent link">&para;</a></h3>
<p>Based on this hypothesis, generational GC divides the heap into generations:</p>
<div class="highlight"><pre><span></span><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Heap                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Young Gen  â”‚                Old Generation                 â”‚
â”‚   (Nursery)  â”‚               (Tenured)                       â”‚
â”‚              â”‚                                               â”‚
â”‚  Small, fast â”‚  Large, collected infrequently                â”‚
â”‚  collected   â”‚                                               â”‚
â”‚  frequently  â”‚                                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    ~10%      â”‚                    ~90%                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></div>

<ul>
<li>New objects are allocated in the <strong>young generation</strong> (nursery).</li>
<li>The nursery is collected frequently (minor GC) -- most objects there are dead.</li>
<li>Objects that survive several nursery collections are <strong>promoted</strong> (tenured) to the old generation.</li>
<li>The old generation is collected infrequently (major GC).</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">GenerationalGC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Two-generation garbage collector.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nursery_size</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">old_size</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">promotion_threshold</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nursery_size</span> <span class="o">=</span> <span class="n">nursery_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">old_size</span> <span class="o">=</span> <span class="n">old_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">promotion_threshold</span> <span class="o">=</span> <span class="n">promotion_threshold</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nursery</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">old_gen</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nursery_used</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">old_used</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Write barrier: track old-to-young pointers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remembered_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">minor_collections</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">major_collections</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">allocate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Allocate in nursery (young generation).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery_used</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery_size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">minor_gc</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery_used</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery_size</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">major_gc</span><span class="p">()</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery_used</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery_size</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">MemoryError</span><span class="p">(</span><span class="s2">&quot;Out of memory&quot;</span><span class="p">)</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="n">name</span><span class="p">,</span>
            <span class="s1">&#39;size&#39;</span><span class="p">:</span> <span class="n">size</span><span class="p">,</span>
            <span class="s1">&#39;generation&#39;</span><span class="p">:</span> <span class="s1">&#39;young&#39;</span><span class="p">,</span>
            <span class="s1">&#39;age&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>          <span class="c1"># Number of GCs survived</span>
            <span class="s1">&#39;marked&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;references&#39;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nursery</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nursery_used</span> <span class="o">+=</span> <span class="n">size</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_barrier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write barrier: called when source.field = target.</span>

<span class="sd">        If source is in old gen and target is in nursery,</span>
<span class="sd">        record source in the remembered set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">source</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">source</span><span class="p">[</span><span class="s1">&#39;generation&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;old&#39;</span> <span class="ow">and</span> <span class="n">target</span><span class="p">[</span><span class="s1">&#39;generation&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;young&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remembered_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">source</span><span class="p">))</span>
            <span class="c1"># In practice, we&#39;d store the actual object reference</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">minor_gc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Collect the nursery (young generation).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minor_collections</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Minor GC #</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">minor_collections</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Nursery: </span><span class="si">{</span><span class="p">[</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">o</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">nursery</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Roots for nursery collection:</span>
        <span class="c1"># 1. Program roots that point into nursery</span>
        <span class="c1"># 2. Old-to-young references (remembered set)</span>
        <span class="n">nursery_roots</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">root</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;generation&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;young&#39;</span><span class="p">:</span>
                <span class="n">nursery_roots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
            <span class="c1"># Also trace from roots into nursery</span>
            <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">root</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">ref</span><span class="p">[</span><span class="s1">&#39;generation&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;young&#39;</span><span class="p">:</span>
                    <span class="n">nursery_roots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>

        <span class="c1"># Trace from old gen (via remembered set)</span>
        <span class="k">for</span> <span class="n">old_obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_gen</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">old_obj</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">ref</span><span class="p">[</span><span class="s1">&#39;generation&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;young&#39;</span><span class="p">:</span>
                    <span class="n">nursery_roots</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>

        <span class="c1"># Mark reachable nursery objects</span>
        <span class="n">marked</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">worklist</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">nursery_roots</span><span class="p">]</span>

        <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">marked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">ref</span><span class="p">[</span><span class="s1">&#39;generation&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;young&#39;</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">:</span>
                    <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

        <span class="c1"># Process nursery objects</span>
        <span class="n">survivors</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">promoted</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">:</span>
                <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;age&#39;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">promotion_threshold</span><span class="p">:</span>
                    <span class="c1"># Promote to old generation</span>
                    <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;generation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;old&#39;</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">old_gen</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">old_used</span> <span class="o">+=</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
                    <span class="n">promoted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">survivors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">freed</span> <span class="o">+=</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Freed: </span><span class="si">{</span><span class="n">obj</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">nursery</span> <span class="o">=</span> <span class="n">survivors</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nursery_used</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">promoted</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Promoted to old gen: </span><span class="si">{</span><span class="n">promoted</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Freed </span><span class="si">{</span><span class="n">freed</span><span class="si">}</span><span class="s2"> bytes, </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nursery</span><span class="p">)</span><span class="si">}</span><span class="s2"> nursery objects remain&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">major_gc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Full heap collection (both generations).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">major_collections</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Major GC #</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">major_collections</span><span class="si">}</span><span class="s2"> ===&quot;</span><span class="p">)</span>

        <span class="n">all_objects</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_gen</span>

        <span class="c1"># Mark from roots</span>
        <span class="n">marked</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">worklist</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">worklist</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">worklist</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">marked</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">ref</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">:</span>
                    <span class="n">worklist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span>

        <span class="c1"># Sweep both generations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nursery</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">old_gen</span> <span class="o">=</span> <span class="p">[</span><span class="n">o</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_gen</span> <span class="k">if</span> <span class="nb">id</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="ow">in</span> <span class="n">marked</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nursery_used</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">old_used</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">o</span><span class="p">[</span><span class="s1">&#39;size&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">old_gen</span><span class="p">)</span>

        <span class="n">freed_count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_objects</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nursery</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">old_gen</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Freed </span><span class="si">{</span><span class="n">freed_count</span><span class="si">}</span><span class="s2"> objects&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  Nursery: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nursery_used</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nursery_size</span><span class="si">}</span><span class="s2"> &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nursery</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects)&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Old gen: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">old_used</span><span class="si">}</span><span class="s2">/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">old_size</span><span class="si">}</span><span class="s2"> &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">old_gen</span><span class="p">)</span><span class="si">}</span><span class="s2"> objects)&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_generational_gc</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate generational GC with promotions.&quot;&quot;&quot;</span>
    <span class="n">gc</span> <span class="o">=</span> <span class="n">GenerationalGC</span><span class="p">(</span><span class="n">nursery_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">old_size</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">promotion_threshold</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Generational GC Demo ===&quot;</span><span class="p">)</span>

    <span class="c1"># Create a long-lived root</span>
    <span class="n">root</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="s2">&quot;root&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">root_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

    <span class="c1"># Simulate workload: allocate temporary objects with some long-lived</span>
    <span class="k">for</span> <span class="n">wave</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Allocation wave </span><span class="si">{</span><span class="n">wave</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>

        <span class="c1"># Long-lived object (will eventually be promoted)</span>
        <span class="n">long_lived</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;L</span><span class="si">{</span><span class="n">wave</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
        <span class="n">root</span><span class="p">[</span><span class="s1">&#39;references&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">long_lived</span><span class="p">)</span>

        <span class="c1"># Short-lived temporaries</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">temp</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">allocate</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;T</span><span class="si">{</span><span class="n">wave</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
            <span class="c1"># temp is not referenced by anything persistent -&gt; garbage</span>

        <span class="n">gc</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>

    <span class="n">gc</span><span class="o">.</span><span class="n">status</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Total minor GCs: </span><span class="si">{</span><span class="n">gc</span><span class="o">.</span><span class="n">minor_collections</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total major GCs: </span><span class="si">{</span><span class="n">gc</span><span class="o">.</span><span class="n">major_collections</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">demonstrate_generational_gc</span><span class="p">()</span>
</code></pre></div>

<h3 id="73-write-barriers">7.3 Write Barriers<a class="header-link" href="#73-write-barriers" title="Permanent link">&para;</a></h3>
<p>The key challenge with generational GC: what if an old-generation object points to a nursery object? During minor GC, we only scan the nursery -- we would miss this reference!</p>
<p><strong>Write barriers</strong> solve this by intercepting every pointer store. If an old object is modified to point to a young object, the old object is added to the <strong>remembered set</strong> (also called the <strong>card table</strong>).</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CardTable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Card table write barrier implementation.</span>

<span class="sd">    The heap is divided into &#39;cards&#39; (e.g., 512-byte blocks).</span>
<span class="sd">    When a pointer in a card is modified, the card is marked dirty.</span>
<span class="sd">    During minor GC, only dirty cards are scanned.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heap_size</span><span class="p">,</span> <span class="n">card_size</span><span class="o">=</span><span class="mi">512</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">card_size</span> <span class="o">=</span> <span class="n">card_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cards</span> <span class="o">=</span> <span class="p">(</span><span class="n">heap_size</span> <span class="o">+</span> <span class="n">card_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="n">card_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cards</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cards</span>  <span class="c1"># False = clean, True = dirty</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mark_dirty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">address</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Mark the card containing this address as dirty.&quot;&quot;&quot;</span>
        <span class="n">card_index</span> <span class="o">=</span> <span class="n">address</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">card_size</span>
        <span class="k">if</span> <span class="n">card_index</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cards</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">[</span><span class="n">card_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_dirty_cards</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return indices of all dirty cards.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dirty</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">)</span> <span class="k">if</span> <span class="n">dirty</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clear all dirty bits after scanning.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cards</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cards</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;D&#39;</span> <span class="k">if</span> <span class="n">d</span> <span class="k">else</span> <span class="s1">&#39;.&#39;</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cards</span><span class="p">)</span>


<span class="c1"># Example</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Card Table Write Barrier ===&quot;</span><span class="p">)</span>
<span class="n">ct</span> <span class="o">=</span> <span class="n">CardTable</span><span class="p">(</span><span class="n">heap_size</span><span class="o">=</span><span class="mi">4096</span><span class="p">,</span> <span class="n">card_size</span><span class="o">=</span><span class="mi">512</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Card table (</span><span class="si">{</span><span class="n">ct</span><span class="o">.</span><span class="n">num_cards</span><span class="si">}</span><span class="s2"> cards): </span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Simulate pointer writes at various addresses</span>
<span class="n">writes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">100</span><span class="p">,</span> <span class="mi">600</span><span class="p">,</span> <span class="mi">1200</span><span class="p">,</span> <span class="mi">3500</span><span class="p">]</span>
<span class="k">for</span> <span class="n">addr</span> <span class="ow">in</span> <span class="n">writes</span><span class="p">:</span>
    <span class="n">ct</span><span class="o">.</span><span class="n">mark_dirty</span><span class="p">(</span><span class="n">addr</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Write at addr </span><span class="si">{</span><span class="n">addr</span><span class="si">}</span><span class="s2"> -&gt; card </span><span class="si">{</span><span class="n">addr</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="mi">512</span><span class="si">}</span><span class="s2"> dirty&quot;</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Card table: </span><span class="si">{</span><span class="n">ct</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dirty cards to scan: </span><span class="si">{</span><span class="n">ct</span><span class="o">.</span><span class="n">get_dirty_cards</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="74-multi-generation-schemes">7.4 Multi-Generation Schemes<a class="header-link" href="#74-multi-generation-schemes" title="Permanent link">&para;</a></h3>
<p>Many production collectors use more than two generations:</p>
<div class="highlight"><pre><span></span><code><span class="nv">JVM</span><span class="w"> </span><span class="nv">Generational</span><span class="w"> </span><span class="nv">Layout</span>:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚<span class="w">   </span><span class="nv">Young</span><span class="w"> </span><span class="nv">Gen</span><span class="w">    </span>â”‚<span class="w">          </span><span class="nv">Old</span><span class="w"> </span><span class="nv">Generation</span><span class="w">               </span>â”‚
â”œâ”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¤<span class="w">                                       </span>â”‚
â”‚<span class="nv">Eden</span>â”‚<span class="w"> </span><span class="nv">S0</span><span class="w">  </span>â”‚<span class="w"> </span><span class="nv">S1</span><span class="w">  </span>â”‚<span class="w">                                       </span>â”‚
â”‚<span class="w">    </span>â”‚<span class="ss">(</span><span class="nv">from</span>â”‚<span class="ss">(</span><span class="nv">to</span><span class="ss">)</span><span class="w"> </span>â”‚<span class="w">                                       </span>â”‚
â”‚<span class="w">    </span>â”‚<span class="nv">surv</span><span class="ss">)</span>â”‚<span class="nv">surv</span><span class="ss">)</span>â”‚<span class="w">                                       </span>â”‚
â”œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚<span class="w"> </span><span class="nv">New</span><span class="w"> </span><span class="nv">objects</span><span class="w">     </span>â”‚<span class="w"> </span><span class="nv">Objects</span><span class="w"> </span><span class="nv">surviving</span><span class="w"> </span><span class="nv">multiple</span><span class="w">            </span>â”‚
â”‚<span class="w"> </span><span class="nv">allocated</span><span class="w"> </span><span class="nv">here</span><span class="w">  </span>â”‚<span class="w"> </span><span class="nv">minor</span><span class="w"> </span><span class="nv">GCs</span><span class="w"> </span><span class="nv">are</span><span class="w"> </span><span class="nv">promoted</span><span class="w"> </span><span class="nv">here</span><span class="w">           </span>â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

<span class="nv">Eden</span>:<span class="w"> </span><span class="nv">New</span><span class="w"> </span><span class="nv">allocations</span>
<span class="nv">S0</span><span class="o">/</span><span class="nv">S1</span>:<span class="w"> </span><span class="nv">Survivor</span><span class="w"> </span><span class="nv">spaces</span><span class="w"> </span><span class="ss">(</span><span class="nv">semi</span><span class="o">-</span><span class="nv">space</span><span class="w"> </span><span class="nv">copying</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">young</span><span class="w"> </span><span class="nv">gen</span><span class="ss">)</span>
<span class="nv">Old</span>:<span class="w"> </span><span class="nv">Long</span><span class="o">-</span><span class="nv">lived</span><span class="w"> </span><span class="nv">objects</span>
</code></pre></div>

<hr />
<h2 id="8-incremental-and-concurrent-gc">8. Incremental and Concurrent GC<a class="header-link" href="#8-incremental-and-concurrent-gc" title="Permanent link">&para;</a></h2>
<h3 id="81-the-pause-problem">8.1 The Pause Problem<a class="header-link" href="#81-the-pause-problem" title="Permanent link">&para;</a></h3>
<p>Stop-the-world GC pauses all application threads (called <strong>mutator</strong> threads) during collection. For interactive or real-time applications, these pauses are problematic.</p>
<table>
<thead>
<tr>
<th>Application</th>
<th>Acceptable Pause</th>
</tr>
</thead>
<tbody>
<tr>
<td>Batch processing</td>
<td>Seconds</td>
</tr>
<tr>
<td>Web server</td>
<td>100ms</td>
</tr>
<tr>
<td>Interactive UI</td>
<td>16ms (60 FPS)</td>
</tr>
<tr>
<td>Trading system</td>
<td>&lt; 1ms</td>
</tr>
<tr>
<td>Hard real-time</td>
<td>Never</td>
</tr>
</tbody>
</table>
<h3 id="82-incremental-collection">8.2 Incremental Collection<a class="header-link" href="#82-incremental-collection" title="Permanent link">&para;</a></h3>
<p><strong>Incremental GC</strong> breaks collection into small steps, interleaved with mutator execution:</p>
<div class="highlight"><pre><span></span><code>Stop-the-world:
  Mutator â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  GC                  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ

Incremental:
  Mutator â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
  GC            â–‘      â–‘      â–‘      â–‘
              (small increments)
</code></pre></div>

<p>The challenge: the mutator can modify the object graph while the collector is working.</p>
<h3 id="83-concurrent-collection">8.3 Concurrent Collection<a class="header-link" href="#83-concurrent-collection" title="Permanent link">&para;</a></h3>
<p><strong>Concurrent GC</strong> runs the collector on separate threads simultaneously with the mutator:</p>
<div class="highlight"><pre><span></span><code><span class="n">Concurrent</span><span class="o">:</span>
<span class="w">  </span><span class="n">Mutator</span><span class="w"> </span><span class="err">â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ</span>
<span class="w">  </span><span class="n">GC</span><span class="w">      </span><span class="err">â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘</span>
<span class="w">          </span><span class="o">(</span><span class="n">runs</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">separate</span><span class="w"> </span><span class="n">thread</span><span class="o">)</span>
</code></pre></div>

<p>This requires careful synchronization to handle concurrent modifications.</p>
<hr />
<h2 id="9-tri-color-marking">9. Tri-Color Marking<a class="header-link" href="#9-tri-color-marking" title="Permanent link">&para;</a></h2>
<h3 id="91-the-tri-color-abstraction">9.1 The Tri-Color Abstraction<a class="header-link" href="#91-the-tri-color-abstraction" title="Permanent link">&para;</a></h3>
<p>Tri-color marking provides a framework for reasoning about incremental and concurrent GC. Objects are classified into three colors:</p>
<ul>
<li><strong>White</strong>: Not yet visited (potentially garbage).</li>
<li><strong>Grey</strong>: Visited, but references not yet scanned.</li>
<li><strong>Black</strong>: Visited and all references scanned.</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">Invariant</span><span class="o">:</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="n">black</span><span class="w"> </span><span class="n">object</span><span class="w"> </span><span class="n">points</span><span class="w"> </span><span class="n">directly</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">white</span><span class="w"> </span><span class="n">object</span><span class="o">.</span>
<span class="w">           </span><span class="o">(</span><span class="n">All</span><span class="w"> </span><span class="n">references</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">black</span><span class="w"> </span><span class="n">objects</span><span class="w"> </span><span class="n">go</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">black</span><span class="w"> </span><span class="n">or</span><span class="w"> </span><span class="n">grey</span><span class="w"> </span><span class="n">objects</span><span class="o">.)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span><span class="w"> </span><span class="nc">Color</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">WHITE</span> <span class="o">=</span> <span class="s2">&quot;white&quot;</span>
    <span class="n">GREY</span> <span class="o">=</span> <span class="s2">&quot;grey&quot;</span>
    <span class="n">BLACK</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TriColorGC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Tri-color marking garbage collector.</span>

<span class="sd">    Demonstrates incremental collection using the tri-color abstraction.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># name -&gt; {&#39;color&#39;: Color, &#39;refs&#39;: [names]}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grey_set</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>  <span class="c1"># Worklist of grey objects</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">refs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;color&#39;</span><span class="p">:</span> <span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span><span class="p">,</span>
            <span class="s1">&#39;refs&#39;</span><span class="p">:</span> <span class="n">refs</span> <span class="ow">or</span> <span class="p">[],</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_root</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">init_marking</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize marking: color all roots grey.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Initialize Marking ===&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_set</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">name</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">GREY</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">grey_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Root </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> -&gt; GREY&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_print_state</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">mark_step</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        One incremental marking step: process one grey object.</span>

<span class="sd">        Returns True if there is more work to do.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">grey_set</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Pick a grey object</span>
        <span class="n">name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grey_set</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Mark step: Processing </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Scan its references</span>
        <span class="k">for</span> <span class="n">ref_name</span> <span class="ow">in</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">ref_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="n">ref_obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">ref_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">ref_obj</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span><span class="p">:</span>
                    <span class="n">ref_obj</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">GREY</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">grey_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ref_name</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">ref_name</span><span class="si">}</span><span class="s2">: WHITE -&gt; GREY&quot;</span><span class="p">)</span>

        <span class="c1"># Mark this object black</span>
        <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">BLACK</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: GREY -&gt; BLACK&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_print_state</span><span class="p">()</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grey_set</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sweep: collect all white objects.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Sweep ===&quot;</span><span class="p">)</span>
        <span class="n">garbage</span> <span class="o">=</span> <span class="p">[</span><span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                   <span class="k">if</span> <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">garbage</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Collected: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="c1"># Reset colors for next cycle</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">obj</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span>

        <span class="k">return</span> <span class="n">garbage</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_print_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">white</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">o</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span><span class="p">]</span>
        <span class="n">grey</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">o</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="n">GREY</span><span class="p">]</span>
        <span class="n">black</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">o</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="n">BLACK</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  State: WHITE=</span><span class="si">{</span><span class="n">white</span><span class="si">}</span><span class="s2">, GREY=</span><span class="si">{</span><span class="n">grey</span><span class="si">}</span><span class="s2">, BLACK=</span><span class="si">{</span><span class="n">black</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_tricolor</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate incremental tri-color marking.&quot;&quot;&quot;</span>
    <span class="n">gc</span> <span class="o">=</span> <span class="n">TriColorGC</span><span class="p">()</span>

    <span class="c1"># Create object graph</span>
    <span class="c1">#   root -&gt; A -&gt; C</span>
    <span class="c1">#        -&gt; B -&gt; D</span>
    <span class="c1">#   E (unreachable)</span>
    <span class="c1">#   F -&gt; G (both unreachable)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="s1">&#39;root&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">])</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;C&#39;</span><span class="p">])</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;D&#39;</span><span class="p">])</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="s1">&#39;D&#39;</span><span class="p">,</span> <span class="p">[])</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="s1">&#39;E&#39;</span><span class="p">,</span> <span class="p">[])</span>           <span class="c1"># Unreachable</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;G&#39;</span><span class="p">])</span>        <span class="c1"># Unreachable</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_object</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">,</span> <span class="p">[])</span>           <span class="c1"># Unreachable</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">add_root</span><span class="p">(</span><span class="s1">&#39;root&#39;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Tri-Color Marking Demo ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Object graph: root -&gt; {A -&gt; C, B -&gt; D}, E, F -&gt; G&quot;</span><span class="p">)</span>

    <span class="c1"># Initialize</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">init_marking</span><span class="p">()</span>

    <span class="c1"># Incremental marking steps</span>
    <span class="n">step</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">gc</span><span class="o">.</span><span class="n">mark_step</span><span class="p">():</span>
        <span class="n">step</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># Final step (returns False)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Marking complete after </span><span class="si">{</span><span class="n">step</span><span class="si">}</span><span class="s2"> steps&quot;</span><span class="p">)</span>

    <span class="c1"># Sweep</span>
    <span class="n">garbage</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">sweep</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Garbage collected: </span><span class="si">{</span><span class="n">garbage</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Surviving objects: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">gc</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">demonstrate_tricolor</span><span class="p">()</span>
</code></pre></div>

<h3 id="92-the-lost-object-problem">9.2 The Lost Object Problem<a class="header-link" href="#92-the-lost-object-problem" title="Permanent link">&para;</a></h3>
<p>If the mutator modifies the object graph during incremental marking, it can cause a live object to be missed (collected as garbage). This happens when:</p>
<ol>
<li>The mutator stores a reference from a black object to a white object.</li>
<li>The mutator deletes all grey-to-white paths to that white object.</li>
</ol>
<p>Now the white object is reachable but has no grey predecessor -- it will be collected!</p>
<div class="highlight"><pre><span></span><code><span class="kr">Before</span><span class="w"> </span><span class="n">mutator</span><span class="w"> </span><span class="n">action</span><span class="o">:</span>
<span class="w">  </span><span class="p">[</span><span class="n">BLACK</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">GREY</span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">WHITE</span><span class="o">:</span><span class="w"> </span><span class="n">C</span><span class="p">]</span>

<span class="n">Mutator</span><span class="w"> </span><span class="n">does</span><span class="o">:</span>
<span class="w">  </span><span class="n">A</span><span class="p">.</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">C</span><span class="w">     </span><span class="p">(</span><span class="n">black</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">white</span><span class="o">!</span><span class="p">)</span>
<span class="w">  </span><span class="n">B</span><span class="p">.</span><span class="n">ref</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">null</span><span class="w">  </span><span class="p">(</span><span class="n">removes</span><span class="w"> </span><span class="n">grey</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">white</span><span class="w"> </span><span class="n">path</span><span class="p">)</span>

<span class="n">After</span><span class="o">:</span>
<span class="w">  </span><span class="p">[</span><span class="n">BLACK</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">[</span><span class="n">WHITE</span><span class="o">:</span><span class="w"> </span><span class="n">C</span><span class="p">]</span><span class="w">    </span><span class="n">C</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">reachable</span><span class="w"> </span><span class="n">but</span><span class="w"> </span><span class="n">will</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">missed</span><span class="o">!</span>
<span class="w">  </span><span class="p">[</span><span class="n">GREY</span><span class="o">:</span><span class="w"> </span><span class="n">B</span><span class="p">]</span>
</code></pre></div>

<h3 id="93-write-barrier-solutions">9.3 Write Barrier Solutions<a class="header-link" href="#93-write-barrier-solutions" title="Permanent link">&para;</a></h3>
<p>Two approaches to prevent the lost object problem:</p>
<p><strong>Dijkstra's write barrier</strong> (snapshot-at-the-beginning): When the mutator stores a reference to a white object, grey the target.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">dijkstra_write_barrier</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">new_target</span><span class="p">,</span> <span class="n">gc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dijkstra&#39;s insertion barrier.</span>
<span class="sd">    When writing a reference, if the target is white, mark it grey.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">new_target</span> <span class="ow">and</span> <span class="n">gc</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">new_target</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span><span class="p">:</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">new_target</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">GREY</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">grey_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_target</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Barrier: </span><span class="si">{</span><span class="n">new_target</span><span class="si">}</span><span class="s2"> WHITE -&gt; GREY (insertion barrier)&quot;</span><span class="p">)</span>

    <span class="c1"># Perform the actual write</span>
    <span class="n">source_obj</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">]):</span>
        <span class="n">source_obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">][</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_target</span>
</code></pre></div>

<p><strong>Steele's write barrier</strong> (incremental update): When a black object is modified, grey the source (re-scan it).</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">steele_write_barrier</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">new_target</span><span class="p">,</span> <span class="n">gc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Steele&#39;s write barrier.</span>
<span class="sd">    When a black object gets a new reference, mark it grey (rescan it).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source_obj</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">source_obj</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="n">BLACK</span><span class="p">:</span>
        <span class="n">source_obj</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">GREY</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">grey_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Barrier: </span><span class="si">{</span><span class="n">source</span><span class="si">}</span><span class="s2"> BLACK -&gt; GREY (rescan)&quot;</span><span class="p">)</span>

    <span class="c1"># Perform the actual write</span>
    <span class="k">if</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">]):</span>
        <span class="n">source_obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">][</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_target</span>
</code></pre></div>

<h3 id="94-yuasas-snapshot-at-the-beginning">9.4 Yuasa's Snapshot-at-the-Beginning<a class="header-link" href="#94-yuasas-snapshot-at-the-beginning" title="Permanent link">&para;</a></h3>
<p>Yuasa's deletion barrier ensures that no white object loses its last grey predecessor. When deleting a reference, if the old target is white, mark it grey:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">yuasa_write_barrier</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">new_target</span><span class="p">,</span> <span class="n">gc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Yuasa&#39;s deletion barrier (snapshot-at-the-beginning).</span>
<span class="sd">    When overwriting a reference, grey the OLD target if it&#39;s white.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source_obj</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">source</span><span class="p">]</span>
    <span class="n">old_target</span> <span class="o">=</span> <span class="n">source_obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">][</span><span class="n">field</span><span class="p">]</span> <span class="k">if</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">])</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">if</span> <span class="n">old_target</span> <span class="ow">and</span> <span class="n">gc</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">old_target</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="n">Color</span><span class="o">.</span><span class="n">WHITE</span><span class="p">:</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">old_target</span><span class="p">][</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">Color</span><span class="o">.</span><span class="n">GREY</span>
        <span class="n">gc</span><span class="o">.</span><span class="n">grey_set</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old_target</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Barrier: </span><span class="si">{</span><span class="n">old_target</span><span class="si">}</span><span class="s2"> WHITE -&gt; GREY (deletion barrier)&quot;</span><span class="p">)</span>

    <span class="c1"># Perform the actual write</span>
    <span class="k">if</span> <span class="n">field</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">]):</span>
        <span class="n">source_obj</span><span class="p">[</span><span class="s1">&#39;refs&#39;</span><span class="p">][</span><span class="n">field</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_target</span>
</code></pre></div>

<hr />
<h2 id="10-gc-in-real-systems">10. GC in Real Systems<a class="header-link" href="#10-gc-in-real-systems" title="Permanent link">&para;</a></h2>
<h3 id="101-jvm-garbage-collectors">10.1 JVM Garbage Collectors<a class="header-link" href="#101-jvm-garbage-collectors" title="Permanent link">&para;</a></h3>
<p>The JVM offers multiple GC implementations:</p>
<table>
<thead>
<tr>
<th>Collector</th>
<th>Type</th>
<th>Generations</th>
<th>Pause Goal</th>
<th>Best For</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Serial GC</strong></td>
<td>Stop-the-world</td>
<td>Young + Old</td>
<td>None</td>
<td>Small heaps, single core</td>
</tr>
<tr>
<td><strong>Parallel GC</strong></td>
<td>Stop-the-world, parallel</td>
<td>Young + Old</td>
<td>Throughput</td>
<td>Batch, background</td>
</tr>
<tr>
<td><strong>CMS</strong> (deprecated)</td>
<td>Concurrent mark-sweep</td>
<td>Young + Old</td>
<td>Low latency</td>
<td>Deprecated in JDK 14</td>
</tr>
<tr>
<td><strong>G1</strong></td>
<td>Region-based, concurrent</td>
<td>Young + Old</td>
<td>Configurable</td>
<td>General purpose (default)</td>
</tr>
<tr>
<td><strong>ZGC</strong></td>
<td>Concurrent, region-based</td>
<td>No generations*</td>
<td>&lt; 10ms</td>
<td>Large heaps (TB-scale)</td>
</tr>
<tr>
<td><strong>Shenandoah</strong></td>
<td>Concurrent, compact</td>
<td>No generations*</td>
<td>&lt; 10ms</td>
<td>Low latency</td>
</tr>
</tbody>
</table>
<p><strong>G1 (Garbage First) Collector</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">G1</span><span class="w"> </span><span class="n">Heap</span><span class="w"> </span><span class="n">Layout</span><span class="w"> </span><span class="p">(</span><span class="n">region</span><span class="o">-</span><span class="n">based</span><span class="p">)</span><span class="o">:</span>

<span class="err">â”Œâ”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”</span>
<span class="err">â”‚</span><span class="n">E</span><span class="w"> </span><span class="err">â”‚</span><span class="n">E</span><span class="w"> </span><span class="err">â”‚</span><span class="n">S</span><span class="w"> </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="n">O</span><span class="w"> </span><span class="err">â”‚</span><span class="n">O</span><span class="w"> </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="n">O</span><span class="w"> </span><span class="err">â”‚</span><span class="n">H</span><span class="w"> </span><span class="err">â”œâ”€â”€â”¤</span><span class="w">  </span><span class="err">â”‚</span><span class="n">E</span><span class="w"> </span><span class="err">â”‚</span><span class="n">O</span><span class="w"> </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="n">S</span><span class="w"> </span><span class="err">â”‚</span><span class="n">O</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â””â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”˜</span>

<span class="n">E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Eden</span><span class="w"> </span><span class="p">(</span><span class="n">young</span><span class="p">)</span><span class="w">       </span><span class="n">S</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Survivor</span><span class="w"> </span><span class="p">(</span><span class="n">young</span><span class="p">)</span>
<span class="n">O</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Old</span><span class="w">                </span><span class="n">H</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Humongous</span><span class="w"> </span><span class="p">(</span><span class="k">large</span><span class="w"> </span><span class="n">objects</span><span class="p">,</span><span class="w"> </span><span class="n">spans</span><span class="w"> </span><span class="n">regions</span><span class="p">)</span>
<span class="p">(</span><span class="n">empty</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Free</span><span class="w"> </span><span class="n">region</span>

<span class="n">Key</span><span class="w"> </span><span class="nl">idea:</span><span class="w"> </span><span class="n">Collect</span><span class="w"> </span><span class="n">regions</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">most</span><span class="w"> </span><span class="n">garbage</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;garbage first&quot;</span><span class="p">).</span>
<span class="w">          </span><span class="n">Pause</span><span class="w"> </span><span class="kt">time</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">controlled</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">collecting</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">subset</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">regions</span><span class="p">.</span>
</code></pre></div>

<p><strong>ZGC</strong> key techniques:
- <strong>Colored pointers</strong>: Uses unused bits in 64-bit pointers for GC metadata
- <strong>Load barriers</strong>: Check and fix pointers on every load (not store)
- <strong>Concurrent relocation</strong>: Moves objects while mutators are running
- Pause times under 10ms regardless of heap size</p>
<h3 id="102-go-garbage-collector">10.2 Go Garbage Collector<a class="header-link" href="#102-go-garbage-collector" title="Permanent link">&para;</a></h3>
<p>Go uses a <strong>concurrent, tri-color mark-sweep</strong> collector:</p>
<ul>
<li>Non-generational (all objects are in one space)</li>
<li>Concurrent marking using Dijkstra's write barrier</li>
<li>STW pauses only for root scanning (typically &lt; 1ms)</li>
<li>Target: minimize latency (not maximize throughput)</li>
<li>Pacing: GC starts when heap grows to 2x the live set</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">Go</span><span class="w"> </span><span class="n">GC</span><span class="w"> </span><span class="nl">Phases</span><span class="p">:</span>
<span class="mf">1.</span><span class="w"> </span><span class="nl">STW</span><span class="p">:</span><span class="w"> </span><span class="n">Scan</span><span class="w"> </span><span class="n">stacks</span><span class="p">,</span><span class="w"> </span><span class="n">enable</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="n">barrier</span><span class="w">  </span><span class="p">(</span><span class="o">~</span><span class="mi">100</span><span class="n">Î¼s</span><span class="p">)</span>
<span class="mf">2.</span><span class="w"> </span><span class="nl">Concurrent</span><span class="p">:</span><span class="w"> </span><span class="n">Mark</span><span class="w"> </span><span class="n">phase</span><span class="w"> </span><span class="p">(</span><span class="n">mutators</span><span class="w"> </span><span class="n">run</span><span class="p">,</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="n">barrier</span><span class="w"> </span><span class="n">active</span><span class="p">)</span>
<span class="mf">3.</span><span class="w"> </span><span class="nl">STW</span><span class="p">:</span><span class="w"> </span><span class="n">Rescan</span><span class="p">,</span><span class="w"> </span><span class="n">disable</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="n">barrier</span><span class="w">      </span><span class="p">(</span><span class="o">~</span><span class="mi">100</span><span class="n">Î¼s</span><span class="p">)</span>
<span class="mf">4.</span><span class="w"> </span><span class="nl">Concurrent</span><span class="p">:</span><span class="w"> </span><span class="n">Sweep</span><span class="w"> </span><span class="n">phase</span>
</code></pre></div>

<h3 id="103-cpython-garbage-collector">10.3 CPython Garbage Collector<a class="header-link" href="#103-cpython-garbage-collector" title="Permanent link">&para;</a></h3>
<p>CPython uses a hybrid approach:</p>
<ul>
<li><strong>Primary</strong>: Reference counting (immediate reclamation)</li>
<li><strong>Secondary</strong>: Generational cycle detector (three generations)</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">gc</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

<span class="k">def</span><span class="w"> </span><span class="nf">cpython_gc_info</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Show CPython GC configuration and statistics.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== CPython GC Info ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># GC thresholds (generation 0, 1, 2)</span>
    <span class="n">thresholds</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_threshold</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Thresholds: Gen0=</span><span class="si">{</span><span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, Gen1=</span><span class="si">{</span><span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, Gen2=</span><span class="si">{</span><span class="n">thresholds</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Gen0: collected after </span><span class="si">{0}</span><span class="s2"> new allocations&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thresholds</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Gen1: collected after </span><span class="si">{0}</span><span class="s2"> Gen0 collections&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thresholds</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Gen2: collected after </span><span class="si">{0}</span><span class="s2"> Gen1 collections&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">thresholds</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

    <span class="c1"># Current counts</span>
    <span class="n">counts</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">get_count</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Current counts: Gen0=</span><span class="si">{</span><span class="n">counts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">, Gen1=</span><span class="si">{</span><span class="n">counts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, Gen2=</span><span class="si">{</span><span class="n">counts</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Reference count example</span>
    <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Reference count of a list: </span><span class="si">{</span><span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Note: getrefcount itself creates a temporary reference, so it&#39;s always +1</span>

    <span class="c1"># Demonstrate cycle detection</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Cycle detection demo:&quot;</span><span class="p">)</span>
    <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>  <span class="c1"># Clean slate</span>

    <span class="c1"># Create a cycle</span>
    <span class="k">class</span><span class="w"> </span><span class="nc">Node</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Node(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">)&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;X&quot;</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span><span class="s2">&quot;Y&quot;</span><span class="p">)</span>
    <span class="n">x</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">y</span>
    <span class="n">y</span><span class="o">.</span><span class="n">next</span> <span class="o">=</span> <span class="n">x</span>  <span class="c1"># Cycle!</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Created cycle: X -&gt; Y -&gt; X&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Ref count of X: </span><span class="si">{</span><span class="n">sys</span><span class="o">.</span><span class="n">getrefcount</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Subtract our ref</span>

    <span class="c1"># Delete local references</span>
    <span class="k">del</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span>

    <span class="c1"># Objects are NOT freed (cycle keeps them alive)</span>
    <span class="c1"># Run cycle detector</span>
    <span class="n">collected</span> <span class="o">=</span> <span class="n">gc</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  After gc.collect(): </span><span class="si">{</span><span class="n">collected</span><span class="si">}</span><span class="s2"> objects collected&quot;</span><span class="p">)</span>

<span class="n">cpython_gc_info</span><span class="p">()</span>
</code></pre></div>

<h3 id="104-rust-ownership-instead-of-gc">10.4 Rust: Ownership Instead of GC<a class="header-link" href="#104-rust-ownership-instead-of-gc" title="Permanent link">&para;</a></h3>
<p>Rust takes a radically different approach: <strong>no garbage collector at all</strong>. Instead, it uses a compile-time ownership system:</p>
<div class="highlight"><pre><span></span><code>Rust Ownership Rules:
1. Each value has exactly one owner
2. When the owner goes out of scope, the value is dropped (freed)
3. References can borrow values (immutably or mutably, but not both)
4. The borrow checker enforces these rules at compile time
</code></pre></div>

<p>This eliminates GC pauses entirely but requires the programmer to think about ownership. For cases where ownership is unclear, Rust provides:</p>
<ul>
<li><code>Rc&lt;T&gt;</code>: Reference counting (single-threaded)</li>
<li><code>Arc&lt;T&gt;</code>: Atomic reference counting (multi-threaded)</li>
<li>These can create cycles, handled by <code>Weak&lt;T&gt;</code> references</li>
</ul>
<h3 id="105-comparison">10.5 Comparison<a class="header-link" href="#105-comparison" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">gc_comparison</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compare GC characteristics across languages/runtimes.&quot;&quot;&quot;</span>
    <span class="n">collectors</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s1">&#39;system&#39;</span><span class="p">:</span> <span class="s1">&#39;JVM G1&#39;</span><span class="p">,</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Generational, region-based&#39;</span><span class="p">,</span>
            <span class="s1">&#39;concurrent&#39;</span><span class="p">:</span> <span class="s1">&#39;Mostly concurrent&#39;</span><span class="p">,</span>
            <span class="s1">&#39;pause&#39;</span><span class="p">:</span> <span class="s1">&#39;~10-200ms&#39;</span><span class="p">,</span>
            <span class="s1">&#39;throughput&#39;</span><span class="p">:</span> <span class="s1">&#39;High&#39;</span><span class="p">,</span>
            <span class="s1">&#39;heap_overhead&#39;</span><span class="p">:</span> <span class="s1">&#39;~10-20%&#39;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;system&#39;</span><span class="p">:</span> <span class="s1">&#39;JVM ZGC&#39;</span><span class="p">,</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Region-based, load barrier&#39;</span><span class="p">,</span>
            <span class="s1">&#39;concurrent&#39;</span><span class="p">:</span> <span class="s1">&#39;Fully concurrent&#39;</span><span class="p">,</span>
            <span class="s1">&#39;pause&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;10ms&#39;</span><span class="p">,</span>
            <span class="s1">&#39;throughput&#39;</span><span class="p">:</span> <span class="s1">&#39;Good&#39;</span><span class="p">,</span>
            <span class="s1">&#39;heap_overhead&#39;</span><span class="p">:</span> <span class="s1">&#39;~15%&#39;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;system&#39;</span><span class="p">:</span> <span class="s1">&#39;Go&#39;</span><span class="p">,</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Tri-color mark-sweep&#39;</span><span class="p">,</span>
            <span class="s1">&#39;concurrent&#39;</span><span class="p">:</span> <span class="s1">&#39;Mostly concurrent&#39;</span><span class="p">,</span>
            <span class="s1">&#39;pause&#39;</span><span class="p">:</span> <span class="s1">&#39;&lt;1ms&#39;</span><span class="p">,</span>
            <span class="s1">&#39;throughput&#39;</span><span class="p">:</span> <span class="s1">&#39;Moderate&#39;</span><span class="p">,</span>
            <span class="s1">&#39;heap_overhead&#39;</span><span class="p">:</span> <span class="s1">&#39;~25-50%&#39;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;system&#39;</span><span class="p">:</span> <span class="s1">&#39;CPython&#39;</span><span class="p">,</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Ref counting + generational&#39;</span><span class="p">,</span>
            <span class="s1">&#39;concurrent&#39;</span><span class="p">:</span> <span class="s1">&#39;No (GIL)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;pause&#39;</span><span class="p">:</span> <span class="s1">&#39;~1-50ms&#39;</span><span class="p">,</span>
            <span class="s1">&#39;throughput&#39;</span><span class="p">:</span> <span class="s1">&#39;Low&#39;</span><span class="p">,</span>
            <span class="s1">&#39;heap_overhead&#39;</span><span class="p">:</span> <span class="s1">&#39;Per-object refcount&#39;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;system&#39;</span><span class="p">:</span> <span class="s1">&#39;Rust&#39;</span><span class="p">,</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Ownership (no GC)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;concurrent&#39;</span><span class="p">:</span> <span class="s1">&#39;N/A&#39;</span><span class="p">,</span>
            <span class="s1">&#39;pause&#39;</span><span class="p">:</span> <span class="s1">&#39;None&#39;</span><span class="p">,</span>
            <span class="s1">&#39;throughput&#39;</span><span class="p">:</span> <span class="s1">&#39;Best&#39;</span><span class="p">,</span>
            <span class="s1">&#39;heap_overhead&#39;</span><span class="p">:</span> <span class="s1">&#39;None&#39;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== GC Comparison ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;System&#39;</span><span class="si">:</span><span class="s2">&lt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Type&#39;</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Pause&#39;</span><span class="si">:</span><span class="s2">&lt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Throughput&#39;</span><span class="si">:</span><span class="s2">&lt;12</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">collectors</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;30</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;pause&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;12</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;throughput&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;12</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">gc_comparison</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="11-gc-tuning-and-metrics">11. GC Tuning and Metrics<a class="header-link" href="#11-gc-tuning-and-metrics" title="Permanent link">&para;</a></h2>
<h3 id="111-key-metrics">11.1 Key Metrics<a class="header-link" href="#111-key-metrics" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Metric</th>
<th>Definition</th>
<th>Goal</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Throughput</strong></td>
<td>Fraction of time spent in application code (not GC)</td>
<td>Maximize (&gt;95%)</td>
</tr>
<tr>
<td><strong>Pause time</strong></td>
<td>Duration of GC-induced application pauses</td>
<td>Minimize</td>
</tr>
<tr>
<td><strong>Footprint</strong></td>
<td>Total memory used (heap + GC metadata)</td>
<td>Minimize</td>
</tr>
<tr>
<td><strong>Promptness</strong></td>
<td>Time between object death and memory reclamation</td>
<td>Minimize</td>
</tr>
<tr>
<td><strong>Allocation rate</strong></td>
<td>Bytes allocated per second</td>
<td>Not directly controllable</td>
</tr>
<tr>
<td><strong>Promotion rate</strong></td>
<td>Bytes promoted from young to old gen per second</td>
<td>Minimize</td>
</tr>
</tbody>
</table>
<h3 id="112-the-gc-tuning-triangle">11.2 The GC Tuning Triangle<a class="header-link" href="#112-the-gc-tuning-triangle" title="Permanent link">&para;</a></h3>
<p>You cannot optimize all metrics simultaneously:</p>
<div class="highlight"><pre><span></span><code>                Throughput
                    /\
                   /  \
                  /    \
                 /      \
                /  Pick  \
               /   Two    \
              /            \
             /              \
            /______________\
        Pause Time      Footprint
</code></pre></div>

<ul>
<li><strong>High throughput + low pause</strong> = large heap (high footprint)</li>
<li><strong>Low pause + small footprint</strong> = more frequent collections (lower throughput)</li>
<li><strong>High throughput + small footprint</strong> = longer pauses (batched collection)</li>
</ul>
<h3 id="113-gc-tuning-example">11.3 GC Tuning Example<a class="header-link" href="#113-gc-tuning-example" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">GCSimulator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate GC behavior under different configurations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">heap_size</span><span class="p">,</span> <span class="n">nursery_ratio</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">gc_overhead_factor</span><span class="o">=</span><span class="mf">0.1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">heap_size</span> <span class="o">=</span> <span class="n">heap_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nursery_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">heap_size</span> <span class="o">*</span> <span class="n">nursery_ratio</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gc_overhead_factor</span> <span class="o">=</span> <span class="n">gc_overhead_factor</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">total_allocated</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_gc_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">total_app_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gc_events</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">simulate_workload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">alloc_rate_mb_s</span><span class="p">,</span> <span class="n">live_set_mb</span><span class="p">,</span> <span class="n">duration_s</span><span class="p">,</span>
                          <span class="n">survival_rate</span><span class="o">=</span><span class="mf">0.05</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simulate a workload and report GC metrics.</span>

<span class="sd">        alloc_rate_mb_s: MB allocated per second</span>
<span class="sd">        live_set_mb: MB of long-lived data</span>
<span class="sd">        duration_s: simulation duration in seconds</span>
<span class="sd">        survival_rate: fraction of nursery objects that survive</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_elapsed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">nursery_used</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="n">time_elapsed</span> <span class="o">&lt;</span> <span class="n">duration_s</span><span class="p">:</span>
            <span class="c1"># Simulate allocation</span>
            <span class="n">alloc_per_tick</span> <span class="o">=</span> <span class="n">alloc_rate_mb_s</span> <span class="o">*</span> <span class="mf">0.001</span>  <span class="c1"># 1ms ticks</span>
            <span class="n">nursery_used</span> <span class="o">+=</span> <span class="n">alloc_per_tick</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_allocated</span> <span class="o">+=</span> <span class="n">alloc_per_tick</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">total_app_time</span> <span class="o">+=</span> <span class="mf">0.001</span>

            <span class="k">if</span> <span class="n">nursery_used</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nursery_size</span><span class="p">:</span>
                <span class="c1"># Minor GC</span>
                <span class="n">survivors</span> <span class="o">=</span> <span class="n">nursery_used</span> <span class="o">*</span> <span class="n">survival_rate</span>
                <span class="n">gc_time</span> <span class="o">=</span> <span class="n">nursery_used</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc_overhead_factor</span> <span class="o">*</span> <span class="mf">0.001</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">gc_events</span><span class="o">.</span><span class="n">append</span><span class="p">({</span>
                    <span class="s1">&#39;time&#39;</span><span class="p">:</span> <span class="n">time_elapsed</span><span class="p">,</span>
                    <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;minor&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;pause_ms&#39;</span><span class="p">:</span> <span class="n">gc_time</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span>
                    <span class="s1">&#39;freed_mb&#39;</span><span class="p">:</span> <span class="n">nursery_used</span> <span class="o">-</span> <span class="n">survivors</span><span class="p">,</span>
                <span class="p">})</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">total_gc_time</span> <span class="o">+=</span> <span class="n">gc_time</span>
                <span class="n">nursery_used</span> <span class="o">=</span> <span class="n">survivors</span>

            <span class="n">time_elapsed</span> <span class="o">+=</span> <span class="mf">0.001</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">report</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print GC performance report.&quot;&quot;&quot;</span>
        <span class="n">total_time</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_app_time</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_gc_time</span>
        <span class="n">throughput</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">total_app_time</span> <span class="o">/</span> <span class="n">total_time</span> <span class="o">*</span> <span class="mi">100</span>

        <span class="n">minor_gcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gc_events</span> <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;minor&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">minor_gcs</span><span class="p">:</span>
            <span class="n">pauses</span> <span class="o">=</span> <span class="p">[</span><span class="n">e</span><span class="p">[</span><span class="s1">&#39;pause_ms&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">minor_gcs</span><span class="p">]</span>
            <span class="n">avg_pause</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pauses</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">pauses</span><span class="p">)</span>
            <span class="n">max_pause</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pauses</span><span class="p">)</span>
            <span class="n">p99_pause</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pauses</span><span class="p">)[</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pauses</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.99</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">avg_pause</span> <span class="o">=</span> <span class="n">max_pause</span> <span class="o">=</span> <span class="n">p99_pause</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== GC Performance Report ===&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total allocated: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">total_allocated</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> MB&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;GC collections: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gc_events</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Throughput: </span><span class="si">{</span><span class="n">throughput</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Avg pause: </span><span class="si">{</span><span class="n">avg_pause</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Max pause: </span><span class="si">{</span><span class="n">max_pause</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;P99 pause: </span><span class="si">{</span><span class="n">p99_pause</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total GC time: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">total_gc_time</span><span class="o">*</span><span class="mi">1000</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>


<span class="c1"># Compare different heap configurations</span>
<span class="k">for</span> <span class="n">heap_mb</span><span class="p">,</span> <span class="n">nursery_pct</span> <span class="ow">in</span> <span class="p">[(</span><span class="mi">256</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">512</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">),</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">)]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="si">{</span><span class="s1">&#39;=&#39;</span><span class="o">*</span><span class="mi">50</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Config: heap=</span><span class="si">{</span><span class="n">heap_mb</span><span class="si">}</span><span class="s2">MB, nursery=</span><span class="si">{</span><span class="n">nursery_pct</span><span class="o">*</span><span class="mi">100</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">%&quot;</span><span class="p">)</span>
    <span class="n">sim</span> <span class="o">=</span> <span class="n">GCSimulator</span><span class="p">(</span><span class="n">heap_mb</span><span class="p">,</span> <span class="n">nursery_ratio</span><span class="o">=</span><span class="n">nursery_pct</span><span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">simulate_workload</span><span class="p">(</span>
        <span class="n">alloc_rate_mb_s</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span>   <span class="c1"># 500 MB/s allocation rate</span>
        <span class="n">live_set_mb</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span>       <span class="c1"># 100 MB long-lived data</span>
        <span class="n">duration_s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span>         <span class="c1"># 10 second simulation</span>
        <span class="n">survival_rate</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>    <span class="c1"># 5% of nursery objects survive</span>
    <span class="p">)</span>
    <span class="n">sim</span><span class="o">.</span><span class="n">report</span><span class="p">()</span>
</code></pre></div>

<h3 id="114-common-gc-tuning-strategies">11.4 Common GC Tuning Strategies<a class="header-link" href="#114-common-gc-tuning-strategies" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Increase heap size</strong>: Reduces GC frequency but increases pause times.</li>
<li><strong>Tune nursery size</strong>: Larger nursery = fewer minor GCs but longer pauses.</li>
<li><strong>Adjust promotion threshold</strong>: Higher threshold keeps objects in nursery longer (good if they die soon after).</li>
<li><strong>Choose the right collector</strong>: Match the collector to your latency/throughput requirements.</li>
<li><strong>Reduce allocation rate</strong>: The most effective strategy -- allocate fewer short-lived objects.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">tuning_checklist</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;GC tuning decision checklist.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== GC Tuning Checklist ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">checks</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s2">&quot;High GC frequency?&quot;</span><span class="p">,</span> <span class="s2">&quot;Increase heap/nursery size&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;Long GC pauses?&quot;</span><span class="p">,</span> <span class="s2">&quot;Use concurrent collector (G1/ZGC/Shenandoah)&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;High promotion rate?&quot;</span><span class="p">,</span> <span class="s2">&quot;Increase nursery size or promotion threshold&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;Full GC happening?&quot;</span><span class="p">,</span> <span class="s2">&quot;Old gen too small or memory leak&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;Low throughput (&lt;95%)?&quot;</span><span class="p">,</span> <span class="s2">&quot;Reduce allocation rate or increase heap&quot;</span><span class="p">),</span>
        <span class="p">(</span><span class="s2">&quot;OOM errors?&quot;</span><span class="p">,</span> <span class="s2">&quot;Memory leak, or genuinely need more heap&quot;</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">symptom</span><span class="p">,</span> <span class="n">remedy</span> <span class="ow">in</span> <span class="n">checks</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Symptom: </span><span class="si">{</span><span class="n">symptom</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Remedy:  </span><span class="si">{</span><span class="n">remedy</span><span class="si">}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">tuning_checklist</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="12-summary">12. Summary<a class="header-link" href="#12-summary" title="Permanent link">&para;</a></h2>
<p>Garbage collection is a fundamental aspect of modern programming language runtimes. We covered the following approaches:</p>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Reclaim Timing</th>
<th>Handles Cycles</th>
<th>Fragmentation</th>
<th>Copy Cost</th>
<th>Pause</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Ref Counting</strong></td>
<td>Immediate</td>
<td>No</td>
<td>Yes</td>
<td>No</td>
<td>Incremental</td>
</tr>
<tr>
<td><strong>Mark-Sweep</strong></td>
<td>Batch</td>
<td>Yes</td>
<td>Yes</td>
<td>No</td>
<td>STW</td>
</tr>
<tr>
<td><strong>Mark-Compact</strong></td>
<td>Batch</td>
<td>Yes</td>
<td>No</td>
<td>Slide</td>
<td>STW</td>
</tr>
<tr>
<td><strong>Copying</strong></td>
<td>Batch</td>
<td>Yes</td>
<td>No</td>
<td>Copy all live</td>
<td>STW</td>
</tr>
<tr>
<td><strong>Generational</strong></td>
<td>Mixed</td>
<td>Yes</td>
<td>Varies</td>
<td>Young only</td>
<td>Short minor</td>
</tr>
<tr>
<td><strong>Concurrent</strong></td>
<td>Batch</td>
<td>Yes</td>
<td>Varies</td>
<td>Varies</td>
<td>Minimal</td>
</tr>
</tbody>
</table>
<p>Key principles:</p>
<ol>
<li><strong>The generational hypothesis</strong> drives the design of most modern collectors: collect young objects frequently and old objects rarely.</li>
<li><strong>Write barriers</strong> are essential for both generational and concurrent GC, tracking cross-generation or concurrent mutations.</li>
<li><strong>Tri-color marking</strong> provides a clean framework for reasoning about concurrent and incremental collection.</li>
<li><strong>No single GC is best for all workloads</strong> -- the right choice depends on your latency, throughput, and footprint requirements.</li>
<li><strong>Rust's ownership model</strong> shows that GC can be avoided entirely with the right type system, at the cost of programming complexity.</li>
</ol>
<hr />
<h2 id="13-exercises">13. Exercises<a class="header-link" href="#13-exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-reference-counting-simulation">Exercise 1: Reference Counting Simulation<a class="header-link" href="#exercise-1-reference-counting-simulation" title="Permanent link">&para;</a></h3>
<p>Implement a reference counting system that supports:
- Object allocation and deallocation
- Pointer assignment with automatic ref count updates
- Detection of when an object becomes garbage</p>
<p>Test with the following scenario:</p>
<div class="highlight"><pre><span></span><code><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">C</span>
<span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">D</span>
<span class="n">Remove</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">B</span><span class="w">  </span><span class="p">(</span><span class="n">should</span><span class="w"> </span><span class="n">free</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="kr">and</span><span class="w"> </span><span class="n">C</span><span class="p">)</span>
<span class="n">Remove</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">D</span><span class="w">  </span><span class="p">(</span><span class="n">should</span><span class="w"> </span><span class="n">free</span><span class="w"> </span><span class="n">D</span><span class="p">)</span>
</code></pre></div>

<h3 id="exercise-2-mark-sweep-implementation">Exercise 2: Mark-Sweep Implementation<a class="header-link" href="#exercise-2-mark-sweep-implementation" title="Permanent link">&para;</a></h3>
<p>Extend the mark-sweep implementation to handle:
(a) Multiple root sets (stack roots, global roots, register roots).
(b) A free list allocator with first-fit, best-fit, and worst-fit strategies. Compare fragmentation under each strategy.
(c) Measure and report: total pause time, objects freed, fragmentation ratio.</p>
<h3 id="exercise-3-copying-collector">Exercise 3: Copying Collector<a class="header-link" href="#exercise-3-copying-collector" title="Permanent link">&para;</a></h3>
<p>Implement a full semi-space copying collector with Cheney's algorithm that:
(a) Uses a flat byte array as the heap (not Python objects).
(b) Implements forwarding pointers for moved objects.
(c) Handles the case where the live set exceeds half the heap (triggering an out-of-memory error).
(d) Measures allocation speed (bump pointer) vs. free-list allocation.</p>
<h3 id="exercise-4-generational-gc">Exercise 4: Generational GC<a class="header-link" href="#exercise-4-generational-gc" title="Permanent link">&para;</a></h3>
<p>Extend the generational GC to:
(a) Three generations (nursery, intermediate, old).
(b) Implement a card table write barrier.
(c) Track and report promotion rate over time.
(d) Experiment: what happens if you set the promotion threshold too high? Too low?</p>
<h3 id="exercise-5-tri-color-marking-safety">Exercise 5: Tri-Color Marking Safety<a class="header-link" href="#exercise-5-tri-color-marking-safety" title="Permanent link">&para;</a></h3>
<p>Given the following object graph and GC state:</p>
<div class="highlight"><pre><span></span><code><span class="n">Objects</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="o">(</span><span class="n">BLACK</span><span class="o">),</span><span class="w"> </span><span class="n">B</span><span class="o">(</span><span class="n">GREY</span><span class="o">),</span><span class="w"> </span><span class="n">C</span><span class="o">(</span><span class="n">WHITE</span><span class="o">),</span><span class="w"> </span><span class="n">D</span><span class="o">(</span><span class="n">WHITE</span><span class="o">),</span><span class="w"> </span><span class="n">E</span><span class="o">(</span><span class="n">BLACK</span><span class="o">)</span>
<span class="n">References</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="o">-&gt;{</span><span class="n">B</span><span class="o">},</span><span class="w"> </span><span class="n">B</span><span class="o">-&gt;{</span><span class="n">C</span><span class="o">,</span><span class="n">D</span><span class="o">},</span><span class="w"> </span><span class="n">E</span><span class="o">-&gt;{}</span>
<span class="n">Roots</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="o">,</span><span class="w"> </span><span class="n">E</span>
</code></pre></div>

<p>(a) Show that marking completes correctly without mutator interference.
(b) Now suppose the mutator performs: <code>A.ref = C; B.ref = null</code> (removing B-&gt;C). Show that C becomes lost without a write barrier.
(c) Show how Dijkstra's barrier prevents the lost object.
(d) Show how Yuasa's barrier prevents the lost object.</p>
<h3 id="exercise-6-gc-comparison">Exercise 6: GC Comparison<a class="header-link" href="#exercise-6-gc-comparison" title="Permanent link">&para;</a></h3>
<p>Write a benchmark that allocates objects in various patterns and measures performance under different simulated GC strategies:
(a) Short-lived burst: allocate 1 million small objects, discard all.
(b) Long-lived: allocate 10,000 objects, keep all, then allocate 1 million temporary objects.
(c) Cyclic: create linked lists that form cycles.</p>
<p>Compare: reference counting, mark-sweep, copying, and generational collectors in terms of total time and peak memory usage.</p>
<hr />
<h2 id="14-references">14. References<a class="header-link" href="#14-references" title="Permanent link">&para;</a></h2>
<ol>
<li>Jones, R., Hosking, A., &amp; Moss, E. (2012). <em>The Garbage Collection Handbook: The Art of Automatic Memory Management</em>. CRC Press.</li>
<li>Wilson, P. R. (1992). "Uniprocessor Garbage Collection Techniques." <em>International Workshop on Memory Management</em>, Springer.</li>
<li>Cheney, C. J. (1970). "A Nonrecursive List Compacting Algorithm." <em>Communications of the ACM</em>, 13(11).</li>
<li>Dijkstra, E. W., Lamport, L., Martin, A. J., Scholten, C. S., &amp; Steffens, E. F. M. (1978). "On-the-fly Garbage Collection: An Exercise in Cooperation." <em>Communications of the ACM</em>, 21(11).</li>
<li>Lieberman, H., &amp; Hewitt, C. (1983). "A Real-Time Garbage Collector Based on the Lifetimes of Objects." <em>Communications of the ACM</em>, 26(6).</li>
<li>Bacon, D. F., &amp; Rajan, V. T. (2001). "Concurrent Cycle Collection in Reference Counted Systems." <em>ECOOP</em>.</li>
<li>Tene, G., Iyengar, B., &amp; Wolf, M. (2011). "C4: The Continuously Concurrent Compacting Collector." <em>ISMM</em>.</li>
</ol>
<hr />
<p><a href="./13_Loop_Optimization.md">Previous: 13. Loop Optimization</a> | <a href="./15_Interpreters_and_Virtual_Machines.md">Next: 15. Interpreters and Virtual Machines</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/13_Loop_Optimization.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Loop Optimization</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/15_Interpreters_and_Virtual_Machines.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Interpreters and Virtual Machines</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">â†‘</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}