{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interpreters and Virtual Machines - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">Interpreters and Virtual Machines</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Interpreters and Virtual Machines</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/14_Garbage_Collection.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Garbage Collection</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/16_Modern_Compiler_Infrastructure.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Modern Compiler Infrastructure</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#table-of-contents">Table of Contents</a></li>
<li><a href="#1-interpreters-vs-compilers">1. Interpreters vs Compilers</a><ul>
<li><a href="#11-the-execution-spectrum">1.1 The Execution Spectrum</a></li>
<li><a href="#12-trade-offs">1.2 Trade-offs</a></li>
<li><a href="#13-hybrid-approaches">1.3 Hybrid Approaches</a></li>
</ul>
</li>
<li><a href="#2-tree-walking-interpreters">2. Tree-Walking Interpreters</a><ul>
<li><a href="#21-the-simplest-interpreter">2.1 The Simplest Interpreter</a></li>
<li><a href="#22-advantages-and-disadvantages">2.2 Advantages and Disadvantages</a></li>
</ul>
</li>
<li><a href="#3-bytecode-and-bytecode-compilation">3. Bytecode and Bytecode Compilation</a><ul>
<li><a href="#31-what-is-bytecode">3.1 What is Bytecode?</a></li>
<li><a href="#32-bytecode-design-principles">3.2 Bytecode Design Principles</a></li>
<li><a href="#33-instruction-encoding">3.3 Instruction Encoding</a></li>
<li><a href="#34-defining-an-instruction-set">3.4 Defining an Instruction Set</a></li>
</ul>
</li>
<li><a href="#4-stack-based-virtual-machines">4. Stack-Based Virtual Machines</a><ul>
<li><a href="#41-how-stack-vms-work">4.1 How Stack VMs Work</a></li>
<li><a href="#42-advantages-of-stack-vms">4.2 Advantages of Stack VMs</a></li>
<li><a href="#43-disadvantages">4.3 Disadvantages</a></li>
<li><a href="#44-basic-stack-vm-implementation">4.4 Basic Stack VM Implementation</a></li>
</ul>
</li>
<li><a href="#5-register-based-virtual-machines">5. Register-Based Virtual Machines</a><ul>
<li><a href="#51-register-vm-design">5.1 Register VM Design</a></li>
<li><a href="#52-register-vm-example">5.2 Register VM Example</a></li>
<li><a href="#53-stack-vs-register-comparison">5.3 Stack vs Register Comparison</a></li>
</ul>
</li>
<li><a href="#6-instruction-dispatch-techniques">6. Instruction Dispatch Techniques</a><ul>
<li><a href="#61-switch-dispatch">6.1 Switch Dispatch</a></li>
<li><a href="#62-direct-threaded-code">6.2 Direct Threaded Code</a></li>
<li><a href="#63-computed-goto-gcc-extension">6.3 Computed Goto (GCC Extension)</a></li>
<li><a href="#64-subroutine-threading">6.4 Subroutine Threading</a></li>
<li><a href="#65-dispatch-performance-comparison">6.5 Dispatch Performance Comparison</a></li>
</ul>
</li>
<li><a href="#7-a-complete-bytecode-compiler-and-vm">7. A Complete Bytecode Compiler and VM</a><ul>
<li><a href="#71-the-language">7.1 The Language</a></li>
<li><a href="#72-the-bytecode-compiler">7.2 The Bytecode Compiler</a></li>
<li><a href="#73-the-virtual-machine">7.3 The Virtual Machine</a></li>
<li><a href="#74-putting-it-all-together">7.4 Putting It All Together</a></li>
</ul>
</li>
<li><a href="#8-jit-compilation">8. JIT Compilation</a><ul>
<li><a href="#81-why-jit">8.1 Why JIT?</a></li>
<li><a href="#82-method-jit">8.2 Method JIT</a></li>
<li><a href="#83-tracing-jit">8.3 Tracing JIT</a></li>
<li><a href="#84-trace-compilation-details">8.4 Trace Compilation Details</a></li>
<li><a href="#85-on-stack-replacement-osr">8.5 On-Stack Replacement (OSR)</a></li>
</ul>
</li>
<li><a href="#9-runtime-optimization-techniques">9. Runtime Optimization Techniques</a><ul>
<li><a href="#91-inline-caching">9.1 Inline Caching</a></li>
<li><a href="#92-type-specialization">9.2 Type Specialization</a></li>
<li><a href="#93-deoptimization">9.3 Deoptimization</a></li>
<li><a href="#94-hidden-classes-shapes">9.4 Hidden Classes / Shapes</a></li>
</ul>
</li>
<li><a href="#10-real-virtual-machines">10. Real Virtual Machines</a><ul>
<li><a href="#101-jvm-java-virtual-machine">10.1 JVM (Java Virtual Machine)</a></li>
<li><a href="#102-cpython-vm">10.2 CPython VM</a></li>
<li><a href="#103-v8-javascript">10.3 V8 (JavaScript)</a></li>
<li><a href="#104-beam-erlang-vm">10.4 BEAM (Erlang VM)</a></li>
<li><a href="#105-vm-comparison">10.5 VM Comparison</a></li>
</ul>
</li>
<li><a href="#11-metacircular-interpreters">11. Metacircular Interpreters</a><ul>
<li><a href="#111-what-is-a-metacircular-interpreter">11.1 What is a Metacircular Interpreter?</a></li>
<li><a href="#112-a-simple-metacircular-evaluator">11.2 A Simple Metacircular Evaluator</a></li>
<li><a href="#113-why-metacircular-interpreters-matter">11.3 Why Metacircular Interpreters Matter</a></li>
</ul>
</li>
<li><a href="#12-summary">12. Summary</a></li>
<li><a href="#13-exercises">13. Exercises</a><ul>
<li><a href="#exercise-1-tree-walking-extensions">Exercise 1: Tree-Walking Extensions</a></li>
<li><a href="#exercise-2-bytecode-optimization">Exercise 2: Bytecode Optimization</a></li>
<li><a href="#exercise-3-register-allocation-for-register-vm">Exercise 3: Register Allocation for Register VM</a></li>
<li><a href="#exercise-4-simple-jit-compiler">Exercise 4: Simple JIT Compiler</a></li>
<li><a href="#exercise-5-debugger-for-the-vm">Exercise 5: Debugger for the VM</a></li>
<li><a href="#exercise-6-vm-performance-analysis">Exercise 6: VM Performance Analysis</a></li>
</ul>
</li>
<li><a href="#14-references">14. References</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="interpreters-and-virtual-machines">Interpreters and Virtual Machines<a class="header-link" href="#interpreters-and-virtual-machines" title="Permanent link">&para;</a></h1>
<p><strong>Previous</strong>: <a href="./14_Garbage_Collection.md">14. Garbage Collection</a> | <strong>Next</strong>: <a href="./16_Modern_Compiler_Infrastructure.md">16. Modern Compiler Infrastructure</a></p>
<hr />
<p>Not all language implementations compile to native machine code. Many of the most widely used languages -- Python, Java, JavaScript, Ruby, Erlang, Lua -- rely on interpreters or virtual machines (or a combination of both) to execute programs. Understanding how interpreters and VMs work is essential for language implementers and for any programmer who wants to understand what happens when their code runs.</p>
<p>This lesson covers the spectrum of execution strategies, from simple tree-walking interpreters to sophisticated JIT-compiling virtual machines. We will build a working bytecode compiler and stack-based VM for a simple language in Python, providing a concrete foundation for understanding how production VMs operate.</p>
<p><strong>Difficulty</strong>: ‚≠ê‚≠ê‚≠ê‚≠ê</p>
<p><strong>Prerequisites</strong>: <a href="./07_Abstract_Syntax_Trees.md">07. Abstract Syntax Trees</a>, <a href="./09_Intermediate_Representations.md">09. Intermediate Representations</a>, <a href="./11_Code_Generation.md">11. Code Generation</a></p>
<p><strong>Learning Objectives</strong>:
- Compare interpreters and compilers along multiple axes (speed, portability, development cycle)
- Implement a tree-walking interpreter for a simple language
- Design a bytecode instruction set and implement a bytecode compiler
- Build a stack-based virtual machine from scratch
- Understand register-based VM design and its advantages
- Explain instruction dispatch techniques and their performance impact
- Describe JIT compilation strategies (method JIT, tracing JIT)
- Explain runtime optimization techniques (inline caching, type specialization)
- Analyze the design of real VMs (JVM, CPython, V8, BEAM)
- Understand metacircular interpreters</p>
<hr />
<h2 id="table-of-contents">Table of Contents<a class="header-link" href="#table-of-contents" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#1-interpreters-vs-compilers">Interpreters vs Compilers</a></li>
<li><a href="#2-tree-walking-interpreters">Tree-Walking Interpreters</a></li>
<li><a href="#3-bytecode-and-bytecode-compilation">Bytecode and Bytecode Compilation</a></li>
<li><a href="#4-stack-based-virtual-machines">Stack-Based Virtual Machines</a></li>
<li><a href="#5-register-based-virtual-machines">Register-Based Virtual Machines</a></li>
<li><a href="#6-instruction-dispatch-techniques">Instruction Dispatch Techniques</a></li>
<li><a href="#7-a-complete-bytecode-compiler-and-vm">A Complete Bytecode Compiler and VM</a></li>
<li><a href="#8-jit-compilation">JIT Compilation</a></li>
<li><a href="#9-runtime-optimization-techniques">Runtime Optimization Techniques</a></li>
<li><a href="#10-real-virtual-machines">Real Virtual Machines</a></li>
<li><a href="#11-metacircular-interpreters">Metacircular Interpreters</a></li>
<li><a href="#12-summary">Summary</a></li>
<li><a href="#13-exercises">Exercises</a></li>
<li><a href="#14-references">References</a></li>
</ol>
<hr />
<h2 id="1-interpreters-vs-compilers">1. Interpreters vs Compilers<a class="header-link" href="#1-interpreters-vs-compilers" title="Permanent link">&para;</a></h2>
<h3 id="11-the-execution-spectrum">1.1 The Execution Spectrum<a class="header-link" href="#11-the-execution-spectrum" title="Permanent link">&para;</a></h3>
<p>Language implementations exist on a spectrum from pure interpretation to pure compilation:</p>
<div class="highlight"><pre><span></span><code><span class="nx">Pure</span><span class="w"> </span><span class="nx">Interpreter</span><span class="w">                                    </span><span class="nx">Native</span><span class="w"> </span><span class="nx">Compiler</span>
<span class="w">     </span><span class="o">|</span><span class="w">                                                    </span><span class="o">|</span>
<span class="w">     </span><span class="nx">v</span><span class="w">                                                    </span><span class="nx">v</span>
<span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="err">‚îÇ</span><span class="w">  </span><span class="nx">Tree</span><span class="w">    </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Bytecode</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Bytecode</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w">  </span><span class="nx">AOT</span><span class="w">     </span><span class="err">‚îÇ</span><span class="w">    </span><span class="nx">Static</span><span class="w">    </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w">  </span><span class="nx">Walking</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Interp</span><span class="p">.</span><span class="w">  </span><span class="err">‚îÇ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">JIT</span><span class="w">    </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">Compile</span><span class="w">  </span><span class="err">‚îÇ</span><span class="w">   </span><span class="nx">Compiler</span><span class="w">   </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w">          </span><span class="err">‚îÇ</span><span class="w">          </span><span class="err">‚îÇ</span><span class="w">          </span><span class="err">‚îÇ</span><span class="w">          </span><span class="err">‚îÇ</span><span class="w">              </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w">  </span><span class="nx">Ruby</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">CPython</span><span class="w">  </span><span class="err">‚îÇ</span><span class="w">  </span><span class="nx">JVM</span><span class="w">     </span><span class="err">‚îÇ</span><span class="w">  </span><span class="nx">GraalVM</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w">   </span><span class="nx">GCC</span><span class="o">/</span><span class="nx">LLVM</span><span class="w">  </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w">  </span><span class="p">(</span><span class="nx">old</span><span class="p">)</span><span class="w">   </span><span class="err">‚îÇ</span><span class="w">  </span><span class="nx">Lua</span><span class="w">     </span><span class="err">‚îÇ</span><span class="w">  </span><span class="nx">V8</span><span class="w">      </span><span class="err">‚îÇ</span><span class="w">  </span><span class="nx">Native</span><span class="w">  </span><span class="err">‚îÇ</span><span class="w">   </span><span class="nx">Rust</span><span class="w">      </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w">  </span><span class="nx">Bash</span><span class="w">    </span><span class="err">‚îÇ</span><span class="w">          </span><span class="err">‚îÇ</span><span class="w">  </span><span class="nx">PyPy</span><span class="w">    </span><span class="err">‚îÇ</span><span class="w">  </span><span class="nx">Image</span><span class="w">   </span><span class="err">‚îÇ</span><span class="w">   </span><span class="nx">Go</span><span class="w">        </span><span class="err">‚îÇ</span>
<span class="err">‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>
<span class="w">   </span><span class="nx">Slow</span><span class="w">                                            </span><span class="nx">Fast</span>
<span class="w">   </span><span class="nx">Portable</span><span class="w">                                        </span><span class="nx">Platform</span><span class="o">-</span><span class="nx">specific</span>
<span class="w">   </span><span class="nx">Quick</span><span class="w"> </span><span class="nx">startup</span><span class="w">                                   </span><span class="nx">Slow</span><span class="w"> </span><span class="nx">startup</span>
<span class="w">   </span><span class="nx">Easy</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">implement</span><span class="w">                               </span><span class="nx">Complex</span><span class="w"> </span><span class="nx">implementation</span>
</code></pre></div>

<h3 id="12-trade-offs">1.2 Trade-offs<a class="header-link" href="#12-trade-offs" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Interpreter</th>
<th>Compiler</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Execution speed</strong></td>
<td>Slow (10-100x slower)</td>
<td>Fast (near hardware speed)</td>
</tr>
<tr>
<td><strong>Startup time</strong></td>
<td>Fast (no compilation phase)</td>
<td>Slow (must compile first)</td>
</tr>
<tr>
<td><strong>Memory usage</strong></td>
<td>Lower (no generated code)</td>
<td>Higher (generated code + data)</td>
</tr>
<tr>
<td><strong>Portability</strong></td>
<td>High (VM abstracts hardware)</td>
<td>Low (target-specific)</td>
</tr>
<tr>
<td><strong>Error messages</strong></td>
<td>Better (has source info)</td>
<td>Often cryptic</td>
</tr>
<tr>
<td><strong>Debugging</strong></td>
<td>Easier (inspect live state)</td>
<td>Harder (optimized away)</td>
</tr>
<tr>
<td><strong>Development cycle</strong></td>
<td>Fast (edit-run)</td>
<td>Slow (edit-compile-run)</td>
</tr>
<tr>
<td><strong>Dynamic features</strong></td>
<td>Easy (<code>eval</code>, metaprogramming)</td>
<td>Hard or impossible</td>
</tr>
<tr>
<td><strong>Optimization</strong></td>
<td>Limited</td>
<td>Extensive</td>
</tr>
</tbody>
</table>
<h3 id="13-hybrid-approaches">1.3 Hybrid Approaches<a class="header-link" href="#13-hybrid-approaches" title="Permanent link">&para;</a></h3>
<p>Most modern systems use hybrid approaches:</p>
<ul>
<li><strong>Java</strong>: Compile to bytecode (AOT), then JIT compile hot methods to native code at runtime.</li>
<li><strong>JavaScript (V8)</strong>: Parse to AST, compile to bytecode, JIT compile hot functions with TurboFan.</li>
<li><strong>Python (PyPy)</strong>: Interpret bytecode, trace hot loops, JIT compile traces.</li>
<li><strong>.NET</strong>: Compile to CIL bytecode, JIT compile to native code at load time or lazily.</li>
</ul>
<hr />
<h2 id="2-tree-walking-interpreters">2. Tree-Walking Interpreters<a class="header-link" href="#2-tree-walking-interpreters" title="Permanent link">&para;</a></h2>
<h3 id="21-the-simplest-interpreter">2.1 The Simplest Interpreter<a class="header-link" href="#21-the-simplest-interpreter" title="Permanent link">&para;</a></h3>
<p>A tree-walking interpreter executes a program by traversing its AST. Each node type has an associated evaluation rule.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Union</span>


<span class="c1"># AST node definitions</span>
<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">NumberLit</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">float</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">StringLit</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">str</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BoolLit</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="nb">bool</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Identifier</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BinOp</span><span class="p">:</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">left</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">right</span><span class="p">:</span> <span class="n">Any</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">UnaryOp</span><span class="p">:</span>
    <span class="n">op</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">operand</span><span class="p">:</span> <span class="n">Any</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Assign</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Any</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">If</span><span class="p">:</span>
    <span class="n">condition</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">then_body</span><span class="p">:</span> <span class="nb">list</span>
    <span class="n">else_body</span><span class="p">:</span> <span class="nb">list</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">While</span><span class="p">:</span>
    <span class="n">condition</span><span class="p">:</span> <span class="n">Any</span>
    <span class="n">body</span><span class="p">:</span> <span class="nb">list</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FuncDef</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">params</span><span class="p">:</span> <span class="nb">list</span>
    <span class="n">body</span><span class="p">:</span> <span class="nb">list</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FuncCall</span><span class="p">:</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="n">args</span><span class="p">:</span> <span class="nb">list</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Return</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Any</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Print</span><span class="p">:</span>
    <span class="n">value</span><span class="p">:</span> <span class="n">Any</span>


<span class="k">class</span><span class="w"> </span><span class="nc">ReturnException</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Used to implement return from functions.&quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">Environment</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Variable scope with lexical scoping.&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Undefined variable: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update existing binding (search up scope chain).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="c1"># If not found anywhere, create in current scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bindings</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TreeWalkInterpreter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A tree-walking interpreter that directly executes AST nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># Captured output for testing</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">interpret</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpret a list of statements.&quot;&quot;&quot;</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">program</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_env</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute a single AST node.&quot;&quot;&quot;</span>
        <span class="n">method_name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;exec_</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown node type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_NumberLit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_StringLit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_BoolLit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_Identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">env</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_BinOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="n">right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

        <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;%&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;!=&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;&lt;=&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;&gt;=&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;and&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="ow">and</span> <span class="n">b</span><span class="p">,</span>
            <span class="s1">&#39;or&#39;</span><span class="p">:</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="ow">or</span> <span class="n">b</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ops</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown operator: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ops</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">](</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_UnaryOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">operand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="n">operand</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;not&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="ow">not</span> <span class="n">operand</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown unary operator: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_Assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="n">env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_If</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">condition</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">then_body</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">else_body</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">else_body</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_While</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_FuncDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="c1"># Store function as closure (captures defining environment)</span>
        <span class="n">env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;function&#39;</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_FuncCall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">env</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">or</span> <span class="n">func</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;function&#39;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not a function&quot;</span><span class="p">)</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">closure_env</span> <span class="o">=</span> <span class="n">func</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> expects </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">)</span><span class="si">}</span><span class="s2"> args, got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Create new scope for function body</span>
        <span class="n">func_env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="n">closure_env</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
            <span class="n">func_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>

        <span class="c1"># Execute function body</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">body</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">func_env</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">ReturnException</span> <span class="k">as</span> <span class="n">ret</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="o">.</span><span class="n">value</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_Return</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span> <span class="k">else</span> <span class="kc">None</span>
        <span class="k">raise</span> <span class="n">ReturnException</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exec_Print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_tree_walker</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate the tree-walking interpreter.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Tree-Walking Interpreter Demo ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">interp</span> <span class="o">=</span> <span class="n">TreeWalkInterpreter</span><span class="p">()</span>

    <span class="c1"># Program: compute factorial</span>
    <span class="n">program</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">FuncDef</span><span class="p">(</span><span class="s1">&#39;factorial&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="p">[</span>
            <span class="n">If</span><span class="p">(</span>
                <span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;&lt;=&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">),</span> <span class="n">NumberLit</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>
                <span class="p">[</span><span class="n">Return</span><span class="p">(</span><span class="n">NumberLit</span><span class="p">(</span><span class="mi">1</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">Return</span><span class="p">(</span><span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">),</span>
                              <span class="n">FuncCall</span><span class="p">(</span><span class="s1">&#39;factorial&#39;</span><span class="p">,</span>
                                       <span class="p">[</span><span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">),</span>
                                               <span class="n">NumberLit</span><span class="p">(</span><span class="mi">1</span><span class="p">))])))]</span>
            <span class="p">)</span>
        <span class="p">]),</span>
        <span class="n">Assign</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">,</span> <span class="n">FuncCall</span><span class="p">(</span><span class="s1">&#39;factorial&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">NumberLit</span><span class="p">(</span><span class="mi">10</span><span class="p">)])),</span>
        <span class="n">Print</span><span class="p">(</span><span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">)),</span>
    <span class="p">]</span>

    <span class="n">interp</span><span class="o">.</span><span class="n">interpret</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>

    <span class="c1"># Program: Fibonacci</span>
    <span class="n">program2</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">FuncDef</span><span class="p">(</span><span class="s1">&#39;fib&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="p">[</span>
            <span class="n">If</span><span class="p">(</span>
                <span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">),</span> <span class="n">NumberLit</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
                <span class="p">[</span><span class="n">Return</span><span class="p">(</span><span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">Return</span><span class="p">(</span><span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
                              <span class="n">FuncCall</span><span class="p">(</span><span class="s1">&#39;fib&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">),</span>
                                                     <span class="n">NumberLit</span><span class="p">(</span><span class="mi">1</span><span class="p">))]),</span>
                              <span class="n">FuncCall</span><span class="p">(</span><span class="s1">&#39;fib&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">),</span>
                                                     <span class="n">NumberLit</span><span class="p">(</span><span class="mi">2</span><span class="p">))])))]</span>
            <span class="p">)</span>
        <span class="p">]),</span>
        <span class="c1"># Print first 10 Fibonacci numbers</span>
        <span class="n">Assign</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">NumberLit</span><span class="p">(</span><span class="mi">0</span><span class="p">)),</span>
        <span class="n">While</span><span class="p">(</span><span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">),</span> <span class="n">NumberLit</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span> <span class="p">[</span>
            <span class="n">Print</span><span class="p">(</span><span class="n">FuncCall</span><span class="p">(</span><span class="s1">&#39;fib&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)])),</span>
            <span class="n">Assign</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">),</span> <span class="n">NumberLit</span><span class="p">(</span><span class="mi">1</span><span class="p">))),</span>
        <span class="p">]),</span>
    <span class="p">]</span>

    <span class="n">interp2</span> <span class="o">=</span> <span class="n">TreeWalkInterpreter</span><span class="p">()</span>
    <span class="n">interp2</span><span class="o">.</span><span class="n">interpret</span><span class="p">(</span><span class="n">program2</span><span class="p">)</span>

<span class="n">demonstrate_tree_walker</span><span class="p">()</span>
</code></pre></div>

<h3 id="22-advantages-and-disadvantages">2.2 Advantages and Disadvantages<a class="header-link" href="#22-advantages-and-disadvantages" title="Permanent link">&para;</a></h3>
<p><strong>Advantages</strong>:
- Simple to implement (a few hundred lines)
- Direct access to AST (great for debugging, error messages)
- Easy to add features (just add a new <code>exec_</code> method)
- Natural for languages with complex semantics</p>
<p><strong>Disadvantages</strong>:
- <strong>Slow</strong>: Each node requires a virtual dispatch (method lookup)
- <strong>Deep recursion</strong>: Deeply nested expressions cause stack overflow
- <strong>No optimization</strong>: Every expression is re-evaluated every time
- <strong>Cache unfriendly</strong>: AST nodes scattered in memory</p>
<p>Tree-walking interpreters are typically 50-200x slower than compiled code.</p>
<hr />
<h2 id="3-bytecode-and-bytecode-compilation">3. Bytecode and Bytecode Compilation<a class="header-link" href="#3-bytecode-and-bytecode-compilation" title="Permanent link">&para;</a></h2>
<h3 id="31-what-is-bytecode">3.1 What is Bytecode?<a class="header-link" href="#31-what-is-bytecode" title="Permanent link">&para;</a></h3>
<p><strong>Bytecode</strong> is a compact binary representation of a program, designed to be executed by a virtual machine rather than real hardware. It sits between source code and machine code:</p>
<div class="highlight"><pre><span></span><code><span class="n">Source</span><span class="w"> </span><span class="n">Code</span><span class="w">       </span><span class="n">AST</span><span class="w">          </span><span class="n">Bytecode</span><span class="w">         </span><span class="n">Machine</span><span class="w"> </span><span class="n">Code</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="w">  </span><span class="o">--&gt;</span><span class="w">  </span><span class="n">Assign</span><span class="w">  </span><span class="o">--&gt;</span><span class="w">  </span><span class="n">LOAD_VAR</span><span class="w"> </span><span class="n">a</span><span class="w">   </span><span class="o">--&gt;</span><span class="w">  </span><span class="n">mov</span><span class="w"> </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">rbp</span><span class="o">-</span><span class="mi">8</span><span class="p">]</span>
<span class="w">                   </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">          </span><span class="n">LOAD_VAR</span><span class="w"> </span><span class="n">b</span><span class="w">       </span><span class="n">add</span><span class="w"> </span><span class="n">eax</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="n">rbp</span><span class="o">-</span><span class="mi">16</span><span class="p">]</span>
<span class="w">                  </span><span class="n">x</span><span class="w">   </span><span class="o">+</span><span class="w">         </span><span class="n">ADD</span><span class="w">              </span><span class="n">mov</span><span class="w"> </span><span class="p">[</span><span class="n">rbp</span><span class="o">-</span><span class="mi">24</span><span class="p">],</span><span class="w"> </span><span class="n">eax</span>
<span class="w">                     </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">        </span><span class="n">STORE_VAR</span><span class="w"> </span><span class="n">x</span>
<span class="w">                    </span><span class="n">a</span><span class="w">   </span><span class="n">b</span>
</code></pre></div>

<h3 id="32-bytecode-design-principles">3.2 Bytecode Design Principles<a class="header-link" href="#32-bytecode-design-principles" title="Permanent link">&para;</a></h3>
<p>Good bytecode design balances several goals:</p>
<ol>
<li><strong>Compactness</strong>: Fewer bytes = faster loading, less memory, better cache use</li>
<li><strong>Simplicity</strong>: Simple instructions are easy to decode and execute</li>
<li><strong>Completeness</strong>: Must express all language features</li>
<li><strong>Performance</strong>: Common operations should be efficient</li>
<li><strong>Verifiability</strong>: Should be possible to validate before execution</li>
</ol>
<h3 id="33-instruction-encoding">3.3 Instruction Encoding<a class="header-link" href="#33-instruction-encoding" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="nx">Fixed</span><span class="o">-</span><span class="nx">width</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">g</span><span class="p">.,</span><span class="w"> </span><span class="mi">32</span><span class="o">-</span><span class="nx">bit</span><span class="p">):</span>
<span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">opcode</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">arg1</span><span class="w">   </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">arg2</span><span class="w">   </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">arg3</span><span class="w">   </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="nx">bits</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="nx">bits</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="nx">bits</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="nx">bits</span><span class="w"> </span><span class="err">‚îÇ</span>
<span class="err">‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>
<span class="w">  </span><span class="nx">Simple</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">decode</span><span class="p">,</span><span class="w"> </span><span class="nx">wastes</span><span class="w"> </span><span class="nx">space</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">simple</span><span class="w"> </span><span class="nx">instructions</span>

<span class="nx">Variable</span><span class="o">-</span><span class="nx">width</span><span class="w"> </span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">g</span><span class="p">.,</span><span class="w"> </span><span class="nx">CPython</span><span class="p">):</span>
<span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span><span class="w">         </span><span class="err">‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="nx">opcode</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w">    </span><span class="k">or</span><span class="w">   </span><span class="err">‚îÇ</span><span class="w"> </span><span class="nx">opcode</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w">  </span><span class="nx">arg</span><span class="w">   </span><span class="err">‚îÇ</span>
<span class="err">‚îÇ</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="nx">bits</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w">         </span><span class="err">‚îÇ</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="nx">bits</span><span class="w"> </span><span class="err">‚îÇ</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span><span class="nx">bits</span><span class="w"> </span><span class="err">‚îÇ</span>
<span class="err">‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span><span class="w">         </span><span class="err">‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò</span>
<span class="w">  </span><span class="nx">Compact</span><span class="p">,</span><span class="w"> </span><span class="nx">but</span><span class="w"> </span><span class="nx">harder</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">decode</span>
</code></pre></div>

<h3 id="34-defining-an-instruction-set">3.4 Defining an Instruction Set<a class="header-link" href="#34-defining-an-instruction-set" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">IntEnum</span><span class="p">,</span> <span class="n">auto</span>


<span class="k">class</span><span class="w"> </span><span class="nc">OpCode</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Bytecode instruction opcodes for our simple VM.&quot;&quot;&quot;</span>

    <span class="c1"># Stack operations</span>
    <span class="n">CONST</span> <span class="o">=</span> <span class="mi">0</span>        <span class="c1"># Push constant: CONST &lt;index&gt;</span>
    <span class="n">POP</span> <span class="o">=</span> <span class="mi">1</span>          <span class="c1"># Pop top of stack</span>

    <span class="c1"># Arithmetic</span>
    <span class="n">ADD</span> <span class="o">=</span> <span class="mi">2</span>          <span class="c1"># Pop two, push sum</span>
    <span class="n">SUB</span> <span class="o">=</span> <span class="mi">3</span>          <span class="c1"># Pop two, push difference</span>
    <span class="n">MUL</span> <span class="o">=</span> <span class="mi">4</span>          <span class="c1"># Pop two, push product</span>
    <span class="n">DIV</span> <span class="o">=</span> <span class="mi">5</span>          <span class="c1"># Pop two, push quotient</span>
    <span class="n">MOD</span> <span class="o">=</span> <span class="mi">6</span>          <span class="c1"># Pop two, push remainder</span>
    <span class="n">NEG</span> <span class="o">=</span> <span class="mi">7</span>          <span class="c1"># Negate top of stack</span>

    <span class="c1"># Comparison</span>
    <span class="n">EQ</span> <span class="o">=</span> <span class="mi">8</span>           <span class="c1"># Equal</span>
    <span class="n">NE</span> <span class="o">=</span> <span class="mi">9</span>           <span class="c1"># Not equal</span>
    <span class="n">LT</span> <span class="o">=</span> <span class="mi">10</span>          <span class="c1"># Less than</span>
    <span class="n">GT</span> <span class="o">=</span> <span class="mi">11</span>          <span class="c1"># Greater than</span>
    <span class="n">LE</span> <span class="o">=</span> <span class="mi">12</span>          <span class="c1"># Less or equal</span>
    <span class="n">GE</span> <span class="o">=</span> <span class="mi">13</span>          <span class="c1"># Greater or equal</span>

    <span class="c1"># Logical</span>
    <span class="n">NOT</span> <span class="o">=</span> <span class="mi">14</span>         <span class="c1"># Logical not</span>

    <span class="c1"># Variables</span>
    <span class="n">LOAD</span> <span class="o">=</span> <span class="mi">15</span>        <span class="c1"># Push variable value: LOAD &lt;slot&gt;</span>
    <span class="n">STORE</span> <span class="o">=</span> <span class="mi">16</span>       <span class="c1"># Pop and store to variable: STORE &lt;slot&gt;</span>
    <span class="n">LOAD_GLOBAL</span> <span class="o">=</span> <span class="mi">17</span> <span class="c1"># Push global value: LOAD_GLOBAL &lt;index&gt;</span>
    <span class="n">STORE_GLOBAL</span> <span class="o">=</span> <span class="mi">18</span><span class="c1"># Store global: STORE_GLOBAL &lt;index&gt;</span>

    <span class="c1"># Control flow</span>
    <span class="n">JUMP</span> <span class="o">=</span> <span class="mi">19</span>        <span class="c1"># Unconditional jump: JUMP &lt;offset&gt;</span>
    <span class="n">JUMP_IF_FALSE</span> <span class="o">=</span> <span class="mi">20</span>  <span class="c1"># Conditional jump: JUMP_IF_FALSE &lt;offset&gt;</span>
    <span class="n">JUMP_IF_TRUE</span> <span class="o">=</span> <span class="mi">21</span>   <span class="c1"># Conditional jump: JUMP_IF_TRUE &lt;offset&gt;</span>

    <span class="c1"># Functions</span>
    <span class="n">CALL</span> <span class="o">=</span> <span class="mi">22</span>        <span class="c1"># Call function: CALL &lt;num_args&gt;</span>
    <span class="n">RETURN</span> <span class="o">=</span> <span class="mi">23</span>      <span class="c1"># Return from function</span>

    <span class="c1"># I/O</span>
    <span class="n">PRINT</span> <span class="o">=</span> <span class="mi">24</span>       <span class="c1"># Print top of stack</span>

    <span class="c1"># Special</span>
    <span class="n">HALT</span> <span class="o">=</span> <span class="mi">25</span>        <span class="c1"># Stop execution</span>

    <span class="c1"># Constants</span>
    <span class="n">TRUE</span> <span class="o">=</span> <span class="mi">26</span>        <span class="c1"># Push True</span>
    <span class="n">FALSE</span> <span class="o">=</span> <span class="mi">27</span>       <span class="c1"># Push False</span>
    <span class="n">NONE</span> <span class="o">=</span> <span class="mi">28</span>        <span class="c1"># Push None</span>


<span class="c1"># Instruction metadata</span>
<span class="n">INSTRUCTION_INFO</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;CONST&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>          <span class="c1"># 1 argument (constant index)</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">POP</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;POP&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;ADD&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">SUB</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;SUB&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">MUL</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;MUL&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">DIV</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;DIV&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">MOD</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;MOD&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">NEG</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;NEG&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">EQ</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;EQ&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">NE</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;NE&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">LT</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;LT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">GT</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;GT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">LE</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;LE&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">GE</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;GE&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">NOT</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;NOT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">LOAD</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;LOAD&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">STORE</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;STORE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">LOAD_GLOBAL</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;LOAD_GLOBAL&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">STORE_GLOBAL</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;STORE_GLOBAL&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;JUMP&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP_IF_FALSE</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;JUMP_IF_FALSE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP_IF_TRUE</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;JUMP_IF_TRUE&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">CALL</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;CALL&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">RETURN</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;RETURN&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">PRINT</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;PRINT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">HALT</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;HALT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;TRUE&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">FALSE</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;FALSE&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">OpCode</span><span class="o">.</span><span class="n">NONE</span><span class="p">:</span> <span class="p">(</span><span class="s1">&#39;NONE&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
<span class="p">}</span>
</code></pre></div>

<hr />
<h2 id="4-stack-based-virtual-machines">4. Stack-Based Virtual Machines<a class="header-link" href="#4-stack-based-virtual-machines" title="Permanent link">&para;</a></h2>
<h3 id="41-how-stack-vms-work">4.1 How Stack VMs Work<a class="header-link" href="#41-how-stack-vms-work" title="Permanent link">&para;</a></h3>
<p>A stack-based VM uses an operand stack for all computations. Operands are pushed onto the stack, operations pop their arguments and push results.</p>
<div class="highlight"><pre><span></span><code>Computing x = a + b <span class="gs">* c:</span>

<span class="gs">Instructions:          Stack (grows right ‚Üí)</span>
<span class="gs">                       []</span>
<span class="gs">LOAD a                 [3]</span>
<span class="gs">LOAD b                 [3, 4]</span>
<span class="gs">LOAD c                 [3, 4, 5]</span>
<span class="gs">MUL                    [3, 20]      (4 *</span> 5 = 20)
ADD                    [23]         (3 + 20 = 23)
STORE x                []           (x = 23)
</code></pre></div>

<h3 id="42-advantages-of-stack-vms">4.2 Advantages of Stack VMs<a class="header-link" href="#42-advantages-of-stack-vms" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Simple code generation</strong>: No register allocation needed</li>
<li><strong>Compact bytecode</strong>: Instructions don't need to specify operand locations</li>
<li><strong>Easy to implement</strong>: The stack provides a natural evaluation order</li>
<li><strong>Portable</strong>: No assumptions about number of hardware registers</li>
</ol>
<h3 id="43-disadvantages">4.3 Disadvantages<a class="header-link" href="#43-disadvantages" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>More instructions</strong>: <code>LOAD a; LOAD b; ADD</code> vs <code>ADD r1, r2, r3</code></li>
<li><strong>Memory traffic</strong>: Every operation reads/writes the stack (memory, not registers)</li>
<li><strong>Harder to optimize</strong>: Stack positions are implicit, making analysis difficult</li>
</ol>
<h3 id="44-basic-stack-vm-implementation">4.4 Basic Stack VM Implementation<a class="header-link" href="#44-basic-stack-vm-implementation" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CodeObject</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compiled code object (like Python&#39;s code object).</span>
<span class="sd">    Contains bytecode, constants, and metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&lt;module&gt;&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bytecode</span> <span class="o">=</span> <span class="p">[]</span>       <span class="c1"># List of (opcode, arg) tuples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span> <span class="o">=</span> <span class="p">[]</span>      <span class="c1"># Constant pool</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_names</span> <span class="o">=</span> <span class="p">[]</span>    <span class="c1"># Local variable names</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_locals</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">emit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Emit a bytecode instruction.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bytecode</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bytecode</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># Return instruction index</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a constant to the pool, return its index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">add_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a local variable, return its slot index.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_names</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">local_names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">local_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_locals</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_names</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">disassemble</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print human-readable bytecode.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Disassembly of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> ===&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Constants: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Locals: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">local_names</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Instructions:&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bytecode</span><span class="p">):</span>
            <span class="n">name</span><span class="p">,</span> <span class="n">num_args</span> <span class="o">=</span> <span class="n">INSTRUCTION_INFO</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">opcode</span><span class="p">,</span> <span class="p">(</span><span class="s1">&#39;???&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Add human-readable annotation</span>
                <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">:</span>
                    <span class="n">extra</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">elif</span> <span class="n">opcode</span> <span class="ow">in</span> <span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">LOAD</span><span class="p">,</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">STORE</span><span class="p">):</span>
                    <span class="n">extra</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">local_names</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">if</span> <span class="n">arg</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">local_names</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
                <span class="k">elif</span> <span class="n">opcode</span> <span class="ow">in</span> <span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP</span><span class="p">,</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP_IF_FALSE</span><span class="p">,</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP_IF_TRUE</span><span class="p">):</span>
                    <span class="n">extra</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; (-&gt; </span><span class="si">{</span><span class="n">arg</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">extra</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">4d</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">name</span><span class="si">:</span><span class="s2">&lt;20s</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">arg</span><span class="si">}{</span><span class="n">extra</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">i</span><span class="si">:</span><span class="s2">4d</span><span class="si">}</span><span class="s2">  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="5-register-based-virtual-machines">5. Register-Based Virtual Machines<a class="header-link" href="#5-register-based-virtual-machines" title="Permanent link">&para;</a></h2>
<h3 id="51-register-vm-design">5.1 Register VM Design<a class="header-link" href="#51-register-vm-design" title="Permanent link">&para;</a></h3>
<p>Register-based VMs use virtual registers instead of a stack. Instructions explicitly name source and destination registers.</p>
<div class="highlight"><pre><span></span><code>Computing x = a + b <span class="gs">* c:</span>

<span class="gs">Stack VM:              Register VM:</span>
<span class="gs">  LOAD a                 MUL  r2, r1, r2    (r2 = b *</span> c)
  LOAD b                 ADD  r0, r0, r2    (r0 = a + r2)
  LOAD c
  MUL
  ADD
  STORE x

  6 instructions         2 instructions
</code></pre></div>

<h3 id="52-register-vm-example">5.2 Register VM Example<a class="header-link" href="#52-register-vm-example" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">RegisterVM</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple register-based VM.</span>

<span class="sd">    Instructions: (opcode, dest, src1, src2)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_registers</span><span class="o">=</span><span class="mi">256</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">registers</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">num_registers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">execute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instructions</span><span class="p">,</span> <span class="n">constants</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute register-based instructions.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">instructions</span><span class="p">):</span>
            <span class="n">instr</span> <span class="o">=</span> <span class="n">instructions</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pc</span><span class="p">]</span>
            <span class="n">opcode</span> <span class="o">=</span> <span class="n">instr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="s1">&#39;LOADK&#39;</span><span class="p">:</span>     <span class="c1"># Load constant: LOADK dest, const_idx</span>
                <span class="n">dest</span><span class="p">,</span> <span class="n">const_idx</span> <span class="o">=</span> <span class="n">instr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">instr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="n">constants</span><span class="p">[</span><span class="n">const_idx</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="s1">&#39;MOVE&#39;</span><span class="p">:</span>     <span class="c1"># Move: MOVE dest, src</span>
                <span class="n">dest</span><span class="p">,</span> <span class="n">src</span> <span class="o">=</span> <span class="n">instr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">instr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">src</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="s1">&#39;ADD&#39;</span><span class="p">:</span>      <span class="c1"># Add: ADD dest, src1, src2</span>
                <span class="n">dest</span><span class="p">,</span> <span class="n">src1</span><span class="p">,</span> <span class="n">src2</span> <span class="o">=</span> <span class="n">instr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">instr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">instr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">src1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">src2</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="s1">&#39;MUL&#39;</span><span class="p">:</span>
                <span class="n">dest</span><span class="p">,</span> <span class="n">src1</span><span class="p">,</span> <span class="n">src2</span> <span class="o">=</span> <span class="n">instr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">instr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">instr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">src1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">src2</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="s1">&#39;SUB&#39;</span><span class="p">:</span>
                <span class="n">dest</span><span class="p">,</span> <span class="n">src1</span><span class="p">,</span> <span class="n">src2</span> <span class="o">=</span> <span class="n">instr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">instr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">instr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">src1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">src2</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="s1">&#39;LT&#39;</span><span class="p">:</span>       <span class="c1"># Less than: LT dest, src1, src2</span>
                <span class="n">dest</span><span class="p">,</span> <span class="n">src1</span><span class="p">,</span> <span class="n">src2</span> <span class="o">=</span> <span class="n">instr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">instr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">instr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">dest</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">src1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">src2</span><span class="p">]</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="s1">&#39;JMP&#39;</span><span class="p">:</span>      <span class="c1"># Jump: JMP offset</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">+=</span> <span class="n">instr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="s1">&#39;JMPF&#39;</span><span class="p">:</span>     <span class="c1"># Jump if false: JMPF test, offset</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">instr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">+=</span> <span class="n">instr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">continue</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="s1">&#39;PRINT&#39;</span><span class="p">:</span>    <span class="c1"># Print: PRINT src</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Output: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">registers</span><span class="p">[</span><span class="n">instr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="s1">&#39;HALT&#39;</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">registers</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_register_vm</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate register-based VM computing sum 1..10.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Register VM Demo ===&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Computing sum of 1 to 10:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">vm</span> <span class="o">=</span> <span class="n">RegisterVM</span><span class="p">()</span>

    <span class="c1"># sum = 0; i = 1; while i &lt;= 10: sum += i; i += 1</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>  <span class="c1"># 0: zero, 1: one, 2: ten</span>

    <span class="n">instructions</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;LOADK&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>        <span class="c1"># r0 = 0 (sum)</span>
        <span class="p">(</span><span class="s1">&#39;LOADK&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>        <span class="c1"># r1 = 1 (i)</span>
        <span class="p">(</span><span class="s1">&#39;LOADK&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>        <span class="c1"># r2 = 10 (limit)</span>
        <span class="p">(</span><span class="s1">&#39;LOADK&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>        <span class="c1"># r3 = 1 (increment)</span>
        <span class="c1"># Loop start (pc=4):</span>
        <span class="p">(</span><span class="s1">&#39;LT&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>       <span class="c1"># r4 = (10 &lt; i), i.e., i &gt; 10</span>
        <span class="p">(</span><span class="s1">&#39;JMPF&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>        <span class="c1"># if not (i &gt; 10), skip next</span>
        <span class="p">(</span><span class="s1">&#39;JMP&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span>             <span class="c1"># jump to end (pc=10)</span>
        <span class="p">(</span><span class="s1">&#39;ADD&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>       <span class="c1"># sum += i</span>
        <span class="p">(</span><span class="s1">&#39;ADD&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>       <span class="c1"># i += 1</span>
        <span class="p">(</span><span class="s1">&#39;JMP&#39;</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">),</span>            <span class="c1"># jump back to loop start (pc=4)</span>
        <span class="c1"># End (pc=10):</span>
        <span class="p">(</span><span class="s1">&#39;PRINT&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>           <span class="c1"># print sum</span>
        <span class="p">(</span><span class="s1">&#39;HALT&#39;</span><span class="p">,),</span>
    <span class="p">]</span>

    <span class="n">vm</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">instructions</span><span class="p">,</span> <span class="n">constants</span><span class="p">)</span>

<span class="n">demonstrate_register_vm</span><span class="p">()</span>
</code></pre></div>

<h3 id="53-stack-vs-register-comparison">5.3 Stack vs Register Comparison<a class="header-link" href="#53-stack-vs-register-comparison" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Aspect</th>
<th>Stack-Based</th>
<th>Register-Based</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Instruction count</strong></td>
<td>More (implicit operands)</td>
<td>Fewer (explicit operands)</td>
</tr>
<tr>
<td><strong>Instruction size</strong></td>
<td>Smaller (no register fields)</td>
<td>Larger (2-3 register operands)</td>
</tr>
<tr>
<td><strong>Code size</strong></td>
<td>Often smaller overall</td>
<td>Often larger overall</td>
</tr>
<tr>
<td><strong>Dispatches</strong></td>
<td>More (more instructions)</td>
<td>Fewer</td>
</tr>
<tr>
<td><strong>Implementation</strong></td>
<td>Simpler</td>
<td>More complex</td>
</tr>
<tr>
<td><strong>Optimization</strong></td>
<td>Harder (stack is implicit)</td>
<td>Easier (registers are explicit)</td>
</tr>
<tr>
<td><strong>Examples</strong></td>
<td>JVM, CPython, CLR, WASM</td>
<td>Lua 5, Dalvik, BEAM</td>
</tr>
</tbody>
</table>
<p>Research by Shi et al. (2008) showed that register-based VMs execute about 47% fewer instructions, and despite larger code size, are typically 20-30% faster.</p>
<hr />
<h2 id="6-instruction-dispatch-techniques">6. Instruction Dispatch Techniques<a class="header-link" href="#6-instruction-dispatch-techniques" title="Permanent link">&para;</a></h2>
<h3 id="61-switch-dispatch">6.1 Switch Dispatch<a class="header-link" href="#61-switch-dispatch" title="Permanent link">&para;</a></h3>
<p>The simplest dispatch mechanism: a large <code>switch</code> (or <code>if/elif</code>) statement.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">switch_dispatch</span><span class="p">(</span><span class="n">bytecode</span><span class="p">,</span> <span class="n">constants</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Execute bytecode using switch dispatch.</span>
<span class="sd">    This is the simplest but slowest dispatch method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">while</span> <span class="n">pc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bytecode</span><span class="p">):</span>
        <span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">bytecode</span><span class="p">[</span><span class="n">pc</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constants</span><span class="p">[</span><span class="n">arg</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">SUB</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">MUL</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">PRINT</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>
        <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">HALT</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="c1"># ... more cases</span>

        <span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>
</code></pre></div>

<p><strong>Problem</strong>: The CPU's branch predictor sees one branch point for all opcodes. It can only predict the next opcode based on the previous one (poor accuracy).</p>
<h3 id="62-direct-threaded-code">6.2 Direct Threaded Code<a class="header-link" href="#62-direct-threaded-code" title="Permanent link">&para;</a></h3>
<p>Replace opcode values with direct pointers to handler code. After each handler executes, it jumps directly to the next handler (no central dispatch loop).</p>
<p>In C (not possible in pure Python due to language limitations):</p>
<div class="highlight"><pre><span></span><code><span class="c1">// C implementation of direct threading</span>
<span class="kt">void</span><span class="o">*</span><span class="w"> </span><span class="n">dispatch_table</span><span class="p">[]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">&amp;&amp;</span><span class="n">op_const</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">op_add</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">op_sub</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="n">op_mul</span><span class="p">,</span><span class="w"> </span><span class="cm">/* ... */</span>
<span class="p">};</span>

<span class="c1">// Initial dispatch</span>
<span class="k">goto</span><span class="w"> </span><span class="o">*</span><span class="n">dispatch_table</span><span class="p">[</span><span class="n">bytecode</span><span class="p">[</span><span class="n">pc</span><span class="p">]];</span>

<span class="nl">op_const</span><span class="p">:</span>
<span class="w">    </span><span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="o">++</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">constants</span><span class="p">[</span><span class="n">bytecode</span><span class="p">[</span><span class="n">pc</span><span class="o">+</span><span class="mi">1</span><span class="p">]];</span>
<span class="w">    </span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="o">*</span><span class="n">dispatch_table</span><span class="p">[</span><span class="n">bytecode</span><span class="p">[</span><span class="n">pc</span><span class="p">]];</span><span class="w">  </span><span class="c1">// Direct jump to next handler</span>

<span class="nl">op_add</span><span class="p">:</span>
<span class="w">    </span><span class="n">sp</span><span class="o">--</span><span class="p">;</span>
<span class="w">    </span><span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="mi">-1</span><span class="p">]</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">stack</span><span class="p">[</span><span class="n">sp</span><span class="p">];</span>
<span class="w">    </span><span class="n">pc</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">goto</span><span class="w"> </span><span class="o">*</span><span class="n">dispatch_table</span><span class="p">[</span><span class="n">bytecode</span><span class="p">[</span><span class="n">pc</span><span class="p">]];</span>
</code></pre></div>

<p><strong>Advantage</strong>: Each handler has its own indirect branch, giving the CPU branch predictor more context. This typically gives 15-25% speedup over switch dispatch.</p>
<h3 id="63-computed-goto-gcc-extension">6.3 Computed Goto (GCC Extension)<a class="header-link" href="#63-computed-goto-gcc-extension" title="Permanent link">&para;</a></h3>
<p>GCC's <code>&amp;&amp;label</code> extension enables direct threading in C. CPython uses this when available:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Python simulation of computed goto dispatch</span>
<span class="c1"># (In practice, this is done in C with goto *dispatch_table[opcode])</span>

<span class="k">def</span><span class="w"> </span><span class="nf">computed_goto_simulation</span><span class="p">(</span><span class="n">bytecode</span><span class="p">,</span> <span class="n">constants</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulate computed goto dispatch in Python.</span>

<span class="sd">    In real C implementations, this uses GCC&#39;s &amp;&amp;label extension</span>
<span class="sd">    for indirect branches, which enables better branch prediction.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Handler functions (simulate goto targets)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">handle_const</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">pc</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constants</span><span class="p">[</span><span class="n">bytecode</span><span class="p">[</span><span class="n">pc</span><span class="p">][</span><span class="mi">1</span><span class="p">]])</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">handle_add</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">pc</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">handle_mul</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">pc</span>
        <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">handle_print</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">pc</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Output: </span><span class="si">{</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">handle_halt</span><span class="p">():</span>
        <span class="k">nonlocal</span> <span class="n">pc</span>
        <span class="n">pc</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bytecode</span><span class="p">)</span>  <span class="c1"># Exit</span>

    <span class="c1"># Dispatch table (simulates array of goto labels)</span>
    <span class="n">dispatch</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">:</span> <span class="n">handle_const</span><span class="p">,</span>
        <span class="n">OpCode</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span> <span class="n">handle_add</span><span class="p">,</span>
        <span class="n">OpCode</span><span class="o">.</span><span class="n">MUL</span><span class="p">:</span> <span class="n">handle_mul</span><span class="p">,</span>
        <span class="n">OpCode</span><span class="o">.</span><span class="n">PRINT</span><span class="p">:</span> <span class="n">handle_print</span><span class="p">,</span>
        <span class="n">OpCode</span><span class="o">.</span><span class="n">HALT</span><span class="p">:</span> <span class="n">handle_halt</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="n">pc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bytecode</span><span class="p">):</span>
        <span class="n">opcode</span> <span class="o">=</span> <span class="n">bytecode</span><span class="p">[</span><span class="n">pc</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dispatch</span><span class="p">[</span><span class="n">opcode</span><span class="p">]()</span>  <span class="c1"># &quot;Computed goto&quot;</span>
</code></pre></div>

<h3 id="64-subroutine-threading">6.4 Subroutine Threading<a class="header-link" href="#64-subroutine-threading" title="Permanent link">&para;</a></h3>
<p>Each bytecode instruction is compiled into a call to its handler subroutine. Faster than switch, slower than direct threading (call/return overhead).</p>
<h3 id="65-dispatch-performance-comparison">6.5 Dispatch Performance Comparison<a class="header-link" href="#65-dispatch-performance-comparison" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

<span class="k">def</span><span class="w"> </span><span class="nf">benchmark_dispatch</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compare dispatch techniques (simplified Python benchmark).</span>
<span class="sd">    Real-world differences are more pronounced in C/C++.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create a simple program: push 1, push 2, add, repeated 1M times</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">100_000</span>

    <span class="n">bytecode</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">constants</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">bytecode</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">bytecode</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">bytecode</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">OpCode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">bytecode</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">OpCode</span><span class="o">.</span><span class="n">POP</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
    <span class="n">bytecode</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">OpCode</span><span class="o">.</span><span class="n">HALT</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="c1"># Method 1: if/elif chain</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">pc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bytecode</span><span class="p">):</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">bytecode</span><span class="p">[</span><span class="n">pc</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">constants</span><span class="p">[</span><span class="n">arg</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span>
            <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">POP</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">HALT</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">time_switch</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="c1"># Method 2: Dictionary dispatch</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">do_const</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span> <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">do_add</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span> <span class="n">b</span><span class="p">,</span> <span class="n">a2</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">();</span> <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a2</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">do_pop</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span><span class="p">):</span> <span class="n">s</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="n">dispatch_table</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">:</span> <span class="n">do_const</span><span class="p">,</span>
        <span class="n">OpCode</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span> <span class="n">do_add</span><span class="p">,</span>
        <span class="n">OpCode</span><span class="o">.</span><span class="n">POP</span><span class="p">:</span> <span class="n">do_pop</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">pc</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">bytecode</span><span class="p">):</span>
        <span class="n">op</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">bytecode</span><span class="p">[</span><span class="n">pc</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">op</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">HALT</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">dispatch_table</span><span class="p">[</span><span class="n">op</span><span class="p">](</span><span class="n">stack</span><span class="p">,</span> <span class="n">constants</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>
    <span class="n">time_dict</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;=== Dispatch Benchmark (</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> iterations) ===&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;if/elif chain: </span><span class="si">{</span><span class="n">time_switch</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dict dispatch: </span><span class="si">{</span><span class="n">time_dict</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Ratio: </span><span class="si">{</span><span class="n">time_dict</span><span class="o">/</span><span class="n">time_switch</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">x&quot;</span><span class="p">)</span>

<span class="c1"># benchmark_dispatch()  # Uncomment to run</span>
</code></pre></div>

<hr />
<h2 id="7-a-complete-bytecode-compiler-and-vm">7. A Complete Bytecode Compiler and VM<a class="header-link" href="#7-a-complete-bytecode-compiler-and-vm" title="Permanent link">&para;</a></h2>
<p>This section builds a complete bytecode compiler and stack-based VM for a simple language.</p>
<h3 id="71-the-language">7.1 The Language<a class="header-link" href="#71-the-language" title="Permanent link">&para;</a></h3>
<p>Our language (called "Mini") supports:
- Integers, floats, booleans, strings
- Arithmetic and comparison operators
- Variables and assignment
- <code>if</code>/<code>else</code> conditionals
- <code>while</code> loops
- Functions with parameters and return values
- Print statement</p>
<h3 id="72-the-bytecode-compiler">7.2 The Bytecode Compiler<a class="header-link" href="#72-the-bytecode-compiler" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Compiler</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Bytecode compiler: AST -&gt; CodeObject.</span>
<span class="sd">    Walks the AST and emits bytecode instructions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">CodeObject</span><span class="p">(</span><span class="s1">&#39;&lt;module&gt;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># name -&gt; CodeObject</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compile a list of AST statements to bytecode.&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">program</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">HALT</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compile a single AST node.&quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;compile_</span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CompileError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot compile </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">method</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_NumberLit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_StringLit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_BoolLit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">FALSE</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_Identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">slot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">add_local</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">LOAD</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_BinOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># Compile left operand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="c1"># Compile right operand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
        <span class="c1"># Emit operation</span>
        <span class="n">op_map</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;+&#39;</span><span class="p">:</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">SUB</span><span class="p">,</span>
            <span class="s1">&#39;*&#39;</span><span class="p">:</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span> <span class="s1">&#39;/&#39;</span><span class="p">:</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">DIV</span><span class="p">,</span>
            <span class="s1">&#39;%&#39;</span><span class="p">:</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">MOD</span><span class="p">,</span>
            <span class="s1">&#39;==&#39;</span><span class="p">:</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">EQ</span><span class="p">,</span> <span class="s1">&#39;!=&#39;</span><span class="p">:</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">NE</span><span class="p">,</span>
            <span class="s1">&#39;&lt;&#39;</span><span class="p">:</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">LT</span><span class="p">,</span> <span class="s1">&#39;&gt;&#39;</span><span class="p">:</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
            <span class="s1">&#39;&lt;=&#39;</span><span class="p">:</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">LE</span><span class="p">,</span> <span class="s1">&#39;&gt;=&#39;</span><span class="p">:</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">op_map</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">CompileError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown operator: </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">op_map</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_UnaryOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">NEG</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="s1">&#39;not&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">NOT</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_Assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="n">slot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">add_local</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">STORE</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_If</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># Compile condition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>

        <span class="c1"># Jump to else/end if false</span>
        <span class="n">jump_to_else</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP_IF_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Placeholder</span>

        <span class="c1"># Compile then body</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">then_body</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">else_body</span><span class="p">:</span>
            <span class="c1"># Jump over else body</span>
            <span class="n">jump_to_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Placeholder</span>

            <span class="c1"># Patch jump to else</span>
            <span class="n">else_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">bytecode</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">bytecode</span><span class="p">[</span><span class="n">jump_to_else</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP_IF_FALSE</span><span class="p">,</span> <span class="n">else_start</span><span class="p">)</span>

            <span class="c1"># Compile else body</span>
            <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">else_body</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

            <span class="c1"># Patch jump to end</span>
            <span class="n">end_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">bytecode</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">bytecode</span><span class="p">[</span><span class="n">jump_to_end</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP</span><span class="p">,</span> <span class="n">end_pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Patch jump to end (no else)</span>
            <span class="n">end_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">bytecode</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">bytecode</span><span class="p">[</span><span class="n">jump_to_else</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP_IF_FALSE</span><span class="p">,</span> <span class="n">end_pos</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_While</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># Loop start</span>
        <span class="n">loop_start</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">bytecode</span><span class="p">)</span>

        <span class="c1"># Compile condition</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>

        <span class="c1"># Jump to end if false</span>
        <span class="n">jump_to_end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP_IF_FALSE</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># Placeholder</span>

        <span class="c1"># Compile body</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

        <span class="c1"># Jump back to start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP</span><span class="p">,</span> <span class="n">loop_start</span><span class="p">)</span>

        <span class="c1"># Patch jump to end</span>
        <span class="n">end_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">bytecode</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">bytecode</span><span class="p">[</span><span class="n">jump_to_end</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP_IF_FALSE</span><span class="p">,</span> <span class="n">end_pos</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_Print</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">PRINT</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_FuncDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># Compile function to a separate CodeObject</span>
        <span class="n">func_code</span> <span class="o">=</span> <span class="n">CodeObject</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Add parameters as locals</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
            <span class="n">func_code</span><span class="o">.</span><span class="n">add_local</span><span class="p">(</span><span class="n">param</span><span class="p">)</span>

        <span class="c1"># Save current code object, switch to function&#39;s</span>
        <span class="n">parent_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">func_code</span>

        <span class="c1"># Compile function body</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>

        <span class="c1"># Ensure function returns None if no explicit return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">NONE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">RETURN</span><span class="p">)</span>

        <span class="c1"># Restore parent code object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">parent_code</span>

        <span class="c1"># Store function in constants</span>
        <span class="n">func_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">add_constant</span><span class="p">(</span><span class="n">func_code</span><span class="p">)</span>
        <span class="n">func_slot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">add_local</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">,</span> <span class="n">func_idx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">STORE</span><span class="p">,</span> <span class="n">func_slot</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_FuncCall</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1"># Push function object</span>
        <span class="n">slot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">add_local</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">LOAD</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span>

        <span class="c1"># Push arguments</span>
        <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>

        <span class="c1"># Call with number of arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">CALL</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_Return</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compile_node</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">NONE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="n">OpCode</span><span class="o">.</span><span class="n">RETURN</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">CompileError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="k">pass</span>
</code></pre></div>

<h3 id="73-the-virtual-machine">7.3 The Virtual Machine<a class="header-link" href="#73-the-virtual-machine" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Frame</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Call frame: represents a function invocation.</span>
<span class="sd">    Contains local variables and a return address.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">,</span> <span class="n">return_addr</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">code</span> <span class="o">=</span> <span class="n">code</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">locals</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">code</span><span class="o">.</span><span class="n">num_locals</span> <span class="o">+</span> <span class="mi">16</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">return_addr</span> <span class="o">=</span> <span class="n">return_addr</span>


<span class="k">class</span><span class="w"> </span><span class="nc">VirtualMachine</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Stack-based virtual machine for our bytecode.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_frame</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">output</span> <span class="o">=</span> <span class="p">[]</span>       <span class="c1"># Captured output</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">code</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Execute a CodeObject.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_frame</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_frame</span><span class="p">)</span>

        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_frame</span>
            <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">pc</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">bytecode</span><span class="p">):</span>
                <span class="k">break</span>

            <span class="n">opcode</span><span class="p">,</span> <span class="n">arg</span> <span class="o">=</span> <span class="n">frame</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">bytecode</span><span class="p">[</span><span class="n">frame</span><span class="o">.</span><span class="n">pc</span><span class="p">]</span>
            <span class="n">frame</span><span class="o">.</span><span class="n">pc</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># Dispatch</span>
            <span class="k">if</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">CONST</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">code</span><span class="o">.</span><span class="n">constants</span><span class="p">[</span><span class="n">arg</span><span class="p">])</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">POP</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">ADD</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">SUB</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">MUL</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">DIV</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Division by zero&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">MOD</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">NEG</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">EQ</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">NE</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">LT</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">GT</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">LE</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">&lt;=</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">GE</span><span class="p">:</span>
                <span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span> <span class="o">&gt;=</span> <span class="n">b</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">NOT</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">LOAD</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frame</span><span class="o">.</span><span class="n">locals</span><span class="p">[</span><span class="n">arg</span><span class="p">])</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">STORE</span><span class="p">:</span>
                <span class="n">frame</span><span class="o">.</span><span class="n">locals</span><span class="p">[</span><span class="n">arg</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP</span><span class="p">:</span>
                <span class="n">frame</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">arg</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP_IF_FALSE</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">():</span>
                    <span class="n">frame</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">arg</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">JUMP_IF_TRUE</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">():</span>
                    <span class="n">frame</span><span class="o">.</span><span class="n">pc</span> <span class="o">=</span> <span class="n">arg</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">CALL</span><span class="p">:</span>
                <span class="n">num_args</span> <span class="o">=</span> <span class="n">arg</span>
                <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_args</span><span class="p">):</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>

                <span class="n">func_code</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># Pop function object</span>

                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func_code</span><span class="p">,</span> <span class="n">CodeObject</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not callable: </span><span class="si">{</span><span class="n">func_code</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

                <span class="c1"># Create new frame</span>
                <span class="n">new_frame</span> <span class="o">=</span> <span class="n">Frame</span><span class="p">(</span><span class="n">func_code</span><span class="p">,</span> <span class="n">return_addr</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Bind arguments to parameters</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
                    <span class="n">new_frame</span><span class="o">.</span><span class="n">locals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

                <span class="c1"># Push current frame&#39;s return info</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_frame</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">current_frame</span> <span class="o">=</span> <span class="n">new_frame</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">RETURN</span><span class="p">:</span>
                <span class="n">return_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

                <span class="c1"># Pop frame</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">return_value</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">current_frame</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">frames</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">return_value</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">PRINT</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">output</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  &gt;&gt; </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">TRUE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">FALSE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">NONE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">opcode</span> <span class="o">==</span> <span class="n">OpCode</span><span class="o">.</span><span class="n">HALT</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown opcode: </span><span class="si">{</span><span class="n">opcode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stack</span> <span class="k">else</span> <span class="kc">None</span>
</code></pre></div>

<h3 id="74-putting-it-all-together">7.4 Putting It All Together<a class="header-link" href="#74-putting-it-all-together" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">run_mini_program</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compile and run a complete Mini program.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Complete Bytecode Compiler + VM Demo ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Program: compute factorial using a loop</span>
    <span class="n">program</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># n = 10</span>
        <span class="n">Assign</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="n">NumberLit</span><span class="p">(</span><span class="mi">10</span><span class="p">)),</span>

        <span class="c1"># result = 1</span>
        <span class="n">Assign</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">,</span> <span class="n">NumberLit</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>

        <span class="c1"># i = 1</span>
        <span class="n">Assign</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">NumberLit</span><span class="p">(</span><span class="mi">1</span><span class="p">)),</span>

        <span class="c1"># while i &lt;= n:</span>
        <span class="n">While</span><span class="p">(</span>
            <span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;&lt;=&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">),</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">)),</span>
            <span class="p">[</span>
                <span class="c1"># result = result * i</span>
                <span class="n">Assign</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">),</span>
                                       <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">))),</span>
                <span class="c1"># i = i + 1</span>
                <span class="n">Assign</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">),</span> <span class="n">NumberLit</span><span class="p">(</span><span class="mi">1</span><span class="p">))),</span>
            <span class="p">]</span>
        <span class="p">),</span>

        <span class="c1"># print(result)</span>
        <span class="n">Print</span><span class="p">(</span><span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;result&#39;</span><span class="p">)),</span>
    <span class="p">]</span>

    <span class="c1"># Compile</span>
    <span class="n">compiler</span> <span class="o">=</span> <span class="n">Compiler</span><span class="p">()</span>
    <span class="n">code</span> <span class="o">=</span> <span class="n">compiler</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>

    <span class="c1"># Disassemble</span>
    <span class="n">code</span><span class="o">.</span><span class="n">disassemble</span><span class="p">()</span>

    <span class="c1"># Execute</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Execution ---&quot;</span><span class="p">)</span>
    <span class="n">vm</span> <span class="o">=</span> <span class="n">VirtualMachine</span><span class="p">()</span>
    <span class="n">vm</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">code</span><span class="p">)</span>

    <span class="c1"># Program 2: Recursive function</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;=&quot;</span> <span class="o">*</span> <span class="mi">50</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Program 2: Recursive Fibonacci</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">program2</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">FuncDef</span><span class="p">(</span><span class="s1">&#39;fib&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">],</span> <span class="p">[</span>
            <span class="n">If</span><span class="p">(</span>
                <span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">),</span> <span class="n">NumberLit</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
                <span class="p">[</span><span class="n">Return</span><span class="p">(</span><span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">))],</span>
                <span class="p">[</span><span class="n">Return</span><span class="p">(</span><span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
                              <span class="n">FuncCall</span><span class="p">(</span><span class="s1">&#39;fib&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">),</span>
                                                     <span class="n">NumberLit</span><span class="p">(</span><span class="mi">1</span><span class="p">))]),</span>
                              <span class="n">FuncCall</span><span class="p">(</span><span class="s1">&#39;fib&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">BinOp</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s1">&#39;n&#39;</span><span class="p">),</span>
                                                     <span class="n">NumberLit</span><span class="p">(</span><span class="mi">2</span><span class="p">))])))]</span>
            <span class="p">)</span>
        <span class="p">]),</span>
        <span class="n">Print</span><span class="p">(</span><span class="n">FuncCall</span><span class="p">(</span><span class="s1">&#39;fib&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">NumberLit</span><span class="p">(</span><span class="mi">10</span><span class="p">)])),</span>
    <span class="p">]</span>

    <span class="n">compiler2</span> <span class="o">=</span> <span class="n">Compiler</span><span class="p">()</span>
    <span class="n">code2</span> <span class="o">=</span> <span class="n">compiler2</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">program2</span><span class="p">)</span>
    <span class="n">code2</span><span class="o">.</span><span class="n">disassemble</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">--- Execution ---&quot;</span><span class="p">)</span>
    <span class="n">vm2</span> <span class="o">=</span> <span class="n">VirtualMachine</span><span class="p">()</span>
    <span class="n">vm2</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">code2</span><span class="p">)</span>

<span class="n">run_mini_program</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="8-jit-compilation">8. JIT Compilation<a class="header-link" href="#8-jit-compilation" title="Permanent link">&para;</a></h2>
<h3 id="81-why-jit">8.1 Why JIT?<a class="header-link" href="#81-why-jit" title="Permanent link">&para;</a></h3>
<p>Bytecode interpretation is still 5-20x slower than native code due to dispatch overhead, lack of register usage, and inability to apply traditional compiler optimizations. <strong>Just-In-Time (JIT) compilation</strong> bridges this gap by compiling bytecode to native code at runtime.</p>
<div class="highlight"><pre><span></span><code>              Startup Speed  ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂  Steady-state Speed
Interpretation  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                         ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
Bytecode        ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
Method JIT      ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
Tracing JIT     ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà                       ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
AOT Compile     ‚ñë‚ñë‚ñë‚ñë                             ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà
</code></pre></div>

<h3 id="82-method-jit">8.2 Method JIT<a class="header-link" href="#82-method-jit" title="Permanent link">&para;</a></h3>
<p>A <strong>method JIT</strong> compiler identifies hot methods (frequently called functions) and compiles them to native code.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">MethodJITSimulator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates method JIT compilation behavior.</span>

<span class="sd">    Hot methods are &quot;compiled&quot; (represented by optimized Python functions)</span>
<span class="sd">    when their call count exceeds a threshold.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hot_threshold</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hot_threshold</span> <span class="o">=</span> <span class="n">hot_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span> <span class="o">=</span> <span class="p">{}</span>       <span class="c1"># method name -&gt; count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span> <span class="o">=</span> <span class="p">{}</span>          <span class="c1"># method name -&gt; compiled version</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compilation_log</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">call_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">interpreted_func</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Call a method, potentially triggering JIT compilation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Track call count</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Check if we should compile</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span> <span class="ow">and</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hot_threshold</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compile_method</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">interpreted_func</span><span class="p">)</span>

        <span class="c1"># Execute compiled version if available</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span><span class="p">[</span><span class="n">name</span><span class="p">](</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">interpreted_func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compile_method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simulate JIT compilation of a method.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compilation_log</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># In reality, this would generate native code</span>
        <span class="c1"># We simulate &quot;optimization&quot; by creating an optimized version</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span>  <span class="c1"># In practice, a native code version</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  [JIT] Compiled method: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;(after </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">call_counts</span><span class="p">[</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2"> calls)&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_method_jit</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Show method JIT behavior.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Method JIT Simulation ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">jit</span> <span class="o">=</span> <span class="n">MethodJITSimulator</span><span class="p">(</span><span class="n">hot_threshold</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fibonacci</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">fibonacci</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># First few calls: interpreted</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">jit</span><span class="o">.</span><span class="n">call_method</span><span class="p">(</span><span class="s1">&#39;fibonacci&#39;</span><span class="p">,</span> <span class="n">fibonacci</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Call counts: </span><span class="si">{</span><span class="n">jit</span><span class="o">.</span><span class="n">call_counts</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Compiled methods: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">jit</span><span class="o">.</span><span class="n">compiled</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">demonstrate_method_jit</span><span class="p">()</span>
</code></pre></div>

<h3 id="83-tracing-jit">8.3 Tracing JIT<a class="header-link" href="#83-tracing-jit" title="Permanent link">&para;</a></h3>
<p>A <strong>tracing JIT</strong> records the actual execution path through a hot loop (a "trace"), then compiles that specific path to native code.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TracingJITSimulator</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates tracing JIT compilation.</span>

<span class="sd">    Records execution traces of hot loops and &quot;compiles&quot; them.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hot_threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hot_threshold</span> <span class="o">=</span> <span class="n">hot_threshold</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_counts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traces</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">recording</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_trace</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">enter_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called at the top of each loop iteration.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">loop_counts</span><span class="p">[</span><span class="n">loop_id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">loop_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">loop_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="k">return</span> <span class="s1">&#39;compiled&#39;</span>  <span class="c1"># Use compiled trace</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">loop_counts</span><span class="p">[</span><span class="n">loop_id</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hot_threshold</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">recording</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recording</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_trace</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_loop</span> <span class="o">=</span> <span class="n">loop_id</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  [Trace] Starting trace recording for loop </span><span class="si">{</span><span class="n">loop_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="s1">&#39;recording&#39;</span>

        <span class="k">return</span> <span class="s1">&#39;interpreting&#39;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">record_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Record an operation during tracing.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">recording</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_trace</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">op</span><span class="p">,</span> <span class="n">args</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">record_guard</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">description</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Record a guard (type check, bounds check, etc.).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">recording</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_trace</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s1">&#39;GUARD&#39;</span><span class="p">,</span> <span class="n">description</span><span class="p">,</span> <span class="n">condition</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">end_loop_iteration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called at the end of each loop iteration.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">recording</span> <span class="ow">and</span> <span class="n">loop_id</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_loop</span><span class="p">:</span>
            <span class="c1"># Compile the trace</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="n">loop_id</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_trace</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">recording</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  [Trace] Compiled trace for loop </span><span class="si">{</span><span class="n">loop_id</span><span class="si">}</span><span class="s2"> &quot;</span>
                  <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_trace</span><span class="p">)</span><span class="si">}</span><span class="s2"> operations)&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_trace</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">show_trace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop_id</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Display a compiled trace.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">loop_id</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No trace for loop </span><span class="si">{</span><span class="n">loop_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">=== Trace for loop </span><span class="si">{</span><span class="n">loop_id</span><span class="si">}</span><span class="s2"> ===&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traces</span><span class="p">[</span><span class="n">loop_id</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;GUARD&#39;</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: GUARD </span><span class="si">{</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">entry</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">entry</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_tracing_jit</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Show tracing JIT behavior.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Tracing JIT Simulation ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">jit</span> <span class="o">=</span> <span class="n">TracingJITSimulator</span><span class="p">(</span><span class="n">hot_threshold</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>

    <span class="c1"># Simulate a loop: sum = 0; for i in range(10): sum += i * 2</span>
    <span class="n">arr</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">iteration</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>  <span class="c1"># Run the same loop 5 times</span>
        <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)):</span>
            <span class="n">status</span> <span class="o">=</span> <span class="n">jit</span><span class="o">.</span><span class="n">enter_loop</span><span class="p">(</span><span class="s1">&#39;sum_loop&#39;</span><span class="p">)</span>

            <span class="c1"># Record operations</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">jit</span><span class="o">.</span><span class="n">record_guard</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span> <span class="s2">&quot;type(val) is int&quot;</span><span class="p">)</span>
            <span class="n">jit</span><span class="o">.</span><span class="n">record_operation</span><span class="p">(</span><span class="s1">&#39;LOAD_ARRAY&#39;</span><span class="p">,</span> <span class="s1">&#39;arr&#39;</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="n">doubled</span> <span class="o">=</span> <span class="n">val</span> <span class="o">*</span> <span class="mi">2</span>
            <span class="n">jit</span><span class="o">.</span><span class="n">record_operation</span><span class="p">(</span><span class="s1">&#39;MUL&#39;</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">total</span> <span class="o">+=</span> <span class="n">doubled</span>
            <span class="n">jit</span><span class="o">.</span><span class="n">record_operation</span><span class="p">(</span><span class="s1">&#39;ADD&#39;</span><span class="p">,</span> <span class="s1">&#39;total&#39;</span><span class="p">,</span> <span class="n">doubled</span><span class="p">)</span>

            <span class="n">jit</span><span class="o">.</span><span class="n">end_loop_iteration</span><span class="p">(</span><span class="s1">&#39;sum_loop&#39;</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Iteration </span><span class="si">{</span><span class="n">iteration</span><span class="si">}</span><span class="s2">: sum = </span><span class="si">{</span><span class="n">total</span><span class="si">}</span><span class="s2">, &quot;</span>
              <span class="sa">f</span><span class="s2">&quot;loop mode = </span><span class="si">{</span><span class="n">status</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">jit</span><span class="o">.</span><span class="n">show_trace</span><span class="p">(</span><span class="s1">&#39;sum_loop&#39;</span><span class="p">)</span>

<span class="n">demonstrate_tracing_jit</span><span class="p">()</span>
</code></pre></div>

<h3 id="84-trace-compilation-details">8.4 Trace Compilation Details<a class="header-link" href="#84-trace-compilation-details" title="Permanent link">&para;</a></h3>
<p>A trace is a linear sequence of operations with guards:</p>
<div class="highlight"><pre><span></span><code><span class="n">Trace</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="ss">&quot;for i in range(n): sum += arr[i] * 2&quot;</span><span class="err">:</span>

<span class="w">  </span><span class="nl">GUARD</span><span class="p">:</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">n</span><span class="w">                    </span><span class="err">#</span><span class="w"> </span><span class="n">Loop</span><span class="w"> </span><span class="k">condition</span>
<span class="w">  </span><span class="n">LOAD_ARRAY</span><span class="w"> </span><span class="n">arr</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w">               </span><span class="err">#</span><span class="w"> </span><span class="k">Load</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
<span class="w">  </span><span class="nl">GUARD</span><span class="p">:</span><span class="w"> </span><span class="n">type</span><span class="p">(</span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nc">int</span><span class="w">      </span><span class="err">#</span><span class="w"> </span><span class="n">Type</span><span class="w"> </span><span class="k">check</span>
<span class="w">  </span><span class="n">MUL</span><span class="w"> </span><span class="n">temp</span><span class="p">,</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="w">             </span><span class="err">#</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arr</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="mi">2</span>
<span class="w">  </span><span class="k">ADD</span><span class="w"> </span><span class="nf">sum</span><span class="p">,</span><span class="w"> </span><span class="nf">sum</span><span class="p">,</span><span class="w"> </span><span class="n">temp</span><span class="w">              </span><span class="err">#</span><span class="w"> </span><span class="nf">sum</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">temp</span>
<span class="w">  </span><span class="k">ADD</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="w">                     </span><span class="err">#</span><span class="w"> </span><span class="n">i</span><span class="o">++</span>
<span class="w">  </span><span class="n">JUMP</span><span class="w"> </span><span class="n">loop_start</span><span class="w">                 </span><span class="err">#</span><span class="w"> </span><span class="n">Back</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="k">start</span>
</code></pre></div>

<p>If any guard fails, the trace is abandoned ("side exit"), and execution falls back to the interpreter. Common guard failures trigger new traces for alternative paths.</p>
<h3 id="85-on-stack-replacement-osr">8.5 On-Stack Replacement (OSR)<a class="header-link" href="#85-on-stack-replacement-osr" title="Permanent link">&para;</a></h3>
<p><strong>On-stack replacement</strong> allows switching between interpreted and compiled code in the middle of a function (even inside a loop). Without OSR, a hot loop would have to complete an entire function call in the interpreter before the compiled version could be used.</p>
<div class="highlight"><pre><span></span><code><span class="nv">Without</span><span class="w"> </span><span class="nv">OSR</span>:
<span class="w">  </span><span class="nv">Interpreter</span>:<span class="w"> </span>‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà<span class="w">  </span><span class="ss">(</span><span class="nv">entire</span><span class="w"> </span><span class="k">loop</span><span class="w"> </span><span class="nv">interpreted</span><span class="ss">)</span>
<span class="w">  </span><span class="k">Next</span><span class="w"> </span><span class="nv">call</span>:<span class="w">   </span>‚ñë‚ñë‚ñë‚ñë<span class="w"> </span><span class="ss">(</span><span class="nv">compiled</span><span class="ss">)</span>

<span class="nv">With</span><span class="w"> </span><span class="nv">OSR</span>:
<span class="w">  </span><span class="nv">Interpreter</span>:<span class="w"> </span>‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë<span class="w">  </span><span class="ss">(</span><span class="nv">OSR</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">compiled</span><span class="w"> </span><span class="nv">code</span><span class="w"> </span><span class="nv">mid</span><span class="o">-</span><span class="k">loop</span><span class="ss">)</span>
<span class="w">               </span>‚Üë<span class="w"> </span><span class="nv">OSR</span><span class="w"> </span><span class="nv">point</span>
</code></pre></div>

<hr />
<h2 id="9-runtime-optimization-techniques">9. Runtime Optimization Techniques<a class="header-link" href="#9-runtime-optimization-techniques" title="Permanent link">&para;</a></h2>
<h3 id="91-inline-caching">9.1 Inline Caching<a class="header-link" href="#91-inline-caching" title="Permanent link">&para;</a></h3>
<p><strong>Inline caching</strong> speeds up method dispatch in dynamic languages. The first time a method is called on an object, the runtime looks up the method and caches the result at the call site.</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">InlineCache</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simulates inline caching for method dispatch.</span>

<span class="sd">    Three states:</span>
<span class="sd">    1. Uninitialized: No cache (first call triggers lookup)</span>
<span class="sd">    2. Monomorphic: One cached type (fastest, most common)</span>
<span class="sd">    3. Polymorphic: Multiple cached types (still fast)</span>
<span class="sd">    4. Megamorphic: Too many types (falls back to generic lookup)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="n">max_entries</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method_name</span> <span class="o">=</span> <span class="n">method_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cache</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># type -&gt; method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_entries</span> <span class="o">=</span> <span class="n">max_entries</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hits</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">misses</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Look up a method using the inline cache.&quot;&quot;&quot;</span>
        <span class="n">obj_type</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">obj_type</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hits</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">obj_type</span><span class="p">]</span>

        <span class="c1"># Cache miss -- do full lookup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">misses</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">method_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_entries</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">[</span><span class="n">obj_type</span><span class="p">]</span> <span class="o">=</span> <span class="n">method</span>  <span class="c1"># Cache it</span>

        <span class="k">return</span> <span class="n">method</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cache</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;uninitialized&quot;</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;monomorphic&quot;</span>
        <span class="k">elif</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_entries</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;polymorphic&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;megamorphic&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;IC(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">method_name</span><span class="si">}</span><span class="s2">, state=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">state</span><span class="si">}</span><span class="s2">, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;hits=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">hits</span><span class="si">}</span><span class="s2">, misses=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">misses</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_inline_caching</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Show inline caching behavior.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Inline Caching Demo ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">Dog</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot;Woof!&quot;</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">Cat</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot;Meow!&quot;</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">Duck</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">speak</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span> <span class="k">return</span> <span class="s2">&quot;Quack!&quot;</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="n">InlineCache</span><span class="p">(</span><span class="s1">&#39;speak&#39;</span><span class="p">)</span>

    <span class="n">animals</span> <span class="o">=</span> <span class="p">[</span><span class="n">Dog</span><span class="p">(),</span> <span class="n">Dog</span><span class="p">(),</span> <span class="n">Dog</span><span class="p">(),</span> <span class="n">Cat</span><span class="p">(),</span> <span class="n">Dog</span><span class="p">(),</span> <span class="n">Duck</span><span class="p">(),</span> <span class="n">Dog</span><span class="p">()]</span>

    <span class="k">for</span> <span class="n">animal</span> <span class="ow">in</span> <span class="n">animals</span><span class="p">:</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">cache</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">method</span><span class="p">()</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">animal</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.speak() = </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2"> | Cache: </span><span class="si">{</span><span class="n">cache</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">demonstrate_inline_caching</span><span class="p">()</span>
</code></pre></div>

<h3 id="92-type-specialization">9.2 Type Specialization<a class="header-link" href="#92-type-specialization" title="Permanent link">&para;</a></h3>
<p>JIT compilers generate specialized code for specific types:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_type_specialization</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Show type specialization in a JIT compiler.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Type Specialization ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Generic add (what the interpreter does)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">generic_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Must check types at runtime.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot add </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="si">}</span><span class="s2"> and </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Specialized add (what the JIT generates after seeing types)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">int_add</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;No type checks needed -- we know both are ints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span>  <span class="c1"># Direct integer addition</span>

    <span class="c1"># In practice, the JIT generates:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Generic version (interpreter):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  1. Check type of a&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  2. Check type of b&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  3. Look up appropriate + operator&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  4. Perform addition&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  5. Box result&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Specialized version (JIT, after seeing int+int):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  1. GUARD: type(a) == int  (deoptimize if not)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  2. GUARD: type(b) == int  (deoptimize if not)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  3. Native integer addition (single CPU instruction)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  4. Result already unboxed&quot;</span><span class="p">)</span>

    <span class="c1"># Benchmark</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">1_000_000</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">generic_add</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">time_generic</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span>
    <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">total</span> <span class="o">=</span> <span class="n">int_add</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
    <span class="n">time_specialized</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">perf_counter</span><span class="p">()</span> <span class="o">-</span> <span class="n">start</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Generic add (</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> iterations): </span><span class="si">{</span><span class="n">time_generic</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Specialized add (</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2"> iterations): </span><span class="si">{</span><span class="n">time_specialized</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">s&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Speedup: </span><span class="si">{</span><span class="n">time_generic</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">time_specialized</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">x&quot;</span><span class="p">)</span>

<span class="c1"># demonstrate_type_specialization()  # Uncomment to run</span>
</code></pre></div>

<h3 id="93-deoptimization">9.3 Deoptimization<a class="header-link" href="#93-deoptimization" title="Permanent link">&para;</a></h3>
<p>When assumptions made by the JIT are violated (guard failure), the runtime must <strong>deoptimize</strong> -- fall back from compiled code to the interpreter.</p>
<div class="highlight"><pre><span></span><code><span class="nx">Compiled</span><span class="w"> </span><span class="nx">code</span><span class="p">:</span>
<span class="w">  </span><span class="nx">GUARD</span><span class="w"> </span><span class="k">type</span><span class="p">(</span><span class="nx">x</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">int</span><span class="w">     </span><span class="err">‚îÄ‚îÄ‚îÄ‚îÄ</span><span class="w"> </span><span class="nx">guard</span><span class="w"> </span><span class="nx">fails</span><span class="w"> </span><span class="err">‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂</span><span class="w">  </span><span class="nx">Deoptimize</span>
<span class="w">  </span><span class="nx">native_int_add</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span><span class="w"> </span><span class="nx">y</span><span class="p">)</span><span class="w">                              </span><span class="err">‚îÇ</span>
<span class="w">  </span><span class="o">...</span><span class="w">                                                </span><span class="err">‚ñº</span>
<span class="w">                                                 </span><span class="nx">Interpreter</span>
<span class="w">                                                 </span><span class="p">(</span><span class="k">continue</span><span class="w"> </span><span class="nx">execution</span>
<span class="w">                                                  </span><span class="nx">with</span><span class="w"> </span><span class="nx">correct</span><span class="w"> </span><span class="nx">semantics</span><span class="p">)</span>
</code></pre></div>

<p>Deoptimization requires:
1. Reconstructing the interpreter state (stack, locals) from the compiled state
2. Invalidating the compiled code (if the assumption is permanently wrong)
3. Possibly recompiling with less aggressive assumptions</p>
<h3 id="94-hidden-classes-shapes">9.4 Hidden Classes / Shapes<a class="header-link" href="#94-hidden-classes-shapes" title="Permanent link">&para;</a></h3>
<p>V8 and other VMs use <strong>hidden classes</strong> (called "shapes" or "maps") to optimize property access on dynamic objects:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_hidden_classes</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate the concept of hidden classes / shapes.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Hidden Classes / Shapes ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># In JavaScript, objects are dictionaries:</span>
    <span class="c1"># let p = {};  p.x = 1;  p.y = 2;</span>

    <span class="c1"># V8 creates hidden classes for each &quot;shape&quot;:</span>
    <span class="n">shapes</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Shape0&#39;</span><span class="p">:</span> <span class="p">{},</span>                          <span class="c1"># Empty object</span>
        <span class="s1">&#39;Shape1&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;offset 0&#39;</span><span class="p">},</span>           <span class="c1"># After p.x = 1</span>
        <span class="s1">&#39;Shape2&#39;</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;x&#39;</span><span class="p">:</span> <span class="s1">&#39;offset 0&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span> <span class="s1">&#39;offset 1&#39;</span><span class="p">},</span>  <span class="c1"># After p.y = 2</span>
    <span class="p">}</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Object shape transitions:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  let p = </span><span class="si">{}</span><span class="s2">          -&gt; Shape0 (empty)&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  p.x = 1             -&gt; Shape1 ({x: offset 0})&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  p.y = 2             -&gt; Shape2 ({x: offset 0, y: offset 1})&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Objects with the same shape share the same hidden class.&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Property access becomes a fixed-offset load (like a struct).&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  let q = </span><span class="si">{}</span><span class="s2">; q.x = 5; q.y = 10;&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  q has the SAME Shape2 as p!&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  Accessing q.y is: load [q + offset_of_y]  (no dictionary lookup)&quot;</span><span class="p">)</span>

<span class="n">demonstrate_hidden_classes</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="10-real-virtual-machines">10. Real Virtual Machines<a class="header-link" href="#10-real-virtual-machines" title="Permanent link">&para;</a></h2>
<h3 id="101-jvm-java-virtual-machine">10.1 JVM (Java Virtual Machine)<a class="header-link" href="#101-jvm-java-virtual-machine" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>JVM Architecture:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    JVM                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê     ‚îÇ
‚îÇ  ‚îÇ Class    ‚îÇ   ‚îÇ      Runtime Data Areas   ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ Loader   ‚îÇ   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ          ‚îÇ   ‚îÇ  ‚îÇMethod‚îÇ  ‚îÇ  Heap     ‚îÇ  ‚îÇ     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ  ‚îÇArea  ‚îÇ  ‚îÇ(GC-managed‚îÇ  ‚îÇ     ‚îÇ
‚îÇ                 ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇExecution ‚îÇ   ‚îÇ  ‚îÇStack ‚îÇ  ‚îÇ PC Regs   ‚îÇ  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ Engine   ‚îÇ   ‚îÇ  ‚îÇ(per  ‚îÇ  ‚îÇ(per thread‚îÇ  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ - Interp ‚îÇ   ‚îÇ  ‚îÇthread‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ - JIT(C1)‚îÇ   ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îÇ     ‚îÇ
‚îÇ  ‚îÇ - JIT(C2)‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></div>

<p>Key characteristics:
- <strong>Stack-based bytecode</strong>: ~200 opcodes
- <strong>Typed instructions</strong>: <code>iadd</code> (int), <code>fadd</code> (float), <code>dadd</code> (double)
- <strong>Tiered compilation</strong>: Interpreter -&gt; C1 (fast compile) -&gt; C2 (optimizing compile)
- <strong>GC</strong>: Multiple collectors (G1 default, ZGC for low latency)
- <strong>Bytecode verification</strong>: Type-safe bytecodes verified before execution</p>
<h3 id="102-cpython-vm">10.2 CPython VM<a class="header-link" href="#102-cpython-vm" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>CPython Architecture:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              CPython                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê              ‚îÇ
‚îÇ  ‚îÇ Parser   ‚îÇ‚îÄ‚îÄ‚ñ∂‚îÇ Compiler   ‚îÇ              ‚îÇ
‚îÇ  ‚îÇ (PEG)    ‚îÇ   ‚îÇ (AST‚ÜíBC)   ‚îÇ              ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îò              ‚îÇ
‚îÇ                            ‚îÇ                ‚îÇ
‚îÇ                            ‚ñº                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ        Bytecode Interpreter      ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  (ceval.c: giant switch stmt)    ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ                                  ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  - Stack-based                   ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  - ~120 opcodes                  ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  - Reference counting + cycle GC ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  - GIL (Global Interpreter Lock) ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></div>

<p>You can inspect CPython bytecode using the <code>dis</code> module:</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">dis</span>

<span class="k">def</span><span class="w"> </span><span class="nf">example_function</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span>

<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== CPython Bytecode ===&quot;</span><span class="p">)</span>
<span class="n">dis</span><span class="o">.</span><span class="n">dis</span><span class="p">(</span><span class="n">example_function</span><span class="p">)</span>
</code></pre></div>

<p>Output (approximate):</p>
<div class="highlight"><pre><span></span><code>  2           0 LOAD_FAST                0 (x)
              2 LOAD_FAST                0 (x)
              4 BINARY_MULTIPLY
              6 LOAD_FAST                1 (y)
              8 LOAD_FAST                1 (y)
             10 BINARY_MULTIPLY
             12 BINARY_ADD
             14 RETURN_VALUE
</code></pre></div>

<h3 id="103-v8-javascript">10.3 V8 (JavaScript)<a class="header-link" href="#103-v8-javascript" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>V8 Architecture:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    V8                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                                ‚îÇ
‚îÇ  ‚îÇ Parser   ‚îÇ‚îÄ‚îÄ‚ñ∂ AST                         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò     ‚îÇ                          ‚îÇ
‚îÇ                   ‚ñº                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ
‚îÇ  ‚îÇ  Ignition            ‚îÇ  (Bytecode         ‚îÇ
‚îÇ  ‚îÇ  (Bytecode Compiler) ‚îÇ   Interpreter)     ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ             ‚îÇ Profile data                   ‚îÇ
‚îÇ             ‚ñº                                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                    ‚îÇ
‚îÇ  ‚îÇ  TurboFan            ‚îÇ  (Optimizing       ‚îÇ
‚îÇ  ‚îÇ  (JIT Compiler)      ‚îÇ   JIT Compiler)    ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                    ‚îÇ
‚îÇ                                              ‚îÇ
‚îÇ  Key techniques:                             ‚îÇ
‚îÇ  - Hidden classes (shapes/maps)              ‚îÇ
‚îÇ  - Inline caching                            ‚îÇ
‚îÇ  - On-stack replacement                      ‚îÇ
‚îÇ  - Deoptimization                            ‚îÇ
‚îÇ  - Generational GC (Orinoco)                 ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></div>

<h3 id="104-beam-erlang-vm">10.4 BEAM (Erlang VM)<a class="header-link" href="#104-beam-erlang-vm" title="Permanent link">&para;</a></h3>
<p>The BEAM is unique among VMs for its focus on concurrency and fault tolerance:</p>
<ul>
<li><strong>Register-based</strong>: 1024 virtual registers per process</li>
<li><strong>Lightweight processes</strong>: Millions of processes, each with ~2KB stack</li>
<li><strong>Preemptive scheduling</strong>: Reductions-based (not time-based)</li>
<li><strong>Hot code loading</strong>: Replace running code without stopping</li>
<li><strong>Pattern matching</strong>: First-class bytecode support for pattern matching</li>
<li><strong>No shared state</strong>: Processes communicate only via message passing</li>
</ul>
<div class="highlight"><pre><span></span><code>BEAM Process Model:
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  BEAM VM                                    ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇProc ‚îÇ  ‚îÇProc ‚îÇ  ‚îÇProc ‚îÇ  ‚îÇProc ‚îÇ  ...  ‚îÇ
‚îÇ  ‚îÇ  1  ‚îÇ  ‚îÇ  2  ‚îÇ  ‚îÇ  3  ‚îÇ  ‚îÇ  4  ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ 2KB ‚îÇ  ‚îÇ 2KB ‚îÇ  ‚îÇ 2KB ‚îÇ  ‚îÇ 2KB ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ     ‚îÇ msg    ‚îÇ msg    ‚îÇ msg    ‚îÇ msg       ‚îÇ
‚îÇ     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò           ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê          ‚îÇ
‚îÇ  ‚îÇ  Scheduler (per CPU core)    ‚îÇ          ‚îÇ
‚îÇ  ‚îÇ  Reduction counting          ‚îÇ          ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre></div>

<h3 id="105-vm-comparison">10.5 VM Comparison<a class="header-link" href="#105-vm-comparison" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">vm_comparison</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Compare real-world VM implementations.&quot;&quot;&quot;</span>
    <span class="n">vms</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;JVM&#39;</span><span class="p">,</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Stack&#39;</span><span class="p">,</span>
            <span class="s1">&#39;jit&#39;</span><span class="p">:</span> <span class="s1">&#39;Method JIT (C1/C2)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;gc&#39;</span><span class="p">:</span> <span class="s1">&#39;Generational (G1/ZGC)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;concurrency&#39;</span><span class="p">:</span> <span class="s1">&#39;OS threads&#39;</span><span class="p">,</span>
            <span class="s1">&#39;typing&#39;</span><span class="p">:</span> <span class="s1">&#39;Static&#39;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;CPython&#39;</span><span class="p">,</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Stack&#39;</span><span class="p">,</span>
            <span class="s1">&#39;jit&#39;</span><span class="p">:</span> <span class="s1">&#39;None (3.13+ experimental)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;gc&#39;</span><span class="p">:</span> <span class="s1">&#39;RefCount + Gen cycle&#39;</span><span class="p">,</span>
            <span class="s1">&#39;concurrency&#39;</span><span class="p">:</span> <span class="s1">&#39;GIL (threads limited)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;typing&#39;</span><span class="p">:</span> <span class="s1">&#39;Dynamic&#39;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;V8&#39;</span><span class="p">,</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Register&#39;</span><span class="p">,</span>
            <span class="s1">&#39;jit&#39;</span><span class="p">:</span> <span class="s1">&#39;TurboFan (optimizing)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;gc&#39;</span><span class="p">:</span> <span class="s1">&#39;Generational (Orinoco)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;concurrency&#39;</span><span class="p">:</span> <span class="s1">&#39;Event loop + workers&#39;</span><span class="p">,</span>
            <span class="s1">&#39;typing&#39;</span><span class="p">:</span> <span class="s1">&#39;Dynamic&#39;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;BEAM&#39;</span><span class="p">,</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Register&#39;</span><span class="p">,</span>
            <span class="s1">&#39;jit&#39;</span><span class="p">:</span> <span class="s1">&#39;JIT (OTP 24+)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;gc&#39;</span><span class="p">:</span> <span class="s1">&#39;Per-process copying&#39;</span><span class="p">,</span>
            <span class="s1">&#39;concurrency&#39;</span><span class="p">:</span> <span class="s1">&#39;Actor model (millions)&#39;</span><span class="p">,</span>
            <span class="s1">&#39;typing&#39;</span><span class="p">:</span> <span class="s1">&#39;Dynamic&#39;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="p">{</span>
            <span class="s1">&#39;name&#39;</span><span class="p">:</span> <span class="s1">&#39;CLR/.NET&#39;</span><span class="p">,</span>
            <span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;Stack&#39;</span><span class="p">,</span>
            <span class="s1">&#39;jit&#39;</span><span class="p">:</span> <span class="s1">&#39;RyuJIT&#39;</span><span class="p">,</span>
            <span class="s1">&#39;gc&#39;</span><span class="p">:</span> <span class="s1">&#39;Generational compacting&#39;</span><span class="p">,</span>
            <span class="s1">&#39;concurrency&#39;</span><span class="p">:</span> <span class="s1">&#39;OS threads + async&#39;</span><span class="p">,</span>
            <span class="s1">&#39;typing&#39;</span><span class="p">:</span> <span class="s1">&#39;Static&#39;</span><span class="p">,</span>
        <span class="p">},</span>
    <span class="p">]</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== VM Comparison ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;VM&#39;</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;Type&#39;</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;JIT&#39;</span><span class="si">:</span><span class="s2">&lt;25</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="s1">&#39;GC&#39;</span><span class="si">:</span><span class="s2">&lt;25</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="mi">70</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">vm</span> <span class="ow">in</span> <span class="n">vms</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">vm</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">vm</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;10</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">vm</span><span class="p">[</span><span class="s1">&#39;jit&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;25</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">vm</span><span class="p">[</span><span class="s1">&#39;gc&#39;</span><span class="p">]</span><span class="si">:</span><span class="s2">&lt;25</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="n">vm_comparison</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="11-metacircular-interpreters">11. Metacircular Interpreters<a class="header-link" href="#11-metacircular-interpreters" title="Permanent link">&para;</a></h2>
<h3 id="111-what-is-a-metacircular-interpreter">11.1 What is a Metacircular Interpreter?<a class="header-link" href="#111-what-is-a-metacircular-interpreter" title="Permanent link">&para;</a></h3>
<p>A <strong>metacircular interpreter</strong> is an interpreter for a language written in the same language. It is a powerful concept from the Lisp tradition:</p>
<ul>
<li><strong>Lisp in Lisp</strong>: The original metacircular evaluator (McCarthy, 1960)</li>
<li><strong>PyPy</strong>: Python interpreter written in (a subset of) Python</li>
<li><strong>Truffle/Graal</strong>: Self-optimizing interpreters written in Java</li>
</ul>
<h3 id="112-a-simple-metacircular-evaluator">11.2 A Simple Metacircular Evaluator<a class="header-link" href="#112-a-simple-metacircular-evaluator" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">metacircular_eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple metacircular evaluator for a Lisp-like language.</span>

<span class="sd">    The language supports:</span>
<span class="sd">    - Numbers and strings (self-evaluating)</span>
<span class="sd">    - Variables (looked up in environment)</span>
<span class="sd">    - (quote x) -&gt; x</span>
<span class="sd">    - (if test then else)</span>
<span class="sd">    - (define name value)</span>
<span class="sd">    - (lambda (params) body)</span>
<span class="sd">    - (function arg1 arg2 ...)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Self-evaluating</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">)):</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="c1"># Variable reference</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;(&#39;</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">env</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="c1"># Must be a list (compound expression)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot evaluate: </span><span class="si">{</span><span class="n">expr</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">head</span> <span class="o">=</span> <span class="n">expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Special forms</span>
    <span class="k">if</span> <span class="n">head</span> <span class="o">==</span> <span class="s1">&#39;quote&#39;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">elif</span> <span class="n">head</span> <span class="o">==</span> <span class="s1">&#39;if&#39;</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">then_clause</span><span class="p">,</span> <span class="o">*</span><span class="n">else_clause</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="k">if</span> <span class="n">metacircular_eval</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">env</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">metacircular_eval</span><span class="p">(</span><span class="n">then_clause</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">else_clause</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">metacircular_eval</span><span class="p">(</span><span class="n">else_clause</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">env</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">elif</span> <span class="n">head</span> <span class="o">==</span> <span class="s1">&#39;define&#39;</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="n">env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">metacircular_eval</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">elif</span> <span class="n">head</span> <span class="o">==</span> <span class="s1">&#39;lambda&#39;</span><span class="p">:</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="k">return</span> <span class="p">(</span><span class="s1">&#39;closure&#39;</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">head</span> <span class="o">==</span> <span class="s1">&#39;begin&#39;</span><span class="p">:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">subexpr</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">metacircular_eval</span><span class="p">(</span><span class="n">subexpr</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">elif</span> <span class="n">head</span> <span class="o">==</span> <span class="s1">&#39;let&#39;</span><span class="p">:</span>
        <span class="c1"># (let ((x 1) (y 2)) body)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">bindings</span><span class="p">,</span> <span class="n">body</span> <span class="o">=</span> <span class="n">expr</span>
        <span class="n">new_env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="n">env</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value_expr</span> <span class="ow">in</span> <span class="n">bindings</span><span class="p">:</span>
            <span class="n">new_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">metacircular_eval</span><span class="p">(</span><span class="n">value_expr</span><span class="p">,</span> <span class="n">env</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">metacircular_eval</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">new_env</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Function application</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">metacircular_eval</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">metacircular_eval</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">env</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="n">func</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;closure&#39;</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">closure_env</span> <span class="o">=</span> <span class="n">func</span>
            <span class="n">new_env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">(</span><span class="n">parent</span><span class="o">=</span><span class="n">closure_env</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">arg</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">params</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
                <span class="n">new_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">metacircular_eval</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="n">new_env</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Not a function: </span><span class="si">{</span><span class="n">func</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">demonstrate_metacircular</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Demonstrate the metacircular evaluator.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;=== Metacircular Evaluator ===</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Create global environment with built-in functions</span>
    <span class="n">global_env</span> <span class="o">=</span> <span class="n">Environment</span><span class="p">()</span>
    <span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">*</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">&gt;</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span>
    <span class="n">global_env</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="s1">&#39;print&#39;</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Output: </span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">x</span><span class="p">)</span>

    <span class="c1"># Evaluate expressions</span>
    <span class="n">programs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># Simple arithmetic</span>
        <span class="p">([</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">]],</span> <span class="s2">&quot;3 + 4*5&quot;</span><span class="p">),</span>

        <span class="c1"># Define and use a variable</span>
        <span class="p">([</span><span class="s1">&#39;begin&#39;</span><span class="p">,</span>
          <span class="p">[</span><span class="s1">&#39;define&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">42</span><span class="p">],</span>
          <span class="p">[</span><span class="s1">&#39;print&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">]],</span> <span class="s2">&quot;define x = 42&quot;</span><span class="p">),</span>

        <span class="c1"># Lambda function</span>
        <span class="p">([</span><span class="s1">&#39;begin&#39;</span><span class="p">,</span>
          <span class="p">[</span><span class="s1">&#39;define&#39;</span><span class="p">,</span> <span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">]]],</span>
          <span class="p">[</span><span class="s1">&#39;print&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;square&#39;</span><span class="p">,</span> <span class="mi">7</span><span class="p">]]],</span> <span class="s2">&quot;define square, compute square(7)&quot;</span><span class="p">),</span>

        <span class="c1"># Recursive factorial (using begin for multiple defines)</span>
        <span class="p">([</span><span class="s1">&#39;begin&#39;</span><span class="p">,</span>
          <span class="p">[</span><span class="s1">&#39;define&#39;</span><span class="p">,</span> <span class="s1">&#39;fact&#39;</span><span class="p">,</span>
           <span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;n&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="s1">&#39;if&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;&lt;&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
             <span class="mi">1</span><span class="p">,</span>
             <span class="p">[</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;fact&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]]]]],</span>
          <span class="p">[</span><span class="s1">&#39;print&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;fact&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]],</span> <span class="s2">&quot;factorial(10)&quot;</span><span class="p">),</span>

        <span class="c1"># Higher-order function</span>
        <span class="p">([</span><span class="s1">&#39;begin&#39;</span><span class="p">,</span>
          <span class="p">[</span><span class="s1">&#39;define&#39;</span><span class="p">,</span> <span class="s1">&#39;apply-twice&#39;</span><span class="p">,</span>
           <span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">],</span>
            <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">]]]],</span>
          <span class="p">[</span><span class="s1">&#39;define&#39;</span><span class="p">,</span> <span class="s1">&#39;add3&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;lambda&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="p">[</span><span class="s1">&#39;+&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]],</span>
          <span class="p">[</span><span class="s1">&#39;print&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;apply-twice&#39;</span><span class="p">,</span> <span class="s1">&#39;add3&#39;</span><span class="p">,</span> <span class="mi">10</span><span class="p">]]],</span> <span class="s2">&quot;apply-twice(add3, 10)&quot;</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">expr</span><span class="p">,</span> <span class="n">description</span> <span class="ow">in</span> <span class="n">programs</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Program: </span><span class="si">{</span><span class="n">description</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">=</span> <span class="n">metacircular_eval</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">global_env</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Result: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">()</span>

<span class="n">demonstrate_metacircular</span><span class="p">()</span>
</code></pre></div>

<h3 id="113-why-metacircular-interpreters-matter">11.3 Why Metacircular Interpreters Matter<a class="header-link" href="#113-why-metacircular-interpreters-matter" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Self-hosting</strong>: A language that can implement itself demonstrates completeness and power.</li>
<li><strong>Reflection</strong>: The interpreter is available to the running program (macros, eval, introspection).</li>
<li><strong>Bootstrapping</strong>: Start with a simple interpreter, then build a better one in the language itself.</li>
<li><strong>Education</strong>: They demonstrate language semantics in the clearest way possible.</li>
<li><strong>Optimization</strong>: PyPy's meta-tracing approach writes the interpreter in Python, then automatically generates a JIT compiler.</li>
</ol>
<hr />
<h2 id="12-summary">12. Summary<a class="header-link" href="#12-summary" title="Permanent link">&para;</a></h2>
<p>This lesson covered the full spectrum of program execution strategies:</p>
<table>
<thead>
<tr>
<th>Approach</th>
<th>Speed</th>
<th>Complexity</th>
<th>Key Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Tree-walking</strong></td>
<td>Slowest (50-200x)</td>
<td>Simple</td>
<td>Early Ruby, Bash</td>
</tr>
<tr>
<td><strong>Bytecode interp.</strong></td>
<td>Slow (5-20x)</td>
<td>Moderate</td>
<td>CPython, Lua</td>
</tr>
<tr>
<td><strong>Bytecode + JIT</strong></td>
<td>Near-native</td>
<td>Complex</td>
<td>JVM, V8, PyPy</td>
</tr>
<tr>
<td><strong>AOT compile</strong></td>
<td>Native</td>
<td>Complex</td>
<td>GCC, Rust, Go</td>
</tr>
</tbody>
</table>
<p>Key concepts:</p>
<ul>
<li><strong>Bytecode</strong> is a compact, portable intermediate form designed for VM execution</li>
<li><strong>Stack-based VMs</strong> are simple to implement but generate more instructions; <strong>register-based VMs</strong> are more efficient but more complex</li>
<li><strong>Instruction dispatch</strong> technique (switch vs. threaded code vs. computed goto) significantly impacts interpreter performance</li>
<li><strong>JIT compilation</strong> bridges the gap between interpretation and native compilation:</li>
<li>Method JIT compiles hot functions</li>
<li>Tracing JIT compiles hot execution paths</li>
<li>Both rely on profiling, speculation, and deoptimization</li>
<li><strong>Runtime optimizations</strong> like inline caching, type specialization, and hidden classes make dynamic languages competitive with static ones</li>
<li><strong>Metacircular interpreters</strong> demonstrate language power and enable advanced techniques like meta-tracing</li>
</ul>
<hr />
<h2 id="13-exercises">13. Exercises<a class="header-link" href="#13-exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-tree-walking-extensions">Exercise 1: Tree-Walking Extensions<a class="header-link" href="#exercise-1-tree-walking-extensions" title="Permanent link">&para;</a></h3>
<p>Extend the tree-walking interpreter from Section 2 to support:
(a) Arrays with <code>push</code>, <code>pop</code>, and indexing.
(b) For loops: <code>for i in range(n): body</code>.
(c) Closures that correctly capture variables from enclosing scopes.</p>
<p>Test with a program that creates a list of closures:</p>
<div class="highlight"><pre><span></span><code>funcs = []
for i in range(5):
    define make_adder(x): return lambda(y): x + y
    push(funcs, make_adder(i))
print(funcs[3](10))  # Should print 13
</code></pre></div>

<h3 id="exercise-2-bytecode-optimization">Exercise 2: Bytecode Optimization<a class="header-link" href="#exercise-2-bytecode-optimization" title="Permanent link">&para;</a></h3>
<p>Implement a bytecode peephole optimizer that handles:
(a) Constant folding: <code>CONST 3; CONST 4; ADD</code> -&gt; <code>CONST 7</code>
(b) Dead store elimination: <code>STORE x; STORE x</code> -&gt; keep only the second
(c) Redundant load elimination: <code>STORE x; LOAD x</code> -&gt; <code>STORE x; DUP</code></p>
<p>Apply it to the output of the compiler from Section 7 and measure the reduction in instruction count.</p>
<h3 id="exercise-3-register-allocation-for-register-vm">Exercise 3: Register Allocation for Register VM<a class="header-link" href="#exercise-3-register-allocation-for-register-vm" title="Permanent link">&para;</a></h3>
<p>Implement a simple register allocator that converts stack-based bytecode to register-based bytecode:
(a) Use a simple stack simulation to track which values are in which registers.
(b) Handle register spilling when you run out of registers.
(c) Compare instruction counts between the stack and register versions for several programs.</p>
<h3 id="exercise-4-simple-jit-compiler">Exercise 4: Simple JIT Compiler<a class="header-link" href="#exercise-4-simple-jit-compiler" title="Permanent link">&para;</a></h3>
<p>Implement a simple JIT-like system that:
(a) Profiles which functions are called most frequently.
(b) For "hot" functions, generates a specialized Python function (using <code>exec</code>) that eliminates the dispatch overhead.
(c) Benchmark the interpreted vs "JIT-compiled" versions.</p>
<h3 id="exercise-5-debugger-for-the-vm">Exercise 5: Debugger for the VM<a class="header-link" href="#exercise-5-debugger-for-the-vm" title="Permanent link">&para;</a></h3>
<p>Add debugging support to the VM from Section 7:
(a) Single-step execution (execute one instruction, then pause).
(b) Breakpoints (pause when reaching a specific instruction index).
(c) Stack and local variable inspection at any point.
(d) Call stack display (show the chain of function calls).</p>
<h3 id="exercise-6-vm-performance-analysis">Exercise 6: VM Performance Analysis<a class="header-link" href="#exercise-6-vm-performance-analysis" title="Permanent link">&para;</a></h3>
<p>Instrument the VM to collect execution statistics:
(a) Count how many times each opcode is executed.
(b) Identify the most common opcode pairs (superinstructions).
(c) Propose and implement 3 superinstructions that combine common pairs.
(d) Measure the reduction in dispatch count and execution time.</p>
<hr />
<h2 id="14-references">14. References<a class="header-link" href="#14-references" title="Permanent link">&para;</a></h2>
<ol>
<li>Aho, A. V., Lam, M. S., Sethi, R., &amp; Ullman, J. D. (2006). <em>Compilers: Principles, Techniques, and Tools</em> (2nd ed.), Chapter 8.</li>
<li>Nystrom, R. (2021). <em>Crafting Interpreters</em>. Available at <a href="https://craftinginterpreters.com/">craftinginterpreters.com</a>.</li>
<li>Smith, J. E., &amp; Nair, R. (2005). <em>Virtual Machines: Versatile Platforms for Systems and Processes</em>. Morgan Kaufmann.</li>
<li>Ertl, M. A., &amp; Gregg, D. (2003). "The Structure and Performance of Efficient Interpreters." <em>Journal of Instruction-Level Parallelism</em>, 5.</li>
<li>Shi, Y., Gregg, D., Beatty, A., &amp; Ertl, M. A. (2008). "Virtual Machine Showdown: Stack versus Registers." <em>ACM TOPLAS</em>, 30(4).</li>
<li>Bolz, C. F., Cuni, A., Fijalkowski, M., &amp; Rigo, A. (2009). "Tracing the Meta-level: PyPy's Tracing JIT Compiler." <em>ICOOOLPS</em>.</li>
<li>Holzle, U., Chambers, C., &amp; Ungar, D. (1991). "Optimizing Dynamically-Typed Object-Oriented Languages With Polymorphic Inline Caches." <em>ECOOP</em>.</li>
<li>Deutsch, L. P., &amp; Schiffman, A. M. (1984). "Efficient Implementation of the Smalltalk-80 System." <em>POPL</em>.</li>
</ol>
<hr />
<p><a href="./14_Garbage_Collection.md">Previous: 14. Garbage Collection</a> | <a href="./16_Modern_Compiler_Infrastructure.md">Next: 16. Modern Compiler Infrastructure</a> | <a href="./00_Overview.md">Overview</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Compiler_Design/14_Garbage_Collection.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Garbage Collection</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Compiler_Design/16_Modern_Compiler_Infrastructure.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Modern Compiler Infrastructure</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}