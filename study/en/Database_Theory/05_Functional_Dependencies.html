{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 05: Functional Dependencies - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">ğŸ </span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">ğŸ’»</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        í•œêµ­ì–´
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">â˜€ï¸</span>
                    <span class="theme-icon dark">ğŸŒ™</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Database_Theory/">Database Theory</a>
    <span class="separator">/</span>
    <span class="current">Lesson 05: Functional Dependencies</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 05: Functional Dependencies</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Database_Theory/04_ER_Modeling.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">ER Modeling</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Database_Theory/06_Normalization.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 06: Normalization (1NF through BCNF)</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#1-introduction">1. Introduction</a><ul>
<li><a href="#11-why-functional-dependencies-matter">1.1 Why Functional Dependencies Matter</a></li>
</ul>
</li>
<li><a href="#2-formal-definition">2. Formal Definition</a><ul>
<li><a href="#21-functional-dependency">2.1 Functional Dependency</a></li>
<li><a href="#22-trivial-and-non-trivial-fds">2.2 Trivial and Non-Trivial FDs</a></li>
<li><a href="#23-examples">2.3 Examples</a></li>
<li><a href="#24-fds-vs-keys">2.4 FDs vs. Keys</a></li>
</ul>
</li>
<li><a href="#3-armstrongs-axioms">3. Armstrong's Axioms</a><ul>
<li><a href="#31-the-three-axioms">3.1 The Three Axioms</a><ul>
<li><a href="#axiom-1-reflexivity">Axiom 1: Reflexivity</a></li>
<li><a href="#axiom-2-augmentation">Axiom 2: Augmentation</a></li>
<li><a href="#axiom-3-transitivity">Axiom 3: Transitivity</a></li>
</ul>
</li>
<li><a href="#32-soundness-and-completeness">3.2 Soundness and Completeness</a></li>
</ul>
</li>
<li><a href="#4-derived-inference-rules">4. Derived Inference Rules</a><ul>
<li><a href="#41-union-rule">4.1 Union Rule</a></li>
<li><a href="#42-decomposition-rule">4.2 Decomposition Rule</a></li>
<li><a href="#43-pseudotransitivity">4.3 Pseudotransitivity</a></li>
<li><a href="#44-self-determination">4.4 Self-Determination</a></li>
<li><a href="#45-accumulation">4.5 Accumulation</a></li>
<li><a href="#46-summary-of-rules">4.6 Summary of Rules</a></li>
</ul>
</li>
<li><a href="#5-closure-of-an-attribute-set">5. Closure of an Attribute Set</a><ul>
<li><a href="#51-definition">5.1 Definition</a></li>
<li><a href="#52-algorithm">5.2 Algorithm</a></li>
<li><a href="#53-worked-example-1">5.3 Worked Example 1</a></li>
<li><a href="#54-worked-example-2">5.4 Worked Example 2</a></li>
<li><a href="#55-uses-of-attribute-closure">5.5 Uses of Attribute Closure</a></li>
</ul>
</li>
<li><a href="#6-closure-of-a-set-of-fds">6. Closure of a Set of FDs</a><ul>
<li><a href="#61-definition">6.1 Definition</a></li>
<li><a href="#62-equivalence-of-fd-sets">6.2 Equivalence of FD Sets</a></li>
<li><a href="#63-example">6.3 Example</a></li>
</ul>
</li>
<li><a href="#7-minimal-cover-canonical-cover">7. Minimal Cover (Canonical Cover)</a><ul>
<li><a href="#71-definition">7.1 Definition</a></li>
<li><a href="#72-algorithm">7.2 Algorithm</a></li>
<li><a href="#73-worked-example">7.3 Worked Example</a></li>
<li><a href="#74-non-uniqueness-of-minimal-covers">7.4 Non-Uniqueness of Minimal Covers</a></li>
</ul>
</li>
<li><a href="#8-finding-candidate-keys-using-fds">8. Finding Candidate Keys Using FDs</a><ul>
<li><a href="#81-attribute-classification">8.1 Attribute Classification</a></li>
<li><a href="#82-algorithm-for-finding-candidate-keys">8.2 Algorithm for Finding Candidate Keys</a></li>
<li><a href="#83-worked-example">8.3 Worked Example</a></li>
</ul>
</li>
<li><a href="#9-entailment-and-implication">9. Entailment and Implication</a><ul>
<li><a href="#91-logical-implication">9.1 Logical Implication</a></li>
<li><a href="#92-testing-implication">9.2 Testing Implication</a></li>
<li><a href="#93-example">9.3 Example</a></li>
</ul>
</li>
<li><a href="#10-fds-in-practice">10. FDs in Practice</a><ul>
<li><a href="#101-identifying-fds-from-requirements">10.1 Identifying FDs from Requirements</a></li>
<li><a href="#102-fds-and-null-values">10.2 FDs and NULL Values</a></li>
<li><a href="#103-discovering-fds-from-data">10.3 Discovering FDs from Data</a></li>
<li><a href="#104-fds-in-sql">10.4 FDs in SQL</a></li>
</ul>
</li>
<li><a href="#11-common-pitfalls">11. Common Pitfalls</a><ul>
<li><a href="#111-confusing-fds-with-data-patterns">11.1 Confusing FDs with Data Patterns</a></li>
<li><a href="#112-direction-matters">11.2 Direction Matters</a></li>
<li><a href="#113-fd-on-a-single-attribute">11.3 FD on a Single Attribute</a></li>
<li><a href="#114-order-of-operations-in-minimal-cover">11.4 Order of Operations in Minimal Cover</a></li>
</ul>
</li>
<li><a href="#12-proofs-and-theory">12. Proofs and Theory</a><ul>
<li><a href="#121-proving-completeness-of-armstrongs-axioms-sketch">12.1 Proving Completeness of Armstrong's Axioms (Sketch)</a></li>
<li><a href="#122-complexity-results">12.2 Complexity Results</a></li>
</ul>
</li>
<li><a href="#13-exercises">13. Exercises</a><ul>
<li><a href="#exercise-1-attribute-closure">Exercise 1: Attribute Closure</a></li>
<li><a href="#exercise-2-finding-candidate-keys">Exercise 2: Finding Candidate Keys</a></li>
<li><a href="#exercise-3-minimal-cover">Exercise 3: Minimal Cover</a></li>
<li><a href="#exercise-4-proving-an-fd">Exercise 4: Proving an FD</a></li>
<li><a href="#exercise-5-fd-implication">Exercise 5: FD Implication</a></li>
<li><a href="#exercise-6-equivalence-of-fd-sets">Exercise 6: Equivalence of FD Sets</a></li>
<li><a href="#exercise-7-multiple-candidate-keys">Exercise 7: Multiple Candidate Keys</a></li>
<li><a href="#exercise-8-closure-proof">Exercise 8: Closure Proof</a></li>
</ul>
</li>
<li><a href="#14-summary">14. Summary</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-05-functional-dependencies">Lesson 05: Functional Dependencies<a class="header-link" href="#lesson-05-functional-dependencies" title="Permanent link">&para;</a></h1>
<p><strong>Previous</strong>: <a href="./04_ER_Modeling.md">04_ER_Modeling.md</a> | <strong>Next</strong>: <a href="./06_Normalization.md">06_Normalization.md</a></p>
<hr />
<blockquote>
<p><strong>Topic</strong>: Database Theory
<strong>Lesson</strong>: 5 of 16
<strong>Prerequisites</strong>: Relational model concepts (relations, tuples, attributes, keys), basic set theory
<strong>Objective</strong>: Understand functional dependencies as the formal foundation for database normalization, master Armstrong's axioms, compute attribute closures, derive candidate keys, and compute minimal covers</p>
</blockquote>
<h2 id="1-introduction">1. Introduction<a class="header-link" href="#1-introduction" title="Permanent link">&para;</a></h2>
<p>Functional dependencies (FDs) are the most important concept in relational database design theory. They formalize the notion of "one attribute uniquely determines another" and provide the mathematical foundation for normalization â€” the process of organizing a database to reduce redundancy and prevent anomalies.</p>
<p>Before we had functional dependencies, database designers relied on intuition and experience. FDs gave us a rigorous framework to reason about what constitutes a "good" schema, and algorithms to systematically achieve it.</p>
<h3 id="11-why-functional-dependencies-matter">1.1 Why Functional Dependencies Matter<a class="header-link" href="#11-why-functional-dependencies-matter" title="Permanent link">&para;</a></h3>
<p>Consider a university database with a single relation:</p>
<div class="highlight"><pre><span></span><code>StudentCourse(student_id, student_name, dept_name, course_id, course_title, grade)
</code></pre></div>

<p>Intuitively, we know:
- A student_id uniquely identifies a student_name and dept_name
- A course_id uniquely identifies a course_title
- The combination (student_id, course_id) uniquely identifies the grade</p>
<p>These intuitive observations are precisely functional dependencies. They allow us to:</p>
<ol>
<li><strong>Identify redundancy</strong>: If student_name appears in every row for the same student_id, we have redundancy</li>
<li><strong>Detect anomalies</strong>: Updating a student's department in one row but not others creates inconsistency</li>
<li><strong>Guide decomposition</strong>: FDs tell us exactly how to split a relation into smaller, well-structured pieces</li>
<li><strong>Verify key constraints</strong>: FDs formally define what it means for an attribute set to be a key</li>
</ol>
<hr />
<h2 id="2-formal-definition">2. Formal Definition<a class="header-link" href="#2-formal-definition" title="Permanent link">&para;</a></h2>
<h3 id="21-functional-dependency">2.1 Functional Dependency<a class="header-link" href="#21-functional-dependency" title="Permanent link">&para;</a></h3>
<p>Let R be a relation schema with attribute set U, and let X, Y âŠ† U.</p>
<blockquote>
<p><strong>Definition</strong>: A <strong>functional dependency</strong> X â†’ Y holds on R if and only if for every legal instance r of R, whenever two tuples tâ‚ and tâ‚‚ agree on the attributes in X, they must also agree on the attributes in Y. Formally:</p>
<p>X â†’ Y âŸº âˆ€ tâ‚, tâ‚‚ âˆˆ r : tâ‚[X] = tâ‚‚[X] âŸ¹ tâ‚[Y] = tâ‚‚[Y]</p>
</blockquote>
<p>Here:
- <strong>X</strong> is called the <strong>determinant</strong> (or left-hand side, LHS)
- <strong>Y</strong> is called the <strong>dependent</strong> (or right-hand side, RHS)
- We read X â†’ Y as "X functionally determines Y" or "Y is functionally dependent on X"</p>
<h3 id="22-trivial-and-non-trivial-fds">2.2 Trivial and Non-Trivial FDs<a class="header-link" href="#22-trivial-and-non-trivial-fds" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: A functional dependency X â†’ Y is <strong>trivial</strong> if Y âŠ† X.</p>
</blockquote>
<p>Examples:
- {student_id, course_id} â†’ {student_id} is trivial
- {student_id} â†’ {student_id} is trivial
- {student_id} â†’ {student_name} is <strong>non-trivial</strong> (student_name âˆ‰ {student_id})</p>
<blockquote>
<p><strong>Definition</strong>: A functional dependency X â†’ Y is <strong>completely non-trivial</strong> if X âˆ© Y = âˆ….</p>
</blockquote>
<h3 id="23-examples">2.3 Examples<a class="header-link" href="#23-examples" title="Permanent link">&para;</a></h3>
<p>Consider the relation schema:</p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, emp_name, dept_id, dept_name, salary, manager_id)
</code></pre></div>

<p>Typical functional dependencies:
- emp_id â†’ emp_name, dept_id, salary, manager_id (employee ID determines all employee attributes)
- dept_id â†’ dept_name (department ID determines department name)
- emp_id â†’ dept_name (transitively, through dept_id)</p>
<p><strong>Important</strong>: FDs are <strong>semantic</strong> constraints. They are determined by the meaning of the data in the real world, not by examining a particular instance. Looking at a snapshot of data can only <strong>disprove</strong> an FD (by finding a counterexample), never <strong>prove</strong> one holds in general.</p>
<h3 id="24-fds-vs-keys">2.4 FDs vs. Keys<a class="header-link" href="#24-fds-vs-keys" title="Permanent link">&para;</a></h3>
<p>There is a deep connection between functional dependencies and keys:</p>
<blockquote>
<p><strong>Definition</strong>: A set of attributes K is a <strong>superkey</strong> of relation R if K â†’ U, where U is the set of all attributes of R.</p>
<p><strong>Definition</strong>: A set of attributes K is a <strong>candidate key</strong> of R if:
1. K â†’ U (K is a superkey), and
2. No proper subset of K functionally determines U (K is minimal)</p>
</blockquote>
<p>Thus, keys are simply functional dependencies whose right-hand side is the entire attribute set, with a minimality condition.</p>
<hr />
<h2 id="3-armstrongs-axioms">3. Armstrong's Axioms<a class="header-link" href="#3-armstrongs-axioms" title="Permanent link">&para;</a></h2>
<p>In 1974, William W. Armstrong proposed a set of inference rules for functional dependencies. These axioms are <strong>sound</strong> (they only derive correct FDs) and <strong>complete</strong> (they can derive all FDs that logically follow from a given set).</p>
<h3 id="31-the-three-axioms">3.1 The Three Axioms<a class="header-link" href="#31-the-three-axioms" title="Permanent link">&para;</a></h3>
<p>Let F be a set of functional dependencies on relation schema R, and let X, Y, Z âŠ† attributes(R).</p>
<h4 id="axiom-1-reflexivity">Axiom 1: Reflexivity<a class="header-link" href="#axiom-1-reflexivity" title="Permanent link">&para;</a></h4>
<blockquote>
<p>If Y âŠ† X, then X â†’ Y.</p>
</blockquote>
<p>This axiom generates all trivial FDs. For example:
- {A, B, C} â†’ {A, B}
- {A, B, C} â†’ {A}
- {A} â†’ {A}</p>
<p><strong>Proof of soundness</strong>: If Y âŠ† X and tâ‚[X] = tâ‚‚[X], then since Y âŠ† X, we have tâ‚[Y] = tâ‚‚[Y]. âˆ</p>
<h4 id="axiom-2-augmentation">Axiom 2: Augmentation<a class="header-link" href="#axiom-2-augmentation" title="Permanent link">&para;</a></h4>
<blockquote>
<p>If X â†’ Y, then XZ â†’ YZ for any Z.</p>
</blockquote>
<p>We can "augment" both sides of an FD with any set of attributes. For example:
- If A â†’ B, then AC â†’ BC
- If AB â†’ C, then ABD â†’ CD</p>
<p><strong>Proof of soundness</strong>: Suppose X â†’ Y and tâ‚[XZ] = tâ‚‚[XZ]. Then tâ‚[X] = tâ‚‚[X] and tâ‚[Z] = tâ‚‚[Z]. Since X â†’ Y, we have tâ‚[Y] = tâ‚‚[Y]. Combining: tâ‚[YZ] = tâ‚‚[YZ]. âˆ</p>
<h4 id="axiom-3-transitivity">Axiom 3: Transitivity<a class="header-link" href="#axiom-3-transitivity" title="Permanent link">&para;</a></h4>
<blockquote>
<p>If X â†’ Y and Y â†’ Z, then X â†’ Z.</p>
</blockquote>
<p>This allows chaining of functional dependencies. For example:
- If student_id â†’ dept_id and dept_id â†’ dept_name, then student_id â†’ dept_name</p>
<p><strong>Proof of soundness</strong>: Suppose X â†’ Y and Y â†’ Z. Let tâ‚[X] = tâ‚‚[X]. By X â†’ Y, tâ‚[Y] = tâ‚‚[Y]. By Y â†’ Z, tâ‚[Z] = tâ‚‚[Z]. Therefore X â†’ Z. âˆ</p>
<h3 id="32-soundness-and-completeness">3.2 Soundness and Completeness<a class="header-link" href="#32-soundness-and-completeness" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Theorem (Armstrong, 1974)</strong>: Armstrong's axioms are <strong>sound and complete</strong>.
- <strong>Soundness</strong>: Every FD derivable from F using these axioms is logically implied by F.
- <strong>Completeness</strong>: Every FD logically implied by F can be derived using these axioms.</p>
</blockquote>
<p>The completeness proof is non-trivial. The key idea is to show that if X â†’ Y cannot be derived from F using Armstrong's axioms, then there exists a two-tuple relation that satisfies F but violates X â†’ Y.</p>
<hr />
<h2 id="4-derived-inference-rules">4. Derived Inference Rules<a class="header-link" href="#4-derived-inference-rules" title="Permanent link">&para;</a></h2>
<p>From Armstrong's three axioms, we can derive several useful additional rules.</p>
<h3 id="41-union-rule">4.1 Union Rule<a class="header-link" href="#41-union-rule" title="Permanent link">&para;</a></h3>
<blockquote>
<p>If X â†’ Y and X â†’ Z, then X â†’ YZ.</p>
</blockquote>
<p><strong>Proof</strong>:
1. X â†’ Y (given)
2. X â†’ Z (given)
3. X â†’ XY (augment step 1 with X; since XX = X, we get X â†’ XY)
4. XY â†’ YZ (augment step 2 with Y)
5. X â†’ YZ (transitivity on steps 3 and 4) âˆ</p>
<h3 id="42-decomposition-rule">4.2 Decomposition Rule<a class="header-link" href="#42-decomposition-rule" title="Permanent link">&para;</a></h3>
<blockquote>
<p>If X â†’ YZ, then X â†’ Y and X â†’ Z.</p>
</blockquote>
<p><strong>Proof</strong>:
1. X â†’ YZ (given)
2. YZ â†’ Y (reflexivity, since Y âŠ† YZ)
3. X â†’ Y (transitivity on steps 1 and 2)
4. YZ â†’ Z (reflexivity, since Z âŠ† YZ)
5. X â†’ Z (transitivity on steps 1 and 4) âˆ</p>
<h3 id="43-pseudotransitivity">4.3 Pseudotransitivity<a class="header-link" href="#43-pseudotransitivity" title="Permanent link">&para;</a></h3>
<blockquote>
<p>If X â†’ Y and WY â†’ Z, then WX â†’ Z.</p>
</blockquote>
<p><strong>Proof</strong>:
1. X â†’ Y (given)
2. WX â†’ WY (augment step 1 with W)
3. WY â†’ Z (given)
4. WX â†’ Z (transitivity on steps 2 and 3) âˆ</p>
<h3 id="44-self-determination">4.4 Self-Determination<a class="header-link" href="#44-self-determination" title="Permanent link">&para;</a></h3>
<blockquote>
<p>X â†’ X for any X.</p>
</blockquote>
<p>This follows directly from reflexivity (X âŠ† X).</p>
<h3 id="45-accumulation">4.5 Accumulation<a class="header-link" href="#45-accumulation" title="Permanent link">&para;</a></h3>
<blockquote>
<p>If X â†’ YZ and Z â†’ BW, then X â†’ YBW.</p>
</blockquote>
<p><strong>Proof</strong>:
1. X â†’ YZ (given)
2. X â†’ Z (decomposition of step 1)
3. Z â†’ BW (given)
4. X â†’ BW (transitivity on steps 2 and 3)
5. X â†’ Y (decomposition of step 1)
6. X â†’ YBW (union of steps 4 and 5) âˆ</p>
<h3 id="46-summary-of-rules">4.6 Summary of Rules<a class="header-link" href="#46-summary-of-rules" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Rule</th>
<th>Statement</th>
<th>Derived From</th>
</tr>
</thead>
<tbody>
<tr>
<td>Reflexivity</td>
<td>Y âŠ† X âŸ¹ X â†’ Y</td>
<td>Axiom</td>
</tr>
<tr>
<td>Augmentation</td>
<td>X â†’ Y âŸ¹ XZ â†’ YZ</td>
<td>Axiom</td>
</tr>
<tr>
<td>Transitivity</td>
<td>X â†’ Y, Y â†’ Z âŸ¹ X â†’ Z</td>
<td>Axiom</td>
</tr>
<tr>
<td>Union</td>
<td>X â†’ Y, X â†’ Z âŸ¹ X â†’ YZ</td>
<td>Aug + Trans</td>
</tr>
<tr>
<td>Decomposition</td>
<td>X â†’ YZ âŸ¹ X â†’ Y, X â†’ Z</td>
<td>Refl + Trans</td>
</tr>
<tr>
<td>Pseudotransitivity</td>
<td>X â†’ Y, WY â†’ Z âŸ¹ WX â†’ Z</td>
<td>Aug + Trans</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="5-closure-of-an-attribute-set">5. Closure of an Attribute Set<a class="header-link" href="#5-closure-of-an-attribute-set" title="Permanent link">&para;</a></h2>
<p>Computing the closure of an attribute set is the most fundamental algorithm in FD theory. It answers the question: "Given a set of FDs F, what attributes are functionally determined by a given set X?"</p>
<h3 id="51-definition">5.1 Definition<a class="header-link" href="#51-definition" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: The <strong>closure of an attribute set X</strong> under a set of functional dependencies F, denoted Xâº (or Xâº_F), is the set of all attributes A such that X â†’ A can be inferred from F using Armstrong's axioms.</p>
<p>Xâº = { A âˆˆ U | F âŠ¨ X â†’ A }</p>
</blockquote>
<h3 id="52-algorithm">5.2 Algorithm<a class="header-link" href="#52-algorithm" title="Permanent link">&para;</a></h3>
<p>The following algorithm computes Xâº efficiently:</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">ComputeClosure</span><span class="o">(</span><span class="n">X</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="o">)</span>
<span class="n">INPUT</span><span class="o">:</span><span class="w">  </span><span class="n">X</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kd">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">attributes</span>
<span class="w">        </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kd">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">functional</span><span class="w"> </span><span class="n">dependencies</span>
<span class="n">OUTPUT</span><span class="o">:</span><span class="w"> </span><span class="n">X</span><span class="err">âº</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">closure</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">under</span><span class="w"> </span><span class="n">F</span>

<span class="mi">1</span><span class="o">.</span><span class="w">  </span><span class="n">result</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="n">X</span>
<span class="mi">2</span><span class="o">.</span><span class="w">  </span><span class="n">REPEAT</span>
<span class="mi">3</span><span class="o">.</span><span class="w">      </span><span class="n">old_result</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="n">result</span>
<span class="mi">4</span><span class="o">.</span><span class="w">      </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">dependency</span><span class="w"> </span><span class="o">(</span><span class="n">V</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">W</span><span class="o">)</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">DO</span>
<span class="mi">5</span><span class="o">.</span><span class="w">          </span><span class="n">IF</span><span class="w"> </span><span class="n">V</span><span class="w"> </span><span class="err">âŠ†</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">THEN</span>
<span class="mi">6</span><span class="o">.</span><span class="w">              </span><span class="n">result</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="err">âˆª</span><span class="w"> </span><span class="n">W</span>
<span class="mi">7</span><span class="o">.</span><span class="w">          </span><span class="n">END</span><span class="w"> </span><span class="n">IF</span>
<span class="mi">8</span><span class="o">.</span><span class="w">      </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="mi">9</span><span class="o">.</span><span class="w">  </span><span class="n">UNTIL</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">old_result</span>
<span class="mi">10</span><span class="o">.</span><span class="w"> </span><span class="n">RETURN</span><span class="w"> </span><span class="n">result</span>
</code></pre></div>

<p><strong>Time complexity</strong>: O(|F| Ã— |U|) in the worst case, where |F| is the number of FDs and |U| is the number of attributes.</p>
<h3 id="53-worked-example-1">5.3 Worked Example 1<a class="header-link" href="#53-worked-example-1" title="Permanent link">&para;</a></h3>
<p>Let R(A, B, C, D, E, F) with the following FDs:</p>
<div class="highlight"><pre><span></span><code>F = { A â†’ BC,  CD â†’ E,  B â†’ D,  E â†’ A }
</code></pre></div>

<p><strong>Compute {A}âº:</strong></p>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>result</th>
<th>Applied FD</th>
<th>New Attributes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Init</td>
<td>{A}</td>
<td>â€”</td>
<td>â€”</td>
</tr>
<tr>
<td>1</td>
<td>{A, B, C}</td>
<td>A â†’ BC</td>
<td>B, C</td>
</tr>
<tr>
<td>2</td>
<td>{A, B, C, D}</td>
<td>B â†’ D</td>
<td>D</td>
</tr>
<tr>
<td>3</td>
<td>{A, B, C, D, E}</td>
<td>CD â†’ E</td>
<td>E</td>
</tr>
<tr>
<td>4</td>
<td>{A, B, C, D, E}</td>
<td>E â†’ A (A already in result)</td>
<td>â€”</td>
</tr>
</tbody>
</table>
<p>Since no new attributes were added in iteration 4, we stop.</p>
<p><strong>{A}âº = {A, B, C, D, E}</strong></p>
<p>Note: F is not in the closure, so A is not a superkey of R (it doesn't determine F).</p>
<p><strong>Compute {A, F}âº:</strong></p>
<p>Starting with {A, F}, after the same iterations plus F already present:</p>
<p><strong>{A, F}âº = {A, B, C, D, E, F}</strong> = all attributes of R.</p>
<p>Therefore, {A, F} is a superkey.</p>
<h3 id="54-worked-example-2">5.4 Worked Example 2<a class="header-link" href="#54-worked-example-2" title="Permanent link">&para;</a></h3>
<p>Let R(A, B, C, D, E) with:</p>
<div class="highlight"><pre><span></span><code>F = { AB â†’ C,  C â†’ D,  D â†’ E,  E â†’ A }
</code></pre></div>

<p><strong>Compute {B, C}âº:</strong></p>
<table>
<thead>
<tr>
<th>Iteration</th>
<th>result</th>
<th>Applied FD</th>
<th>New Attributes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Init</td>
<td>{B, C}</td>
<td>â€”</td>
<td>â€”</td>
</tr>
<tr>
<td>1</td>
<td>{B, C, D}</td>
<td>C â†’ D</td>
<td>D</td>
</tr>
<tr>
<td>2</td>
<td>{B, C, D, E}</td>
<td>D â†’ E</td>
<td>E</td>
</tr>
<tr>
<td>3</td>
<td>{A, B, C, D, E}</td>
<td>E â†’ A</td>
<td>A</td>
</tr>
<tr>
<td>4</td>
<td>{A, B, C, D, E}</td>
<td>AB â†’ C (C already present)</td>
<td>â€”</td>
</tr>
</tbody>
</table>
<p><strong>{B, C}âº = {A, B, C, D, E}</strong> â€” so {B, C} is a superkey.</p>
<h3 id="55-uses-of-attribute-closure">5.5 Uses of Attribute Closure<a class="header-link" href="#55-uses-of-attribute-closure" title="Permanent link">&para;</a></h3>
<p>The closure algorithm has three main applications:</p>
<ol>
<li>
<p><strong>Testing if X â†’ Y holds</strong>: Compute Xâº. If Y âŠ† Xâº, then X â†’ Y holds.</p>
</li>
<li>
<p><strong>Testing if X is a superkey</strong>: Compute Xâº. If Xâº = U (all attributes), then X is a superkey.</p>
</li>
<li>
<p><strong>Computing Fâº (the closure of F)</strong>: For each subset X âŠ† U, compute Xâº and output X â†’ Y for each Y âŠ† Xâº. (This is exponential and rarely practical, but it's theoretically important.)</p>
</li>
</ol>
<hr />
<h2 id="6-closure-of-a-set-of-fds">6. Closure of a Set of FDs<a class="header-link" href="#6-closure-of-a-set-of-fds" title="Permanent link">&para;</a></h2>
<h3 id="61-definition">6.1 Definition<a class="header-link" href="#61-definition" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: The <strong>closure of a set of functional dependencies F</strong>, denoted Fâº, is the set of all functional dependencies that can be logically inferred from F.</p>
<p>Fâº = { X â†’ Y | F âŠ¨ X â†’ Y }</p>
</blockquote>
<p>Fâº can be extremely large. For a relation with n attributes, there are 2â¿ possible subsets for X and 2â¿ for Y, giving up to 2Â²â¿ possible FDs. In practice, we almost never compute Fâº directly; we use the attribute closure algorithm instead.</p>
<h3 id="62-equivalence-of-fd-sets">6.2 Equivalence of FD Sets<a class="header-link" href="#62-equivalence-of-fd-sets" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: Two sets of FDs F and G are <strong>equivalent</strong> (denoted F â‰¡ G) if Fâº = Gâº.</p>
</blockquote>
<p>To test whether F â‰¡ G:
1. Check if every FD in G can be derived from F: for each X â†’ Y in G, verify Y âŠ† Xâº_F
2. Check if every FD in F can be derived from G: for each X â†’ Y in F, verify Y âŠ† Xâº_G</p>
<p>If both checks pass, F â‰¡ G.</p>
<h3 id="63-example">6.3 Example<a class="header-link" href="#63-example" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>F = { A â†’ B, B â†’ C }
G = { A â†’ B, B â†’ C, A â†’ C }
</code></pre></div>

<p>F â‰¡ G because A â†’ C is derivable from F by transitivity, and all FDs in F are trivially in G.</p>
<hr />
<h2 id="7-minimal-cover-canonical-cover">7. Minimal Cover (Canonical Cover)<a class="header-link" href="#7-minimal-cover-canonical-cover" title="Permanent link">&para;</a></h2>
<p>A minimal cover is a "simplified" version of a set of FDs â€” it removes redundancy while preserving the same logical content. This is essential for normalization algorithms.</p>
<h3 id="71-definition">7.1 Definition<a class="header-link" href="#71-definition" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: A set of FDs F_min is a <strong>minimal cover</strong> (or <strong>canonical cover</strong>) of F if:
1. <strong>Equivalence</strong>: F_min â‰¡ F (same closure)
2. <strong>Single attribute on RHS</strong>: Every FD in F_min has the form X â†’ A where A is a single attribute
3. <strong>No redundant FDs</strong>: Removing any FD from F_min changes the closure
4. <strong>No extraneous attributes on LHS</strong>: For each FD X â†’ A in F_min, no proper subset of X functionally determines A under F_min</p>
</blockquote>
<h3 id="72-algorithm">7.2 Algorithm<a class="header-link" href="#72-algorithm" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">MinimalCover</span><span class="o">(</span><span class="n">F</span><span class="o">)</span>
<span class="n">INPUT</span><span class="o">:</span><span class="w">  </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="kd">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">functional</span><span class="w"> </span><span class="n">dependencies</span>
<span class="n">OUTPUT</span><span class="o">:</span><span class="w"> </span><span class="n">F_min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">minimal</span><span class="w"> </span><span class="n">cover</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">F</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">DECOMPOSE</span><span class="w"> </span><span class="n">right</span><span class="o">-</span><span class="n">hand</span><span class="w"> </span><span class="n">sides</span>
<span class="w">    </span><span class="n">Replace</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="o">{</span><span class="n">Aâ‚</span><span class="o">,</span><span class="w"> </span><span class="n">Aâ‚‚</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">Aâ‚™</span><span class="o">}</span><span class="w"> </span><span class="k">with</span>
<span class="w">    </span><span class="n">X</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">Aâ‚</span><span class="o">,</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">Aâ‚‚</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">Aâ‚™</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n">REMOVE</span><span class="w"> </span><span class="n">extraneous</span><span class="w"> </span><span class="n">attributes</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">left</span><span class="o">-</span><span class="n">hand</span><span class="w"> </span><span class="n">sides</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="o">(</span><span class="n">X</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="o">|</span><span class="n">X</span><span class="o">|</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">attribute</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">DO</span>
<span class="w">            </span><span class="n">IF</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="err">âˆˆ</span><span class="w"> </span><span class="n">closure</span><span class="o">(</span><span class="n">X</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">{</span><span class="n">B</span><span class="o">},</span><span class="w"> </span><span class="n">F</span><span class="o">)</span><span class="w"> </span><span class="n">THEN</span>
<span class="w">                </span><span class="n">Replace</span><span class="w"> </span><span class="o">(</span><span class="n">X</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="o">((</span><span class="n">X</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">{</span><span class="n">B</span><span class="o">})</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">A</span><span class="o">)</span>
<span class="w">            </span><span class="n">END</span><span class="w"> </span><span class="n">IF</span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w"> </span><span class="n">REMOVE</span><span class="w"> </span><span class="n">redundant</span><span class="w"> </span><span class="n">FDs</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="o">(</span><span class="n">X</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">IF</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="err">âˆˆ</span><span class="w"> </span><span class="n">closure</span><span class="o">(</span><span class="n">X</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="o">{</span><span class="n">X</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">A</span><span class="o">})</span><span class="w"> </span><span class="n">THEN</span>
<span class="w">            </span><span class="n">Remove</span><span class="w"> </span><span class="o">(</span><span class="n">X</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="n">F</span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">IF</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>

<span class="n">RETURN</span><span class="w"> </span><span class="n">F</span>
</code></pre></div>

<p><strong>Important</strong>: Step 2 must come before Step 3. If we remove redundant FDs first, some attributes that were extraneous might no longer appear to be extraneous.</p>
<h3 id="73-worked-example">7.3 Worked Example<a class="header-link" href="#73-worked-example" title="Permanent link">&para;</a></h3>
<p>Let R(A, B, C, D) with:</p>
<div class="highlight"><pre><span></span><code>F = { A â†’ BC,  B â†’ C,  AB â†’ D,  D â†’ A }
</code></pre></div>

<p><strong>Step 1: Decompose RHS</strong></p>
<div class="highlight"><pre><span></span><code>F = { A â†’ B,  A â†’ C,  B â†’ C,  AB â†’ D,  D â†’ A }
</code></pre></div>

<p><strong>Step 2: Remove extraneous LHS attributes</strong></p>
<p>Check AB â†’ D: Can we remove A or B?
- Check if B alone determines D: Compute {B}âº under current F:
  - {B} â†’ {B, C} (via B â†’ C) â€” no more. D âˆ‰ {B}âº. So B alone doesn't work; keep A.
- Check if A alone determines D: Compute {A}âº under current F:
  - {A} â†’ {A, B, C} (via A â†’ B, A â†’ C) â†’ {A, B, C, D} (via AB â†’ D, since A and B are both present)
  - D âˆˆ {A}âº. So A is extraneous in AB â†’ D!</p>
<p>Replace AB â†’ D with A â†’ D:</p>
<div class="highlight"><pre><span></span><code>F = { A â†’ B,  A â†’ C,  B â†’ C,  A â†’ D,  D â†’ A }
</code></pre></div>

<p><strong>Step 3: Remove redundant FDs</strong></p>
<p>Check A â†’ B: Remove it. Compute {A}âº under F - {A â†’ B}:
- F - {A â†’ B} = { A â†’ C,  B â†’ C,  A â†’ D,  D â†’ A }
- {A}âº = {A, C, D} (via A â†’ C, A â†’ D, D â†’ A). B âˆ‰ {A}âº. So A â†’ B is NOT redundant. Keep it.</p>
<p>Check A â†’ C: Remove it. Compute {A}âº under F - {A â†’ C}:
- {A}âº: A â†’ B gives B, B â†’ C gives C. C âˆˆ {A}âº. So A â†’ C IS redundant. Remove it.</p>
<div class="highlight"><pre><span></span><code>F = { A â†’ B,  B â†’ C,  A â†’ D,  D â†’ A }
</code></pre></div>

<p>Check B â†’ C: Remove it. Compute {B}âº under F - {B â†’ C}:
- {B}âº = {B}. C âˆ‰ {B}âº. Not redundant. Keep it.</p>
<p>Check A â†’ D: Remove it. Compute {A}âº under F - {A â†’ D}:
- {A}âº = {A, B, C}. D âˆ‰ {A}âº. Not redundant. Keep it.</p>
<p>Check D â†’ A: Remove it. Compute {D}âº under F - {D â†’ A}:
- {D}âº = {D}. A âˆ‰ {D}âº. Not redundant. Keep it.</p>
<p><strong>Minimal cover:</strong></p>
<div class="highlight"><pre><span></span><code>F_min = { A â†’ B,  B â†’ C,  A â†’ D,  D â†’ A }
</code></pre></div>

<h3 id="74-non-uniqueness-of-minimal-covers">7.4 Non-Uniqueness of Minimal Covers<a class="header-link" href="#74-non-uniqueness-of-minimal-covers" title="Permanent link">&para;</a></h3>
<p>A minimal cover is <strong>not unique</strong>. Different orderings in Step 2 or Step 3 can produce different (but equivalent) minimal covers. For example, in Step 2, checking attributes in different orders can lead to different simplifications.</p>
<hr />
<h2 id="8-finding-candidate-keys-using-fds">8. Finding Candidate Keys Using FDs<a class="header-link" href="#8-finding-candidate-keys-using-fds" title="Permanent link">&para;</a></h2>
<h3 id="81-attribute-classification">8.1 Attribute Classification<a class="header-link" href="#81-attribute-classification" title="Permanent link">&para;</a></h3>
<p>To find candidate keys efficiently, we first classify attributes:</p>
<table>
<thead>
<tr>
<th>Category</th>
<th>Definition</th>
<th>Role in Keys</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>L-only</strong></td>
<td>Appears only on the LHS of FDs (never on RHS)</td>
<td>Must be in every key</td>
</tr>
<tr>
<td><strong>R-only</strong></td>
<td>Appears only on the RHS (never on LHS)</td>
<td>Never in any key</td>
</tr>
<tr>
<td><strong>Both</strong></td>
<td>Appears on both LHS and RHS</td>
<td>May or may not be in a key</td>
</tr>
<tr>
<td><strong>Neither</strong></td>
<td>Appears in no FD at all</td>
<td>Must be in every key</td>
</tr>
</tbody>
</table>
<h3 id="82-algorithm-for-finding-candidate-keys">8.2 Algorithm for Finding Candidate Keys<a class="header-link" href="#82-algorithm-for-finding-candidate-keys" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">FindCandidateKeys</span><span class="o">(</span><span class="n">R</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="o">)</span>
<span class="n">INPUT</span><span class="o">:</span><span class="w">  </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">relation</span><span class="w"> </span><span class="n">schema</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">FDs</span>
<span class="n">OUTPUT</span><span class="o">:</span><span class="w"> </span><span class="n">Set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="n">keys</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">Classify</span><span class="w"> </span><span class="n">attributes</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">L</span><span class="o">-</span><span class="n">only</span><span class="o">,</span><span class="w"> </span><span class="n">R</span><span class="o">-</span><span class="n">only</span><span class="o">,</span><span class="w"> </span><span class="n">Both</span><span class="o">,</span><span class="w"> </span><span class="n">Neither</span><span class="o">.</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n">Let</span><span class="w"> </span><span class="n">CORE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">L</span><span class="o">-</span><span class="n">only</span><span class="w"> </span><span class="err">âˆª</span><span class="w"> </span><span class="n">Neither</span><span class="o">.</span>
<span class="w">        </span><span class="o">(</span><span class="n">CORE</span><span class="w"> </span><span class="n">must</span><span class="w"> </span><span class="n">be</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">every</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="n">key</span><span class="o">.)</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w"> </span><span class="n">Compute</span><span class="w"> </span><span class="n">CORE</span><span class="err">âº</span><span class="o">.</span>
<span class="w">        </span><span class="n">If</span><span class="w"> </span><span class="n">CORE</span><span class="err">âº</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">attributes</span><span class="o">,</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">CORE</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">only</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="n">key</span><span class="o">.</span><span class="w"> </span><span class="n">DONE</span><span class="o">.</span>
<span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="o">:</span><span class="w"> </span><span class="n">Otherwise</span><span class="o">,</span><span class="w"> </span><span class="k">try</span><span class="w"> </span><span class="n">adding</span><span class="w"> </span><span class="n">subsets</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="s2">&quot;Both&quot;</span><span class="w"> </span><span class="n">attributes</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">CORE</span><span class="o">.</span>
<span class="w">        </span><span class="n">Start</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="n">attributes</span><span class="o">,</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">pairs</span><span class="o">,</span><span class="w"> </span><span class="n">etc</span><span class="o">.</span>
<span class="w">        </span><span class="n">For</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">subset</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="s2">&quot;Both&quot;</span><span class="o">:</span>
<span class="w">            </span><span class="n">Compute</span><span class="w"> </span><span class="o">(</span><span class="n">CORE</span><span class="w"> </span><span class="err">âˆª</span><span class="w"> </span><span class="n">S</span><span class="o">)</span><span class="err">âº</span>
<span class="w">            </span><span class="n">If</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">equals</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">attributes</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">proper</span><span class="w"> </span><span class="n">subset</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="o">(</span><span class="n">CORE</span><span class="w"> </span><span class="err">âˆª</span><span class="w"> </span><span class="n">S</span><span class="o">)</span>
<span class="w">            </span><span class="n">containing</span><span class="w"> </span><span class="n">CORE</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">also</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">superkey</span><span class="o">,</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">CORE</span><span class="w"> </span><span class="err">âˆª</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="n">key</span><span class="o">.</span>
</code></pre></div>

<h3 id="83-worked-example">8.3 Worked Example<a class="header-link" href="#83-worked-example" title="Permanent link">&para;</a></h3>
<p>Let R(A, B, C, D, E, F) with:</p>
<div class="highlight"><pre><span></span><code>F = { AB â†’ C,  C â†’ D,  D â†’ E,  CF â†’ B }
</code></pre></div>

<p><strong>Step 1: Classify attributes</strong></p>
<table>
<thead>
<tr>
<th>Attribute</th>
<th>LHS?</th>
<th>RHS?</th>
<th>Category</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>Yes (ABâ†’C)</td>
<td>No</td>
<td>L-only</td>
</tr>
<tr>
<td>B</td>
<td>Yes (ABâ†’C)</td>
<td>Yes (CFâ†’B)</td>
<td>Both</td>
</tr>
<tr>
<td>C</td>
<td>Yes (Câ†’D, CFâ†’B)</td>
<td>Yes (ABâ†’C)</td>
<td>Both</td>
</tr>
<tr>
<td>D</td>
<td>Yes (Dâ†’E)</td>
<td>Yes (Câ†’D)</td>
<td>Both</td>
</tr>
<tr>
<td>E</td>
<td>No</td>
<td>Yes (Dâ†’E)</td>
<td>R-only</td>
</tr>
<tr>
<td>F</td>
<td>Yes (CFâ†’B)</td>
<td>No</td>
<td>L-only</td>
</tr>
</tbody>
</table>
<p><strong>Step 2: CORE = {A, F}</strong> (L-only attributes; no "Neither" attributes)</p>
<p><strong>Step 3: Compute {A, F}âº</strong></p>
<ul>
<li>Start: {A, F}</li>
<li>No FD has LHS âŠ† {A, F} (AB needs B, Câ†’D needs C, etc.)</li>
<li>{A, F}âº = {A, F} â‰  all attributes</li>
</ul>
<p><strong>Step 4: Try adding "Both" attributes (B, C, D)</strong></p>
<p>Try adding B: {A, B, F}âº
- AB â†’ C: {A, B, F, C}
- C â†’ D: {A, B, C, D, F}
- D â†’ E: {A, B, C, D, E, F} = all attributes!
- {A, B, F} is a superkey. Check minimality: CORE = {A, F} alone doesn't work. So {A, B, F} is a candidate key.</p>
<p>Try adding C: {A, C, F}âº
- CF â†’ B: {A, B, C, F}
- AB â†’ C: already have C
- C â†’ D: {A, B, C, D, F}
- D â†’ E: {A, B, C, D, E, F} = all attributes!
- {A, C, F} is a superkey. Check minimality: {A, F} alone doesn't work. So {A, C, F} is a candidate key.</p>
<p>Try adding D: {A, D, F}âº
- D â†’ E: {A, D, E, F}
- No more applicable FDs. {A, D, E, F} â‰  all attributes. Not a superkey.</p>
<p><strong>Candidate keys: {A, B, F} and {A, C, F}</strong></p>
<p>We don't need to check pairs (like {B, C}) since we already found candidate keys with single additions and they are minimal.</p>
<hr />
<h2 id="9-entailment-and-implication">9. Entailment and Implication<a class="header-link" href="#9-entailment-and-implication" title="Permanent link">&para;</a></h2>
<h3 id="91-logical-implication">9.1 Logical Implication<a class="header-link" href="#91-logical-implication" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: A set of FDs F <strong>logically implies</strong> an FD X â†’ Y (written F âŠ¨ X â†’ Y) if every relation instance that satisfies all FDs in F also satisfies X â†’ Y.</p>
</blockquote>
<h3 id="92-testing-implication">9.2 Testing Implication<a class="header-link" href="#92-testing-implication" title="Permanent link">&para;</a></h3>
<p>To test if F âŠ¨ X â†’ Y:
1. Compute Xâº under F
2. If Y âŠ† Xâº, then F âŠ¨ X â†’ Y</p>
<p>This is the practical workhorse: instead of reasoning through chains of axiom applications, just run the closure algorithm.</p>
<h3 id="93-example">9.3 Example<a class="header-link" href="#93-example" title="Permanent link">&para;</a></h3>
<p>Given F = { A â†’ B, B â†’ C, CD â†’ E }:</p>
<p>Does F âŠ¨ AD â†’ E?</p>
<p>Compute {A, D}âº:
- A â†’ B: {A, B, D}
- B â†’ C: {A, B, C, D}
- CD â†’ E: {A, B, C, D, E}</p>
<p>Since E âˆˆ {A, D}âº, yes, F âŠ¨ AD â†’ E. âœ“</p>
<p>Does F âŠ¨ A â†’ E?</p>
<p>Compute {A}âº:
- A â†’ B: {A, B}
- B â†’ C: {A, B, C}
- No more applicable FDs.</p>
<p>E âˆ‰ {A}âº = {A, B, C}. So F âŠ­ A â†’ E. âœ—</p>
<hr />
<h2 id="10-fds-in-practice">10. FDs in Practice<a class="header-link" href="#10-fds-in-practice" title="Permanent link">&para;</a></h2>
<h3 id="101-identifying-fds-from-requirements">10.1 Identifying FDs from Requirements<a class="header-link" href="#101-identifying-fds-from-requirements" title="Permanent link">&para;</a></h3>
<p>Real-world FDs come from business rules and domain knowledge:</p>
<table>
<thead>
<tr>
<th>Business Rule</th>
<th>Functional Dependency</th>
</tr>
</thead>
<tbody>
<tr>
<td>"Each employee has exactly one department"</td>
<td>emp_id â†’ dept_id</td>
</tr>
<tr>
<td>"Each department has exactly one name"</td>
<td>dept_id â†’ dept_name</td>
</tr>
<tr>
<td>"Each student gets one grade per course"</td>
<td>{student_id, course_id} â†’ grade</td>
</tr>
<tr>
<td>"Each ISBN identifies one book title"</td>
<td>isbn â†’ title</td>
</tr>
<tr>
<td>"A flight on a given date has one pilot"</td>
<td>{flight_num, date} â†’ pilot_id</td>
</tr>
</tbody>
</table>
<h3 id="102-fds-and-null-values">10.2 FDs and NULL Values<a class="header-link" href="#102-fds-and-null-values" title="Permanent link">&para;</a></h3>
<p>Standard FD theory assumes no NULL values. In practice:
- NULLs complicate FD reasoning (NULL â‰  NULL in SQL)
- SQL's UNIQUE constraint allows multiple NULLs (except for PRIMARY KEY)
- Some database systems offer "NULLS NOT DISTINCT" to treat NULLs as equal for uniqueness checks</p>
<h3 id="103-discovering-fds-from-data">10.3 Discovering FDs from Data<a class="header-link" href="#103-discovering-fds-from-data" title="Permanent link">&para;</a></h3>
<p>While FDs are semantic constraints (determined by domain knowledge, not data), there are algorithms for <strong>discovering approximate FDs</strong> from data:</p>
<ul>
<li><strong>TANE</strong> algorithm: Discovers all FDs holding in a dataset</li>
<li><strong>FUN</strong> algorithm: Uses lattice-based search</li>
<li><strong>FDTool</strong>: Practical tool for FD discovery</li>
</ul>
<p>These are useful for reverse-engineering poorly documented databases, but the discovered FDs should always be validated against domain knowledge.</p>
<h3 id="104-fds-in-sql">10.4 FDs in SQL<a class="header-link" href="#104-fds-in-sql" title="Permanent link">&para;</a></h3>
<p>SQL doesn't have a direct <code>FUNCTIONAL DEPENDENCY</code> constraint, but FDs are enforced through:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- Primary key enforces: emp_id â†’ all other attributes</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">Employee</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">emp_id</span><span class="w">    </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">emp_name</span><span class="w">  </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
<span class="w">    </span><span class="n">dept_id</span><span class="w">   </span><span class="nb">INT</span><span class="p">,</span>
<span class="w">    </span><span class="n">salary</span><span class="w">    </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">);</span>

<span class="c1">-- UNIQUE constraint enforces: email â†’ (implicitly all attributes, if it&#39;s a key)</span>
<span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">Employee</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="k">CONSTRAINT</span><span class="w"> </span><span class="n">uq_email</span><span class="w"> </span><span class="k">UNIQUE</span><span class="p">(</span><span class="n">email</span><span class="p">);</span>

<span class="c1">-- The FD dept_id â†’ dept_name is enforced by having a separate Departments table</span>
<span class="c1">-- with dept_id as its primary key</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">Department</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">dept_id</span><span class="w">   </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">dept_name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>

<hr />
<h2 id="11-common-pitfalls">11. Common Pitfalls<a class="header-link" href="#11-common-pitfalls" title="Permanent link">&para;</a></h2>
<h3 id="111-confusing-fds-with-data-patterns">11.1 Confusing FDs with Data Patterns<a class="header-link" href="#111-confusing-fds-with-data-patterns" title="Permanent link">&para;</a></h3>
<p>A common mistake is looking at data and concluding an FD exists:</p>
<div class="highlight"><pre><span></span><code>| city        | state |
|-------------|-------|
| Springfield | IL    |
| Portland    | OR    |
| Austin      | TX    |
</code></pre></div>

<p>This data is consistent with city â†’ state, but in reality, many cities share names across states (Springfield exists in over 30 states). The FD city â†’ state does <strong>not</strong> hold.</p>
<h3 id="112-direction-matters">11.2 Direction Matters<a class="header-link" href="#112-direction-matters" title="Permanent link">&para;</a></h3>
<p>X â†’ Y does <strong>not</strong> imply Y â†’ X.</p>
<ul>
<li>dept_id â†’ dept_name (a department has one name) âœ“</li>
<li>dept_name â†’ dept_id (a name identifies one department) â€” depends on whether names are unique!</li>
</ul>
<h3 id="113-fd-on-a-single-attribute">11.3 FD on a Single Attribute<a class="header-link" href="#113-fd-on-a-single-attribute" title="Permanent link">&para;</a></h3>
<p>An FD like {} â†’ A (the empty set determines A) means A has the same value in every tuple. This is a rare but valid FD (e.g., a table where all employees are in the same company: {} â†’ company_name).</p>
<h3 id="114-order-of-operations-in-minimal-cover">11.4 Order of Operations in Minimal Cover<a class="header-link" href="#114-order-of-operations-in-minimal-cover" title="Permanent link">&para;</a></h3>
<p>Step 2 (remove extraneous LHS attributes) must precede Step 3 (remove redundant FDs). Reversing the order can produce incorrect results.</p>
<hr />
<h2 id="12-proofs-and-theory">12. Proofs and Theory<a class="header-link" href="#12-proofs-and-theory" title="Permanent link">&para;</a></h2>
<h3 id="121-proving-completeness-of-armstrongs-axioms-sketch">12.1 Proving Completeness of Armstrong's Axioms (Sketch)<a class="header-link" href="#121-proving-completeness-of-armstrongs-axioms-sketch" title="Permanent link">&para;</a></h3>
<p><strong>Claim</strong>: If F âŠ­ X â†’ Y using Armstrong's axioms, then there exists a relation instance satisfying F but violating X â†’ Y.</p>
<p><strong>Proof sketch</strong>: Construct a two-tuple relation r = {tâ‚, tâ‚‚} where:
- tâ‚[A] = tâ‚‚[A] = 1 for all A âˆˆ Xâº
- tâ‚[A] = 1, tâ‚‚[A] = 0 for all A âˆ‰ Xâº</p>
<p>We need to verify:
1. r satisfies every FD in F: For any V â†’ W in F, if tâ‚[V] = tâ‚‚[V], then V âŠ† Xâº, so W âŠ† Xâº (by the closure algorithm), so tâ‚[W] = tâ‚‚[W]. âœ“
2. r violates X â†’ Y (assuming Y âŠ„ Xâº): Since tâ‚[X] = tâ‚‚[X] (all 1's) but there exists some A âˆˆ Y with A âˆ‰ Xâº, so tâ‚[A] â‰  tâ‚‚[A]. âœ“</p>
<p>This contradicts the assumption that X â†’ Y is logically implied by F, proving completeness. âˆ</p>
<h3 id="122-complexity-results">12.2 Complexity Results<a class="header-link" href="#122-complexity-results" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Complexity</th>
</tr>
</thead>
<tbody>
<tr>
<td>Computing Xâº</td>
<td>O(|F| Ã— |U|) â€” polynomial</td>
</tr>
<tr>
<td>Testing if F âŠ¨ X â†’ Y</td>
<td>O(|F| Ã— |U|) â€” polynomial</td>
</tr>
<tr>
<td>Computing Fâº</td>
<td>Exponential (can be 2^(2n))</td>
</tr>
<tr>
<td>Finding all candidate keys</td>
<td>NP-complete in general</td>
</tr>
<tr>
<td>Computing minimal cover</td>
<td>Polynomial</td>
</tr>
<tr>
<td>Testing if X is a superkey</td>
<td>O(|F| Ã— |U|) â€” polynomial</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="13-exercises">13. Exercises<a class="header-link" href="#13-exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-attribute-closure">Exercise 1: Attribute Closure<a class="header-link" href="#exercise-1-attribute-closure" title="Permanent link">&para;</a></h3>
<p>Let R(A, B, C, D, E) with F = { AB â†’ C, C â†’ D, BD â†’ E, A â†’ B }.</p>
<p>Compute the following closures:
1. {A}âº
2. {B, C}âº
3. {A, D}âº
4. {C, D}âº</p>
<details>
<summary>Solution</summary>

1. **{A}âº**: A â†’ B gives {A, B}; AB â†’ C gives {A, B, C}; C â†’ D gives {A, B, C, D}; BD â†’ E gives {A, B, C, D, E}. **{A}âº = {A, B, C, D, E}**

2. **{B, C}âº**: C â†’ D gives {B, C, D}; BD â†’ E gives {B, C, D, E}. No more. **{B, C}âº = {B, C, D, E}**

3. **{A, D}âº**: A â†’ B gives {A, B, D}; AB â†’ C gives {A, B, C, D}; BD â†’ E gives {A, B, C, D, E}. **{A, D}âº = {A, B, C, D, E}**

4. **{C, D}âº**: C â†’ D (already have D). No other FD has LHS âŠ† {C, D}. **{C, D}âº = {C, D}**
</details>

<h3 id="exercise-2-finding-candidate-keys">Exercise 2: Finding Candidate Keys<a class="header-link" href="#exercise-2-finding-candidate-keys" title="Permanent link">&para;</a></h3>
<p>For the relation and FDs in Exercise 1, find all candidate keys.</p>
<details>
<summary>Solution</summary>

Classify attributes:
- A: LHS only (in ABâ†’C, Aâ†’B) â†’ L-only
- B: Both (LHS in ABâ†’C, BDâ†’E; RHS in Aâ†’B)
- C: Both (LHS in Câ†’D; RHS in ABâ†’C)
- D: Both (LHS in BDâ†’E; RHS in Câ†’D)
- E: RHS only (in BDâ†’E) â†’ R-only

CORE = {A} (L-only; no "Neither" attributes).
{A}âº = {A, B, C, D, E} = all attributes.

**{A} is the only candidate key.**
</details>

<h3 id="exercise-3-minimal-cover">Exercise 3: Minimal Cover<a class="header-link" href="#exercise-3-minimal-cover" title="Permanent link">&para;</a></h3>
<p>Find a minimal cover for:</p>
<div class="highlight"><pre><span></span><code>F = { A â†’ BC,  B â†’ C,  AB â†’ D,  D â†’ BC }
</code></pre></div>

<details>
<summary>Solution</summary>

**Step 1: Decompose RHS**

<div class="highlight"><pre><span></span><code>F = { A â†’ B, A â†’ C, B â†’ C, AB â†’ D, D â†’ B, D â†’ C }
</code></pre></div>



**Step 2: Remove extraneous LHS attributes**

Check AB â†’ D:
- Try removing A: {B}âº = {B, C}. D âˆ‰ {B}âº. Keep A.
- Try removing B: {A}âº = {A, B, C, D} (via Aâ†’B, Aâ†’C, then ABâ†’D since B now included, then Dâ†’B, Dâ†’C). D âˆˆ {A}âº. Remove B!

Replace AB â†’ D with A â†’ D.


<div class="highlight"><pre><span></span><code>F = { A â†’ B, A â†’ C, B â†’ C, A â†’ D, D â†’ B, D â†’ C }
</code></pre></div>



**Step 3: Remove redundant FDs**

- A â†’ B: Remove. {A}âº under F - {Aâ†’B} = {A, C, D, B, C} (Aâ†’C, Aâ†’D, Dâ†’B, Dâ†’C). B âˆˆ {A}âº. **Redundant! Remove.**
- A â†’ C: Remove. {A}âº under F - {Aâ†’C} = {A, D, B, C} (Aâ†’D, Dâ†’B, Dâ†’C). C âˆˆ {A}âº. **Redundant! Remove.**
- B â†’ C: Remove. {B}âº under F - {Bâ†’C} = {B}. C âˆ‰ {B}âº. **Not redundant. Keep.**
- A â†’ D: Remove. {A}âº under F - {Aâ†’D} = {A}. D âˆ‰ {A}âº. **Not redundant. Keep.**
- D â†’ B: Remove. {D}âº under F - {Dâ†’B} = {D, C}. B âˆ‰ {D}âº. **Not redundant. Keep.**
- D â†’ C: Remove. {D}âº under F - {Dâ†’C} = {D, B, C}. C âˆˆ {D}âº (via Dâ†’B, Bâ†’C). **Redundant! Remove.**

**Minimal cover: F_min = { B â†’ C, A â†’ D, D â†’ B }**
</details>

<h3 id="exercise-4-proving-an-fd">Exercise 4: Proving an FD<a class="header-link" href="#exercise-4-proving-an-fd" title="Permanent link">&para;</a></h3>
<p>Given F = { A â†’ B, B â†’ C, C â†’ D }, prove that A â†’ D using Armstrong's axioms. Write out each step explicitly.</p>
<details>
<summary>Solution</summary>

1. A â†’ B (given)
2. B â†’ C (given)
3. A â†’ C (transitivity on steps 1 and 2)
4. C â†’ D (given)
5. A â†’ D (transitivity on steps 3 and 4) âˆ
</details>

<h3 id="exercise-5-fd-implication">Exercise 5: FD Implication<a class="header-link" href="#exercise-5-fd-implication" title="Permanent link">&para;</a></h3>
<p>Given F = { A â†’ B, BC â†’ D, E â†’ C }:</p>
<p>Determine whether the following FDs are implied by F:
1. AE â†’ D
2. BE â†’ D
3. A â†’ D</p>
<details>
<summary>Solution</summary>

1. **AE â†’ D**: Compute {A, E}âº = {A, E} â†’ {A, B, E} (Aâ†’B) â†’ {A, B, C, E} (Eâ†’C) â†’ {A, B, C, D, E} (BCâ†’D). D âˆˆ {A,E}âº. **Yes, F âŠ¨ AE â†’ D.** âœ“

2. **BE â†’ D**: Compute {B, E}âº = {B, E} â†’ {B, C, E} (Eâ†’C) â†’ {B, C, D, E} (BCâ†’D). D âˆˆ {B,E}âº. **Yes, F âŠ¨ BE â†’ D.** âœ“

3. **A â†’ D**: Compute {A}âº = {A} â†’ {A, B} (Aâ†’B). No more applicable. D âˆ‰ {A}âº. **No, F âŠ­ A â†’ D.** âœ—
</details>

<h3 id="exercise-6-equivalence-of-fd-sets">Exercise 6: Equivalence of FD Sets<a class="header-link" href="#exercise-6-equivalence-of-fd-sets" title="Permanent link">&para;</a></h3>
<p>Are the following two sets of FDs equivalent?</p>
<div class="highlight"><pre><span></span><code>F = { A â†’ B, B â†’ C, A â†’ C }
G = { A â†’ B, B â†’ C }
</code></pre></div>

<details>
<summary>Solution</summary>

Check if every FD in F is implied by G:
- A â†’ B: In G directly. âœ“
- B â†’ C: In G directly. âœ“
- A â†’ C: {A}âº_G = {A, B, C}. C âˆˆ {A}âº. âœ“

Check if every FD in G is implied by F:
- A â†’ B: In F directly. âœ“
- B â†’ C: In F directly. âœ“

**F â‰¡ G.** The FD A â†’ C in F is redundant; it follows from A â†’ B and B â†’ C by transitivity.
</details>

<h3 id="exercise-7-multiple-candidate-keys">Exercise 7: Multiple Candidate Keys<a class="header-link" href="#exercise-7-multiple-candidate-keys" title="Permanent link">&para;</a></h3>
<p>Let R(A, B, C, D, E) with F = { AB â†’ CDE, C â†’ A, D â†’ B }.</p>
<p>Find all candidate keys.</p>
<details>
<summary>Solution</summary>

Classify attributes:
- A: Both (LHS: ABâ†’CDE; RHS: Câ†’A)
- B: Both (LHS: ABâ†’CDE; RHS: Dâ†’B)
- C: Both (LHS: Câ†’A; RHS: ABâ†’CDE)
- D: Both (LHS: Dâ†’B; RHS: ABâ†’CDE)
- E: RHS only â†’ R-only

No L-only or Neither attributes, so CORE = {}.

Try single attributes:
- {A}âº = {A}. Not superkey.
- {B}âº = {B}. Not superkey.
- {C}âº = {C, A} = {A, C}. Not superkey.
- {D}âº = {D, B} = {B, D}. Not superkey.

Try pairs:
- {A, B}âº = {A, B, C, D, E}. **Superkey!** Minimal (neither {A} nor {B} alone works). **Candidate key: {A, B}**
- {A, D}âº = {A, B, D} â†’ {A, B, C, D, E}. **Superkey!** Check: {A}âº={A}, {D}âº={B,D}. Minimal. **Candidate key: {A, D}**
- {B, C}âº = {A, B, C} â†’ {A, B, C, D, E}. **Superkey!** Check: {B}âº={B}, {C}âº={A,C}. Minimal. **Candidate key: {B, C}**
- {C, D}âº = {A, B, C, D} â†’ {A, B, C, D, E}. **Superkey!** Check: {C}âº={A,C}, {D}âº={B,D}. Minimal. **Candidate key: {C, D}**

**All candidate keys: {A,B}, {A,D}, {B,C}, {C,D}**
</details>

<h3 id="exercise-8-closure-proof">Exercise 8: Closure Proof<a class="header-link" href="#exercise-8-closure-proof" title="Permanent link">&para;</a></h3>
<p>Prove that the Union Rule (X â†’ Y, X â†’ Z âŸ¹ X â†’ YZ) follows from Armstrong's axioms.</p>
<details>
<summary>Solution</summary>

1. X â†’ Y (given)
2. X â†’ XY (augment step 1 with X: XX â†’ XY, and XX = X)
3. X â†’ Z (given)
4. XY â†’ YZ (augment step 3 with Y: XY â†’ ZY)
5. X â†’ YZ (transitivity on steps 2 and 4) âˆ
</details>

<hr />
<h2 id="14-summary">14. Summary<a class="header-link" href="#14-summary" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Key Point</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Functional Dependency</strong></td>
<td>X â†’ Y means X uniquely determines Y</td>
</tr>
<tr>
<td><strong>Armstrong's Axioms</strong></td>
<td>Reflexivity, Augmentation, Transitivity â€” sound and complete</td>
</tr>
<tr>
<td><strong>Derived Rules</strong></td>
<td>Union, Decomposition, Pseudotransitivity</td>
</tr>
<tr>
<td><strong>Attribute Closure Xâº</strong></td>
<td>All attributes determined by X â€” the key algorithm</td>
</tr>
<tr>
<td><strong>FD Set Closure Fâº</strong></td>
<td>All FDs implied by F â€” usually computed via Xâº</td>
</tr>
<tr>
<td><strong>Minimal Cover</strong></td>
<td>Simplified equivalent FD set â€” needed for normalization</td>
</tr>
<tr>
<td><strong>Candidate Keys</strong></td>
<td>Found by classifying attributes and computing closures</td>
</tr>
</tbody>
</table>
<p>Functional dependencies are the theoretical bedrock of relational database design. The algorithms in this lesson â€” attribute closure and minimal cover â€” will be used extensively in the next lesson on normalization, where we apply FDs to decompose relations into well-structured schemas.</p>
<hr />
<p><strong>Previous</strong>: <a href="./04_ER_Modeling.md">04_ER_Modeling.md</a> | <strong>Next</strong>: <a href="./06_Normalization.md">06_Normalization.md</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Database_Theory/04_ER_Modeling.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">ER Modeling</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Database_Theory/06_Normalization.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 06: Normalization (1NF through BCNF)</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">â†‘</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}