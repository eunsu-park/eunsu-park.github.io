{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 06: Normalization (1NF through BCNF) - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Database_Theory/">Database Theory</a>
    <span class="separator">/</span>
    <span class="current">Lesson 06: Normalization (1NF through BCNF)</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 06: Normalization (1NF through BCNF)</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Database_Theory/05_Functional_Dependencies.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 05: Functional Dependencies</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Database_Theory/07_Advanced_Normalization.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 07: Advanced Normalization</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#1-introduction">1. Introduction</a><ul>
<li><a href="#11-the-problem-poor-schema-design">1.1 The Problem: Poor Schema Design</a></li>
<li><a href="#12-data-anomalies">1.2 Data Anomalies</a><ul>
<li><a href="#update-anomaly">Update Anomaly</a></li>
<li><a href="#insertion-anomaly">Insertion Anomaly</a></li>
<li><a href="#deletion-anomaly">Deletion Anomaly</a></li>
</ul>
</li>
<li><a href="#13-root-cause-redundancy-from-fd-violations">1.3 Root Cause: Redundancy from FD Violations</a></li>
<li><a href="#14-goals-of-normalization">1.4 Goals of Normalization</a></li>
</ul>
</li>
<li><a href="#2-first-normal-form-1nf">2. First Normal Form (1NF)</a><ul>
<li><a href="#21-definition">2.1 Definition</a></li>
<li><a href="#22-violations-and-fixes">2.2 Violations and Fixes</a></li>
<li><a href="#23-1nf-and-the-relational-model">2.3 1NF and the Relational Model</a></li>
</ul>
</li>
<li><a href="#3-second-normal-form-2nf">3. Second Normal Form (2NF)</a><ul>
<li><a href="#31-partial-dependency">3.1 Partial Dependency</a></li>
<li><a href="#32-definition">3.2 Definition</a></li>
<li><a href="#33-example">3.3 Example</a></li>
<li><a href="#34-formal-test-for-2nf">3.4 Formal Test for 2NF</a></li>
</ul>
</li>
<li><a href="#4-third-normal-form-3nf">4. Third Normal Form (3NF)</a><ul>
<li><a href="#41-transitive-dependency">4.1 Transitive Dependency</a></li>
<li><a href="#42-definition">4.2 Definition</a></li>
<li><a href="#43-example">4.3 Example</a></li>
<li><a href="#44-the-importance-of-prime-attribute-exception">4.4 The Importance of "Prime Attribute" Exception</a></li>
</ul>
</li>
<li><a href="#5-boyce-codd-normal-form-bcnf">5. Boyce-Codd Normal Form (BCNF)</a><ul>
<li><a href="#51-definition">5.1 Definition</a></li>
<li><a href="#52-relationship-3nf-vs-bcnf">5.2 Relationship: 3NF vs BCNF</a></li>
<li><a href="#53-example-3nf-but-not-bcnf">5.3 Example: 3NF but Not BCNF</a></li>
<li><a href="#54-when-3nf-and-bcnf-differ">5.4 When 3NF and BCNF Differ</a></li>
</ul>
</li>
<li><a href="#6-decomposition-properties">6. Decomposition Properties</a><ul>
<li><a href="#61-lossless-join-property">6.1 Lossless-Join Property</a><ul>
<li><a href="#binary-decomposition-test">Binary Decomposition Test</a></li>
<li><a href="#example">Example</a></li>
<li><a href="#why-lossless-join-matters">Why Lossless-Join Matters</a></li>
</ul>
</li>
<li><a href="#62-dependency-preservation">6.2 Dependency Preservation</a><ul>
<li><a href="#why-dependency-preservation-matters">Why Dependency Preservation Matters</a></li>
<li><a href="#example_1">Example</a></li>
</ul>
</li>
<li><a href="#63-can-we-always-have-both">6.3 Can We Always Have Both?</a></li>
</ul>
</li>
<li><a href="#7-the-lossless-join-test-algorithm-for-n-ary-decomposition">7. The Lossless-Join Test Algorithm (For n-ary Decomposition)</a><ul>
<li><a href="#71-algorithm-chase-test">7.1 Algorithm (Chase Test)</a></li>
<li><a href="#72-worked-example">7.2 Worked Example</a></li>
</ul>
</li>
<li><a href="#8-3nf-synthesis-algorithm">8. 3NF Synthesis Algorithm</a><ul>
<li><a href="#81-algorithm">8.1 Algorithm</a></li>
<li><a href="#82-why-each-step-matters">8.2 Why Each Step Matters</a></li>
<li><a href="#83-worked-example">8.3 Worked Example</a></li>
</ul>
</li>
<li><a href="#9-bcnf-decomposition-algorithm">9. BCNF Decomposition Algorithm</a><ul>
<li><a href="#91-algorithm">9.1 Algorithm</a></li>
<li><a href="#92-worked-example">9.2 Worked Example</a></li>
<li><a href="#93-bcnf-vs-3nf-the-tradeoff">9.3 BCNF vs 3NF: The Tradeoff</a></li>
</ul>
</li>
<li><a href="#10-complete-worked-example-unnormalized-to-bcnf">10. Complete Worked Example: Unnormalized to BCNF</a><ul>
<li><a href="#101-scenario">10.1 Scenario</a></li>
<li><a href="#102-check-1nf">10.2 Check 1NF</a></li>
<li><a href="#103-check-2nf">10.3 Check 2NF</a></li>
<li><a href="#104-check-3nf">10.4 Check 3NF</a></li>
<li><a href="#105-check-bcnf">10.5 Check BCNF</a></li>
<li><a href="#106-summary-of-decomposition">10.6 Summary of Decomposition</a></li>
</ul>
</li>
<li><a href="#11-normalization-in-sql">11. Normalization in SQL</a><ul>
<li><a href="#111-implementing-the-normalized-schema">11.1 Implementing the Normalized Schema</a></li>
<li><a href="#112-verifying-normalization-via-queries">11.2 Verifying Normalization via Queries</a></li>
</ul>
</li>
<li><a href="#12-summary-of-normal-forms">12. Summary of Normal Forms</a><ul>
<li><a href="#decision-flowchart">Decision Flowchart</a></li>
</ul>
</li>
<li><a href="#13-exercises">13. Exercises</a><ul>
<li><a href="#exercise-1-identifying-normal-forms">Exercise 1: Identifying Normal Forms</a></li>
<li><a href="#exercise-2-3nf-synthesis">Exercise 2: 3NF Synthesis</a></li>
<li><a href="#exercise-3-bcnf-decomposition">Exercise 3: BCNF Decomposition</a></li>
<li><a href="#exercise-4-lossless-join-verification">Exercise 4: Lossless-Join Verification</a></li>
<li><a href="#exercise-5-full-normalization">Exercise 5: Full Normalization</a></li>
<li><a href="#exercise-6-anomaly-identification">Exercise 6: Anomaly Identification</a></li>
</ul>
</li>
<li><a href="#14-summary">14. Summary</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-06-normalization-1nf-through-bcnf">Lesson 06: Normalization (1NF through BCNF)<a class="header-link" href="#lesson-06-normalization-1nf-through-bcnf" title="Permanent link">&para;</a></h1>
<p><strong>Previous</strong>: <a href="./05_Functional_Dependencies.md">05_Functional_Dependencies.md</a> | <strong>Next</strong>: <a href="./07_Advanced_Normalization.md">07_Advanced_Normalization.md</a></p>
<hr />
<blockquote>
<p><strong>Topic</strong>: Database Theory
<strong>Lesson</strong>: 6 of 16
<strong>Prerequisites</strong>: Functional dependencies, attribute closure, minimal cover (Lesson 05)
<strong>Objective</strong>: Understand normalization from 1NF through BCNF, master decomposition algorithms, verify lossless-join and dependency-preservation properties, and apply normalization to real-world schemas</p>
</blockquote>
<h2 id="1-introduction">1. Introduction<a class="header-link" href="#1-introduction" title="Permanent link">&para;</a></h2>
<p>Normalization is the process of organizing a relational database schema to reduce redundancy and eliminate certain types of data anomalies. Introduced by Edgar F. Codd in 1970, it provides a systematic, theory-driven approach to schema design.</p>
<h3 id="11-the-problem-poor-schema-design">1.1 The Problem: Poor Schema Design<a class="header-link" href="#11-the-problem-poor-schema-design" title="Permanent link">&para;</a></h3>
<p>Consider this single-relation design for a university:</p>
<div class="highlight"><pre><span></span><code><span class="nx">UniversityCourse</span><span class="p">(</span>
<span class="w">    </span><span class="nx">student_id</span><span class="p">,</span><span class="w"> </span><span class="nx">student_name</span><span class="p">,</span><span class="w"> </span><span class="nx">student_addr</span><span class="p">,</span>
<span class="w">    </span><span class="nx">course_id</span><span class="p">,</span><span class="w"> </span><span class="nx">course_title</span><span class="p">,</span><span class="w"> </span><span class="nx">dept_name</span><span class="p">,</span><span class="w"> </span><span class="nx">dept_building</span><span class="p">,</span>
<span class="w">    </span><span class="nx">instructor_id</span><span class="p">,</span><span class="w"> </span><span class="nx">instructor_name</span><span class="p">,</span>
<span class="w">    </span><span class="nx">grade</span><span class="p">,</span><span class="w"> </span><span class="nx">semester</span>
<span class="p">)</span>
</code></pre></div>

<p>This "universal relation" stores everything in one table. While it works for simple queries, it suffers from serious problems.</p>
<h3 id="12-data-anomalies">1.2 Data Anomalies<a class="header-link" href="#12-data-anomalies" title="Permanent link">&para;</a></h3>
<h4 id="update-anomaly">Update Anomaly<a class="header-link" href="#update-anomaly" title="Permanent link">&para;</a></h4>
<p>If the Computer Science department moves to a new building, we must update <code>dept_building</code> in <strong>every row</strong> where <code>dept_name = 'Computer Science'</code>. If we miss even one row, the data becomes inconsistent.</p>
<div class="highlight"><pre><span></span><code>Before:
| course_id | dept_name | dept_building |
|-----------|-----------|---------------|
| CS101     | CS        | Watson Hall   |
| CS201     | CS        | Watson Hall   |    ‚Üê must update ALL rows
| CS301     | CS        | Watson Hall   |

If we update only the first row:
| CS101     | CS        | Taylor Hall   |    ‚Üê updated
| CS201     | CS        | Watson Hall   |    ‚Üê inconsistent!
| CS301     | CS        | Watson Hall   |    ‚Üê inconsistent!
</code></pre></div>

<h4 id="insertion-anomaly">Insertion Anomaly<a class="header-link" href="#insertion-anomaly" title="Permanent link">&para;</a></h4>
<p>We cannot record a new department (e.g., its name and building) unless a student enrolls in one of its courses, because <code>student_id</code> is part of the primary key.</p>
<h4 id="deletion-anomaly">Deletion Anomaly<a class="header-link" href="#deletion-anomaly" title="Permanent link">&para;</a></h4>
<p>If the last student enrolled in a course drops it, we lose not just the enrollment data but also the course title, instructor assignment, and department information.</p>
<h3 id="13-root-cause-redundancy-from-fd-violations">1.3 Root Cause: Redundancy from FD Violations<a class="header-link" href="#13-root-cause-redundancy-from-fd-violations" title="Permanent link">&para;</a></h3>
<p>All three anomalies stem from the same root cause: <strong>attributes that depend on only part of the key, or on non-key attributes, are stored redundantly</strong>. Normalization eliminates this redundancy through systematic decomposition guided by functional dependencies.</p>
<h3 id="14-goals-of-normalization">1.4 Goals of Normalization<a class="header-link" href="#14-goals-of-normalization" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Eliminate redundancy</strong>: Each fact is stored exactly once</li>
<li><strong>Prevent anomalies</strong>: Updates, insertions, and deletions are clean</li>
<li><strong>Preserve information</strong>: No data is lost during decomposition (lossless join)</li>
<li><strong>Preserve constraints</strong>: FDs are still enforceable (dependency preservation)</li>
</ol>
<hr />
<h2 id="2-first-normal-form-1nf">2. First Normal Form (1NF)<a class="header-link" href="#2-first-normal-form-1nf" title="Permanent link">&para;</a></h2>
<h3 id="21-definition">2.1 Definition<a class="header-link" href="#21-definition" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: A relation is in <strong>First Normal Form (1NF)</strong> if:
1. All attributes contain only <strong>atomic</strong> (indivisible) values
2. There are no <strong>repeating groups</strong> or arrays
3. Each row is uniquely identifiable (has a primary key)</p>
</blockquote>
<p>1NF is the baseline requirement for being a valid relation in the relational model.</p>
<h3 id="22-violations-and-fixes">2.2 Violations and Fixes<a class="header-link" href="#22-violations-and-fixes" title="Permanent link">&para;</a></h3>
<p><strong>Violation 1: Non-atomic values</strong></p>
<div class="highlight"><pre><span></span><code>| student_id | name       | phone_numbers          |
|------------|------------|------------------------|
| 101        | Alice      | 555-1234, 555-5678     |    ‚Üê multi-valued!
| 102        | Bob        | 555-9999               |
</code></pre></div>

<p><strong>Fix</strong>: Create a separate row for each phone number, or a separate table:</p>
<div class="highlight"><pre><span></span><code>Student(student_id, name)
StudentPhone(student_id, phone_number)

| student_id | phone_number |
|------------|--------------|
| 101        | 555-1234     |
| 101        | 555-5678     |
| 102        | 555-9999     |
</code></pre></div>

<p><strong>Violation 2: Repeating groups</strong></p>
<div class="highlight"><pre><span></span><code>| order_id | item1  | qty1 | item2  | qty2 | item3  | qty3 |
|----------|--------|------|--------|------|--------|------|
| 1001     | Pen    | 5    | Paper  | 10   | NULL   | NULL |
</code></pre></div>

<p><strong>Fix</strong>: Normalize into two tables:</p>
<div class="highlight"><pre><span></span><code>Order(order_id, order_date, customer_id)
OrderItem(order_id, item_name, quantity)
</code></pre></div>

<h3 id="23-1nf-and-the-relational-model">2.3 1NF and the Relational Model<a class="header-link" href="#23-1nf-and-the-relational-model" title="Permanent link">&para;</a></h3>
<p>In strict relational theory, a relation is by definition in 1NF ‚Äî the relational model doesn't allow non-atomic domains. However, in practice, many systems allow arrays (PostgreSQL <code>int[]</code>), JSON columns, or comma-separated values. While sometimes useful for performance, these violate the spirit of 1NF and make FD-based reasoning difficult.</p>
<hr />
<h2 id="3-second-normal-form-2nf">3. Second Normal Form (2NF)<a class="header-link" href="#3-second-normal-form-2nf" title="Permanent link">&para;</a></h2>
<h3 id="31-partial-dependency">3.1 Partial Dependency<a class="header-link" href="#31-partial-dependency" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: A <strong>partial dependency</strong> exists when a non-prime attribute (an attribute not part of any candidate key) is functionally dependent on a <strong>proper subset</strong> of a candidate key.</p>
</blockquote>
<p>In other words, some attribute depends on only <em>part</em> of the key, not the whole key.</p>
<h3 id="32-definition">3.2 Definition<a class="header-link" href="#32-definition" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: A relation is in <strong>Second Normal Form (2NF)</strong> if:
1. It is in 1NF, and
2. Every non-prime attribute is <strong>fully functionally dependent</strong> on every candidate key (no partial dependencies)</p>
</blockquote>
<p>Note: 2NF is only relevant when a candidate key is composite (has more than one attribute). If all candidate keys are single attributes, the relation is automatically in 2NF.</p>
<h3 id="33-example">3.3 Example<a class="header-link" href="#33-example" title="Permanent link">&para;</a></h3>
<p>Consider:</p>
<div class="highlight"><pre><span></span><code>StudentCourse(student_id, course_id, student_name, grade)
</code></pre></div>

<p>Candidate key: {student_id, course_id}</p>
<p>FDs:
- {student_id, course_id} ‚Üí grade (full dependency)
- student_id ‚Üí student_name (partial dependency! student_name depends on only part of the key)</p>
<p>This violates 2NF.</p>
<p><strong>Decomposition to achieve 2NF:</strong></p>
<div class="highlight"><pre><span></span><code>Student(student_id, student_name)
    Key: {student_id}
    FD: student_id ‚Üí student_name

Enrollment(student_id, course_id, grade)
    Key: {student_id, course_id}
    FD: {student_id, course_id} ‚Üí grade
</code></pre></div>

<h3 id="34-formal-test-for-2nf">3.4 Formal Test for 2NF<a class="header-link" href="#34-formal-test-for-2nf" title="Permanent link">&para;</a></h3>
<p>For each candidate key K and each non-prime attribute A:
1. Check if there exists a proper subset X ‚äÇ K such that X ‚Üí A
2. If any such partial dependency exists, the relation is not in 2NF</p>
<hr />
<h2 id="4-third-normal-form-3nf">4. Third Normal Form (3NF)<a class="header-link" href="#4-third-normal-form-3nf" title="Permanent link">&para;</a></h2>
<h3 id="41-transitive-dependency">4.1 Transitive Dependency<a class="header-link" href="#41-transitive-dependency" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: A <strong>transitive dependency</strong> exists when a non-prime attribute A depends on another non-prime attribute B, which in turn depends on a candidate key K:</p>
<p>K ‚Üí B ‚Üí A, where B is not a superkey and A is not part of any candidate key.</p>
</blockquote>
<h3 id="42-definition">4.2 Definition<a class="header-link" href="#42-definition" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: A relation schema R is in <strong>Third Normal Form (3NF)</strong> if for every non-trivial functional dependency X ‚Üí A where A is a single attribute:
1. X is a superkey of R, <strong>OR</strong>
2. A is a <strong>prime attribute</strong> (member of some candidate key)</p>
</blockquote>
<p>Equivalently: no non-prime attribute is transitively dependent on any candidate key.</p>
<h3 id="43-example">4.3 Example<a class="header-link" href="#43-example" title="Permanent link">&para;</a></h3>
<p>Consider:</p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, dept_id, dept_name, dept_location)
</code></pre></div>

<p>Candidate key: {emp_id}</p>
<p>FDs:
- emp_id ‚Üí dept_id, dept_name, dept_location
- dept_id ‚Üí dept_name, dept_location</p>
<p>The dependency emp_id ‚Üí dept_name is transitive through dept_id:
- emp_id ‚Üí dept_id ‚Üí dept_name</p>
<p>This violates 3NF because dept_name depends on dept_id (a non-superkey) and dept_name is not a prime attribute.</p>
<p><strong>Decomposition to achieve 3NF:</strong></p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, dept_id)
    Key: {emp_id}
    FD: emp_id ‚Üí dept_id

Department(dept_id, dept_name, dept_location)
    Key: {dept_id}
    FD: dept_id ‚Üí dept_name, dept_location
</code></pre></div>

<h3 id="44-the-importance-of-prime-attribute-exception">4.4 The Importance of "Prime Attribute" Exception<a class="header-link" href="#44-the-importance-of-prime-attribute-exception" title="Permanent link">&para;</a></h3>
<p>The condition "A is a prime attribute" in 3NF is what distinguishes it from BCNF. This exception allows certain FDs where the dependent is part of a candidate key, even if the determinant is not a superkey. This exception is what makes 3NF decomposition always dependency-preserving (unlike BCNF).</p>
<hr />
<h2 id="5-boyce-codd-normal-form-bcnf">5. Boyce-Codd Normal Form (BCNF)<a class="header-link" href="#5-boyce-codd-normal-form-bcnf" title="Permanent link">&para;</a></h2>
<h3 id="51-definition">5.1 Definition<a class="header-link" href="#51-definition" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: A relation schema R is in <strong>Boyce-Codd Normal Form (BCNF)</strong> if for every non-trivial functional dependency X ‚Üí Y:</p>
<p>X is a superkey of R.</p>
</blockquote>
<p>BCNF is strictly stronger than 3NF. It eliminates the "prime attribute" exception: <strong>every</strong> determinant must be a superkey, period.</p>
<h3 id="52-relationship-3nf-vs-bcnf">5.2 Relationship: 3NF vs BCNF<a class="header-link" href="#52-relationship-3nf-vs-bcnf" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>BCNF ‚äÇ 3NF ‚äÇ 2NF ‚äÇ 1NF

Every BCNF relation is in 3NF.
Every 3NF relation is in 2NF.
Every 2NF relation is in 1NF.

But not vice versa.
</code></pre></div>

<h3 id="53-example-3nf-but-not-bcnf">5.3 Example: 3NF but Not BCNF<a class="header-link" href="#53-example-3nf-but-not-bcnf" title="Permanent link">&para;</a></h3>
<p>Consider:</p>
<div class="highlight"><pre><span></span><code>TeachingAssignment(student_id, course, instructor)
</code></pre></div>

<p>Business rules:
- Each instructor teaches exactly one course: instructor ‚Üí course
- Each student has exactly one instructor per course: {student_id, course} ‚Üí instructor
- A student can have only one instructor for a given course</p>
<p>Candidate keys: {student_id, course} and {student_id, instructor}</p>
<p>FDs:
- {student_id, course} ‚Üí instructor
- {student_id, instructor} ‚Üí course
- instructor ‚Üí course</p>
<p>Check 3NF for instructor ‚Üí course:
- instructor is not a superkey ‚úó
- course is a prime attribute (part of candidate key {student_id, course}) ‚úì</p>
<p>So the relation is in <strong>3NF</strong> (condition 2 of the 3NF definition is satisfied).</p>
<p>Check BCNF for instructor ‚Üí course:
- instructor is not a superkey ‚úó</p>
<p>So the relation is <strong>not in BCNF</strong>.</p>
<h3 id="54-when-3nf-and-bcnf-differ">5.4 When 3NF and BCNF Differ<a class="header-link" href="#54-when-3nf-and-bcnf-differ" title="Permanent link">&para;</a></h3>
<p>3NF and BCNF differ only when:
1. There are multiple overlapping candidate keys, AND
2. A non-superkey attribute determines part of a candidate key</p>
<p>In practice, this situation is relatively rare. Most relations that are in 3NF are also in BCNF.</p>
<hr />
<h2 id="6-decomposition-properties">6. Decomposition Properties<a class="header-link" href="#6-decomposition-properties" title="Permanent link">&para;</a></h2>
<p>When we decompose a relation to achieve a higher normal form, we must ensure the decomposition is "good." Two critical properties define what "good" means.</p>
<h3 id="61-lossless-join-property">6.1 Lossless-Join Property<a class="header-link" href="#61-lossless-join-property" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: A decomposition of R into R‚ÇÅ, R‚ÇÇ, ..., R‚Çô has the <strong>lossless-join property</strong> if for every legal instance r of R:</p>
<p>r = œÄ_{R‚ÇÅ}(r) ‚ãà œÄ_{R‚ÇÇ}(r) ‚ãà ... ‚ãà œÄ_{R‚Çô}(r)</p>
</blockquote>
<p>In other words, we can reconstruct the original relation by naturally joining the decomposed relations. No information is lost.</p>
<h4 id="binary-decomposition-test">Binary Decomposition Test<a class="header-link" href="#binary-decomposition-test" title="Permanent link">&para;</a></h4>
<p>For a decomposition of R into R‚ÇÅ and R‚ÇÇ:</p>
<blockquote>
<p><strong>Theorem</strong>: The decomposition is lossless-join if and only if:</p>
<p>(R‚ÇÅ ‚à© R‚ÇÇ) ‚Üí (R‚ÇÅ - R‚ÇÇ) ‚àà F‚Å∫, or
(R‚ÇÅ ‚à© R‚ÇÇ) ‚Üí (R‚ÇÇ - R‚ÇÅ) ‚àà F‚Å∫</p>
</blockquote>
<p>The common attributes must functionally determine all of one side. Equivalently, the common attributes must be a superkey of at least one of the decomposed relations.</p>
<h4 id="example">Example<a class="header-link" href="#example" title="Permanent link">&para;</a></h4>
<p>Decompose Employee(emp_id, dept_id, dept_name) into:
- R‚ÇÅ(emp_id, dept_id) and R‚ÇÇ(dept_id, dept_name)</p>
<p>Common attributes: {dept_id}
R‚ÇÇ - R‚ÇÅ = {dept_name}</p>
<p>Is dept_id ‚Üí dept_name in F‚Å∫? Yes!</p>
<p>So this decomposition is lossless-join. ‚úì</p>
<h4 id="why-lossless-join-matters">Why Lossless-Join Matters<a class="header-link" href="#why-lossless-join-matters" title="Permanent link">&para;</a></h4>
<p>Without the lossless-join property, joining the decomposed tables produces <strong>spurious tuples</strong> ‚Äî rows that didn't exist in the original relation:</p>
<div class="highlight"><pre><span></span><code>Original:
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |
| 4 | 2 | 5 |

Decompose into R1(A,B) and R2(B,C):
R1:          R2:
| A | B |    | B | C |
|---|---|    |---|---|
| 1 | 2 |    | 2 | 3 |
| 4 | 2 |    | 2 | 5 |

R1 ‚ãà R2:
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |    ‚Üê original ‚úì
| 1 | 2 | 5 |    ‚Üê SPURIOUS! ‚úó
| 4 | 2 | 3 |    ‚Üê SPURIOUS! ‚úó
| 4 | 2 | 5 |    ‚Üê original ‚úì
</code></pre></div>

<p>Here, B does not determine A or C, so the decomposition is lossy (not lossless).</p>
<h3 id="62-dependency-preservation">6.2 Dependency Preservation<a class="header-link" href="#62-dependency-preservation" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>Definition</strong>: A decomposition of R into R‚ÇÅ, R‚ÇÇ, ..., R‚Çô is <strong>dependency-preserving</strong> if:</p>
<p>(F‚ÇÅ ‚à™ F‚ÇÇ ‚à™ ... ‚à™ F‚Çô)‚Å∫ = F‚Å∫</p>
<p>where F·µ¢ is the set of FDs in F‚Å∫ that involve only attributes of R·µ¢.</p>
</blockquote>
<p>In simpler terms: every FD in the original F can be verified by checking constraints within individual decomposed relations, without needing to join tables.</p>
<h4 id="why-dependency-preservation-matters">Why Dependency Preservation Matters<a class="header-link" href="#why-dependency-preservation-matters" title="Permanent link">&para;</a></h4>
<p>If a decomposition is not dependency-preserving, some FDs can only be enforced by joining multiple tables ‚Äî this is expensive and often impractical. Without dependency preservation, the DBMS cannot efficiently maintain data integrity.</p>
<h4 id="example_1">Example<a class="header-link" href="#example_1" title="Permanent link">&para;</a></h4>
<p>R(A, B, C) with F = { A ‚Üí B, B ‚Üí C }</p>
<p>Decompose into R‚ÇÅ(A, C) and R‚ÇÇ(B, C).</p>
<p>FDs on R‚ÇÅ: Can we enforce A ‚Üí B? No ‚Äî B is not in R‚ÇÅ.
FDs on R‚ÇÇ: Can we enforce A ‚Üí B? No ‚Äî A is not in R‚ÇÇ.</p>
<p>The FD A ‚Üí B is <strong>not preserved</strong>. To check it, we'd need to join R‚ÇÅ and R‚ÇÇ.</p>
<p>A better decomposition: R‚ÇÅ(A, B) and R‚ÇÇ(B, C) ‚Äî this preserves both A ‚Üí B and B ‚Üí C.</p>
<h3 id="63-can-we-always-have-both">6.3 Can We Always Have Both?<a class="header-link" href="#63-can-we-always-have-both" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Normal Form</th>
<th style="text-align: center;">Lossless Join</th>
<th style="text-align: center;">Dependency Preservation</th>
</tr>
</thead>
<tbody>
<tr>
<td>3NF</td>
<td style="text-align: center;">Always achievable ‚úì</td>
<td style="text-align: center;">Always achievable ‚úì</td>
</tr>
<tr>
<td>BCNF</td>
<td style="text-align: center;">Always achievable ‚úì</td>
<td style="text-align: center;"><strong>Not always</strong> ‚úó</td>
</tr>
</tbody>
</table>
<p>This is the key tradeoff: BCNF is a stricter normal form, but achieving it may sacrifice dependency preservation. 3NF guarantees both properties.</p>
<hr />
<h2 id="7-the-lossless-join-test-algorithm-for-n-ary-decomposition">7. The Lossless-Join Test Algorithm (For n-ary Decomposition)<a class="header-link" href="#7-the-lossless-join-test-algorithm-for-n-ary-decomposition" title="Permanent link">&para;</a></h2>
<p>For decompositions into more than two relations, we use a tabular algorithm.</p>
<h3 id="71-algorithm-chase-test">7.1 Algorithm (Chase Test)<a class="header-link" href="#71-algorithm-chase-test" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="nl">ALGORITHM</span><span class="p">:</span><span class="w"> </span><span class="n">LosslessJoinTest</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="err">{</span><span class="n">R‚ÇÅ</span><span class="p">,</span><span class="w"> </span><span class="n">R‚ÇÇ</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">R‚Çô</span><span class="err">}</span><span class="p">)</span>
<span class="k">INPUT</span><span class="err">:</span><span class="w">  </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="n">A‚ÇÅ</span><span class="p">,</span><span class="w"> </span><span class="n">A‚ÇÇ</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">A‚Çò</span><span class="err">}</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="n">attributes</span><span class="p">)</span>
<span class="w">        </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">FDs</span>
<span class="w">        </span><span class="err">{</span><span class="n">R‚ÇÅ</span><span class="p">,</span><span class="w"> </span><span class="n">R‚ÇÇ</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">R‚Çô</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">decomposition</span>
<span class="k">OUTPUT</span><span class="err">:</span><span class="w"> </span><span class="k">TRUE</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">lossless</span><span class="o">-</span><span class="k">join</span><span class="p">,</span><span class="w"> </span><span class="k">FALSE</span><span class="w"> </span><span class="n">otherwise</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="k">Create</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="err">√ó</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">matrix</span><span class="p">.</span>
<span class="w">        </span><span class="k">Row</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">corresponds</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">R·µ¢</span><span class="p">,</span><span class="w"> </span><span class="k">column</span><span class="w"> </span><span class="n">j</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">attribute</span><span class="w"> </span><span class="n">A‚±º</span><span class="p">.</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="err">:</span><span class="w"> </span><span class="k">Initialize</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="nl">matrix</span><span class="p">:</span>
<span class="w">        </span><span class="k">If</span><span class="w"> </span><span class="n">A‚±º</span><span class="w"> </span><span class="err">‚àà</span><span class="w"> </span><span class="n">R·µ¢</span><span class="p">,</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">entry</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a‚±º</span><span class="w"> </span><span class="p">(</span><span class="n">distinguished</span><span class="w"> </span><span class="n">symbol</span><span class="p">)</span>
<span class="w">        </span><span class="n">Otherwise</span><span class="p">,</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="n">entry</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b·µ¢‚±º</span><span class="w"> </span><span class="p">(</span><span class="n">subscripted</span><span class="w"> </span><span class="n">symbol</span><span class="p">)</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="err">:</span><span class="w"> </span><span class="n">REPEAT</span>
<span class="w">            </span><span class="k">FOR</span><span class="w"> </span><span class="k">EACH</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Y</span><span class="p">)</span><span class="w"> </span><span class="ow">IN</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">DO</span>
<span class="w">                </span><span class="n">Find</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="k">rows</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">agree</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="n">columns</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">X</span>
<span class="w">                </span><span class="k">For</span><span class="w"> </span><span class="n">those</span><span class="w"> </span><span class="k">rows</span><span class="p">,</span><span class="w"> </span><span class="n">make</span><span class="w"> </span><span class="n">their</span><span class="w"> </span><span class="n">Y</span><span class="o">-</span><span class="n">columns</span><span class="w"> </span><span class="nl">equal</span><span class="p">:</span>
<span class="w">                    </span><span class="k">If</span><span class="w"> </span><span class="ow">any</span><span class="w"> </span><span class="k">row</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">a‚±º</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="ow">some</span><span class="w"> </span><span class="k">column</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">Y</span><span class="p">,</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="k">rows</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">a‚±º</span>
<span class="w">                    </span><span class="n">Otherwise</span><span class="p">,</span><span class="w"> </span><span class="n">pick</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">b·µ¢‚±º</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="k">set</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="k">rows</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="k">value</span>
<span class="w">            </span><span class="k">END</span><span class="w"> </span><span class="k">FOR</span>
<span class="w">        </span><span class="n">UNTIL</span><span class="w"> </span><span class="k">no</span><span class="w"> </span><span class="n">change</span><span class="w"> </span><span class="n">occurs</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="err">:</span><span class="w"> </span><span class="k">If</span><span class="w"> </span><span class="ow">any</span><span class="w"> </span><span class="k">row</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="n">distinguished</span><span class="w"> </span><span class="n">symbols</span><span class="w"> </span><span class="p">(</span><span class="n">a‚ÇÅ</span><span class="p">,</span><span class="w"> </span><span class="n">a‚ÇÇ</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">a‚Çò</span><span class="p">),</span><span class="w"> </span><span class="k">RETURN</span><span class="w"> </span><span class="k">TRUE</span><span class="p">.</span>
<span class="w">        </span><span class="n">Otherwise</span><span class="p">,</span><span class="w"> </span><span class="k">RETURN</span><span class="w"> </span><span class="k">FALSE</span><span class="p">.</span>
</code></pre></div>

<h3 id="72-worked-example">7.2 Worked Example<a class="header-link" href="#72-worked-example" title="Permanent link">&para;</a></h3>
<p>R(A, B, C, D, E), F = { A ‚Üí C, B ‚Üí C, C ‚Üí D, DE ‚Üí C, CE ‚Üí A }</p>
<p>Decomposition: R‚ÇÅ(A, D), R‚ÇÇ(A, B), R‚ÇÉ(B, E), R‚ÇÑ(C, D, E), R‚ÇÖ(A, E)</p>
<p><strong>Step 1-2: Initial matrix</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>R‚ÇÅ</td>
<td>a‚ÇÅ</td>
<td>b‚ÇÅ‚ÇÇ</td>
<td>b‚ÇÅ‚ÇÉ</td>
<td>a‚ÇÑ</td>
<td>b‚ÇÅ‚ÇÖ</td>
</tr>
<tr>
<td>R‚ÇÇ</td>
<td>a‚ÇÅ</td>
<td>a‚ÇÇ</td>
<td>b‚ÇÇ‚ÇÉ</td>
<td>b‚ÇÇ‚ÇÑ</td>
<td>b‚ÇÇ‚ÇÖ</td>
</tr>
<tr>
<td>R‚ÇÉ</td>
<td>b‚ÇÉ‚ÇÅ</td>
<td>a‚ÇÇ</td>
<td>b‚ÇÉ‚ÇÉ</td>
<td>b‚ÇÉ‚ÇÑ</td>
<td>a‚ÇÖ</td>
</tr>
<tr>
<td>R‚ÇÑ</td>
<td>b‚ÇÑ‚ÇÅ</td>
<td>b‚ÇÑ‚ÇÇ</td>
<td>a‚ÇÉ</td>
<td>a‚ÇÑ</td>
<td>a‚ÇÖ</td>
</tr>
<tr>
<td>R‚ÇÖ</td>
<td>a‚ÇÅ</td>
<td>b‚ÇÖ‚ÇÇ</td>
<td>b‚ÇÖ‚ÇÉ</td>
<td>b‚ÇÖ‚ÇÑ</td>
<td>a‚ÇÖ</td>
</tr>
</tbody>
</table>
<p><strong>Step 3: Apply FDs iteratively</strong></p>
<p>Apply A ‚Üí C: Rows with same A value.
- Rows R‚ÇÅ, R‚ÇÇ, R‚ÇÖ have A = a‚ÇÅ. Make their C columns equal.
  - R‚ÇÅ: b‚ÇÅ‚ÇÉ, R‚ÇÇ: b‚ÇÇ‚ÇÉ, R‚ÇÖ: b‚ÇÖ‚ÇÉ. No distinguished symbol. Pick b‚ÇÅ‚ÇÉ for all.
  - R‚ÇÅ: b‚ÇÅ‚ÇÉ, R‚ÇÇ: b‚ÇÅ‚ÇÉ, R‚ÇÖ: b‚ÇÅ‚ÇÉ</p>
<p>Apply B ‚Üí C: Rows R‚ÇÇ, R‚ÇÉ have B = a‚ÇÇ.
- R‚ÇÇ: b‚ÇÅ‚ÇÉ, R‚ÇÉ: b‚ÇÉ‚ÇÉ. Pick b‚ÇÅ‚ÇÉ.
- R‚ÇÉ: b‚ÇÅ‚ÇÉ</p>
<p>Apply C ‚Üí D: Rows with same C value.
- Rows R‚ÇÅ, R‚ÇÇ, R‚ÇÉ, R‚ÇÖ all have C = b‚ÇÅ‚ÇÉ. R‚ÇÑ has C = a‚ÇÉ (different).
  - R‚ÇÅ: a‚ÇÑ, R‚ÇÇ: b‚ÇÇ‚ÇÑ, R‚ÇÉ: b‚ÇÉ‚ÇÑ, R‚ÇÖ: b‚ÇÖ‚ÇÑ. R‚ÇÅ has distinguished a‚ÇÑ. Set all to a‚ÇÑ.
  - R‚ÇÇ: a‚ÇÑ, R‚ÇÉ: a‚ÇÑ, R‚ÇÖ: a‚ÇÑ</p>
<p>Apply DE ‚Üí C: Rows with same D and E values.
- R‚ÇÉ: D=a‚ÇÑ, E=a‚ÇÖ; R‚ÇÑ: D=a‚ÇÑ, E=a‚ÇÖ; R‚ÇÖ: D=a‚ÇÑ, E=a‚ÇÖ.
  - These rows agree on DE. Make C equal: R‚ÇÉ: b‚ÇÅ‚ÇÉ, R‚ÇÑ: a‚ÇÉ, R‚ÇÖ: b‚ÇÅ‚ÇÉ. R‚ÇÑ has a‚ÇÉ. Set all to a‚ÇÉ.
  - R‚ÇÉ: a‚ÇÉ, R‚ÇÖ: a‚ÇÉ.</p>
<p>Apply CE ‚Üí A: Rows with same C and E.
- R‚ÇÉ: C=a‚ÇÉ, E=a‚ÇÖ; R‚ÇÑ: C=a‚ÇÉ, E=a‚ÇÖ; R‚ÇÖ: C=a‚ÇÉ, E=a‚ÇÖ.
  - R‚ÇÖ has A=a‚ÇÅ (distinguished). Set R‚ÇÉ: a‚ÇÅ, R‚ÇÑ: a‚ÇÅ.</p>
<p>Now re-apply A ‚Üí C: Rows R‚ÇÅ,R‚ÇÇ,R‚ÇÉ,R‚ÇÑ,R‚ÇÖ have A=a‚ÇÅ.
- C values: R‚ÇÅ=b‚ÇÅ‚ÇÉ, R‚ÇÇ=b‚ÇÅ‚ÇÉ, R‚ÇÉ=a‚ÇÉ, R‚ÇÑ=a‚ÇÉ, R‚ÇÖ=a‚ÇÉ. Has a‚ÇÉ. Set all to a‚ÇÉ.
- R‚ÇÅ=a‚ÇÉ, R‚ÇÇ=a‚ÇÉ.</p>
<p>Re-apply C ‚Üí D on all rows (now all C=a‚ÇÉ): already all D=a‚ÇÑ. No change.</p>
<p>Check row R‚ÇÖ: A=a‚ÇÅ, B=b‚ÇÖ‚ÇÇ, C=a‚ÇÉ, D=a‚ÇÑ, E=a‚ÇÖ. Still has b‚ÇÖ‚ÇÇ for B.</p>
<p>Apply B ‚Üí C: R‚ÇÇ has B=a‚ÇÇ, R‚ÇÉ has B=a‚ÇÇ. Both already C=a‚ÇÉ. No change.</p>
<p>Check: Row R‚ÇÉ = (a‚ÇÅ, a‚ÇÇ, a‚ÇÉ, a‚ÇÑ, a‚ÇÖ) ‚Äî <strong>all distinguished symbols!</strong></p>
<p><strong>Result: The decomposition is lossless-join. ‚úì</strong></p>
<hr />
<h2 id="8-3nf-synthesis-algorithm">8. 3NF Synthesis Algorithm<a class="header-link" href="#8-3nf-synthesis-algorithm" title="Permanent link">&para;</a></h2>
<p>The 3NF synthesis algorithm produces a decomposition that is both <strong>lossless-join</strong> and <strong>dependency-preserving</strong>.</p>
<h3 id="81-algorithm">8.1 Algorithm<a class="header-link" href="#81-algorithm" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="n">NF_Synthesis</span><span class="o">(</span><span class="n">R</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="o">)</span>
<span class="n">INPUT</span><span class="o">:</span><span class="w">  </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">relation</span><span class="w"> </span><span class="n">schema</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">FDs</span>
<span class="n">OUTPUT</span><span class="o">:</span><span class="w"> </span><span class="n">Decomposition</span><span class="w"> </span><span class="o">{</span><span class="n">R‚ÇÅ</span><span class="o">,</span><span class="w"> </span><span class="n">R‚ÇÇ</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">R‚Çô</span><span class="o">}</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">3</span><span class="n">NF</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">lossless</span><span class="w"> </span><span class="n">join</span>
<span class="w">        </span><span class="n">and</span><span class="w"> </span><span class="n">dependency</span><span class="w"> </span><span class="n">preservation</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">Compute</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">minimal</span><span class="w"> </span><span class="n">cover</span><span class="w"> </span><span class="n">F_min</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">F</span><span class="o">.</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n">For</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">F_min</span><span class="o">:</span>
<span class="w">            </span><span class="n">Create</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">relation</span><span class="w"> </span><span class="n">schema</span><span class="w"> </span><span class="n">R·µ¢</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">‚à™</span><span class="w"> </span><span class="o">{</span><span class="n">A</span><span class="o">}</span>
<span class="w">        </span><span class="n">Group</span><span class="w"> </span><span class="n">FDs</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">LHS</span><span class="o">:</span>
<span class="w">            </span><span class="n">If</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">A‚ÇÅ</span><span class="o">,</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">A‚ÇÇ</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">A‚Çñ</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">have</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">same</span><span class="w"> </span><span class="n">X</span><span class="o">,</span>
<span class="w">            </span><span class="n">create</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="n">schema</span><span class="w"> </span><span class="n">R·µ¢</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">‚à™</span><span class="w"> </span><span class="o">{</span><span class="n">A‚ÇÅ</span><span class="o">,</span><span class="w"> </span><span class="n">A‚ÇÇ</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">A‚Çñ</span><span class="o">}</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w"> </span><span class="n">If</span><span class="w"> </span><span class="n">none</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">schemas</span><span class="w"> </span><span class="n">contains</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">R</span><span class="o">,</span>
<span class="w">        </span><span class="n">add</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">schema</span><span class="w"> </span><span class="n">R‚Çñ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="n">candidate</span><span class="w"> </span><span class="n">key</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">R</span><span class="o">.</span>

<span class="n">Step</span><span class="w"> </span><span class="mi">4</span><span class="o">:</span><span class="w"> </span><span class="n">Remove</span><span class="w"> </span><span class="n">any</span><span class="w"> </span><span class="n">schema</span><span class="w"> </span><span class="n">R·µ¢</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">subset</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">another</span><span class="w"> </span><span class="n">schema</span><span class="w"> </span><span class="n">R‚±º</span><span class="o">.</span>

<span class="n">RETURN</span><span class="w"> </span><span class="o">{</span><span class="n">R‚ÇÅ</span><span class="o">,</span><span class="w"> </span><span class="n">R‚ÇÇ</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">R‚Çô</span><span class="o">}</span>
</code></pre></div>

<h3 id="82-why-each-step-matters">8.2 Why Each Step Matters<a class="header-link" href="#82-why-each-step-matters" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Step 1</strong> (minimal cover): Ensures no redundant FDs generate extra tables</li>
<li><strong>Step 2</strong> (one table per LHS group): Directly preserves each FD</li>
<li><strong>Step 3</strong> (add key if needed): Guarantees lossless-join property</li>
<li><strong>Step 4</strong> (remove subsets): Eliminates redundant tables</li>
</ul>
<h3 id="83-worked-example">8.3 Worked Example<a class="header-link" href="#83-worked-example" title="Permanent link">&para;</a></h3>
<p>R(A, B, C, D, E, H) with:</p>
<div class="highlight"><pre><span></span><code>F = { A ‚Üí BC,  E ‚Üí HA,  B ‚Üí D }
</code></pre></div>

<p><strong>Step 1: Compute minimal cover</strong></p>
<p>Decompose RHS:</p>
<div class="highlight"><pre><span></span><code>F = { A ‚Üí B, A ‚Üí C, E ‚Üí H, E ‚Üí A, B ‚Üí D }
</code></pre></div>

<p>Check extraneous LHS: All LHS are single attributes. Nothing to simplify.</p>
<p>Check redundant FDs:
- A ‚Üí B: Remove. {A}‚Å∫ under rest = {A, C} ‚à™ ... = {A, C}. B ‚àâ {A}‚Å∫. Keep.
- A ‚Üí C: Remove. {A}‚Å∫ under rest = {A, B, D} (via A‚ÜíB, B‚ÜíD). C ‚àâ {A}‚Å∫. Keep.
- E ‚Üí H: Remove. {E}‚Å∫ under rest = {E, A, B, C, D} (E‚ÜíA, A‚ÜíB, A‚ÜíC, B‚ÜíD). H ‚àâ {E}‚Å∫. Keep.
- E ‚Üí A: Remove. {E}‚Å∫ under rest = {E, H}. A ‚àâ {E}‚Å∫. Keep.
- B ‚Üí D: Remove. {B}‚Å∫ under rest = {B}. D ‚àâ {B}‚Å∫. Keep.</p>
<p>Minimal cover:</p>
<div class="highlight"><pre><span></span><code>F_min = { A ‚Üí B, A ‚Üí C, E ‚Üí H, E ‚Üí A, B ‚Üí D }
</code></pre></div>

<p><strong>Step 2: Group by LHS and create schemas</strong></p>
<table>
<thead>
<tr>
<th>LHS</th>
<th>FDs</th>
<th>Schema</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>A ‚Üí B, A ‚Üí C</td>
<td>R‚ÇÅ(A, B, C)</td>
</tr>
<tr>
<td>E</td>
<td>E ‚Üí H, E ‚Üí A</td>
<td>R‚ÇÇ(E, H, A)</td>
</tr>
<tr>
<td>B</td>
<td>B ‚Üí D</td>
<td>R‚ÇÉ(B, D)</td>
</tr>
</tbody>
</table>
<p><strong>Step 3: Check for candidate key</strong></p>
<p>Compute {E}‚Å∫ = {E, H, A, B, C, D} = all attributes. So {E} is a candidate key.</p>
<p>Is E in any schema? R‚ÇÇ contains E. R‚ÇÇ's key is E. ‚úì (A candidate key is present.)</p>
<p><strong>Step 4: Remove subset schemas</strong></p>
<p>None is a subset of another.</p>
<p><strong>Final decomposition:</strong></p>
<div class="highlight"><pre><span></span><code>R‚ÇÅ(A, B, C)    ‚Äî key: {A}
R‚ÇÇ(E, H, A)    ‚Äî key: {E}
R‚ÇÉ(B, D)       ‚Äî key: {B}
</code></pre></div>

<p>All in 3NF ‚úì, lossless-join ‚úì, dependency-preserving ‚úì.</p>
<hr />
<h2 id="9-bcnf-decomposition-algorithm">9. BCNF Decomposition Algorithm<a class="header-link" href="#9-bcnf-decomposition-algorithm" title="Permanent link">&para;</a></h2>
<h3 id="91-algorithm">9.1 Algorithm<a class="header-link" href="#91-algorithm" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">BCNF_Decomposition</span><span class="o">(</span><span class="n">R</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="o">)</span>
<span class="n">INPUT</span><span class="o">:</span><span class="w">  </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">relation</span><span class="w"> </span><span class="n">schema</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kd">set</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">FDs</span>
<span class="n">OUTPUT</span><span class="o">:</span><span class="w"> </span><span class="n">Decomposition</span><span class="w"> </span><span class="n">into</span><span class="w"> </span><span class="n">BCNF</span><span class="w"> </span><span class="n">relations</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">lossless</span><span class="w"> </span><span class="n">join</span>

<span class="n">result</span><span class="w"> </span><span class="err">‚Üê</span><span class="w"> </span><span class="o">{</span><span class="n">R</span><span class="o">}</span>

<span class="n">WHILE</span><span class="w"> </span><span class="n">there</span><span class="w"> </span><span class="n">exists</span><span class="w"> </span><span class="n">R·µ¢</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">BCNF</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">Find</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">violates</span><span class="w"> </span><span class="n">BCNF</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">R·µ¢</span>
<span class="w">    </span><span class="o">(</span><span class="n">i</span><span class="o">.</span><span class="na">e</span><span class="o">.,</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">superkey</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">R·µ¢</span><span class="o">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="err">‚äÑ</span><span class="w"> </span><span class="n">X</span><span class="o">)</span>

<span class="w">    </span><span class="n">Compute</span><span class="w"> </span><span class="n">X</span><span class="err">‚Å∫</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">respect</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">F</span>

<span class="w">    </span><span class="n">Replace</span><span class="w"> </span><span class="n">R·µ¢</span><span class="w"> </span><span class="k">with</span><span class="o">:</span>
<span class="w">        </span><span class="n">R‚ÇÅ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="err">‚Å∫</span><span class="w"> </span><span class="err">‚à©</span><span class="w"> </span><span class="n">attributes</span><span class="o">(</span><span class="n">R·µ¢</span><span class="o">)</span><span class="w">    </span><span class="o">(</span><span class="n">everything</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="n">determines</span><span class="w"> </span><span class="n">within</span><span class="w"> </span><span class="n">R·µ¢</span><span class="o">)</span>
<span class="w">        </span><span class="n">R‚ÇÇ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">‚à™</span><span class="w"> </span><span class="o">(</span><span class="n">attributes</span><span class="o">(</span><span class="n">R·µ¢</span><span class="o">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X</span><span class="err">‚Å∫</span><span class="o">)</span><span class="w">   </span><span class="o">(</span><span class="n">X</span><span class="w"> </span><span class="n">plus</span><span class="w"> </span><span class="n">what</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="n">doesn</span><span class="err">&#39;</span><span class="n">t</span><span class="w"> </span><span class="n">determine</span><span class="o">)</span>
<span class="n">END</span><span class="w"> </span><span class="n">WHILE</span>

<span class="n">RETURN</span><span class="w"> </span><span class="n">result</span>
</code></pre></div>

<p>The key decomposition step splits R·µ¢ into:
- R‚ÇÅ: all attributes that X determines (within R·µ¢) ‚Äî X is a key of R‚ÇÅ
- R‚ÇÇ: X plus the remaining attributes ‚Äî X is a foreign key back to R‚ÇÅ</p>
<p>This guarantees lossless join (R‚ÇÅ ‚à© R‚ÇÇ = X, and X ‚Üí R‚ÇÅ).</p>
<h3 id="92-worked-example">9.2 Worked Example<a class="header-link" href="#92-worked-example" title="Permanent link">&para;</a></h3>
<p>R(A, B, C, D) with F = { AB ‚Üí C, C ‚Üí B, AB ‚Üí D }</p>
<p><strong>Step 1: Is R in BCNF?</strong></p>
<p>Candidate key: {A, B} ({A,B}‚Å∫ = {A,B,C,D}).
Also {A, C} is a candidate key ({A,C}‚Å∫: C‚ÜíB gives {A,B,C}, AB‚ÜíD gives {A,B,C,D}).</p>
<p>Check FDs:
- AB ‚Üí C: {A,B} is a superkey. ‚úì
- C ‚Üí B: {C}‚Å∫ = {C, B}. C is not a superkey. <strong>BCNF violation!</strong>
- AB ‚Üí D: {A,B} is a superkey. ‚úì</p>
<p><strong>Step 2: Decompose on C ‚Üí B</strong></p>
<p>Compute {C}‚Å∫ ‚à© {A,B,C,D} = {B, C} ‚à© {A,B,C,D} = {B, C}</p>
<ul>
<li>R‚ÇÅ = {B, C} with FD: C ‚Üí B (key: C)</li>
<li>R‚ÇÇ = {C} ‚à™ ({A,B,C,D} - {B,C}) = {A, C, D}</li>
</ul>
<p>Project FDs onto R‚ÇÇ(A, C, D):
- AB ‚Üí C becomes irrelevant (B ‚àâ R‚ÇÇ)
- C ‚Üí B becomes irrelevant (B ‚àâ R‚ÇÇ)
- AB ‚Üí D becomes... need to check: under projected FDs, {A,C}‚Å∫ on R‚ÇÇ. C‚ÜíB is not in R‚ÇÇ. But from original: AC ‚Üí D? {A,C}‚Å∫ = {A,C,B,D} (C‚ÜíB, AB‚ÜíD). So AC ‚Üí D holds. Key of R‚ÇÇ is {A, C}.
- Check: is AC a superkey of R‚ÇÇ? {A,C}‚Å∫ restricted to R‚ÇÇ = {A,C,D}. Yes. ‚úì</p>
<p><strong>Step 3: Check R‚ÇÅ and R‚ÇÇ</strong></p>
<ul>
<li>R‚ÇÅ(B, C), FD: C ‚Üí B. Key: {C}. C is a superkey. BCNF ‚úì</li>
<li>R‚ÇÇ(A, C, D), FD: AC ‚Üí D. Key: {A, C}. AC is a superkey. BCNF ‚úì</li>
</ul>
<p><strong>Final BCNF decomposition:</strong></p>
<div class="highlight"><pre><span></span><code>R‚ÇÅ(B, C)      ‚Äî key: {C}
R‚ÇÇ(A, C, D)   ‚Äî key: {A, C}
</code></pre></div>

<p><strong>Check dependency preservation:</strong>
- AB ‚Üí C: cannot be checked from R‚ÇÅ or R‚ÇÇ alone (A and B are never in the same table). <strong>Not preserved!</strong>
- C ‚Üí B: in R‚ÇÅ. ‚úì
- AB ‚Üí D: not directly preserved, but AC ‚Üí D is in R‚ÇÇ.</p>
<p>This illustrates the BCNF tradeoff: we achieved BCNF but lost the FD AB ‚Üí C.</p>
<h3 id="93-bcnf-vs-3nf-the-tradeoff">9.3 BCNF vs 3NF: The Tradeoff<a class="header-link" href="#93-bcnf-vs-3nf-the-tradeoff" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Property</th>
<th style="text-align: center;">3NF Synthesis</th>
<th style="text-align: center;">BCNF Decomposition</th>
</tr>
</thead>
<tbody>
<tr>
<td>Lossless Join</td>
<td style="text-align: center;">‚úì Always</td>
<td style="text-align: center;">‚úì Always</td>
</tr>
<tr>
<td>Dependency Preservation</td>
<td style="text-align: center;">‚úì Always</td>
<td style="text-align: center;">‚úó Not always</td>
</tr>
<tr>
<td>Redundancy Elimination</td>
<td style="text-align: center;">Good (minimal)</td>
<td style="text-align: center;">Best (none from FDs)</td>
</tr>
<tr>
<td>When to prefer</td>
<td style="text-align: center;">When dependency preservation is critical</td>
<td style="text-align: center;">When minimal redundancy is critical</td>
</tr>
</tbody>
</table>
<p><strong>Practical guidance</strong>:
- Start with BCNF decomposition
- If dependency preservation fails, fall back to 3NF
- In practice, most schemas achieve BCNF without losing dependencies</p>
<hr />
<h2 id="10-complete-worked-example-unnormalized-to-bcnf">10. Complete Worked Example: Unnormalized to BCNF<a class="header-link" href="#10-complete-worked-example-unnormalized-to-bcnf" title="Permanent link">&para;</a></h2>
<h3 id="101-scenario">10.1 Scenario<a class="header-link" href="#101-scenario" title="Permanent link">&para;</a></h3>
<p>A company tracks project assignments:</p>
<div class="highlight"><pre><span></span><code>ProjectAssignment(
    emp_id, emp_name, emp_phone,
    dept_id, dept_name, dept_budget,
    proj_id, proj_name, proj_budget,
    hours_worked, role
)
</code></pre></div>

<p><strong>Business rules (FDs):</strong></p>
<div class="highlight"><pre><span></span><code>F = {
    emp_id ‚Üí emp_name, emp_phone, dept_id,
    dept_id ‚Üí dept_name, dept_budget,
    proj_id ‚Üí proj_name, proj_budget,
    {emp_id, proj_id} ‚Üí hours_worked, role
}
</code></pre></div>

<p><strong>Candidate key</strong>: {emp_id, proj_id}</p>
<h3 id="102-check-1nf">10.2 Check 1NF<a class="header-link" href="#102-check-1nf" title="Permanent link">&para;</a></h3>
<p>All values are atomic (single values, no arrays). ‚úì In 1NF.</p>
<h3 id="103-check-2nf">10.3 Check 2NF<a class="header-link" href="#103-check-2nf" title="Permanent link">&para;</a></h3>
<p>Non-prime attributes: emp_name, emp_phone, dept_id, dept_name, dept_budget, proj_name, proj_budget, hours_worked, role.</p>
<p>Partial dependencies (attribute depends on proper subset of key {emp_id, proj_id}):
- emp_id ‚Üí emp_name, emp_phone, dept_id (partial: depends on emp_id alone)
- proj_id ‚Üí proj_name, proj_budget (partial: depends on proj_id alone)</p>
<p><strong>Not in 2NF.</strong> Decompose:</p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, emp_name, emp_phone, dept_id)
    FDs: emp_id ‚Üí emp_name, emp_phone, dept_id

Project(proj_id, proj_name, proj_budget)
    FDs: proj_id ‚Üí proj_name, proj_budget

Assignment(emp_id, proj_id, hours_worked, role)
    FDs: {emp_id, proj_id} ‚Üí hours_worked, role
</code></pre></div>

<p>Now in 2NF. ‚úì</p>
<h3 id="104-check-3nf">10.4 Check 3NF<a class="header-link" href="#104-check-3nf" title="Permanent link">&para;</a></h3>
<p><strong>Employee(emp_id, emp_name, emp_phone, dept_id)</strong></p>
<p>Key: {emp_id}</p>
<p>Are there transitive dependencies?
- emp_id ‚Üí dept_id (direct) ‚úì
- But where are dept_name, dept_budget? They were removed ‚Äî but wait, we also have dept_id ‚Üí dept_name, dept_budget from the original FDs. Since dept_name and dept_budget are not in this relation anymore, no transitive dependency exists within this relation.</p>
<p>Actually, let's reconsider. The original FD dept_id ‚Üí dept_name, dept_budget means Employee should not contain dept_name or dept_budget. And it doesn't ‚Äî they went with the decomposition in step 2. But we need a Department table:</p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, emp_name, emp_phone, dept_id)
</code></pre></div>

<p>Is there any transitive dependency among the remaining attributes? emp_id ‚Üí emp_name, emp_phone, dept_id. All are direct dependencies from the key. No non-prime attribute determines another non-prime attribute within this table (emp_phone doesn't determine dept_id, etc.).</p>
<p>In 3NF ‚úì.</p>
<p>But the FD dept_id ‚Üí dept_name, dept_budget from the original schema is "orphaned." We need a Department table:</p>
<div class="highlight"><pre><span></span><code>Department(dept_id, dept_name, dept_budget)
    Key: {dept_id}
</code></pre></div>

<p><strong>All relations now in 3NF:</strong></p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, emp_name, emp_phone, dept_id)    ‚Äî key: {emp_id}
Department(dept_id, dept_name, dept_budget)         ‚Äî key: {dept_id}
Project(proj_id, proj_name, proj_budget)           ‚Äî key: {proj_id}
Assignment(emp_id, proj_id, hours_worked, role)     ‚Äî key: {emp_id, proj_id}
</code></pre></div>

<h3 id="105-check-bcnf">10.5 Check BCNF<a class="header-link" href="#105-check-bcnf" title="Permanent link">&para;</a></h3>
<p>For each relation, check: is every determinant a superkey?</p>
<ul>
<li><strong>Employee</strong>: emp_id ‚Üí (emp_name, emp_phone, dept_id). emp_id is the key. ‚úì</li>
<li><strong>Department</strong>: dept_id ‚Üí (dept_name, dept_budget). dept_id is the key. ‚úì</li>
<li><strong>Project</strong>: proj_id ‚Üí (proj_name, proj_budget). proj_id is the key. ‚úì</li>
<li><strong>Assignment</strong>: {emp_id, proj_id} ‚Üí (hours_worked, role). {emp_id, proj_id} is the key. ‚úì</li>
</ul>
<p><strong>All in BCNF!</strong> ‚úì</p>
<h3 id="106-summary-of-decomposition">10.6 Summary of Decomposition<a class="header-link" href="#106-summary-of-decomposition" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>ORIGINAL (unnormalized):
    ProjectAssignment(emp_id, emp_name, emp_phone, dept_id, dept_name,
                      dept_budget, proj_id, proj_name, proj_budget,
                      hours_worked, role)

FINAL (BCNF):
    Employee(emp_id, emp_name, emp_phone, dept_id)
    Department(dept_id, dept_name, dept_budget)
    Project(proj_id, proj_name, proj_budget)
    Assignment(emp_id, proj_id, hours_worked, role)
</code></pre></div>

<p>Anomalies eliminated:
- <strong>Update</strong>: Changing a department name requires updating only one row in Department
- <strong>Insert</strong>: Can add a department without any employees
- <strong>Delete</strong>: Removing all assignments for a project doesn't lose project information</p>
<hr />
<h2 id="11-normalization-in-sql">11. Normalization in SQL<a class="header-link" href="#11-normalization-in-sql" title="Permanent link">&para;</a></h2>
<h3 id="111-implementing-the-normalized-schema">11.1 Implementing the Normalized Schema<a class="header-link" href="#111-implementing-the-normalized-schema" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">Department</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">dept_id</span><span class="w">     </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">dept_name</span><span class="w">   </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">dept_budget</span><span class="w"> </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span>
<span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">Employee</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">emp_id</span><span class="w">    </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">emp_name</span><span class="w">  </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">emp_phone</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
<span class="w">    </span><span class="n">dept_id</span><span class="w">   </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">dept_id</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">Department</span><span class="p">(</span><span class="n">dept_id</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">Project</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">proj_id</span><span class="w">     </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">proj_name</span><span class="w">   </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">proj_budget</span><span class="w"> </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span>
<span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">Assignment</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">emp_id</span><span class="w">       </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">proj_id</span><span class="w">      </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">hours_worked</span><span class="w"> </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="k">role</span><span class="w">         </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">emp_id</span><span class="p">,</span><span class="w"> </span><span class="n">proj_id</span><span class="p">),</span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">emp_id</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">Employee</span><span class="p">(</span><span class="n">emp_id</span><span class="p">),</span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">proj_id</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">Project</span><span class="p">(</span><span class="n">proj_id</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>

<h3 id="112-verifying-normalization-via-queries">11.2 Verifying Normalization via Queries<a class="header-link" href="#112-verifying-normalization-via-queries" title="Permanent link">&para;</a></h3>
<p>To check for potential normalization issues in an existing database:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- Check for potential 2NF violations: partial dependencies</span>
<span class="c1">-- If a non-key column has duplicate values correlated with part of a composite key</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">emp_id</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">emp_name</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name_count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">project_assignment_denormalized</span>
<span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">emp_id</span>
<span class="k">HAVING</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">emp_name</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="c1">-- If this returns rows, emp_name is inconsistently stored (update anomaly)</span>

<span class="c1">-- Check for potential 3NF violations: transitive dependencies</span>
<span class="c1">-- Columns that move together might indicate a missing entity</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">dept_id</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">dept_name</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">names</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">employee_denormalized</span>
<span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">dept_id</span>
<span class="k">HAVING</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">dept_name</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="c1">-- If this returns rows, dept_name is inconsistent for a given dept_id</span>
</code></pre></div>

<hr />
<h2 id="12-summary-of-normal-forms">12. Summary of Normal Forms<a class="header-link" href="#12-summary-of-normal-forms" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Normal Form</th>
<th>Condition</th>
<th>Eliminates</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1NF</strong></td>
<td>Atomic values, no repeating groups</td>
<td>Non-relational structures</td>
</tr>
<tr>
<td><strong>2NF</strong></td>
<td>1NF + no partial dependencies</td>
<td>Redundancy from partial key dependencies</td>
</tr>
<tr>
<td><strong>3NF</strong></td>
<td>2NF + no transitive dependencies</td>
<td>Redundancy from transitive dependencies</td>
</tr>
<tr>
<td><strong>BCNF</strong></td>
<td>Every determinant is a superkey</td>
<td>All FD-based redundancy</td>
</tr>
</tbody>
</table>
<h3 id="decision-flowchart">Decision Flowchart<a class="header-link" href="#decision-flowchart" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">Start</span><span class="o">:</span><span class="w"> </span><span class="n">Relation</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">FDs</span><span class="w"> </span><span class="n">F</span>

<span class="n">Is</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">1</span><span class="n">NF</span><span class="o">?</span>
<span class="err">‚îú‚îÄ‚îÄ</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Remove</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">atomic</span><span class="w"> </span><span class="n">values</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">repeating</span><span class="w"> </span><span class="n">groups</span>
<span class="err">‚îî‚îÄ‚îÄ</span><span class="w"> </span><span class="n">Yes</span><span class="w"> </span><span class="err">‚Üì</span>

<span class="n">Is</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">2</span><span class="n">NF</span><span class="o">?</span>
<span class="err">‚îú‚îÄ‚îÄ</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Remove</span><span class="w"> </span><span class="n">partial</span><span class="w"> </span><span class="n">dependencies</span><span class="w"> </span><span class="o">(</span><span class="n">separate</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="n">attributes</span>
<span class="err">‚îÇ</span><span class="w">         </span><span class="n">that</span><span class="w"> </span><span class="n">depend</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">part</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">key</span><span class="o">)</span>
<span class="err">‚îî‚îÄ‚îÄ</span><span class="w"> </span><span class="n">Yes</span><span class="w"> </span><span class="err">‚Üì</span>

<span class="n">Is</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">3</span><span class="n">NF</span><span class="o">?</span>
<span class="err">‚îú‚îÄ‚îÄ</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Remove</span><span class="w"> </span><span class="n">transitive</span><span class="w"> </span><span class="n">dependencies</span><span class="w"> </span><span class="o">(</span><span class="n">separate</span><span class="w"> </span><span class="n">out</span><span class="w"> </span><span class="n">attributes</span>
<span class="err">‚îÇ</span><span class="w">         </span><span class="n">that</span><span class="w"> </span><span class="n">depend</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">key</span><span class="w"> </span><span class="n">attributes</span><span class="o">)</span>
<span class="err">‚îî‚îÄ‚îÄ</span><span class="w"> </span><span class="n">Yes</span><span class="w"> </span><span class="err">‚Üì</span>

<span class="n">Is</span><span class="w"> </span><span class="n">R</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">BCNF</span><span class="o">?</span>
<span class="err">‚îú‚îÄ‚îÄ</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Check</span><span class="o">:</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">dependency</span><span class="w"> </span><span class="n">preservation</span><span class="w"> </span><span class="n">acceptable</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">lose</span><span class="o">?</span>
<span class="err">‚îÇ</span><span class="w">   </span><span class="err">‚îú‚îÄ‚îÄ</span><span class="w"> </span><span class="n">Yes</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Decompose</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">BCNF</span><span class="w"> </span><span class="n">algorithm</span>
<span class="err">‚îÇ</span><span class="w">   </span><span class="err">‚îî‚îÄ‚îÄ</span><span class="w"> </span><span class="n">No</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Stay</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="mi">3</span><span class="n">NF</span>
<span class="err">‚îî‚îÄ‚îÄ</span><span class="w"> </span><span class="n">Yes</span><span class="w"> </span><span class="err">‚Üí</span><span class="w"> </span><span class="n">Done</span><span class="o">!</span>
</code></pre></div>

<hr />
<h2 id="13-exercises">13. Exercises<a class="header-link" href="#13-exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-identifying-normal-forms">Exercise 1: Identifying Normal Forms<a class="header-link" href="#exercise-1-identifying-normal-forms" title="Permanent link">&para;</a></h3>
<p>For each relation, identify the highest normal form (1NF, 2NF, 3NF, or BCNF):</p>
<p><strong>a)</strong> R(A, B, C, D), Key: {A, B}, FDs: A ‚Üí C, AB ‚Üí D</p>
<p><strong>b)</strong> R(A, B, C), Key: {A}, FDs: A ‚Üí B, B ‚Üí C</p>
<p><strong>c)</strong> R(A, B, C, D), Key: {A}, FDs: A ‚Üí BCD</p>
<p><strong>d)</strong> R(A, B, C), Keys: {A, B} and {A, C}, FDs: AB ‚Üí C, AC ‚Üí B, B ‚Üí C, C ‚Üí B</p>
<details>
<summary>Solution</summary>

**a)** A ‚Üí C is a partial dependency (C depends on part of key {A,B}). **1NF** (not 2NF).

**b)** A ‚Üí B (direct from key, OK), B ‚Üí C (transitive: A ‚Üí B ‚Üí C). Not 3NF. But no partial dependency (single-attribute key), so 2NF. **2NF** (not 3NF).

**c)** Only FD is from the key. Every determinant (A) is a superkey. **BCNF**.

**d)** B ‚Üí C: B is not a superkey, but C is a prime attribute (part of key {A,C}). So 3NF holds. B is not a superkey, so BCNF fails. **3NF** (not BCNF).
</details>

<h3 id="exercise-2-3nf-synthesis">Exercise 2: 3NF Synthesis<a class="header-link" href="#exercise-2-3nf-synthesis" title="Permanent link">&para;</a></h3>
<p>Apply the 3NF synthesis algorithm to:</p>
<p>R(A, B, C, D, E) with F = { A ‚Üí B, BC ‚Üí D, D ‚Üí E, E ‚Üí C }</p>
<details>
<summary>Solution</summary>

**Step 1: Minimal cover**

Decompose RHS: already single attributes.

Check extraneous LHS in BC ‚Üí D:
- Remove B: {C}‚Å∫ = {C}. D ‚àâ {C}‚Å∫. Keep B.
- Remove C: {B}‚Å∫ = {B}. D ‚àâ {B}‚Å∫. Keep C.

Check redundant FDs:
- A ‚Üí B: {A}‚Å∫ without A‚ÜíB = {A}. B ‚àâ {A}‚Å∫. Keep.
- BC ‚Üí D: {B,C}‚Å∫ without BC‚ÜíD = {B,C}. D ‚àâ {B,C}‚Å∫. Keep.
- D ‚Üí E: {D}‚Å∫ without D‚ÜíE = {D}. E ‚àâ {D}‚Å∫. Keep.
- E ‚Üí C: {E}‚Å∫ without E‚ÜíC = {E}. C ‚àâ {E}‚Å∫. Keep.

F_min = { A ‚Üí B, BC ‚Üí D, D ‚Üí E, E ‚Üí C }

**Step 2: Create schemas (group by LHS)**

- R‚ÇÅ(A, B) from A ‚Üí B
- R‚ÇÇ(B, C, D) from BC ‚Üí D
- R‚ÇÉ(D, E) from D ‚Üí E
- R‚ÇÑ(E, C) from E ‚Üí C

**Step 3: Check for candidate key**

{A}‚Å∫ = {A, B}. Not all.
{A, C}‚Å∫ = {A, B, C, D, E}. All! Candidate key: {A, C}.
{A, E}‚Å∫ = {A, B, C, D, E} (E‚ÜíC, A‚ÜíB, BC‚ÜíD, D‚ÜíE). All! Candidate key: {A, E}.
{A, D}‚Å∫ = {A, B, D, E, C}. All! Candidate key: {A, D}.

None of R‚ÇÅ-R‚ÇÑ contains {A,C}, {A,E}, or {A,D} entirely.
- R‚ÇÅ = {A,B}: no
- R‚ÇÇ = {B,C,D}: no A
- R‚ÇÉ = {D,E}: no A
- R‚ÇÑ = {E,C}: no A

Add R‚ÇÖ = {A, C} (or {A, D} or {A, E}).

**Step 4: Remove subsets**

R‚ÇÑ(E, C) ‚äÜ R‚ÇÇ(B, C, D)? No (E not in R‚ÇÇ). No subsets to remove.

**Final decomposition:**

<div class="highlight"><pre><span></span><code>R‚ÇÅ(A, B)       ‚Äî key: {A}
R‚ÇÇ(B, C, D)    ‚Äî key: {B, C}
R‚ÇÉ(D, E)       ‚Äî key: {D}
R‚ÇÑ(E, C)       ‚Äî key: {E}
R‚ÇÖ(A, C)       ‚Äî key: {A, C} (candidate key of R)
</code></pre></div>



All in 3NF ‚úì, lossless-join ‚úì, dependency-preserving ‚úì.
</details>

<h3 id="exercise-3-bcnf-decomposition">Exercise 3: BCNF Decomposition<a class="header-link" href="#exercise-3-bcnf-decomposition" title="Permanent link">&para;</a></h3>
<p>Decompose into BCNF:</p>
<p>R(A, B, C, D) with F = { AB ‚Üí C, C ‚Üí A, C ‚Üí D }</p>
<details>
<summary>Solution</summary>

Candidate keys: {A,B} and {B,C} (verify: {A,B}‚Å∫ = {A,B,C,D}, {B,C}‚Å∫ = {A,B,C,D}).

Check BCNF:
- AB ‚Üí C: {A,B} is a superkey. ‚úì
- C ‚Üí A: {C}‚Å∫ = {A,C,D}. C is not a superkey. **BCNF violation!**
- C ‚Üí D: Same issue. **BCNF violation!**

Decompose on C ‚Üí A (or C ‚Üí AD):
- {C}‚Å∫ ‚à© {A,B,C,D} = {A,C,D}
- R‚ÇÅ = (A, C, D) with key {C}
- R‚ÇÇ = {C} ‚à™ ({A,B,C,D} - {A,C,D}) = (B, C) with key {B,C}

Check R‚ÇÅ(A, C, D):
- C ‚Üí A: C is a key of R‚ÇÅ. ‚úì
- C ‚Üí D: C is a key of R‚ÇÅ. ‚úì
- BCNF ‚úì

Check R‚ÇÇ(B, C):
- No non-trivial FDs with determinant that's not a superkey.
- BCNF ‚úì

**BCNF decomposition: R‚ÇÅ(A, C, D), R‚ÇÇ(B, C)**

Dependency preservation: AB ‚Üí C requires joining R‚ÇÅ and R‚ÇÇ. **Not preserved.**
</details>

<h3 id="exercise-4-lossless-join-verification">Exercise 4: Lossless-Join Verification<a class="header-link" href="#exercise-4-lossless-join-verification" title="Permanent link">&para;</a></h3>
<p>Verify whether the following decomposition has the lossless-join property:</p>
<p>R(A, B, C, D) with F = { A ‚Üí B, B ‚Üí C }</p>
<p>Decomposition: R‚ÇÅ(A, B), R‚ÇÇ(A, C), R‚ÇÉ(B, D)</p>
<details>
<summary>Solution</summary>

Use the chase test:

Initial matrix:
|    | A  | B   | C   | D   |
|----|----|-----|-----|-----|
| R‚ÇÅ | a‚ÇÅ | a‚ÇÇ  | b‚ÇÅ‚ÇÉ | b‚ÇÅ‚ÇÑ |
| R‚ÇÇ | a‚ÇÅ | b‚ÇÇ‚ÇÇ | a‚ÇÉ  | b‚ÇÇ‚ÇÑ |
| R‚ÇÉ | b‚ÇÉ‚ÇÅ| a‚ÇÇ  | b‚ÇÉ‚ÇÉ | a‚ÇÑ  |

Apply A ‚Üí B: R‚ÇÅ and R‚ÇÇ agree on A (= a‚ÇÅ).
- R‚ÇÅ.B = a‚ÇÇ, R‚ÇÇ.B = b‚ÇÇ‚ÇÇ. R‚ÇÅ has distinguished. Set R‚ÇÇ.B = a‚ÇÇ.

|    | A  | B  | C   | D   |
|----|----|----|-----|-----|
| R‚ÇÅ | a‚ÇÅ | a‚ÇÇ | b‚ÇÅ‚ÇÉ | b‚ÇÅ‚ÇÑ |
| R‚ÇÇ | a‚ÇÅ | a‚ÇÇ | a‚ÇÉ  | b‚ÇÇ‚ÇÑ |
| R‚ÇÉ | b‚ÇÉ‚ÇÅ| a‚ÇÇ | b‚ÇÉ‚ÇÉ | a‚ÇÑ  |

Apply B ‚Üí C: R‚ÇÅ, R‚ÇÇ, R‚ÇÉ agree on B (= a‚ÇÇ).
- C values: b‚ÇÅ‚ÇÉ, a‚ÇÉ, b‚ÇÉ‚ÇÉ. Has a‚ÇÉ. Set all to a‚ÇÉ.

|    | A  | B  | C  | D   |
|----|----|----|----| ----|
| R‚ÇÅ | a‚ÇÅ | a‚ÇÇ | a‚ÇÉ | b‚ÇÅ‚ÇÑ |
| R‚ÇÇ | a‚ÇÅ | a‚ÇÇ | a‚ÇÉ | b‚ÇÇ‚ÇÑ |
| R‚ÇÉ | b‚ÇÉ‚ÇÅ| a‚ÇÇ | a‚ÇÉ | a‚ÇÑ  |

No more changes from further iterations.

Check rows: No row has all distinguished symbols. Row R‚ÇÅ has b‚ÇÅ‚ÇÑ, Row R‚ÇÇ has b‚ÇÇ‚ÇÑ, Row R‚ÇÉ has b‚ÇÉ‚ÇÅ.

**The decomposition is NOT lossless-join.** ‚úó

The problem: R‚ÇÉ(B, D) shares only B with the others, and B is not a key of any relation containing D's determining attributes.

A correct decomposition: R‚ÇÅ(A, B), R‚ÇÇ(B, C, D) ‚Äî this is lossless since B ‚Üí C holds and {B} is a key of R‚ÇÇ restricted to {B,C}.

Actually, wait: B ‚Üí D is not given. The FDs are only A ‚Üí B and B ‚Üí C. So D has no determining FD. Let's reconsider: {A}‚Å∫ = {A,B,C}. The key must include D somehow: key = {A, D}.

Better decomposition: R‚ÇÅ(A, B, C) and R‚ÇÇ(A, D). Common = {A}. A ‚Üí {B,C}. {A} is a key of R‚ÇÅ. Lossless ‚úì.
</details>

<h3 id="exercise-5-full-normalization">Exercise 5: Full Normalization<a class="header-link" href="#exercise-5-full-normalization" title="Permanent link">&para;</a></h3>
<p>Normalize the following to 3NF using the synthesis algorithm:</p>
<div class="highlight"><pre><span></span><code>Library(isbn, title, author_id, author_name, publisher_id,
        publisher_name, publisher_city, branch_id, branch_name, copies)
</code></pre></div>

<p>FDs:</p>
<div class="highlight"><pre><span></span><code>isbn ‚Üí title, author_id, publisher_id
author_id ‚Üí author_name
publisher_id ‚Üí publisher_name, publisher_city
{isbn, branch_id} ‚Üí copies
branch_id ‚Üí branch_name
</code></pre></div>

<details>
<summary>Solution</summary>

**Step 1: Minimal cover**

Decompose RHS:

<div class="highlight"><pre><span></span><code>isbn ‚Üí title, isbn ‚Üí author_id, isbn ‚Üí publisher_id,
author_id ‚Üí author_name,
publisher_id ‚Üí publisher_name, publisher_id ‚Üí publisher_city,
{isbn, branch_id} ‚Üí copies,
branch_id ‚Üí branch_name
</code></pre></div>



Already minimal (all single attributes on RHS, no extraneous LHS, no redundant FDs).

**Step 2: Group by LHS**

- R‚ÇÅ(isbn, title, author_id, publisher_id) ‚Äî from isbn ‚Üí title, author_id, publisher_id
- R‚ÇÇ(author_id, author_name) ‚Äî from author_id ‚Üí author_name
- R‚ÇÉ(publisher_id, publisher_name, publisher_city) ‚Äî from publisher_id ‚Üí publisher_name, publisher_city
- R‚ÇÑ(isbn, branch_id, copies) ‚Äî from {isbn, branch_id} ‚Üí copies
- R‚ÇÖ(branch_id, branch_name) ‚Äî from branch_id ‚Üí branch_name

**Step 3: Candidate key = {isbn, branch_id}**

R‚ÇÑ contains {isbn, branch_id}. ‚úì

**Step 4: No subsets to remove.**

**Final 3NF decomposition:**

<div class="highlight"><pre><span></span><code>Book(isbn, title, author_id, publisher_id)         ‚Äî key: {isbn}
Author(author_id, author_name)                      ‚Äî key: {author_id}
Publisher(publisher_id, publisher_name, publisher_city) ‚Äî key: {publisher_id}
BranchStock(isbn, branch_id, copies)                ‚Äî key: {isbn, branch_id}
Branch(branch_id, branch_name)                      ‚Äî key: {branch_id}
</code></pre></div>



This is also in BCNF since every determinant is a single-attribute key (or composite key in BranchStock).
</details>

<h3 id="exercise-6-anomaly-identification">Exercise 6: Anomaly Identification<a class="header-link" href="#exercise-6-anomaly-identification" title="Permanent link">&para;</a></h3>
<p>Given the following relation and sample data, identify specific update, insertion, and deletion anomalies:</p>
<div class="highlight"><pre><span></span><code>CourseSection(course_id, section, semester, instructor, building, room)

FDs: {course_id, section, semester} ‚Üí instructor, building, room
     building, room ‚Üí capacity   (assume capacity is also an attribute)
</code></pre></div>

<div class="highlight"><pre><span></span><code>| course_id | section | semester | instructor | building | room | capacity |
|-----------|---------|----------|------------|----------|------|----------|
| CS101     | 1       | Fall24   | Dr. Smith  | Watson   | 101  | 50       |
| CS101     | 2       | Fall24   | Dr. Jones  | Watson   | 101  | 50       |
| CS201     | 1       | Fall24   | Dr. Smith  | Watson   | 201  | 30       |
| CS201     | 1       | Spr25    | Dr. Smith  | Taylor   | 105  | 40       |
</code></pre></div>

<details>
<summary>Solution</summary>

**Update anomaly**: If the capacity of Watson 101 changes (e.g., renovation adds seats), we must update multiple rows (rows 1 and 2). If we update only row 1, rows 1 and 2 become inconsistent.

**Insertion anomaly**: We cannot record that Taylor 302 has capacity 60 unless there is a course section scheduled in that room. There's no way to store room information independently.

**Deletion anomaly**: If CS201 Section 1 Spring 2025 is cancelled (delete row 4), we lose the information that Taylor 105 has capacity 40 (assuming no other section uses that room).

**Root cause**: The transitive dependency {course_id, section, semester} ‚Üí {building, room} ‚Üí capacity creates redundancy.

**Fix**: Decompose into:

<div class="highlight"><pre><span></span><code>CourseSection(course_id, section, semester, instructor, building, room)
Room(building, room, capacity)
</code></pre></div>


</details>

<hr />
<h2 id="14-summary">14. Summary<a class="header-link" href="#14-summary" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Key Idea</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1NF</strong></td>
<td>Atomic values only ‚Äî foundation of relational model</td>
</tr>
<tr>
<td><strong>2NF</strong></td>
<td>No partial dependencies ‚Äî every non-prime attribute depends on the full key</td>
</tr>
<tr>
<td><strong>3NF</strong></td>
<td>No transitive dependencies ‚Äî non-prime attributes depend only on keys</td>
</tr>
<tr>
<td><strong>BCNF</strong></td>
<td>Every determinant is a superkey ‚Äî strictest FD-based form</td>
</tr>
<tr>
<td><strong>Lossless Join</strong></td>
<td>Natural join recovers original data ‚Äî mandatory</td>
</tr>
<tr>
<td><strong>Dependency Preservation</strong></td>
<td>All FDs checkable without joins ‚Äî desirable but sometimes sacrificed for BCNF</td>
</tr>
<tr>
<td><strong>3NF Synthesis</strong></td>
<td>Guarantees both lossless join and dependency preservation</td>
</tr>
<tr>
<td><strong>BCNF Decomposition</strong></td>
<td>Guarantees lossless join; may lose dependency preservation</td>
</tr>
</tbody>
</table>
<p>Normalization through BCNF handles all redundancy caused by functional dependencies. However, there are other types of dependencies ‚Äî multivalued dependencies and join dependencies ‚Äî that require higher normal forms. We explore these in the next lesson.</p>
<hr />
<p><strong>Previous</strong>: <a href="./05_Functional_Dependencies.md">05_Functional_Dependencies.md</a> | <strong>Next</strong>: <a href="./07_Advanced_Normalization.md">07_Advanced_Normalization.md</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Database_Theory/05_Functional_Dependencies.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 05: Functional Dependencies</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Database_Theory/07_Advanced_Normalization.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 07: Advanced Normalization</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}