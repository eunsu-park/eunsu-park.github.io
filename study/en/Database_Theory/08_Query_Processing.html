{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 08: Query Processing - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">ğŸ </span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">ğŸ’»</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        í•œêµ­ì–´
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">â˜€ï¸</span>
                    <span class="theme-icon dark">ğŸŒ™</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Database_Theory/">Database Theory</a>
    <span class="separator">/</span>
    <span class="current">Lesson 08: Query Processing</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 08: Query Processing</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Database_Theory/07_Advanced_Normalization.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 07: Advanced Normalization</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Database_Theory/09_Indexing.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">09. Indexing</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#1-introduction">1. Introduction</a><ul>
<li><a href="#11-the-query-processing-pipeline">1.1 The Query Processing Pipeline</a></li>
<li><a href="#12-example-a-simple-querys-journey">1.2 Example: A Simple Query's Journey</a></li>
</ul>
</li>
<li><a href="#2-parsing-and-translation">2. Parsing and Translation</a><ul>
<li><a href="#21-parsing">2.1 Parsing</a></li>
<li><a href="#22-translation-to-relational-algebra">2.2 Translation to Relational Algebra</a></li>
</ul>
</li>
<li><a href="#3-query-evaluation-plans-and-the-iterator-model">3. Query Evaluation Plans and the Iterator Model</a><ul>
<li><a href="#31-query-evaluation-plan">3.1 Query Evaluation Plan</a></li>
<li><a href="#32-the-iterator-volcanopipeline-model">3.2 The Iterator (Volcano/Pipeline) Model</a></li>
<li><a href="#33-materialization-vs-pipelining">3.3 Materialization vs Pipelining</a></li>
<li><a href="#34-pull-vs-push-model">3.4 Pull vs Push Model</a></li>
</ul>
</li>
<li><a href="#4-cost-estimation">4. Cost Estimation</a><ul>
<li><a href="#41-cost-metrics">4.1 Cost Metrics</a></li>
<li><a href="#42-notation">4.2 Notation</a></li>
<li><a href="#43-example-catalog-statistics">4.3 Example Catalog Statistics</a></li>
</ul>
</li>
<li><a href="#5-selection-implementation">5. Selection Implementation</a><ul>
<li><a href="#51-algorithm-a1-linear-scan-full-table-scan">5.1 Algorithm A1: Linear Scan (Full Table Scan)</a></li>
<li><a href="#52-algorithm-a2-binary-search">5.2 Algorithm A2: Binary Search</a></li>
<li><a href="#53-algorithm-a3-primary-index-equality-on-key">5.3 Algorithm A3: Primary Index, Equality on Key</a></li>
<li><a href="#54-algorithm-a4-primary-index-equality-on-non-key">5.4 Algorithm A4: Primary Index, Equality on Non-Key</a></li>
<li><a href="#55-algorithm-a5-secondary-index-equality">5.5 Algorithm A5: Secondary Index, Equality</a></li>
<li><a href="#56-selection-with-range-predicates">5.6 Selection with Range Predicates</a></li>
<li><a href="#57-selection-with-complex-predicates">5.7 Selection with Complex Predicates</a></li>
<li><a href="#58-comparison-summary">5.8 Comparison Summary</a></li>
</ul>
</li>
<li><a href="#6-join-algorithms">6. Join Algorithms</a><ul>
<li><a href="#61-notation">6.1 Notation</a></li>
<li><a href="#62-algorithm-j1-nested-loop-join-nlj">6.2 Algorithm J1: Nested Loop Join (NLJ)</a></li>
<li><a href="#63-algorithm-j2-block-nested-loop-join-bnlj">6.3 Algorithm J2: Block Nested Loop Join (BNLJ)</a></li>
<li><a href="#64-algorithm-j3-indexed-nested-loop-join">6.4 Algorithm J3: Indexed Nested Loop Join</a></li>
<li><a href="#65-algorithm-j4-sort-merge-join">6.5 Algorithm J4: Sort-Merge Join</a></li>
<li><a href="#66-algorithm-j5-hash-join">6.6 Algorithm J5: Hash Join</a></li>
<li><a href="#67-cost-comparison">6.7 Cost Comparison</a></li>
</ul>
</li>
<li><a href="#7-query-optimization">7. Query Optimization</a><ul>
<li><a href="#71-overview">7.1 Overview</a></li>
<li><a href="#72-equivalence-rules-for-relational-algebra">7.2 Equivalence Rules for Relational Algebra</a><ul>
<li><a href="#rule-1-cascade-of-selections">Rule 1: Cascade of Selections</a></li>
<li><a href="#rule-2-commutativity-of-selection">Rule 2: Commutativity of Selection</a></li>
<li><a href="#rule-3-cascade-of-projections">Rule 3: Cascade of Projections</a></li>
<li><a href="#rule-4-commutativity-of-join">Rule 4: Commutativity of Join</a></li>
<li><a href="#rule-5-associativity-of-join">Rule 5: Associativity of Join</a></li>
<li><a href="#rule-6-push-selection-through-join">Rule 6: Push Selection Through Join</a></li>
<li><a href="#rule-7-push-selection-through-set-operations">Rule 7: Push Selection Through Set Operations</a></li>
<li><a href="#rule-8-push-projection-through-join">Rule 8: Push Projection Through Join</a></li>
</ul>
</li>
<li><a href="#73-heuristic-optimization">7.3 Heuristic Optimization</a><ul>
<li><a href="#example-heuristic-optimization">Example: Heuristic Optimization</a></li>
</ul>
</li>
<li><a href="#74-cost-based-optimization">7.4 Cost-Based Optimization</a><ul>
<li><a href="#selectivity-estimation">Selectivity Estimation</a></li>
<li><a href="#join-size-estimation">Join Size Estimation</a></li>
<li><a href="#histograms">Histograms</a></li>
</ul>
</li>
<li><a href="#75-join-ordering-optimization">7.5 Join Ordering Optimization</a></li>
<li><a href="#76-left-deep-vs-bushy-join-trees">7.6 Left-Deep vs Bushy Join Trees</a></li>
</ul>
</li>
<li><a href="#8-statistics-and-catalog-information">8. Statistics and Catalog Information</a><ul>
<li><a href="#81-what-the-catalog-stores">8.1 What the Catalog Stores</a></li>
<li><a href="#82-updating-statistics">8.2 Updating Statistics</a></li>
<li><a href="#83-impact-of-stale-statistics">8.3 Impact of Stale Statistics</a></li>
</ul>
</li>
<li><a href="#9-query-execution-engine-architecture">9. Query Execution Engine Architecture</a><ul>
<li><a href="#91-components">9.1 Components</a></li>
<li><a href="#92-plan-caching">9.2 Plan Caching</a></li>
<li><a href="#93-reading-execution-plans">9.3 Reading Execution Plans</a></li>
<li><a href="#94-adaptive-query-execution">9.4 Adaptive Query Execution</a></li>
</ul>
</li>
<li><a href="#10-advanced-topics">10. Advanced Topics</a><ul>
<li><a href="#101-parallel-query-execution">10.1 Parallel Query Execution</a></li>
<li><a href="#102-columnar-execution">10.2 Columnar Execution</a></li>
<li><a href="#103-just-in-time-jit-compilation">10.3 Just-In-Time (JIT) Compilation</a></li>
</ul>
</li>
<li><a href="#11-exercises">11. Exercises</a><ul>
<li><a href="#exercise-1-cost-calculation">Exercise 1: Cost Calculation</a></li>
<li><a href="#exercise-2-selectivity-estimation">Exercise 2: Selectivity Estimation</a></li>
<li><a href="#exercise-3-heuristic-optimization">Exercise 3: Heuristic Optimization</a></li>
<li><a href="#exercise-4-join-algorithm-selection">Exercise 4: Join Algorithm Selection</a></li>
<li><a href="#exercise-5-reading-execution-plans">Exercise 5: Reading Execution Plans</a></li>
<li><a href="#exercise-6-equivalence-rules">Exercise 6: Equivalence Rules</a></li>
<li><a href="#exercise-7-cost-based-optimization">Exercise 7: Cost-Based Optimization</a></li>
</ul>
</li>
<li><a href="#12-summary">12. Summary</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-08-query-processing">Lesson 08: Query Processing<a class="header-link" href="#lesson-08-query-processing" title="Permanent link">&para;</a></h1>
<p><strong>Previous</strong>: <a href="./07_Advanced_Normalization.md">07_Advanced_Normalization.md</a> | <strong>Next</strong>: <a href="./09_Indexing.md">09_Indexing.md</a></p>
<hr />
<blockquote>
<p><strong>Topic</strong>: Database Theory
<strong>Lesson</strong>: 8 of 16
<strong>Prerequisites</strong>: Relational algebra (Lesson 03), SQL basics, understanding of disk I/O
<strong>Objective</strong>: Understand how a DBMS transforms a SQL query into an efficient execution plan, master the cost models for selection and join algorithms, and grasp query optimization techniques</p>
</blockquote>
<h2 id="1-introduction">1. Introduction<a class="header-link" href="#1-introduction" title="Permanent link">&para;</a></h2>
<p>When you write a SQL query, the database does not simply execute it as written. Between your SQL statement and the actual disk accesses lies a sophisticated pipeline of <strong>parsing</strong>, <strong>optimization</strong>, and <strong>execution</strong>. Understanding this pipeline is crucial for writing efficient queries and diagnosing performance problems.</p>
<h3 id="11-the-query-processing-pipeline">1.1 The Query Processing Pipeline<a class="header-link" href="#11-the-query-processing-pipeline" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="nv">SQL</span><span class="w"> </span><span class="nv">Query</span>
<span class="w">    </span>â”‚
<span class="w">    </span>â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚<span class="w">    </span><span class="nv">Parser</span><span class="w">        </span>â”‚<span class="w"> </span>â†’<span class="w"> </span><span class="nv">Syntax</span><span class="w"> </span><span class="nv">check</span>,<span class="w"> </span><span class="nv">parse</span><span class="w"> </span><span class="nv">tree</span>
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
<span class="w">         </span>â”‚
<span class="w">         </span>â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚<span class="w">  </span><span class="nv">Translator</span><span class="w">      </span>â”‚<span class="w"> </span>â†’<span class="w"> </span><span class="nv">Relational</span><span class="w"> </span><span class="nv">algebra</span><span class="w"> </span><span class="nv">expression</span>
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
<span class="w">         </span>â”‚
<span class="w">         </span>â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚<span class="w">  </span><span class="nv">Optimizer</span><span class="w">       </span>â”‚<span class="w"> </span>â†’<span class="w"> </span><span class="nv">Choose</span><span class="w"> </span><span class="nv">best</span><span class="w"> </span><span class="nv">execution</span><span class="w"> </span><span class="nv">plan</span>
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
<span class="w">         </span>â”‚
<span class="w">         </span>â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚<span class="w">  </span><span class="nv">Execution</span><span class="w">       </span>â”‚<span class="w"> </span>â†’<span class="w"> </span><span class="nv">Run</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">plan</span>,<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="nv">results</span>
â”‚<span class="w">  </span><span class="nv">Engine</span><span class="w">          </span>â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre></div>

<h3 id="12-example-a-simple-querys-journey">1.2 Example: A Simple Query's Journey<a class="header-link" href="#12-example-a-simple-querys-journey" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">dept_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="n">e</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">departments</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">dept_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">dept_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">salary</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">80000</span><span class="p">;</span>
</code></pre></div>

<ol>
<li><strong>Parser</strong>: Checks syntax, resolves table/column names, produces a parse tree</li>
<li><strong>Translator</strong>: Converts to relational algebra: Ï€_{name, dept_name}(Ïƒ_{salary &gt; 80000}(employees â‹ˆ_{dept_id} departments))</li>
<li><strong>Optimizer</strong>: Considers many equivalent plans:</li>
<li>Filter first, then join? Or join first, then filter?</li>
<li>Use an index on salary? On dept_id?</li>
<li>Nested loop join? Hash join? Sort-merge join?</li>
<li><strong>Execution engine</strong>: Executes the chosen plan using the iterator model</li>
</ol>
<hr />
<h2 id="2-parsing-and-translation">2. Parsing and Translation<a class="header-link" href="#2-parsing-and-translation" title="Permanent link">&para;</a></h2>
<h3 id="21-parsing">2.1 Parsing<a class="header-link" href="#21-parsing" title="Permanent link">&para;</a></h3>
<p>The parser performs:</p>
<ol>
<li><strong>Lexical analysis</strong>: Breaks the query into tokens (keywords, identifiers, operators, literals)</li>
<li><strong>Syntax analysis</strong>: Verifies the query follows SQL grammar rules, builds a parse tree</li>
<li><strong>Semantic analysis</strong>: Checks that tables and columns exist, types are compatible, user has permissions</li>
</ol>
<p><strong>Parse tree</strong> for our example:</p>
<div class="highlight"><pre><span></span><code>         SELECT
        /      \
   ProjectList  FROM
   /      \      |
 e.name  d.dept_name  JoinClause
                        /    \
                  employees  departments
                       |
                  ON e.dept_id = d.dept_id
                       |
                  WHERE e.salary &gt; 80000
</code></pre></div>

<h3 id="22-translation-to-relational-algebra">2.2 Translation to Relational Algebra<a class="header-link" href="#22-translation-to-relational-algebra" title="Permanent link">&para;</a></h3>
<p>The parser output is translated into an initial relational algebra expression (or an equivalent internal representation called a <strong>query tree</strong>):</p>
<div class="highlight"><pre><span></span><code>Ï€_{name, dept_name}
    â”‚
    Ïƒ_{salary &gt; 80000}
    â”‚
    â‹ˆ_{dept_id}
   / \
  e   d
</code></pre></div>

<p>This initial expression is <strong>logically correct</strong> but not necessarily <strong>efficient</strong>. The optimizer's job is to find an equivalent but faster plan.</p>
<hr />
<h2 id="3-query-evaluation-plans-and-the-iterator-model">3. Query Evaluation Plans and the Iterator Model<a class="header-link" href="#3-query-evaluation-plans-and-the-iterator-model" title="Permanent link">&para;</a></h2>
<h3 id="31-query-evaluation-plan">3.1 Query Evaluation Plan<a class="header-link" href="#31-query-evaluation-plan" title="Permanent link">&para;</a></h3>
<p>A <strong>query evaluation plan</strong> (or execution plan) specifies:
- The relational algebra operations to perform
- The <strong>algorithm</strong> to use for each operation
- The <strong>order</strong> in which operations are executed
- How data flows between operations</p>
<h3 id="32-the-iterator-volcanopipeline-model">3.2 The Iterator (Volcano/Pipeline) Model<a class="header-link" href="#32-the-iterator-volcanopipeline-model" title="Permanent link">&para;</a></h3>
<p>Most modern databases use the <strong>iterator model</strong> (also called the Volcano model, after the Volcano query processing system by Goetz Graefe):</p>
<p>Every operator implements three methods:</p>
<div class="highlight"><pre><span></span><code><span class="nv">open</span><span class="ss">()</span><span class="w">   </span>â†’<span class="w"> </span><span class="nv">Initialize</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">operator</span>.<span class="w"> </span><span class="nv">Open</span><span class="w"> </span><span class="nv">child</span><span class="w"> </span><span class="nv">iterators</span>,<span class="w"> </span><span class="nv">allocate</span><span class="w"> </span><span class="nv">buffers</span>.
<span class="k">next</span><span class="ss">()</span><span class="w">   </span>â†’<span class="w"> </span><span class="k">Return</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="k">next</span><span class="w"> </span><span class="nv">tuple</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nb">result</span>.<span class="w"> </span><span class="k">Call</span><span class="w"> </span><span class="nl">children</span><span class="err">&#39;s next() as needed.</span>
<span class="err">close()  â†’ Clean up. Release buffers, close child iterators.</span>
</code></pre></div>

<p><strong>Key insight</strong>: Operators are composed into a tree. The root calls <code>next()</code>, which cascades down to the leaves (table scans). Tuples flow <strong>upward</strong> one at a time.</p>
<div class="highlight"><pre><span></span><code>         Ï€_{name, dept_name}     â† root calls next()
              â”‚
         Ïƒ_{salary &gt; 80000}     â† filters, passes matching tuples up
              â”‚
         â‹ˆ_{dept_id}            â† produces joined tuples
            / \
      Scan(e)  Scan(d)          â† read tuples from disk
</code></pre></div>

<h3 id="33-materialization-vs-pipelining">3.3 Materialization vs Pipelining<a class="header-link" href="#33-materialization-vs-pipelining" title="Permanent link">&para;</a></h3>
<p><strong>Materialization</strong>: Each operator produces its <strong>entire</strong> result, stores it in a temporary relation, then passes it to the parent. Simple but requires lots of temporary storage.</p>
<p><strong>Pipelining</strong>: Tuples flow through operators without being fully materialized. As soon as one tuple is produced, it's passed to the next operator. Much more memory-efficient.</p>
<div class="highlight"><pre><span></span><code><span class="n">Materialization</span><span class="o">:</span>
<span class="w">  </span><span class="n">Scan</span><span class="o">(</span><span class="n">e</span><span class="o">)</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="o">[</span><span class="n">full</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="n">table</span><span class="o">]</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="err">Ïƒ</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="o">[</span><span class="n">full</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="n">table</span><span class="o">]</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="err">â‹ˆ</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="o">[</span><span class="n">full</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="n">table</span><span class="o">]</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="err">Ï€</span>

<span class="n">Pipelining</span><span class="o">:</span>
<span class="w">  </span><span class="n">Scan</span><span class="o">(</span><span class="n">e</span><span class="o">)</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="err">Ïƒ</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="err">â‹ˆ</span><span class="w"> </span><span class="err">â†’</span><span class="w"> </span><span class="err">Ï€</span>
<span class="w">  </span><span class="o">(</span><span class="n">tuple</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">tuple</span><span class="o">,</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">full</span><span class="w"> </span><span class="n">temp</span><span class="w"> </span><span class="n">tables</span><span class="o">)</span>
</code></pre></div>

<p>Pipelining is preferred but not always possible. Some operations are <strong>blocking</strong> â€” they must consume all input before producing any output:
- <strong>Sorting</strong> (must see all tuples to sort)
- <strong>Hash join build phase</strong> (must build the entire hash table)
- <strong>Aggregation</strong> (must process all groups)</p>
<h3 id="34-pull-vs-push-model">3.4 Pull vs Push Model<a class="header-link" href="#34-pull-vs-push-model" title="Permanent link">&para;</a></h3>
<p>The iterator model described above is a <strong>pull</strong> model (or demand-driven): the parent pulls tuples from children by calling <code>next()</code>.</p>
<p>Modern systems increasingly use a <strong>push</strong> model (or data-driven): children push tuples to parents. This can be more cache-friendly and amenable to compilation.</p>
<div class="highlight"><pre><span></span><code><span class="nv">Pull</span><span class="w"> </span><span class="ss">(</span><span class="nv">Volcano</span><span class="ss">)</span>:<span class="w">                    </span><span class="nv">Push</span>:
<span class="w">  </span><span class="nv">Parent</span><span class="w"> </span><span class="nv">calls</span><span class="w"> </span><span class="nv">child</span>.<span class="k">next</span><span class="ss">()</span><span class="w">          </span><span class="nv">Child</span><span class="w"> </span><span class="nv">calls</span><span class="w"> </span><span class="nv">parent</span>.<span class="nv">consume</span><span class="ss">(</span><span class="nv">tuple</span><span class="ss">)</span>
<span class="w">  </span><span class="nv">Child</span><span class="w"> </span><span class="nv">returns</span><span class="w"> </span><span class="nv">one</span><span class="w"> </span><span class="nv">tuple</span><span class="w">            </span><span class="nv">Parent</span><span class="w"> </span><span class="nv">processes</span><span class="w"> </span><span class="nv">immediately</span>
<span class="w">  </span><span class="nv">Parent</span><span class="w"> </span><span class="nv">processes</span><span class="w">                   </span><span class="nv">More</span><span class="w"> </span><span class="nv">cache</span><span class="o">-</span><span class="nv">friendly</span>
</code></pre></div>

<p>Some systems (e.g., HyPer, Umbra) compile queries into tight loops that push data through operators, achieving near-hand-coded performance.</p>
<hr />
<h2 id="4-cost-estimation">4. Cost Estimation<a class="header-link" href="#4-cost-estimation" title="Permanent link">&para;</a></h2>
<h3 id="41-cost-metrics">4.1 Cost Metrics<a class="header-link" href="#41-cost-metrics" title="Permanent link">&para;</a></h3>
<p>The primary costs in query processing:</p>
<table>
<thead>
<tr>
<th>Cost Component</th>
<th>Symbol</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Disk I/O</strong></td>
<td>tT, tS</td>
<td>Transfer time (sequential read) and seek time</td>
</tr>
<tr>
<td><strong>CPU</strong></td>
<td>â€”</td>
<td>Comparison, hashing, computation</td>
</tr>
<tr>
<td><strong>Memory</strong></td>
<td>M</td>
<td>Available buffer pages</td>
</tr>
<tr>
<td><strong>Network</strong></td>
<td>â€”</td>
<td>For distributed queries</td>
</tr>
</tbody>
</table>
<p><strong>Disk I/O dominates</strong> in traditional systems. For a disk with:
- Seek time (tS) â‰ˆ 4 ms
- Transfer time per block (tT) â‰ˆ 0.1 ms</p>
<p>A single random I/O costs ~4.1 ms, while a sequential read costs ~0.1 ms per block. This 40:1 ratio explains why sequential access patterns are so important.</p>
<h3 id="42-notation">4.2 Notation<a class="header-link" href="#42-notation" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Symbol</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td>n_r</td>
<td>Number of tuples in relation r</td>
</tr>
<tr>
<td>b_r</td>
<td>Number of disk blocks containing tuples of r</td>
</tr>
<tr>
<td>l_r</td>
<td>Size of a tuple of r in bytes</td>
</tr>
<tr>
<td>f_r</td>
<td>Blocking factor: tuples per block = âŒŠB / l_râŒ‹</td>
</tr>
<tr>
<td>B</td>
<td>Block (page) size in bytes</td>
</tr>
<tr>
<td>V(A, r)</td>
<td>Number of distinct values of attribute A in r</td>
</tr>
<tr>
<td>M</td>
<td>Number of available buffer pages in memory</td>
</tr>
</tbody>
</table>
<p>Relationship: b_r = âŒˆn_r / f_râŒ‰</p>
<h3 id="43-example-catalog-statistics">4.3 Example Catalog Statistics<a class="header-link" href="#43-example-catalog-statistics" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>employees (e):
    n_e = 10,000 tuples
    l_e = 200 bytes
    B   = 4,096 bytes (4 KB pages)
    f_e = âŒŠ4096 / 200âŒ‹ = 20 tuples/block
    b_e = âŒˆ10000 / 20âŒ‰ = 500 blocks
    V(dept_id, e) = 50 distinct departments
    V(salary, e) = 2,000 distinct salary values

departments (d):
    n_d = 50 tuples
    l_d = 100 bytes
    f_d = âŒŠ4096 / 100âŒ‹ = 40 tuples/block
    b_d = âŒˆ50 / 40âŒ‰ = 2 blocks
</code></pre></div>

<hr />
<h2 id="5-selection-implementation">5. Selection Implementation<a class="header-link" href="#5-selection-implementation" title="Permanent link">&para;</a></h2>
<p>Selection (Ïƒ) filters tuples that satisfy a predicate. The implementation strategy depends heavily on available indexes.</p>
<h3 id="51-algorithm-a1-linear-scan-full-table-scan">5.1 Algorithm A1: Linear Scan (Full Table Scan)<a class="header-link" href="#51-algorithm-a1-linear-scan-full-table-scan" title="Permanent link">&para;</a></h3>
<p>Scan every block of the relation, test each tuple against the predicate.</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">LinearScan</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">predicate</span><span class="o">)</span>
<span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">IF</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">satisfies</span><span class="w"> </span><span class="n">predicate</span><span class="w"> </span><span class="n">THEN</span>
<span class="w">            </span><span class="n">output</span><span class="w"> </span><span class="n">t</span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">IF</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
</code></pre></div>

<p><strong>Cost</strong>: b_r block transfers + 1 seek</p>
<p>For our example: 500 transfers + 1 seek = 500 Ã— 0.1ms + 4ms = <strong>54 ms</strong></p>
<p><strong>When used</strong>: Always applicable. Used when no index exists or when selectivity is very low (most tuples qualify).</p>
<h3 id="52-algorithm-a2-binary-search">5.2 Algorithm A2: Binary Search<a class="header-link" href="#52-algorithm-a2-binary-search" title="Permanent link">&para;</a></h3>
<p>If the file is sorted on the selection attribute and the predicate is an equality:</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">BinarySearch</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="o">)</span>
<span class="n">Use</span><span class="w"> </span><span class="n">binary</span><span class="w"> </span><span class="n">search</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">containing</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span>
<span class="n">Scan</span><span class="w"> </span><span class="n">forward</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="n">tuples</span>
</code></pre></div>

<p><strong>Cost</strong>: âŒˆlogâ‚‚(b_r)âŒ‰ seeks and transfers for the search + additional blocks for duplicate values</p>
<p>For equality on a key: âŒˆlogâ‚‚(500)âŒ‰ = 9 block accesses = 9 Ã— (4ms + 0.1ms) = <strong>37 ms</strong></p>
<h3 id="53-algorithm-a3-primary-index-equality-on-key">5.3 Algorithm A3: Primary Index, Equality on Key<a class="header-link" href="#53-algorithm-a3-primary-index-equality-on-key" title="Permanent link">&para;</a></h3>
<p>If a primary Bâº-tree index exists on the selection attribute (which is a key):</p>
<div class="highlight"><pre><span></span><code>Cost = (h_i + 1) Ã— (tS + tT)
</code></pre></div>

<p>where h_i is the height of the Bâº-tree (typically 2-4).</p>
<p>For h_i = 3: 4 Ã— 4.1ms = <strong>16.4 ms</strong> (3 index levels + 1 data block)</p>
<h3 id="54-algorithm-a4-primary-index-equality-on-non-key">5.4 Algorithm A4: Primary Index, Equality on Non-Key<a class="header-link" href="#54-algorithm-a4-primary-index-equality-on-non-key" title="Permanent link">&para;</a></h3>
<p>Multiple tuples may match. They are contiguous (since the file is sorted on this attribute):</p>
<div class="highlight"><pre><span></span><code>Cost = h_i Ã— (tS + tT) + tS + tT Ã— b
</code></pre></div>

<p>where b is the number of blocks containing matching tuples.</p>
<h3 id="55-algorithm-a5-secondary-index-equality">5.5 Algorithm A5: Secondary Index, Equality<a class="header-link" href="#55-algorithm-a5-secondary-index-equality" title="Permanent link">&para;</a></h3>
<p><strong>On a candidate key</strong> (at most one match):</p>
<div class="highlight"><pre><span></span><code>Cost = (h_i + 1) Ã— (tS + tT)
</code></pre></div>

<p>Same as primary index for a key attribute.</p>
<p><strong>On a non-key attribute</strong> (multiple matches):</p>
<div class="highlight"><pre><span></span><code>Cost = (h_i + n) Ã— (tS + tT)
</code></pre></div>

<p>where n is the number of matching tuples. Each matching tuple may be in a <strong>different block</strong> (unlike primary index where they're contiguous), so each requires a separate seek.</p>
<p>This can be <strong>very expensive</strong> for low-selectivity predicates. If n = 500, the cost is (3 + 500) Ã— 4.1ms = <strong>2,062 ms</strong> â€” much worse than a full table scan (54 ms)!</p>
<h3 id="56-selection-with-range-predicates">5.6 Selection with Range Predicates<a class="header-link" href="#56-selection-with-range-predicates" title="Permanent link">&para;</a></h3>
<p>For predicates like <code>salary &gt; 80000</code>:</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Cost</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linear scan</td>
<td>b_r (always works)</td>
</tr>
<tr>
<td>Primary index (Bâº-tree)</td>
<td>h_i + b/2 (scan half the leaf level on average)</td>
</tr>
<tr>
<td>Secondary index (Bâº-tree)</td>
<td>h_i + leaf pages in range + matching record pointers</td>
</tr>
</tbody>
</table>
<h3 id="57-selection-with-complex-predicates">5.7 Selection with Complex Predicates<a class="header-link" href="#57-selection-with-complex-predicates" title="Permanent link">&para;</a></h3>
<p><strong>Conjunctive selection</strong> (Ïƒ_{Î¸â‚ âˆ§ Î¸â‚‚ âˆ§ ... âˆ§ Î¸â‚™}):</p>
<ol>
<li>If an index exists on one condition, use it and apply remaining conditions as filters</li>
<li>If indexes exist on multiple conditions, use <strong>index intersection</strong>: fetch record pointers from each index, intersect them, then retrieve matching records</li>
<li>Composite index on multiple attributes (ideal if available)</li>
</ol>
<p><strong>Disjunctive selection</strong> (Ïƒ_{Î¸â‚ âˆ¨ Î¸â‚‚ âˆ¨ ... âˆ¨ Î¸â‚™}):</p>
<ol>
<li>If indexes exist on ALL conditions, use <strong>index union</strong>: fetch pointers from each index, union them</li>
<li>If any condition lacks an index, must use linear scan (one missing index invalidates the whole approach)</li>
</ol>
<h3 id="58-comparison-summary">5.8 Comparison Summary<a class="header-link" href="#58-comparison-summary" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Condition</th>
<th>Cost (blocks)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linear scan</td>
<td>Always</td>
<td>b_r</td>
</tr>
<tr>
<td>Binary search</td>
<td>Sorted file, equality</td>
<td>âŒˆlogâ‚‚(b_r)âŒ‰</td>
</tr>
<tr>
<td>Primary Bâº-tree, key</td>
<td>Index on key</td>
<td>h_i + 1</td>
</tr>
<tr>
<td>Primary Bâº-tree, non-key</td>
<td>Index on non-key</td>
<td>h_i + matching blocks</td>
</tr>
<tr>
<td>Secondary Bâº-tree, key</td>
<td>Index on key</td>
<td>h_i + 1</td>
</tr>
<tr>
<td>Secondary Bâº-tree, non-key</td>
<td>Index on non-key</td>
<td>h_i + n (each match = 1 seek!)</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6-join-algorithms">6. Join Algorithms<a class="header-link" href="#6-join-algorithms" title="Permanent link">&para;</a></h2>
<p>Join is typically the most expensive operation in query processing. The choice of join algorithm dramatically affects performance.</p>
<h3 id="61-notation">6.1 Notation<a class="header-link" href="#61-notation" title="Permanent link">&para;</a></h3>
<p>We join relations r (outer) and s (inner):
- b_r, b_s = number of blocks
- n_r, n_s = number of tuples
- M = available memory pages</p>
<h3 id="62-algorithm-j1-nested-loop-join-nlj">6.2 Algorithm J1: Nested Loop Join (NLJ)<a class="header-link" href="#62-algorithm-j1-nested-loop-join-nlj" title="Permanent link">&para;</a></h3>
<p>The simplest join algorithm. For each tuple in r, scan all of s looking for matches.</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">NestedLoopJoin</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">s</span><span class="o">,</span><span class="w"> </span><span class="err">Î¸</span><span class="o">)</span>
<span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_r</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_s</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">IF</span><span class="w"> </span><span class="o">(</span><span class="n">t_r</span><span class="o">,</span><span class="w"> </span><span class="n">t_s</span><span class="o">)</span><span class="w"> </span><span class="n">satisfies</span><span class="w"> </span><span class="err">Î¸</span><span class="w"> </span><span class="n">THEN</span>
<span class="w">            </span><span class="n">output</span><span class="w"> </span><span class="o">(</span><span class="n">t_r</span><span class="w"> </span><span class="err">â‹ˆ</span><span class="w"> </span><span class="n">t_s</span><span class="o">)</span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">IF</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
</code></pre></div>

<p><strong>Cost (worst case â€” single buffer page for each relation)</strong>:</p>
<div class="highlight"><pre><span></span><code>Cost = n_r Ã— b_s + b_r   block transfers
     = n_r + b_r          seeks
</code></pre></div>

<p>For each of the n_r tuples in r, we scan all b_s blocks of s. Plus b_r block reads for r itself.</p>
<p><strong>Example</strong>: Join employees (outer) with departments (inner):
- n_r = 10,000, b_s = 2, b_r = 500
- Transfers: 10,000 Ã— 2 + 500 = 20,500
- Seeks: 10,000 + 500 = 10,500
- Time: 20,500 Ã— 0.1ms + 10,500 Ã— 4ms = <strong>44,050 ms â‰ˆ 44 seconds</strong></p>
<p><strong>Optimization</strong>: Always put the <strong>smaller</strong> relation as the inner (s). If we swap:
- n_r = 50, b_s = 500, b_r = 2
- Transfers: 50 Ã— 500 + 2 = 25,002
- This is worse in transfers but better in seeks.</p>
<p>In practice, tuple-level nested loop is rarely used. Block-level is much better.</p>
<h3 id="63-algorithm-j2-block-nested-loop-join-bnlj">6.3 Algorithm J2: Block Nested Loop Join (BNLJ)<a class="header-link" href="#63-algorithm-j2-block-nested-loop-join-bnlj" title="Permanent link">&para;</a></h3>
<p>Instead of iterating tuple-by-tuple, iterate block-by-block.</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">BlockNestedLoopJoin</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">s</span><span class="o">,</span><span class="w"> </span><span class="err">Î¸</span><span class="o">)</span>
<span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">B_r</span><span class="w"> </span><span class="n">OF</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">B_s</span><span class="w"> </span><span class="n">OF</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_r</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">B_r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">            </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_s</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">B_s</span><span class="w"> </span><span class="n">DO</span>
<span class="w">                </span><span class="n">IF</span><span class="w"> </span><span class="o">(</span><span class="n">t_r</span><span class="o">,</span><span class="w"> </span><span class="n">t_s</span><span class="o">)</span><span class="w"> </span><span class="n">satisfies</span><span class="w"> </span><span class="err">Î¸</span><span class="w"> </span><span class="n">THEN</span>
<span class="w">                    </span><span class="n">output</span><span class="w"> </span><span class="o">(</span><span class="n">t_r</span><span class="w"> </span><span class="err">â‹ˆ</span><span class="w"> </span><span class="n">t_s</span><span class="o">)</span>
<span class="w">                </span><span class="n">END</span><span class="w"> </span><span class="n">IF</span>
<span class="w">            </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
</code></pre></div>

<p><strong>Cost</strong>:</p>
<div class="highlight"><pre><span></span><code>Block transfers = b_r Ã— b_s + b_r
Seeks           = 2 Ã— b_r
</code></pre></div>

<p>Each block of r is read once. For each block of r, all of s is scanned (b_s blocks). s is read b_r times.</p>
<p><strong>Example</strong>: Same tables:
- Transfers: 500 Ã— 2 + 500 = 1,500
- Seeks: 2 Ã— 500 = 1,000
- Time: 1,500 Ã— 0.1ms + 1,000 Ã— 4ms = <strong>4,150 ms â‰ˆ 4.2 seconds</strong></p>
<p>A 10x improvement over tuple-level NLJ!</p>
<p><strong>Further optimization with M buffer pages</strong>:</p>
<p>Use (M - 2) pages for the outer relation, 1 page for the inner, 1 page for output:</p>
<div class="highlight"><pre><span></span><code>Block transfers = âŒˆb_r / (M-2)âŒ‰ Ã— b_s + b_r
Seeks           = 2 Ã— âŒˆb_r / (M-2)âŒ‰
</code></pre></div>

<p>With M = 52 (50 pages for outer, 1 for inner, 1 for output):
- Outer chunks: âŒˆ500 / 50âŒ‰ = 10
- Transfers: 10 Ã— 2 + 500 = 520
- Seeks: 2 Ã— 10 = 20
- Time: 520 Ã— 0.1ms + 20 Ã— 4ms = <strong>132 ms</strong></p>
<p>If the entire outer fits in memory (b_r â‰¤ M - 2), the cost is just <strong>b_r + b_s</strong> transfers and <strong>2</strong> seeks â€” a single pass!</p>
<h3 id="64-algorithm-j3-indexed-nested-loop-join">6.4 Algorithm J3: Indexed Nested Loop Join<a class="header-link" href="#64-algorithm-j3-indexed-nested-loop-join" title="Permanent link">&para;</a></h3>
<p>If an index exists on the join attribute of the inner relation, use it instead of scanning.</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">IndexedNestedLoopJoin</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">s</span><span class="o">,</span><span class="w"> </span><span class="err">Î¸</span><span class="o">)</span>
<span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_r</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">Use</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">tuples</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="n">t_r</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="n">t_s</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">output</span><span class="w"> </span><span class="o">(</span><span class="n">t_r</span><span class="w"> </span><span class="err">â‹ˆ</span><span class="w"> </span><span class="n">t_s</span><span class="o">)</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
</code></pre></div>

<p><strong>Cost</strong>:</p>
<div class="highlight"><pre><span></span><code>Cost = b_r + n_r Ã— c
</code></pre></div>

<p>where c is the cost of a single index lookup on s (typically h_i + 1 for an equality on a key with Bâº-tree).</p>
<p><strong>Example</strong>: Index on departments.dept_id (h_i = 2):
- c = 2 + 1 = 3 (index traversal + 1 data block)
- Cost: 500 + 10,000 Ã— 3 = 30,500 block accesses
- But with seeks: much better than BNLJ if index is in memory</p>
<p>If the index is in the buffer cache (common for small indexes):
- c â‰ˆ 1 (just the data block)
- Cost: 500 + 10,000 Ã— 1 = 10,500 transfers</p>
<h3 id="65-algorithm-j4-sort-merge-join">6.5 Algorithm J4: Sort-Merge Join<a class="header-link" href="#65-algorithm-j4-sort-merge-join" title="Permanent link">&para;</a></h3>
<p>Sort both relations on the join attribute, then merge them.</p>
<div class="highlight"><pre><span></span><code><span class="nl">ALGORITHM</span><span class="p">:</span><span class="w"> </span><span class="n">SortMergeJoin</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">join_attr</span><span class="p">)</span>
<span class="n">Phase</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">Sort</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">join_attr</span><span class="w"> </span><span class="p">(</span><span class="k">external</span><span class="w"> </span><span class="k">merge</span><span class="w"> </span><span class="n">sort</span><span class="p">)</span>
<span class="n">Phase</span><span class="w"> </span><span class="mi">2</span><span class="err">:</span><span class="w"> </span><span class="n">Sort</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="n">join_attr</span><span class="w"> </span><span class="p">(</span><span class="k">external</span><span class="w"> </span><span class="k">merge</span><span class="w"> </span><span class="n">sort</span><span class="p">)</span>
<span class="n">Phase</span><span class="w"> </span><span class="mi">3</span><span class="err">:</span><span class="w"> </span><span class="k">Merge</span>
<span class="w">    </span><span class="n">p_r</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">sorted</span><span class="w"> </span><span class="n">r</span>
<span class="w">    </span><span class="n">p_s</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="n">sorted</span><span class="w"> </span><span class="n">s</span>
<span class="w">    </span><span class="k">WHILE</span><span class="w"> </span><span class="n">neither</span><span class="w"> </span><span class="n">relation</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">exhausted</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="n">p_r</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_s</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">            </span><span class="k">Output</span><span class="w"> </span><span class="ow">all</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="n">combinations</span>
<span class="w">            </span><span class="n">Advance</span><span class="w"> </span><span class="k">both</span><span class="w"> </span><span class="n">pointers</span><span class="w"> </span><span class="n">past</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">equal</span><span class="w"> </span><span class="k">group</span>
<span class="w">        </span><span class="k">ELSE</span><span class="w"> </span><span class="k">IF</span><span class="w"> </span><span class="n">p_r</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p_s</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">            </span><span class="n">Advance</span><span class="w"> </span><span class="n">p_r</span>
<span class="w">        </span><span class="k">ELSE</span>
<span class="w">            </span><span class="n">Advance</span><span class="w"> </span><span class="n">p_s</span>
<span class="w">        </span><span class="k">END</span><span class="w"> </span><span class="k">IF</span>
<span class="w">    </span><span class="k">END</span><span class="w"> </span><span class="k">WHILE</span>
</code></pre></div>

<p><strong>Cost</strong>:</p>
<div class="highlight"><pre><span></span><code>Sorting cost = O(b Ã— log_M(b)) for each relation (external merge sort)
Merge cost   = b_r + b_s (single pass through both sorted relations)

Total = sort(r) + sort(s) + b_r + b_s
</code></pre></div>

<p>External merge sort cost for relation with b blocks and M memory pages:
- Number of runs after initial sort: âŒˆb / MâŒ‰
- Number of merge passes: âŒˆlog_{M-1}(âŒˆb/MâŒ‰)âŒ‰
- Each pass reads and writes all blocks: 2 Ã— b per pass
- Total sort cost: 2 Ã— b Ã— (1 + âŒˆlog_{M-1}(âŒˆb/MâŒ‰)âŒ‰) block transfers</p>
<p><strong>Example</strong> (M = 52):
- Sort employees: âŒˆ500/52âŒ‰ = 10 runs, âŒˆlogâ‚…â‚(10)âŒ‰ = 1 merge pass
  - Cost: 2 Ã— 500 Ã— (1 + 1) = 2,000 transfers
- Sort departments: Already fits in memory (2 blocks &lt; 52)
  - Cost: 2 Ã— 2 = 4 transfers
- Merge: 500 + 2 = 502 transfers
- <strong>Total: 2,506 transfers</strong></p>
<p><strong>When sort-merge excels</strong>:
- Both relations are already sorted (skip the sort phase!)
- Large relations where hash join runs out of memory
- Non-equality joins (sort-merge can handle Î¸-joins, while hash join cannot)</p>
<h3 id="66-algorithm-j5-hash-join">6.6 Algorithm J5: Hash Join<a class="header-link" href="#66-algorithm-j5-hash-join" title="Permanent link">&para;</a></h3>
<p>Build a hash table on the smaller relation, then probe with the larger.</p>
<div class="highlight"><pre><span></span><code><span class="nl">ALGORITHM</span><span class="p">:</span><span class="w"> </span><span class="n">HashJoin</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">join_attr</span><span class="p">)</span>
<span class="n">Phase</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">Build</span><span class="p">)</span><span class="err">:</span><span class="w"> </span><span class="n">Hash</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">smaller</span><span class="w"> </span><span class="n">relation</span><span class="w"> </span><span class="p">(</span><span class="n">say</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">memory</span>
<span class="w">    </span><span class="n">hash_table</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="err">{}</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="k">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_s</span><span class="w"> </span><span class="ow">IN</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">bucket</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">t_s</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="p">)</span>
<span class="w">        </span><span class="k">Insert</span><span class="w"> </span><span class="n">t_s</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">hash_table</span><span class="o">[</span><span class="n">bucket</span><span class="o">]</span>
<span class="w">    </span><span class="k">END</span><span class="w"> </span><span class="k">FOR</span>

<span class="n">Phase</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="n">Probe</span><span class="p">)</span><span class="err">:</span><span class="w"> </span><span class="n">Scan</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">larger</span><span class="w"> </span><span class="n">relation</span><span class="p">,</span><span class="w"> </span><span class="n">probe</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">hash</span><span class="w"> </span><span class="nc">table</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="k">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_r</span><span class="w"> </span><span class="ow">IN</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">bucket</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">t_r</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="p">)</span>
<span class="w">        </span><span class="k">FOR</span><span class="w"> </span><span class="k">EACH</span><span class="w"> </span><span class="n">t_s</span><span class="w"> </span><span class="ow">IN</span><span class="w"> </span><span class="n">hash_table</span><span class="o">[</span><span class="n">bucket</span><span class="o">]</span><span class="w"> </span><span class="n">DO</span>
<span class="w">            </span><span class="k">IF</span><span class="w"> </span><span class="n">t_r</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_s</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">                </span><span class="k">output</span><span class="w"> </span><span class="p">(</span><span class="n">t_r</span><span class="w"> </span><span class="err">â‹ˆ</span><span class="w"> </span><span class="n">t_s</span><span class="p">)</span>
<span class="w">            </span><span class="k">END</span><span class="w"> </span><span class="k">IF</span>
<span class="w">        </span><span class="k">END</span><span class="w"> </span><span class="k">FOR</span>
<span class="w">    </span><span class="k">END</span><span class="w"> </span><span class="k">FOR</span>
</code></pre></div>

<p><strong>Cost (if build relation fits in memory)</strong>:</p>
<div class="highlight"><pre><span></span><code>Cost = b_s + b_r  block transfers (read both relations once)
     = 2          seeks
</code></pre></div>

<p>This is optimal! We read each relation exactly once.</p>
<p><strong>Example</strong>: departments (2 blocks) fits in memory:
- Cost: 2 + 500 = 502 transfers, 2 seeks
- Time: 502 Ã— 0.1ms + 2 Ã— 4ms = <strong>58.2 ms</strong></p>
<p><strong>Grace Hash Join (when build doesn't fit in memory)</strong>:</p>
<p>If the smaller relation doesn't fit in memory, use partitioning:</p>
<div class="highlight"><pre><span></span><code><span class="nv">Phase</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ss">(</span><span class="nv">Partition</span><span class="ss">)</span>:<span class="w"> </span><span class="nv">Hash</span><span class="w"> </span><span class="nv">both</span><span class="w"> </span><span class="nv">r</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">M</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="nv">partitions</span>
<span class="w">    </span><span class="nv">Each</span><span class="w"> </span><span class="nv">partition</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">written</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">disk</span>

<span class="nv">Phase</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="ss">(</span><span class="nv">Build</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="nv">Probe</span><span class="ss">)</span>:<span class="w"> </span><span class="k">For</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="nv">partition</span><span class="w"> </span><span class="nv">i</span>:
<span class="w">    </span><span class="nv">Load</span><span class="w"> </span><span class="nv">partition</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">s</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">hash</span><span class="w"> </span><span class="nv">table</span>
<span class="w">    </span><span class="nv">Scan</span><span class="w"> </span><span class="nv">partition</span><span class="w"> </span><span class="nv">i</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">r</span>,<span class="w"> </span><span class="nv">probe</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">hash</span><span class="w"> </span><span class="nv">table</span>
</code></pre></div>

<p><strong>Cost</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">Partitioning</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="err">Ã—</span><span class="w"> </span><span class="o">(</span><span class="n">b_r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b_s</span><span class="o">)</span><span class="w">    </span><span class="n">transfers</span><span class="w"> </span><span class="o">(</span><span class="n">read</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">write</span><span class="w"> </span><span class="n">both</span><span class="o">)</span>
<span class="n">Build</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="n">Probe</span><span class="o">:</span><span class="w"> </span><span class="n">b_r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b_s</span><span class="w">          </span><span class="n">transfers</span><span class="w"> </span><span class="o">(</span><span class="n">read</span><span class="w"> </span><span class="n">both</span><span class="w"> </span><span class="n">partitions</span><span class="o">)</span>
<span class="n">Total</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="err">Ã—</span><span class="w"> </span><span class="o">(</span><span class="n">b_r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b_s</span><span class="o">)</span><span class="w">           </span><span class="n">transfers</span>
</code></pre></div>

<p><strong>Requirement</strong>: Each partition of the smaller relation must fit in memory:</p>
<div class="highlight"><pre><span></span><code>b_s / (M - 1) â‰¤ M - 2
âŸ¹ b_s â‰¤ (M - 1)(M - 2) â‰ˆ MÂ²
</code></pre></div>

<p>So hash join works if the smaller relation has at most about MÂ² blocks.</p>
<h3 id="67-cost-comparison">6.7 Cost Comparison<a class="header-link" href="#67-cost-comparison" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th style="text-align: center;">Block Transfers</th>
<th style="text-align: center;">Seeks</th>
<th>Best When</th>
</tr>
</thead>
<tbody>
<tr>
<td>Nested Loop</td>
<td style="text-align: center;">n_r Ã— b_s + b_r</td>
<td style="text-align: center;">n_r + b_r</td>
<td>Never (worst case)</td>
</tr>
<tr>
<td>Block Nested Loop</td>
<td style="text-align: center;">âŒˆb_r/(M-2)âŒ‰ Ã— b_s + b_r</td>
<td style="text-align: center;">2âŒˆb_r/(M-2)âŒ‰</td>
<td>No index, small M</td>
</tr>
<tr>
<td>Indexed NL</td>
<td style="text-align: center;">b_r + n_r Ã— c</td>
<td style="text-align: center;">b_r + n_r</td>
<td>Index on inner join attr</td>
</tr>
<tr>
<td>Sort-Merge</td>
<td style="text-align: center;">Sort cost + b_r + b_s</td>
<td style="text-align: center;">Many seeks</td>
<td>Already sorted, or Î¸-joins</td>
</tr>
<tr>
<td>Hash Join (in-mem)</td>
<td style="text-align: center;">b_r + b_s</td>
<td style="text-align: center;">2</td>
<td>Smaller relation fits in memory</td>
</tr>
<tr>
<td>Grace Hash Join</td>
<td style="text-align: center;">3(b_r + b_s)</td>
<td style="text-align: center;">Moderate</td>
<td>Large relations, MÂ² sufficient</td>
</tr>
</tbody>
</table>
<p><strong>Practical comparison for our example</strong> (employees â‹ˆ departments, M = 52):</p>
<table>
<thead>
<tr>
<th>Algorithm</th>
<th>Transfers</th>
<th>Time (approx)</th>
</tr>
</thead>
<tbody>
<tr>
<td>Tuple NLJ</td>
<td>20,500</td>
<td>44 sec</td>
</tr>
<tr>
<td>Block NLJ (M=52)</td>
<td>520</td>
<td>132 ms</td>
</tr>
<tr>
<td>Sort-Merge</td>
<td>2,506</td>
<td>~260 ms</td>
</tr>
<tr>
<td>Hash Join (in-mem)</td>
<td>502</td>
<td>58 ms</td>
</tr>
</tbody>
</table>
<p>Hash join wins decisively when the smaller relation fits in memory.</p>
<hr />
<h2 id="7-query-optimization">7. Query Optimization<a class="header-link" href="#7-query-optimization" title="Permanent link">&para;</a></h2>
<h3 id="71-overview">7.1 Overview<a class="header-link" href="#71-overview" title="Permanent link">&para;</a></h3>
<p>The optimizer transforms an initial query plan into an equivalent but more efficient one. Two main approaches:</p>
<ol>
<li><strong>Heuristic (rule-based) optimization</strong>: Apply transformation rules that are "almost always" beneficial</li>
<li><strong>Cost-based optimization</strong>: Enumerate alternative plans, estimate cost of each, pick the cheapest</li>
</ol>
<p>Most real systems use a combination of both.</p>
<h3 id="72-equivalence-rules-for-relational-algebra">7.2 Equivalence Rules for Relational Algebra<a class="header-link" href="#72-equivalence-rules-for-relational-algebra" title="Permanent link">&para;</a></h3>
<p>These rules allow the optimizer to transform one expression into an equivalent one:</p>
<h4 id="rule-1-cascade-of-selections">Rule 1: Cascade of Selections<a class="header-link" href="#rule-1-cascade-of-selections" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Ïƒ_{Î¸â‚ âˆ§ Î¸â‚‚}(r) = Ïƒ_{Î¸â‚}(Ïƒ_{Î¸â‚‚}(r))
</code></pre></div>

<p>A conjunction can be split into sequential selections.</p>
<h4 id="rule-2-commutativity-of-selection">Rule 2: Commutativity of Selection<a class="header-link" href="#rule-2-commutativity-of-selection" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Ïƒ_{Î¸â‚}(Ïƒ_{Î¸â‚‚}(r)) = Ïƒ_{Î¸â‚‚}(Ïƒ_{Î¸â‚}(r))
</code></pre></div>

<p>Order of selections doesn't matter.</p>
<h4 id="rule-3-cascade-of-projections">Rule 3: Cascade of Projections<a class="header-link" href="#rule-3-cascade-of-projections" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Ï€_{Lâ‚}(Ï€_{Lâ‚‚}(...(Ï€_{Lâ‚™}(r)))) = Ï€_{Lâ‚}(r)
</code></pre></div>

<p>Only the outermost projection matters (as long as Lâ‚ âŠ† Lâ‚‚ âŠ† ... âŠ† Lâ‚™).</p>
<h4 id="rule-4-commutativity-of-join">Rule 4: Commutativity of Join<a class="header-link" href="#rule-4-commutativity-of-join" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>r â‹ˆ s = s â‹ˆ r
</code></pre></div>

<h4 id="rule-5-associativity-of-join">Rule 5: Associativity of Join<a class="header-link" href="#rule-5-associativity-of-join" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>(r â‹ˆ s) â‹ˆ t = r â‹ˆ (s â‹ˆ t)
</code></pre></div>

<p>This is critical for multi-way joins. For n tables, there are (2(n-1))! / (n-1)! different join orderings (Catalan number). For 5 tables, that's 14 orderings. For 10 tables: 4,862.</p>
<h4 id="rule-6-push-selection-through-join">Rule 6: Push Selection Through Join<a class="header-link" href="#rule-6-push-selection-through-join" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Ïƒ_{Î¸}(r â‹ˆ s) = Ïƒ_{Î¸}(r) â‹ˆ s     (if Î¸ involves only attributes of r)
</code></pre></div>

<p>This is the single most important optimization: <strong>filter early to reduce intermediate result sizes</strong>.</p>
<h4 id="rule-7-push-selection-through-set-operations">Rule 7: Push Selection Through Set Operations<a class="header-link" href="#rule-7-push-selection-through-set-operations" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Ïƒ_{Î¸}(r âˆª s) = Ïƒ_{Î¸}(r) âˆª Ïƒ_{Î¸}(s)
Ïƒ_{Î¸}(r âˆ© s) = Ïƒ_{Î¸}(r) âˆ© s     (or r âˆ© Ïƒ_{Î¸}(s))
Ïƒ_{Î¸}(r - s) = Ïƒ_{Î¸}(r) - s
</code></pre></div>

<h4 id="rule-8-push-projection-through-join">Rule 8: Push Projection Through Join<a class="header-link" href="#rule-8-push-projection-through-join" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>Ï€_{L}(r â‹ˆ_{Î¸} s) = Ï€_{L}(Ï€_{Lâ‚}(r) â‹ˆ_{Î¸} Ï€_{Lâ‚‚}(s))
</code></pre></div>

<p>where Lâ‚ = attributes of r needed in L or Î¸, Lâ‚‚ = attributes of s needed in L or Î¸.</p>
<h3 id="73-heuristic-optimization">7.3 Heuristic Optimization<a class="header-link" href="#73-heuristic-optimization" title="Permanent link">&para;</a></h3>
<p>The general strategy:</p>
<ol>
<li><strong>Decompose</strong> conjunctive selections (Rule 1)</li>
<li><strong>Push selections down</strong> as far as possible (Rule 6, 7)</li>
<li><strong>Push projections down</strong> as far as possible (Rule 8)</li>
<li><strong>Choose join order</strong>: put the most selective joins first</li>
<li><strong>Identify subtrees</strong> that can be executed as a pipeline</li>
</ol>
<h4 id="example-heuristic-optimization">Example: Heuristic Optimization<a class="header-link" href="#example-heuristic-optimization" title="Permanent link">&para;</a></h4>
<p>Original:</p>
<div class="highlight"><pre><span></span><code>Ï€_{e.name, d.dept_name}(Ïƒ_{e.salary &gt; 80000 âˆ§ d.building = &#39;Watson&#39;}(employees â‹ˆ departments))
</code></pre></div>

<p><strong>Step 1</strong>: Decompose selection</p>
<div class="highlight"><pre><span></span><code>Ï€_{e.name, d.dept_name}(Ïƒ_{e.salary &gt; 80000}(Ïƒ_{d.building = &#39;Watson&#39;}(employees â‹ˆ departments)))
</code></pre></div>

<p><strong>Step 2</strong>: Push selections down</p>
<div class="highlight"><pre><span></span><code>Ï€_{e.name, d.dept_name}(Ïƒ_{e.salary &gt; 80000}(employees) â‹ˆ Ïƒ_{d.building = &#39;Watson&#39;}(departments))
</code></pre></div>

<p><strong>Step 3</strong>: Push projections down</p>
<div class="highlight"><pre><span></span><code>Ï€_{e.name, d.dept_name}(
    Ï€_{e.name, e.dept_id}(Ïƒ_{e.salary &gt; 80000}(employees))
    â‹ˆ
    Ï€_{d.dept_id, d.dept_name}(Ïƒ_{d.building = &#39;Watson&#39;}(departments))
)
</code></pre></div>

<p><strong>Before and after comparison:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">BEFORE</span><span class="o">:</span><span class="w"> </span><span class="n">Join</span><span class="w"> </span><span class="n">ALL</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="n">ALL</span><span class="w"> </span><span class="n">departments</span><span class="o">,</span><span class="w"> </span><span class="n">THEN</span><span class="w"> </span><span class="n">filter</span><span class="o">.</span>
<span class="w">  </span><span class="n">Cost</span><span class="o">:</span><span class="w"> </span><span class="mi">10</span><span class="o">,</span><span class="mi">000</span><span class="w"> </span><span class="err">Ã—</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="o">,</span><span class="mi">000</span><span class="w"> </span><span class="n">intermediate</span><span class="w"> </span><span class="n">tuples</span>

<span class="n">AFTER</span><span class="o">:</span><span class="w"> </span><span class="n">Filter</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="o">(</span><span class="n">say</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">000</span><span class="w"> </span><span class="n">remain</span><span class="o">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">departments</span><span class="w"> </span><span class="o">(</span><span class="n">say</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="n">remain</span><span class="o">),</span><span class="w"> </span><span class="n">THEN</span><span class="w"> </span><span class="n">join</span><span class="o">.</span>
<span class="w">  </span><span class="n">Cost</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">000</span><span class="w"> </span><span class="err">Ã—</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="mi">000</span><span class="w"> </span><span class="n">intermediate</span><span class="w"> </span><span class="n">tuples</span><span class="w"> </span><span class="err">â€”</span><span class="w"> </span><span class="mi">100</span><span class="n">x</span><span class="w"> </span><span class="n">reduction</span><span class="o">!</span>
</code></pre></div>

<h3 id="74-cost-based-optimization">7.4 Cost-Based Optimization<a class="header-link" href="#74-cost-based-optimization" title="Permanent link">&para;</a></h3>
<p>Heuristic optimization is good but not sufficient. The optimizer must estimate the <strong>actual cost</strong> of each plan to choose the best one.</p>
<h4 id="selectivity-estimation">Selectivity Estimation<a class="header-link" href="#selectivity-estimation" title="Permanent link">&para;</a></h4>
<p>The <strong>selectivity</strong> of a predicate estimates the fraction of tuples that satisfy it:</p>
<table>
<thead>
<tr>
<th>Predicate</th>
<th>Estimated Selectivity</th>
</tr>
</thead>
<tbody>
<tr>
<td>A = v (equality)</td>
<td>1 / V(A, r)</td>
</tr>
<tr>
<td>A &gt; v (range, uniform distribution)</td>
<td>(max(A) - v) / (max(A) - min(A))</td>
</tr>
<tr>
<td>A â‰¥ vâ‚ AND A â‰¤ vâ‚‚</td>
<td>(vâ‚‚ - vâ‚) / (max(A) - min(A))</td>
</tr>
<tr>
<td>Î¸â‚ âˆ§ Î¸â‚‚ (conjunction, independent)</td>
<td>sel(Î¸â‚) Ã— sel(Î¸â‚‚)</td>
</tr>
<tr>
<td>Î¸â‚ âˆ¨ Î¸â‚‚ (disjunction, independent)</td>
<td>sel(Î¸â‚) + sel(Î¸â‚‚) - sel(Î¸â‚) Ã— sel(Î¸â‚‚)</td>
</tr>
<tr>
<td>NOT Î¸</td>
<td>1 - sel(Î¸)</td>
</tr>
</tbody>
</table>
<p><strong>Example</strong>: Estimate size of Ïƒ_{salary &gt; 80000}(employees)</p>
<p>If salary ranges from 30,000 to 150,000 (uniform distribution):</p>
<div class="highlight"><pre><span></span><code>sel = (150,000 - 80,000) / (150,000 - 30,000) = 70,000 / 120,000 â‰ˆ 0.583
Estimated tuples = 10,000 Ã— 0.583 â‰ˆ 5,833
</code></pre></div>

<h4 id="join-size-estimation">Join Size Estimation<a class="header-link" href="#join-size-estimation" title="Permanent link">&para;</a></h4>
<p>For a natural join r â‹ˆ s on attribute A:</p>
<div class="highlight"><pre><span></span><code>Estimated size = (n_r Ã— n_s) / max(V(A, r), V(A, s))
</code></pre></div>

<p><strong>Example</strong>: employees â‹ˆ departments on dept_id:</p>
<div class="highlight"><pre><span></span><code>Size = (10,000 Ã— 50) / max(50, 50) = 500,000 / 50 = 10,000
</code></pre></div>

<p>This makes sense: each employee is in one department, so the join produces one tuple per employee.</p>
<h4 id="histograms">Histograms<a class="header-link" href="#histograms" title="Permanent link">&para;</a></h4>
<p>The uniform distribution assumption is often inaccurate. Real databases maintain <strong>histograms</strong> â€” statistics about the distribution of values:</p>
<p><strong>Equi-width histogram</strong>: Divide the value range into equal-width buckets, count tuples per bucket.</p>
<div class="highlight"><pre><span></span><code>salary histogram (5 buckets):
  [30K-54K):  2,500 employees
  [54K-78K):  3,000 employees
  [78K-102K): 2,500 employees
  [102K-126K): 1,500 employees
  [126K-150K]: 500 employees
</code></pre></div>

<p>With this histogram, Ïƒ_{salary &gt; 80000} would estimate:</p>
<div class="highlight"><pre><span></span><code>(102K-80K)/(102K-78K) Ã— 2,500 + 1,500 + 500 = (22/24) Ã— 2,500 + 2,000 â‰ˆ 4,292
</code></pre></div>

<p>Much more accurate than the uniform estimate of 5,833!</p>
<p><strong>Equi-depth (equi-height) histogram</strong>: Each bucket has approximately the same number of tuples. Better for skewed distributions.</p>
<h3 id="75-join-ordering-optimization">7.5 Join Ordering Optimization<a class="header-link" href="#75-join-ordering-optimization" title="Permanent link">&para;</a></h3>
<p>For multi-way joins, the order matters enormously. Consider:</p>
<div class="highlight"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">r3</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">r4</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="p">...</span>
</code></pre></div>

<p>Possible orderings (for 4 tables):
1. ((r1 â‹ˆ r2) â‹ˆ r3) â‹ˆ r4
2. (r1 â‹ˆ (r2 â‹ˆ r3)) â‹ˆ r4
3. (r1 â‹ˆ r2) â‹ˆ (r3 â‹ˆ r4)
4. ... (many more)</p>
<p>The optimizer uses <strong>dynamic programming</strong> to find the best order:</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">FindBestJoinOrder</span><span class="o">({</span><span class="n">Râ‚</span><span class="o">,</span><span class="w"> </span><span class="n">Râ‚‚</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">Râ‚™</span><span class="o">})</span>

<span class="n">FOR</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="n">relation</span><span class="w"> </span><span class="n">Ráµ¢</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">bestPlan</span><span class="o">({</span><span class="n">Ráµ¢</span><span class="o">})</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="n">path</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">Ráµ¢</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>

<span class="n">FOR</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">TO</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">subset</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="s1">&#39;size&#39;</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">bestPlan</span><span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="n">MIN</span><span class="w"> </span><span class="n">over</span><span class="w"> </span><span class="n">all</span><span class="w"> </span><span class="n">ways</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">split</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="n">into</span>
<span class="w">                       </span><span class="n">Sâ‚</span><span class="w"> </span><span class="err">âˆª</span><span class="w"> </span><span class="n">Sâ‚‚</span><span class="w"> </span><span class="n">where</span><span class="w"> </span><span class="n">Sâ‚</span><span class="o">,</span><span class="w"> </span><span class="n">Sâ‚‚</span><span class="w"> </span><span class="n">non</span><span class="o">-</span><span class="n">empty</span><span class="o">:</span>
<span class="w">                       </span><span class="n">cost</span><span class="o">(</span><span class="n">bestPlan</span><span class="o">(</span><span class="n">Sâ‚</span><span class="o">)</span><span class="w"> </span><span class="err">â‹ˆ</span><span class="w"> </span><span class="n">bestPlan</span><span class="o">(</span><span class="n">Sâ‚‚</span><span class="o">))</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>

<span class="n">RETURN</span><span class="w"> </span><span class="n">bestPlan</span><span class="o">({</span><span class="n">Râ‚</span><span class="o">,</span><span class="w"> </span><span class="n">Râ‚‚</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">Râ‚™</span><span class="o">})</span>
</code></pre></div>

<p>This considers all possible join trees (including bushy trees, not just left-deep trees). Complexity: O(3â¿) â€” exponential, but practical for queries with up to ~15-20 tables.</p>
<p>For larger queries, heuristics or greedy algorithms are used instead.</p>
<h3 id="76-left-deep-vs-bushy-join-trees">7.6 Left-Deep vs Bushy Join Trees<a class="header-link" href="#76-left-deep-vs-bushy-join-trees" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Left-deep tree:              Bushy tree:

        â‹ˆ                        â‹ˆ
       / \                      / \
      â‹ˆ   Râ‚„                  â‹ˆ   â‹ˆ
     / \                      / \ / \
    â‹ˆ   Râ‚ƒ                  Râ‚ Râ‚‚ Râ‚ƒ Râ‚„
   / \
  Râ‚  Râ‚‚
</code></pre></div>

<p><strong>Left-deep trees</strong> are preferred by many optimizers because:
1. The inner relation at each join step can use pipelining (no materialization)
2. Indexed nested loop join works naturally (inner = indexed table)
3. Search space is smaller: n! orderings vs. exponentially more for bushy trees</p>
<hr />
<h2 id="8-statistics-and-catalog-information">8. Statistics and Catalog Information<a class="header-link" href="#8-statistics-and-catalog-information" title="Permanent link">&para;</a></h2>
<h3 id="81-what-the-catalog-stores">8.1 What the Catalog Stores<a class="header-link" href="#81-what-the-catalog-stores" title="Permanent link">&para;</a></h3>
<p>The system catalog (metadata) maintains statistics for cost estimation:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL catalog tables:</span>
<span class="n">pg_class</span><span class="w">     </span><span class="c1">-- table/index statistics (n_r, b_r, etc.)</span>
<span class="n">pg_statistic</span><span class="w"> </span><span class="c1">-- column-level statistics (histograms, distinct values, correlation)</span>
<span class="n">pg_stats</span><span class="w">     </span><span class="c1">-- human-readable view of statistics</span>
</code></pre></div>

<p>Key statistics:
- <strong>n_r</strong> (reltuples): Number of rows in the table
- <strong>b_r</strong> (relpages): Number of disk pages
- <strong>V(A, r)</strong> (n_distinct): Number of distinct values per column
- <strong>Histograms</strong>: Value distribution per column
- <strong>Correlation</strong>: How well the physical order matches the logical order (important for range scans)
- <strong>Most common values (MCV)</strong>: List of the most frequent values and their frequencies
- <strong>NULL fraction</strong>: Fraction of NULL values per column</p>
<h3 id="82-updating-statistics">8.2 Updating Statistics<a class="header-link" href="#82-updating-statistics" title="Permanent link">&para;</a></h3>
<p>Statistics become stale as data changes. Databases provide commands to refresh them:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL</span>
<span class="k">ANALYZE</span><span class="w"> </span><span class="n">employees</span><span class="p">;</span><span class="w">              </span><span class="c1">-- Update stats for one table</span>
<span class="k">ANALYZE</span><span class="p">;</span><span class="w">                         </span><span class="c1">-- Update stats for all tables</span>
<span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="p">(</span><span class="n">autovacuum_analyze_threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">);</span>

<span class="c1">-- MySQL</span>
<span class="k">ANALYZE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employees</span><span class="p">;</span>

<span class="c1">-- SQL Server</span>
<span class="k">UPDATE</span><span class="w"> </span><span class="k">STATISTICS</span><span class="w"> </span><span class="n">employees</span><span class="p">;</span>
</code></pre></div>

<p>PostgreSQL's <strong>autovacuum</strong> process automatically updates statistics when enough rows have changed (default: 10% of the table).</p>
<h3 id="83-impact-of-stale-statistics">8.3 Impact of Stale Statistics<a class="header-link" href="#83-impact-of-stale-statistics" title="Permanent link">&para;</a></h3>
<p>Stale statistics lead to <strong>bad plans</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">Scenario</span><span class="o">:</span><span class="w"> </span><span class="n">Table</span><span class="w"> </span><span class="n">had</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">000</span><span class="w"> </span><span class="n">rows</span><span class="w"> </span><span class="n">when</span><span class="w"> </span><span class="n">stats</span><span class="w"> </span><span class="n">were</span><span class="w"> </span><span class="n">collected</span><span class="o">.</span>
<span class="w">          </span><span class="n">Now</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">000</span><span class="o">,</span><span class="mi">000</span><span class="w"> </span><span class="n">rows</span><span class="o">.</span>

<span class="n">Optimizer</span><span class="w"> </span><span class="n">thinks</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Small table, nested loop join is fine.&quot;</span>
<span class="n">Reality</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;Huge table, hash join would be 1000x faster.&quot;</span>
</code></pre></div>

<p>This is one of the most common causes of sudden query performance degradation in production systems.</p>
<hr />
<h2 id="9-query-execution-engine-architecture">9. Query Execution Engine Architecture<a class="header-link" href="#9-query-execution-engine-architecture" title="Permanent link">&para;</a></h2>
<h3 id="91-components">9.1 Components<a class="header-link" href="#91-components" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="err">â”‚</span><span class="w">                    </span><span class="n">Query</span><span class="w"> </span><span class="n">Executor</span><span class="w">                         </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><span class="w">  </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><span class="w">  </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="n">Plan</span><span class="w"> </span><span class="n">Cache</span><span class="w">  </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="n">Iterator</span><span class="w">   </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="n">Expression</span><span class="w">         </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="p">(</span><span class="n">prepared</span><span class="w">   </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="n">Operators</span><span class="w">  </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="n">Evaluator</span><span class="w">          </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">  </span><span class="n">statements</span><span class="p">)</span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">            </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="p">(</span><span class="n">predicates</span><span class="p">,</span><span class="w">       </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">             </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">SeqScan</span><span class="w">  </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">  </span><span class="n">projections</span><span class="p">,</span><span class="w">      </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">             </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">IdxScan</span><span class="w">  </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">  </span><span class="n">aggregations</span><span class="p">)</span><span class="w">     </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">             </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">NestLoop</span><span class="w"> </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">                    </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">             </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">HashJoin</span><span class="w"> </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">                    </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">             </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">SortMrg</span><span class="w">  </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">                    </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">             </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">HashAgg</span><span class="w">  </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">                    </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">             </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Sort</span><span class="w">     </span><span class="err">â”‚</span><span class="w">  </span><span class="err">â”‚</span><span class="w">                    </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">  </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><span class="w">  </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><span class="w">  </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><span class="w"> </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">                         </span><span class="err">â”‚</span><span class="w">                                 </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">              </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><span class="w">                     </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">              </span><span class="err">â”‚</span><span class="w">  </span><span class="n">Buffer</span><span class="w"> </span><span class="n">Manager</span><span class="w">     </span><span class="err">â”‚</span><span class="w">                     </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">              </span><span class="err">â”‚</span><span class="w">  </span><span class="p">(</span><span class="n">page</span><span class="w"> </span><span class="n">cache</span><span class="p">)</span><span class="w">       </span><span class="err">â”‚</span><span class="w">                     </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">              </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><span class="w">                     </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">                         </span><span class="err">â”‚</span><span class="w">                                 </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">              </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span><span class="w">                     </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">              </span><span class="err">â”‚</span><span class="w">  </span><span class="n">Storage</span><span class="w"> </span><span class="n">Engine</span><span class="w">     </span><span class="err">â”‚</span><span class="w">                     </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">              </span><span class="err">â”‚</span><span class="w">  </span><span class="p">(</span><span class="n">disk</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="p">)</span><span class="w">         </span><span class="err">â”‚</span><span class="w">                     </span><span class="err">â”‚</span>
<span class="err">â”‚</span><span class="w">              </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span><span class="w">                     </span><span class="err">â”‚</span>
<span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
</code></pre></div>

<h3 id="92-plan-caching">9.2 Plan Caching<a class="header-link" href="#92-plan-caching" title="Permanent link">&para;</a></h3>
<p>Parsing and optimization are expensive. Databases cache execution plans to avoid repeating this work:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL: prepared statements cache plans</span>
<span class="k">PREPARE</span><span class="w"> </span><span class="n">find_emp</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">emp_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">$</span><span class="mi">1</span><span class="p">;</span>

<span class="k">EXECUTE</span><span class="w"> </span><span class="n">find_emp</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w">   </span><span class="c1">-- First execution: parse + optimize + execute</span>
<span class="k">EXECUTE</span><span class="w"> </span><span class="n">find_emp</span><span class="p">(</span><span class="mi">99</span><span class="p">);</span><span class="w">   </span><span class="c1">-- Subsequent: reuse cached plan</span>
</code></pre></div>

<p><strong>Plan invalidation</strong>: Cached plans become invalid when:
- Table structure changes (ALTER TABLE)
- Statistics are updated (ANALYZE)
- Indexes are created or dropped</p>
<h3 id="93-reading-execution-plans">9.3 Reading Execution Plans<a class="header-link" href="#93-reading-execution-plans" title="Permanent link">&para;</a></h3>
<p>Most databases provide a command to view the execution plan:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL</span>
<span class="k">EXPLAIN</span><span class="w"> </span><span class="k">ANALYZE</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">dept_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="n">e</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">departments</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">dept_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">dept_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">salary</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">80000</span><span class="p">;</span>
</code></pre></div>

<p>Output (example):</p>
<div class="highlight"><pre><span></span><code><span class="nf">Hash</span><span class="w"> </span><span class="nf">Join</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">1.12</span><span class="p">.</span><span class="mf">.25.47</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">167</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">actual</span><span class="w"> </span><span class="n">time</span><span class="o">=</span><span class="mf">0.05</span><span class="p">.</span><span class="mf">.0.31</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">150</span><span class="w"> </span><span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="nf">Hash</span><span class="w"> </span><span class="n">Cond</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">dept_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">dept_id</span><span class="p">)</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="kr">Scan</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="n">e</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.00</span><span class="p">.</span><span class="mf">.22.50</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">167</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">actual</span><span class="w"> </span><span class="n">time</span><span class="o">=</span><span class="mf">0.01</span><span class="p">.</span><span class="mf">.0.15</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">150</span><span class="w"> </span><span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">Filter</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">salary</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">80000</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rows</span><span class="w"> </span><span class="n">Removed</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">Filter</span><span class="o">:</span><span class="w"> </span><span class="mi">850</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="nf">Hash</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">1.05</span><span class="p">.</span><span class="mf">.1.05</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">50</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">28</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">actual</span><span class="w"> </span><span class="n">time</span><span class="o">=</span><span class="mf">0.02</span><span class="p">.</span><span class="mf">.0.02</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">50</span><span class="w"> </span><span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">Buckets</span><span class="o">:</span><span class="w"> </span><span class="mi">1024</span><span class="w">  </span><span class="n">Batches</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Memory</span><span class="w"> </span><span class="n">Usage</span><span class="o">:</span><span class="w"> </span><span class="mi">12</span><span class="n">kB</span>
<span class="w">        </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="kr">Scan</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">departments</span><span class="w"> </span><span class="n">d</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.00</span><span class="p">.</span><span class="mf">.1.05</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">50</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">28</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">actual</span><span class="w"> </span><span class="n">time</span><span class="o">=</span><span class="mf">0.00</span><span class="p">.</span><span class="mf">.0.01</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">50</span><span class="w"> </span><span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Planning</span><span class="w"> </span><span class="n">Time</span><span class="o">:</span><span class="w"> </span><span class="mf">0.15</span><span class="w"> </span><span class="n">ms</span>
<span class="n">Execution</span><span class="w"> </span><span class="n">Time</span><span class="o">:</span><span class="w"> </span><span class="mf">0.38</span><span class="w"> </span><span class="n">ms</span>
</code></pre></div>

<p><strong>Reading this plan (bottom-up)</strong>:
1. Sequential scan on departments (50 rows) â†’ build hash table (12 KB)
2. Sequential scan on employees with filter salary &gt; 80000 (150 of 1000 rows pass)
3. Hash join using dept_id
4. Total: 0.38 ms execution time</p>
<h3 id="94-adaptive-query-execution">9.4 Adaptive Query Execution<a class="header-link" href="#94-adaptive-query-execution" title="Permanent link">&para;</a></h3>
<p>Modern databases can adjust execution plans during runtime:</p>
<ul>
<li><strong>PostgreSQL</strong>: Uses generic vs. custom plans for prepared statements. After 5 executions, it compares and may switch.</li>
<li><strong>Oracle</strong>: Adaptive cursor sharing â€” detects when a cached plan performs poorly for certain parameter values</li>
<li><strong>Spark SQL</strong>: Adaptive Query Execution (AQE) â€” re-optimizes mid-query based on actual partition sizes</li>
</ul>
<hr />
<h2 id="10-advanced-topics">10. Advanced Topics<a class="header-link" href="#10-advanced-topics" title="Permanent link">&para;</a></h2>
<h3 id="101-parallel-query-execution">10.1 Parallel Query Execution<a class="header-link" href="#101-parallel-query-execution" title="Permanent link">&para;</a></h3>
<p>Modern databases parallelize query execution across multiple CPU cores:</p>
<div class="highlight"><pre><span></span><code>              Gather
             /  |  \
     Worker1  Worker2  Worker3
        |        |        |
     Scan(p1) Scan(p2) Scan(p3)  â† parallel sequential scan
</code></pre></div>

<p>Parallelizable operations:
- Scan (divide table into ranges)
- Filter (each worker filters its partition)
- Hash join (parallel build + parallel probe)
- Aggregation (partial aggregation per worker, then merge)
- Sort (parallel sort, then merge)</p>
<h3 id="102-columnar-execution">10.2 Columnar Execution<a class="header-link" href="#102-columnar-execution" title="Permanent link">&para;</a></h3>
<p>Traditional row-store: read entire rows, even if only a few columns are needed.</p>
<p>Column-store: store each column separately, read only needed columns.</p>
<div class="highlight"><pre><span></span><code>Row store:                     Column store:
[id=1, name=Alice, sal=80K]   id:   [1, 2, 3, ...]
[id=2, name=Bob,   sal=90K]   name: [Alice, Bob, ...]
[id=3, name=Carol, sal=75K]   sal:  [80K, 90K, 75K, ...]
</code></pre></div>

<p>Advantages of column stores for analytics:
- Read only needed columns (less I/O)
- Better compression (similar values together)
- CPU-friendly (SIMD operations on column arrays)
- Used by: DuckDB, ClickHouse, Redshift, BigQuery</p>
<h3 id="103-just-in-time-jit-compilation">10.3 Just-In-Time (JIT) Compilation<a class="header-link" href="#103-just-in-time-jit-compilation" title="Permanent link">&para;</a></h3>
<p>Instead of interpreting the query plan (calling virtual functions for each tuple), compile it into native machine code:</p>
<div class="highlight"><pre><span></span><code>Traditional (interpreted):
  for each tuple:
    call virtual function: evaluate predicate
    call virtual function: project columns
    call virtual function: hash for join

JIT-compiled:
  for each tuple:
    if tuple.salary &gt; 80000:    // inlined, no virtual dispatch
      hash = tuple.dept_id % N   // inlined
      emit(tuple.name, ...)      // inlined
</code></pre></div>

<p>JIT compilation removes interpretation overhead, especially beneficial for complex expressions and large datasets.</p>
<p>PostgreSQL supports JIT compilation (using LLVM) for expression evaluation and tuple deforming.</p>
<hr />
<h2 id="11-exercises">11. Exercises<a class="header-link" href="#11-exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-cost-calculation">Exercise 1: Cost Calculation<a class="header-link" href="#exercise-1-cost-calculation" title="Permanent link">&para;</a></h3>
<p>Given:
- employees: n = 10,000, b = 500, index on emp_id (Bâº-tree, height 3)
- departments: n = 200, b = 10
- Memory: M = 12 pages</p>
<p>Calculate the cost (in block transfers) for joining employees and departments on dept_id using:</p>
<ol>
<li>Block nested loop join (employees as outer)</li>
<li>Block nested loop join (departments as outer)</li>
<li>Hash join (departments as build)</li>
</ol>
<details>
<summary>Solution</summary>

1. **BNLJ (employees outer)**:
   - Outer chunks: âŒˆ500 / (12-2)âŒ‰ = âŒˆ500/10âŒ‰ = 50
   - Cost: 50 Ã— 10 + 500 = 1,000 transfers

2. **BNLJ (departments outer)**:
   - Outer chunks: âŒˆ10 / (12-2)âŒ‰ = âŒˆ10/10âŒ‰ = 1
   - Cost: 1 Ã— 500 + 10 = 510 transfers

3. **Hash join (departments as build)**:
   - departments (10 blocks) fits in 12-page memory
   - Cost: 10 + 500 = 510 transfers

The hash join and departments-outer BNLJ are comparable. Hash join has fewer seeks (2 vs. 2). In practice, hash join is preferred due to better cache behavior.
</details>

<h3 id="exercise-2-selectivity-estimation">Exercise 2: Selectivity Estimation<a class="header-link" href="#exercise-2-selectivity-estimation" title="Permanent link">&para;</a></h3>
<p>Given: employees table with 10,000 rows.
- salary: min=30,000, max=150,000, V(salary) = 2,000
- dept_id: V(dept_id) = 50
- city: V(city) = 100</p>
<p>Estimate the number of tuples returned by:</p>
<ol>
<li>Ïƒ_{salary = 75000}(employees)</li>
<li>Ïƒ_{salary &gt; 100000}(employees)</li>
<li>Ïƒ_{dept_id = 5 âˆ§ city = 'Boston'}(employees)</li>
</ol>
<details>
<summary>Solution</summary>

1. **salary = 75000**: sel = 1/V(salary) = 1/2000. Result: 10,000/2,000 = **5 tuples**

2. **salary > 100000**: sel = (150,000 - 100,000)/(150,000 - 30,000) = 50,000/120,000 â‰ˆ 0.417. Result: 10,000 Ã— 0.417 â‰ˆ **4,167 tuples**

3. **dept_id = 5 AND city = 'Boston'** (assuming independence):
   - sel(dept_id = 5) = 1/50
   - sel(city = 'Boston') = 1/100
   - Combined: (1/50) Ã— (1/100) = 1/5,000
   - Result: 10,000 / 5,000 = **2 tuples**
</details>

<h3 id="exercise-3-heuristic-optimization">Exercise 3: Heuristic Optimization<a class="header-link" href="#exercise-3-heuristic-optimization" title="Permanent link">&para;</a></h3>
<p>Optimize the following query tree using heuristic rules:</p>
<div class="highlight"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">product_name</span><span class="p">,</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">category_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">products</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">categories</span><span class="w"> </span><span class="k">c</span><span class="p">,</span><span class="w"> </span><span class="n">order_items</span><span class="w"> </span><span class="n">oi</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">category_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">category_id</span>
<span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">product_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oi</span><span class="p">.</span><span class="n">product_id</span>
<span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="n">oi</span><span class="p">.</span><span class="n">quantity</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span>
<span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">category_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Electronics&#39;</span><span class="p">;</span>
</code></pre></div>

<p>Draw the initial and optimized query trees.</p>
<details>
<summary>Solution</summary>

**Initial (unoptimized) tree:**


<div class="highlight"><pre><span></span><code>Ï€_{product_name, category_name}
    â”‚
Ïƒ_{p.cat_id=c.cat_id âˆ§ p.prod_id=oi.prod_id âˆ§ oi.qty&gt;10 âˆ§ c.cat_name=&#39;Electronics&#39;}
    â”‚
    Ã—  (Cartesian product)
   / \
  Ã—   oi
 / \
p   c
</code></pre></div>



**Optimized tree (push selections down, use joins instead of Cartesian product):**


<div class="highlight"><pre><span></span><code>Ï€_{product_name, category_name}
    â”‚
    â‹ˆ_{p.cat_id = c.cat_id}
   / \
  â‹ˆ_{p.prod_id = oi.prod_id}    Ïƒ_{cat_name=&#39;Electronics&#39;}(c)
 / \
p   Ïƒ_{qty &gt; 10}(oi)
</code></pre></div>



**Optimizations applied:**
1. Decomposed conjunctive selection
2. Pushed Ïƒ_{qty > 10} to order_items (before join)
3. Pushed Ïƒ_{cat_name = 'Electronics'} to categories (before join)
4. Replaced Cartesian products with targeted joins
5. Projected early (not shown for clarity, but only needed columns pass through)

The key gain: categories filtered to ~1 row ('Electronics'), order_items filtered to a subset (qty > 10), before any joins occur.
</details>

<h3 id="exercise-4-join-algorithm-selection">Exercise 4: Join Algorithm Selection<a class="header-link" href="#exercise-4-join-algorithm-selection" title="Permanent link">&para;</a></h3>
<p>For each scenario, which join algorithm would the optimizer likely choose?</p>
<ol>
<li>Joining a 100-row lookup table with a 10M-row fact table. Index exists on the fact table's join column.</li>
<li>Joining two 1M-row tables, neither sorted, plenty of memory (1GB buffer pool).</li>
<li>Joining two 1M-row tables on a range condition (r.date BETWEEN s.start_date AND s.end_date).</li>
<li>Joining two tables where both are already sorted on the join column.</li>
</ol>
<details>
<summary>Solution</summary>

1. **Indexed nested loop join.** The lookup table (100 rows) is the outer; for each row, use the index on the fact table to find matches. Cost: 100 index lookups, each O(log n). Much faster than scanning 10M rows.

2. **Hash join.** With plenty of memory, one table's hash table fits entirely in memory. Cost: read both tables once (optimal). No index needed, no sorting needed.

3. **Sort-merge join** or **Block nested loop join.** Hash join doesn't work for range conditions (can't hash ranges). Sort-merge on the date columns allows efficient range matching. Block NLJ is a fallback if sorting is too expensive.

4. **Sort-merge join (skip the sort phase).** Both tables are already sorted, so the merge phase costs just b_r + b_s â€” a single pass through each table. This is optimal.
</details>

<h3 id="exercise-5-reading-execution-plans">Exercise 5: Reading Execution Plans<a class="header-link" href="#exercise-5-reading-execution-plans" title="Permanent link">&para;</a></h3>
<p>Given this PostgreSQL EXPLAIN output, answer the questions below:</p>
<div class="highlight"><pre><span></span><code><span class="n">Nested</span><span class="w"> </span><span class="nf">Loop</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.29</span><span class="p">.</span><span class="mf">.8.33</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="nf">Index</span><span class="w"> </span><span class="kr">Scan</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">idx_emp_id</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">employees</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.29</span><span class="p">.</span><span class="mf">.4.30</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="w">        </span><span class="nf">Index</span><span class="w"> </span><span class="n">Cond</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">emp_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="kr">Scan</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">departments</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.00</span><span class="p">.</span><span class="mf">.1.62</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>
<span class="w">        </span><span class="n">Filter</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">dept_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">employees</span><span class="p">.</span><span class="n">dept_id</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rows</span><span class="w"> </span><span class="n">Removed</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">Filter</span><span class="o">:</span><span class="w"> </span><span class="mi">49</span>
</code></pre></div>

<ol>
<li>What join algorithm is used?</li>
<li>Which table is the outer (driving) table?</li>
<li>Why does the optimizer use an index scan on employees?</li>
<li>Why is a sequential scan used on departments?</li>
<li>What is the estimated total cost?</li>
</ol>
<details>
<summary>Solution</summary>

1. **Nested Loop Join.**

2. **employees is the outer table** (listed first under Nested Loop). It drives the loop.

3. **Because emp_id = 42 is a highly selective equality predicate.** The index on emp_id finds exactly 1 row (rows=1). Reading the entire employees table would be wasteful.

4. **departments is small (50 rows, ~2 pages).** For each outer row (just 1 in this case), the entire departments table is scanned. Since there's only 1 outer row, the sequential scan runs only once. An index lookup might not be faster for a single probe on a tiny table.

5. **Total estimated cost: 8.33** (in PostgreSQL's cost units, where 1.0 â‰ˆ a sequential page read). This is very cheap â€” essentially 1 index lookup + 1 small table scan.
</details>

<h3 id="exercise-6-equivalence-rules">Exercise 6: Equivalence Rules<a class="header-link" href="#exercise-6-equivalence-rules" title="Permanent link">&para;</a></h3>
<p>Using equivalence rules, show that these two expressions produce the same result:</p>
<p><strong>Expression A:</strong></p>
<div class="highlight"><pre><span></span><code>Ïƒ_{dept=&#39;CS&#39;}(employees â‹ˆ departments)
</code></pre></div>

<p><strong>Expression B:</strong></p>
<div class="highlight"><pre><span></span><code>employees â‹ˆ Ïƒ_{dept=&#39;CS&#39;}(departments)
</code></pre></div>

<p>Which is more efficient and why?</p>
<details>
<summary>Solution</summary>

**Proof of equivalence:**

By Rule 6 (Push selection through join), if the predicate dept='CS' involves only attributes of departments:


<div class="highlight"><pre><span></span><code>Ïƒ_{dept=&#39;CS&#39;}(employees â‹ˆ departments) = employees â‹ˆ Ïƒ_{dept=&#39;CS&#39;}(departments)
</code></pre></div>



This is valid because:
1. The join produces all matching (employee, department) pairs
2. The selection then filters to dept='CS'
3. Equivalently, we can filter departments first to get only the CS department, then join

**Expression B is more efficient** because:
- Expression A: Join ALL employees with ALL departments (10,000 Ã— 50 combinations to evaluate), then filter. The join produces 10,000 rows, then the filter keeps only ~200 (if 1/50 are in CS).
- Expression B: Filter departments first (50 â†’ 1 row), then join. The join only needs to match employees against 1 department row. Much less work.

The size of intermediate results:
- A: 10,000 intermediate rows â†’ filter â†’ 200 final rows
- B: 1 intermediate row Ã— employees â†’ 200 final rows directly
</details>

<h3 id="exercise-7-cost-based-optimization">Exercise 7: Cost-Based Optimization<a class="header-link" href="#exercise-7-cost-based-optimization" title="Permanent link">&para;</a></h3>
<p>Given three tables and their statistics:</p>
<div class="highlight"><pre><span></span><code>orders (o):     n = 100,000,  b = 5,000
customers (c):  n = 10,000,   b = 500
products (p):   n = 1,000,    b = 50
</code></pre></div>

<p>Join predicates: o.cust_id = c.cust_id AND o.prod_id = p.prod_id</p>
<p>Assume hash join and M = 100 pages. Compare these two join orderings:</p>
<p><strong>Plan A</strong>: (orders â‹ˆ customers) â‹ˆ products
<strong>Plan B</strong>: (orders â‹ˆ products) â‹ˆ customers</p>
<details>
<summary>Solution</summary>

**Plan A: (orders â‹ˆ customers) â‹ˆ products**

Step 1: orders â‹ˆ customers (hash join, customers as build)
- Build: 500 blocks (customers fits in 100 pages? No, 500 > 100. Need Grace hash join.)
- Grace hash join cost: 3 Ã— (5,000 + 500) = 16,500 transfers
- Result size: 100,000 rows (each order has one customer)
- Result blocks: ~5,000 (similar to orders)

Step 2: result â‹ˆ products (hash join, products as build)
- Build: 50 blocks (products fits in 100 pages. In-memory hash join.)
- Cost: 5,000 + 50 = 5,050 transfers
- Total for Plan A: 16,500 + 5,050 = **21,550 transfers**

**Plan B: (orders â‹ˆ products) â‹ˆ customers**

Step 1: orders â‹ˆ products (hash join, products as build)
- Build: 50 blocks (products fits in memory!)
- In-memory hash join cost: 5,000 + 50 = 5,050 transfers
- Result size: 100,000 rows (each order has one product)
- Result blocks: ~5,000

Step 2: result â‹ˆ customers (hash join, customers as build)
- Build: 500 blocks (doesn't fit in 100 pages. Grace hash join.)
- Cost: 3 Ã— (5,000 + 500) = 16,500 transfers
- Total for Plan B: 5,050 + 16,500 = **21,550 transfers**

Interestingly, the total transfer count is the same! But Plan B is slightly better because:
1. Step 1 uses in-memory hash join (fewer seeks, better cache)
2. The intermediate result of Step 1 might be pipelined into Step 2

A smarter approach: Build hash tables on BOTH small tables (products: 50, customers: 500), then scan orders once:

**Plan C**: Scan orders once, probe both hash tables
- Cost: 5,000 + 500 + 50 = 5,550 transfers (if both hash tables fit in memory â€” they need 550 pages, which exceeds M=100)

With M=600, Plan C would be optimal.
</details>

<hr />
<h2 id="12-summary">12. Summary<a class="header-link" href="#12-summary" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>Concept</th>
<th>Key Point</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Query Processing Pipeline</strong></td>
<td>Parse â†’ Optimize â†’ Execute</td>
</tr>
<tr>
<td><strong>Iterator Model</strong></td>
<td>open/next/close interface; tuples flow upward through operator tree</td>
</tr>
<tr>
<td><strong>Pipelining</strong></td>
<td>Avoids materializing intermediate results</td>
</tr>
<tr>
<td><strong>Selection algorithms</strong></td>
<td>Linear scan, binary search, index scan; choice depends on selectivity</td>
</tr>
<tr>
<td><strong>Join algorithms</strong></td>
<td>NLJ, Block NLJ, Indexed NLJ, Sort-Merge, Hash Join</td>
</tr>
<tr>
<td><strong>Hash join</strong></td>
<td>Optimal when build relation fits in memory: cost = b_r + b_s</td>
</tr>
<tr>
<td><strong>Sort-merge join</strong></td>
<td>Best for pre-sorted data and range joins</td>
</tr>
<tr>
<td><strong>Heuristic optimization</strong></td>
<td>Push selections down, push projections down, reorder joins</td>
</tr>
<tr>
<td><strong>Cost-based optimization</strong></td>
<td>Use statistics to estimate cost; dynamic programming for join ordering</td>
</tr>
<tr>
<td><strong>Statistics</strong></td>
<td>Histograms, distinct values, correlation â€” essential for good plans</td>
</tr>
<tr>
<td><strong>Plan caching</strong></td>
<td>Avoid repeated parsing/optimization for prepared statements</td>
</tr>
</tbody>
</table>
<p>Query processing is where database theory meets systems engineering. Understanding these concepts helps you write better queries, create appropriate indexes (covered in the next lesson), and diagnose performance problems by reading execution plans.</p>
<hr />
<p><strong>Previous</strong>: <a href="./07_Advanced_Normalization.md">07_Advanced_Normalization.md</a> | <strong>Next</strong>: <a href="./09_Indexing.md">09_Indexing.md</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Database_Theory/07_Advanced_Normalization.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 07: Advanced Normalization</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Database_Theory/09_Indexing.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">09. Indexing</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">â†‘</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}