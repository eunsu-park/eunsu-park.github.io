{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>15. 2D MHD Solver - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/MHD/">MHD</a>
    <span class="separator">/</span>
    <span class="current">15. 2D MHD Solver</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>15. 2D MHD Solver</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/MHD/14_Space_Weather.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">14. Space Weather MHD</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/MHD/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/MHD/16_Relativistic_MHD.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">16. Relativistic MHD</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#learning-objectives">Learning Objectives</a></li>
<li><a href="#1-introduction-to-2d-mhd">1. Introduction to 2D MHD</a><ul>
<li><a href="#11-2d-mhd-equations">1.1 2D MHD Equations</a></li>
<li><a href="#12-divergence-constraint">1.2 Divergence Constraint</a></li>
<li><a href="#13-challenges-in-2d">1.3 Challenges in 2D</a></li>
</ul>
</li>
<li><a href="#2-finite-volume-method-in-2d">2. Finite Volume Method in 2D</a><ul>
<li><a href="#21-cell-centered-discretization">2.1 Cell-Centered Discretization</a></li>
<li><a href="#22-semi-discrete-form">2.2 Semi-Discrete Form</a></li>
<li><a href="#23-dimensional-splitting-strang-splitting">2.3 Dimensional Splitting (Strang Splitting)</a></li>
<li><a href="#24-unsplit-methods">2.4 Unsplit Methods</a></li>
</ul>
</li>
<li><a href="#3-constrained-transport-ct">3. Constrained Transport (CT)</a><ul>
<li><a href="#31-yee-mesh-staggered-grid">3.1 Yee Mesh (Staggered Grid)</a></li>
<li><a href="#32-faradays-law-in-integral-form">3.2 Faraday's Law in Integral Form</a></li>
<li><a href="#33-electric-field-calculation">3.3 Electric Field Calculation</a></li>
<li><a href="#34-divergence-free-guarantee">3.4 Divergence-Free Guarantee</a></li>
</ul>
</li>
<li><a href="#4-higher-order-reconstruction">4. Higher-Order Reconstruction</a><ul>
<li><a href="#41-piecewise-linear-method-plm">4.1 Piecewise Linear Method (PLM)</a></li>
<li><a href="#42-weno-weighted-essentially-non-oscillatory">4.2 WENO (Weighted Essentially Non-Oscillatory)</a></li>
<li><a href="#43-characteristic-vs-primitive-variable-reconstruction">4.3 Characteristic vs. Primitive Variable Reconstruction</a></li>
</ul>
</li>
<li><a href="#5-time-integration">5. Time Integration</a><ul>
<li><a href="#51-cfl-condition-in-2d">5.1 CFL Condition in 2D</a></li>
<li><a href="#52-time-stepping-schemes">5.2 Time Stepping Schemes</a></li>
</ul>
</li>
<li><a href="#6-benchmark-problem-orszag-tang-vortex">6. Benchmark Problem: Orszag-Tang Vortex</a><ul>
<li><a href="#61-initial-conditions">6.1 Initial Conditions</a></li>
<li><a href="#62-evolution">6.2 Evolution</a></li>
<li><a href="#63-expected-results">6.3 Expected Results</a></li>
</ul>
</li>
<li><a href="#7-kelvin-helmholtz-instability-in-mhd">7. Kelvin-Helmholtz Instability in MHD</a><ul>
<li><a href="#71-setup">7.1 Setup</a></li>
<li><a href="#72-linear-stability-analysis">7.2 Linear Stability Analysis</a></li>
<li><a href="#73-numerical-simulation">7.3 Numerical Simulation</a></li>
</ul>
</li>
<li><a href="#8-python-implementation-2d-mhd-solver-with-ct">8. Python Implementation: 2D MHD Solver with CT</a><ul>
<li><a href="#81-data-structures">8.1 Data Structures</a></li>
<li><a href="#82-ct-update-for-magnetic-field">8.2 CT Update for Magnetic Field</a></li>
<li><a href="#83-full-2d-mhd-solver-simplified">8.3 Full 2D MHD Solver (Simplified)</a></li>
<li><a href="#84-orszag-tang-vortex-setup">8.4 Orszag-Tang Vortex Setup</a></li>
<li><a href="#85-simple-forward-euler-update-for-demonstration">8.5 Simple Forward Euler Update (for demonstration)</a></li>
<li><a href="#86-visualization">8.6 Visualization</a></li>
<li><a href="#87-kelvin-helmholtz-instability-setup">8.7 Kelvin-Helmholtz Instability Setup</a></li>
<li><a href="#88-production-quality-codes">8.8 Production-Quality Codes</a></li>
</ul>
</li>
<li><a href="#9-advanced-topics">9. Advanced Topics</a><ul>
<li><a href="#91-adaptive-mesh-refinement-amr">9.1 Adaptive Mesh Refinement (AMR)</a></li>
<li><a href="#92-divergence-cleaning">9.2 Divergence Cleaning</a></li>
<li><a href="#93-positivity-preserving-methods">9.3 Positivity-Preserving Methods</a></li>
<li><a href="#94-high-order-methods">9.4 High-Order Methods</a></li>
</ul>
</li>
<li><a href="#10-summary">10. Summary</a></li>
<li><a href="#practice-problems">Practice Problems</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="15-2d-mhd-solver">15. 2D MHD Solver<a class="header-link" href="#15-2d-mhd-solver" title="Permanent link">&para;</a></h1>
<h2 id="learning-objectives">Learning Objectives<a class="header-link" href="#learning-objectives" title="Permanent link">&para;</a></h2>
<ul>
<li>Extend 1D MHD methods to 2D using dimensional splitting and unsplit schemes</li>
<li>Implement finite volume methods on 2D Cartesian grids</li>
<li>Apply Constrained Transport (CT) to preserve $\nabla \cdot B = 0$ exactly</li>
<li>Use staggered grids (Yee mesh) for magnetic field components</li>
<li>Implement higher-order reconstruction: PLM, WENO</li>
<li>Simulate benchmark problems: Orszag-Tang vortex, Kelvin-Helmholtz instability</li>
<li>Understand corner transport upwind (CTU) methods</li>
</ul>
<h2 id="1-introduction-to-2d-mhd">1. Introduction to 2D MHD<a class="header-link" href="#1-introduction-to-2d-mhd" title="Permanent link">&para;</a></h2>
<p>Extending MHD simulations from 1D to 2D introduces new challenges: multidimensional wave propagation, geometric source terms, and the critical requirement of preserving $\nabla \cdot B = 0$ in multiple dimensions.</p>
<h3 id="11-2d-mhd-equations">1.1 2D MHD Equations<a class="header-link" href="#11-2d-mhd-equations" title="Permanent link">&para;</a></h3>
<p>In 2D Cartesian coordinates $(x, y)$, the ideal MHD equations are:</p>
<div class="highlight"><pre><span></span><code>‚àÇU/‚àÇt + ‚àÇF/‚àÇx + ‚àÇG/‚àÇy = 0
</code></pre></div>

<p>where the conserved variables are:</p>
<div class="highlight"><pre><span></span><code>U = [œÅ, œÅv_x, œÅv_y, œÅv_z, B_x, B_y, B_z, E]·µÄ
</code></pre></div>

<p>The fluxes in the $x$ direction:</p>
<div class="highlight"><pre><span></span><code>F = [œÅv_x, œÅv_x¬≤ + p_T - B_x¬≤/Œº‚ÇÄ, œÅv_x v_y - B_x B_y/Œº‚ÇÄ, œÅv_x v_z - B_x B_z/Œº‚ÇÄ,
     0, v_x B_y - v_y B_x, v_x B_z - v_z B_x,
     v_x(E + p_T) - B_x(v¬∑B)/Œº‚ÇÄ]·µÄ
</code></pre></div>

<p>and similarly for $G$ (fluxes in $y$ direction), with total pressure:</p>
<div class="highlight"><pre><span></span><code>p_T = p + B¬≤/(2Œº‚ÇÄ)
</code></pre></div>

<h3 id="12-divergence-constraint">1.2 Divergence Constraint<a class="header-link" href="#12-divergence-constraint" title="Permanent link">&para;</a></h3>
<p>The magnetic field must satisfy:</p>
<div class="highlight"><pre><span></span><code>‚àá ¬∑ B = ‚àÇB_x/‚àÇx + ‚àÇB_y/‚àÇy = 0
</code></pre></div>

<p>In 1D, this reduces to $\partial B_x / \partial x = 0$, which is automatically satisfied if $B_x$ is constant initially. In 2D, preserving $\nabla \cdot B = 0$ requires special numerical treatment.</p>
<p><strong>Consequences of violating $\nabla \cdot B = 0$:</strong>
- Unphysical monopole forces
- Numerical instabilities
- Incorrect wave speeds and shock structure</p>
<h3 id="13-challenges-in-2d">1.3 Challenges in 2D<a class="header-link" href="#13-challenges-in-2d" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>Computational cost</strong>: $N_x \times N_y$ cells, $\mathcal{O}(N^2)$ operations per timestep</li>
<li><strong>Multidimensional effects</strong>: Corner coupling, transverse waves</li>
<li><strong>Divergence preservation</strong>: Requires specialized discretization (CT, divergence cleaning, etc.)</li>
<li><strong>CFL condition</strong>: Timestep limited by 2D wave propagation</li>
</ol>
<h2 id="2-finite-volume-method-in-2d">2. Finite Volume Method in 2D<a class="header-link" href="#2-finite-volume-method-in-2d" title="Permanent link">&para;</a></h2>
<h3 id="21-cell-centered-discretization">2.1 Cell-Centered Discretization<a class="header-link" href="#21-cell-centered-discretization" title="Permanent link">&para;</a></h3>
<p>Divide the domain into rectangular cells $[x_{i-1/2}, x_{i+1/2}] \times [y_{j-1/2}, y_{j+1/2}]$.</p>
<p>Cell-averaged conserved variables:</p>
<div class="highlight"><pre><span></span><code>U_{i,j} = (1/ŒîxŒîy) ‚à´‚à´ U(x,y,t) dx dy
</code></pre></div>

<h3 id="22-semi-discrete-form">2.2 Semi-Discrete Form<a class="header-link" href="#22-semi-discrete-form" title="Permanent link">&para;</a></h3>
<p>The finite volume discretization:</p>
<div class="highlight"><pre><span></span><code>dU_{i,j}/dt = -(F_{i+1/2,j} - F_{i-1/2,j})/Œîx - (G_{i,j+1/2} - G_{i,j-1/2})/Œîy
</code></pre></div>

<p>Fluxes at cell faces are computed from Riemann solvers (HLL, HLLD, Roe, etc.).</p>
<h3 id="23-dimensional-splitting-strang-splitting">2.3 Dimensional Splitting (Strang Splitting)<a class="header-link" href="#23-dimensional-splitting-strang-splitting" title="Permanent link">&para;</a></h3>
<p><strong>Idea</strong>: Split 2D evolution into alternating 1D sweeps.</p>
<p>For one timestep $\Delta t$:</p>
<ol>
<li><strong>Half step in $x$</strong>: Evolve using $\partial U / \partial t + \partial F / \partial x = 0$ for $\Delta t / 2$</li>
<li><strong>Full step in $y$</strong>: Evolve using $\partial U / \partial t + \partial G / \partial y = 0$ for $\Delta t$</li>
<li><strong>Half step in $x$</strong>: Evolve again in $x$ for $\Delta t / 2$</li>
</ol>
<p>This is <strong>Strang splitting</strong> (second-order accurate in time if each 1D step is second-order).</p>
<p><strong>Advantages:</strong>
- Reuse 1D Riemann solvers
- Simple to implement</p>
<p><strong>Disadvantages:</strong>
- Anisotropic errors (directional bias)
- Difficult to preserve $\nabla \cdot B = 0$ across dimension splits</p>
<h3 id="24-unsplit-methods">2.4 Unsplit Methods<a class="header-link" href="#24-unsplit-methods" title="Permanent link">&para;</a></h3>
<p><strong>Corner Transport Upwind (CTU)</strong> methods update all directions simultaneously, including transverse flux corrections.</p>
<p><strong>Algorithm</strong> (simplified CTU):</p>
<ol>
<li>Reconstruct states at cell faces in both $x$ and $y$ directions</li>
<li>Solve Riemann problems at all faces</li>
<li>Compute transverse flux corrections (e.g., upwind corner states)</li>
<li>Update conserved variables including corner coupling</li>
</ol>
<p>CTU methods are fully multidimensional and reduce directional bias.</p>
<h2 id="3-constrained-transport-ct">3. Constrained Transport (CT)<a class="header-link" href="#3-constrained-transport-ct" title="Permanent link">&para;</a></h2>
<p>Constrained Transport is a numerical method that preserves $\nabla \cdot B = 0$ to machine precision by using a staggered grid for magnetic fields and evolving the magnetic field via Faraday's law in integral form.</p>
<h3 id="31-yee-mesh-staggered-grid">3.1 Yee Mesh (Staggered Grid)<a class="header-link" href="#31-yee-mesh-staggered-grid" title="Permanent link">&para;</a></h3>
<p><strong>Cell-centered quantities</strong> (at $(x_i, y_j)$):
- $\rho, p, v_x, v_y, v_z, E$</p>
<p><strong>Face-centered magnetic field</strong> (staggered):
- $B_x$ at $(x_{i-1/2}, y_j)$ (faces perpendicular to $x$)
- $B_y$ at $(x_i, y_{j-1/2})$ (faces perpendicular to $y$)
- $B_z$ at cell centers $(x_i, y_j)$ (if $B_z$ is present but does not affect divergence in 2D)</p>
<p><strong>Edge-centered electric field</strong>:
- $E_z$ at $(x_i, y_j)$ (cell corners in 2D $xy$ plane)</p>
<h3 id="32-faradays-law-in-integral-form">3.2 Faraday's Law in Integral Form<a class="header-link" href="#32-faradays-law-in-integral-form" title="Permanent link">&para;</a></h3>
<p>Faraday's law:</p>
<div class="highlight"><pre><span></span><code>‚àÇB/‚àÇt = -‚àá √ó E
</code></pre></div>

<p>In 2D (with $B = (B_x, B_y, B_z)$ and $E_z$ the only relevant electric field component):</p>
<div class="highlight"><pre><span></span><code>‚àÇB_x/‚àÇt = -‚àÇE_z/‚àÇy
‚àÇB_y/‚àÇt = ‚àÇE_z/‚àÇx
</code></pre></div>

<p>Integrate over cell faces:</p>
<div class="highlight"><pre><span></span><code>d/dt ‚à´ B_x dy = -[E_z(top) - E_z(bottom)]
d/dt ‚à´ B_y dx = [E_z(right) - E_z(left)]
</code></pre></div>

<p>This naturally preserves $\nabla \cdot B = 0$ if it holds initially.</p>
<h3 id="33-electric-field-calculation">3.3 Electric Field Calculation<a class="header-link" href="#33-electric-field-calculation" title="Permanent link">&para;</a></h3>
<p>The electric field in ideal MHD:</p>
<div class="highlight"><pre><span></span><code>E = -v √ó B
</code></pre></div>

<p>In 2D:</p>
<div class="highlight"><pre><span></span><code>E_z = v_x B_y - v_y B_x
</code></pre></div>

<p><strong>CT algorithm</strong>:</p>
<ol>
<li><strong>Reconstruct primitive variables</strong> at cell faces</li>
<li><strong>Solve Riemann problems</strong> to get face-centered velocities and magnetic fields</li>
<li>
<p><strong>Compute electric field at cell edges</strong> using upwinded $v$ and $B$ from adjacent faces:
   <code>E_z(i,j) = [v_x B_y - v_y B_x]_{i,j}</code>
   Averaging strategies: arithmetic mean, upwind, Riemann solver-based</p>
</li>
<li>
<p><strong>Update magnetic field</strong> using discrete Faraday's law:
   <code>B_x(i-1/2, j)^{n+1} = B_x(i-1/2, j)^n - Œît/Œîy [E_z(i,j+1/2) - E_z(i,j-1/2)]
   B_y(i, j-1/2)^{n+1} = B_y(i, j-1/2)^n + Œît/Œîx [E_z(i+1/2,j) - E_z(i-1/2,j)]</code></p>
</li>
</ol>
<h3 id="34-divergence-free-guarantee">3.4 Divergence-Free Guarantee<a class="header-link" href="#34-divergence-free-guarantee" title="Permanent link">&para;</a></h3>
<p>Since the discrete update is derived from the integral form of Faraday's law, the discrete divergence:</p>
<div class="highlight"><pre><span></span><code>(‚àá ¬∑ B)_{i,j} = [B_x(i+1/2,j) - B_x(i-1/2,j)]/Œîx + [B_y(i,j+1/2) - B_y(i,j-1/2)]/Œîy
</code></pre></div>

<p>is preserved to machine precision (if zero initially).</p>
<h2 id="4-higher-order-reconstruction">4. Higher-Order Reconstruction<a class="header-link" href="#4-higher-order-reconstruction" title="Permanent link">&para;</a></h2>
<h3 id="41-piecewise-linear-method-plm">4.1 Piecewise Linear Method (PLM)<a class="header-link" href="#41-piecewise-linear-method-plm" title="Permanent link">&para;</a></h3>
<p>Second-order spatial accuracy requires reconstructing the solution within each cell as linear:</p>
<div class="highlight"><pre><span></span><code>U(x) = U_i + œÉ_i (x - x_i)
</code></pre></div>

<p>where $\sigma_i$ is the slope, estimated from neighboring cells:</p>
<div class="highlight"><pre><span></span><code>œÉ_i ‚âà (U_{i+1} - U_{i-1}) / (2Œîx)  (centered difference)
</code></pre></div>

<p><strong>Slope limiting</strong>: To prevent spurious oscillations near discontinuities, apply a limiter:</p>
<div class="highlight"><pre><span></span><code>œÉ_i = minmod(œÉ_L, œÉ_C, œÉ_R)
</code></pre></div>

<p>where:
- $\sigma_L = (U_i - U_{i-1}) / \Delta x$
- $\sigma_C = (U_{i+1} - U_{i-1}) / (2 \Delta x)$
- $\sigma_R = (U_{i+1} - U_i) / \Delta x$</p>
<p><strong>minmod limiter</strong>:</p>
<div class="highlight"><pre><span></span><code>minmod(a, b, c) =
    min(|a|, |b|, |c|) * sign(a)  if sign(a) = sign(b) = sign(c)
    0                              otherwise
</code></pre></div>

<p>Other limiters: MC (monotonized central), van Leer, superbee.</p>
<h3 id="42-weno-weighted-essentially-non-oscillatory">4.2 WENO (Weighted Essentially Non-Oscillatory)<a class="header-link" href="#42-weno-weighted-essentially-non-oscillatory" title="Permanent link">&para;</a></h3>
<p>WENO schemes achieve high-order accuracy (5th order or higher) by using weighted combinations of multiple stencils.</p>
<p><strong>WENO5 reconstruction</strong> (simplified):</p>
<p>Use 5-point stencil $\{U_{i-2}, U_{i-1}, U_i, U_{i+1}, U_{i+2}\}$ to construct three 3-point candidate polynomials, then blend them with smoothness-based weights to obtain the reconstructed value at $x_{i+1/2}$.</p>
<p><strong>Advantages</strong>:
- High-order accuracy in smooth regions
- Non-oscillatory near discontinuities</p>
<p><strong>Disadvantages</strong>:
- Computationally expensive (large stencil, nonlinear weights)
- Complex implementation</p>
<h3 id="43-characteristic-vs-primitive-variable-reconstruction">4.3 Characteristic vs. Primitive Variable Reconstruction<a class="header-link" href="#43-characteristic-vs-primitive-variable-reconstruction" title="Permanent link">&para;</a></h3>
<p>Reconstruction can be done in:
- <strong>Primitive variables</strong> $(\\rho, v_x, v_y, v_z, B_x, B_y, B_z, p)$: Simpler, but may produce unphysical states
- <strong>Conserved variables</strong> $U$: Guarantees conservation, but can generate oscillations
- <strong>Characteristic variables</strong> $W = L \cdot U$: Decouple waves, best for capturing discontinuities</p>
<p>For MHD, characteristic reconstruction is preferred but requires solving for eigenvectors of the Jacobian (expensive in 2D/3D).</p>
<h2 id="5-time-integration">5. Time Integration<a class="header-link" href="#5-time-integration" title="Permanent link">&para;</a></h2>
<h3 id="51-cfl-condition-in-2d">5.1 CFL Condition in 2D<a class="header-link" href="#51-cfl-condition-in-2d" title="Permanent link">&para;</a></h3>
<p>The timestep is limited by:</p>
<div class="highlight"><pre><span></span><code>Œît ‚â§ CFL * min(Œîx, Œîy) / max(|Œª|)
</code></pre></div>

<p>where $\lambda$ are the wave speeds (fast magnetosonic, Alfv√©n, slow magnetosonic, entropy).</p>
<p>For safety, typically $CFL \approx 0.4-0.8$.</p>
<h3 id="52-time-stepping-schemes">5.2 Time Stepping Schemes<a class="header-link" href="#52-time-stepping-schemes" title="Permanent link">&para;</a></h3>
<p><strong>Second-order Runge-Kutta (RK2)</strong>:</p>
<div class="highlight"><pre><span></span><code>U* = U^n + Œît L(U^n)
U^{n+1} = 0.5 U^n + 0.5 U* + 0.5 Œît L(U*)
</code></pre></div>

<p>where $L(U) = -(‚àÇF/‚àÇx + ‚àÇG/‚àÇy)$ is the spatial operator.</p>
<p><strong>Third-order Runge-Kutta (RK3)</strong> (TVD-RK3):</p>
<div class="highlight"><pre><span></span><code>U^{(1)} = U^n + Œît L(U^n)
U^{(2)} = 3/4 U^n + 1/4 U^{(1)} + 1/4 Œît L(U^{(1)})
U^{n+1} = 1/3 U^n + 2/3 U^{(2)} + 2/3 Œît L(U^{(2)})
</code></pre></div>

<p>RK3 is commonly used with WENO schemes.</p>
<h2 id="6-benchmark-problem-orszag-tang-vortex">6. Benchmark Problem: Orszag-Tang Vortex<a class="header-link" href="#6-benchmark-problem-orszag-tang-vortex" title="Permanent link">&para;</a></h2>
<p>The <strong>Orszag-Tang vortex</strong> is a standard 2D MHD test problem featuring the formation of shocks, current sheets, and complex vortex structures.</p>
<h3 id="61-initial-conditions">6.1 Initial Conditions<a class="header-link" href="#61-initial-conditions" title="Permanent link">&para;</a></h3>
<p>Domain: $[0, 1] \times [0, 1]$ with periodic boundary conditions.</p>
<div class="highlight"><pre><span></span><code>œÅ = Œ≥¬≤
p = Œ≥
v_x = -sin(2œÄy)
v_y = sin(2œÄx)
v_z = 0
B_x = -sin(2œÄy) / sqrt(4œÄ)
B_y = sin(4œÄx) / sqrt(4œÄ)
B_z = 0
</code></pre></div>

<p>where $\gamma = 5/3$ (adiabatic index).</p>
<p>This setup has $\beta \sim 1$ (comparable plasma and magnetic pressure) and creates a turbulent cascade.</p>
<h3 id="62-evolution">6.2 Evolution<a class="header-link" href="#62-evolution" title="Permanent link">&para;</a></h3>
<p>As the vortex evolves:
- Shocks form and interact
- Current sheets develop at boundaries between oppositely directed fields
- Magnetic reconnection occurs
- Vorticity cascades to smaller scales</p>
<p><strong>Key diagnostics</strong>:
- Density contours: Show shock structures
- Magnetic field lines: Illustrate reconnection and topology changes
- Current density $|j_z| = |\nabla \times B|_z$: Locates current sheets</p>
<h3 id="63-expected-results">6.3 Expected Results<a class="header-link" href="#63-expected-results" title="Permanent link">&para;</a></h3>
<p>At $t \approx 0.5$, a complex pattern of shocks and vortices emerges. High-resolution simulations (512¬≤ or higher) are required to resolve fine structures.</p>
<h2 id="7-kelvin-helmholtz-instability-in-mhd">7. Kelvin-Helmholtz Instability in MHD<a class="header-link" href="#7-kelvin-helmholtz-instability-in-mhd" title="Permanent link">&para;</a></h2>
<p>The <strong>Kelvin-Helmholtz (KH) instability</strong> arises at the interface between two fluids in relative shear motion.</p>
<h3 id="71-setup">7.1 Setup<a class="header-link" href="#71-setup" title="Permanent link">&para;</a></h3>
<p>Domain: $[0, 1] \times [-1, 1]$ with periodic boundary in $x$, reflecting or periodic in $y$.</p>
<p><strong>Velocity shear layer</strong>:</p>
<div class="highlight"><pre><span></span><code>v_x(y) = -V‚ÇÄ tanh(y / a)
v_y = Œ¥v‚ÇÄ sin(2œÄx)  (perturbation)
</code></pre></div>

<p>where $V_0$ is the shear velocity, $a$ is the shear layer thickness, and $\delta v_0 \ll V_0$ is the perturbation amplitude.</p>
<p><strong>Magnetic field</strong> (uniform in $x$ direction):</p>
<div class="highlight"><pre><span></span><code>B_x = B‚ÇÄ
B_y = 0
</code></pre></div>

<h3 id="72-linear-stability-analysis">7.2 Linear Stability Analysis<a class="header-link" href="#72-linear-stability-analysis" title="Permanent link">&para;</a></h3>
<p>In the absence of magnetic field, the KH growth rate for mode $k$ is:</p>
<div class="highlight"><pre><span></span><code>Œ≥_KH ~ k V‚ÇÄ / 2  (for thin shear layer)
</code></pre></div>

<p>With magnetic field, magnetic tension stabilizes short wavelengths. The dispersion relation:</p>
<div class="highlight"><pre><span></span><code>Œ≥¬≤ = k¬≤ V‚ÇÄ¬≤ - k¬≤ v_A¬≤
</code></pre></div>

<p>where $v_A = B_0 / \sqrt{\mu_0 \rho}$ is the Alfv√©n speed.</p>
<p><strong>Stabilization condition</strong>:</p>
<div class="highlight"><pre><span></span><code>B‚ÇÄ &gt; sqrt(Œº‚ÇÄ œÅ) V‚ÇÄ  (v_A &gt; V‚ÇÄ)
</code></pre></div>

<p>If $v_A > V_0$, the KH mode is suppressed.</p>
<h3 id="73-numerical-simulation">7.3 Numerical Simulation<a class="header-link" href="#73-numerical-simulation" title="Permanent link">&para;</a></h3>
<p>Initial conditions:</p>
<div class="highlight"><pre><span></span><code>œÅ = 1
p = 1
v_x = -V‚ÇÄ tanh(y / a)
v_y = Œ¥v‚ÇÄ sin(2œÄx)
B_x = B‚ÇÄ
B_y = 0
</code></pre></div>

<p>Typical parameters: $V_0 = 1$, $a = 0.1$, $\delta v_0 = 0.01$, $B_0 = 0$ to $2$.</p>
<p><strong>Observations</strong>:
- $B_0 = 0$: Classic KH rolls develop
- $B_0 = 0.5$: KH growth slowed, but still unstable
- $B_0 = 2$: KH suppressed, magnetic tension stabilizes</p>
<h2 id="8-python-implementation-2d-mhd-solver-with-ct">8. Python Implementation: 2D MHD Solver with CT<a class="header-link" href="#8-python-implementation-2d-mhd-solver-with-ct" title="Permanent link">&para;</a></h2>
<h3 id="81-data-structures">8.1 Data Structures<a class="header-link" href="#81-data-structures" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">animation</span>

<span class="k">class</span><span class="w"> </span><span class="nc">MHD2D</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">5</span><span class="o">/</span><span class="mi">3</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Nx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ny</span> <span class="o">=</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Lx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ly</span> <span class="o">=</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Ly</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="n">Lx</span> <span class="o">/</span> <span class="n">Nx</span><span class="p">,</span> <span class="n">Ly</span> <span class="o">/</span> <span class="n">Ny</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>

        <span class="c1"># Cell centers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">Lx</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">Nx</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="n">Ly</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="n">Ny</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>

        <span class="c1"># Staggered grid for magnetic field (CT)</span>
        <span class="c1"># Bx at (i-1/2, j), By at (i, j-1/2)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_Bx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Lx</span><span class="p">,</span> <span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_By</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Ly</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Conserved variables (cell-centered)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">my</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>

        <span class="c1"># Magnetic field (staggered)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Bx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>  <span class="c1"># Face-centered in x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">By</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># Face-centered in y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Bz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">))</span>    <span class="c1"># Cell-centered (if needed)</span>

        <span class="c1"># Electric field (edge-centered)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ez</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Nx</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">Ny</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">primitive_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute primitive variables from conserved.&quot;&quot;&quot;</span>
        <span class="n">vx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mx</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span>
        <span class="n">vy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">my</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span>
        <span class="n">vz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mz</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span>

        <span class="c1"># Average magnetic field to cell centers</span>
        <span class="n">Bx_cc</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Bx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bx</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>
        <span class="n">By_cc</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">By</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">By</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>
        <span class="n">Bz_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bz</span>

        <span class="n">B2</span> <span class="o">=</span> <span class="n">Bx_cc</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">By_cc</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Bz_cc</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">E</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">vx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">vy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">vz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">B2</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">,</span> <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">Bx_cc</span><span class="p">,</span> <span class="n">By_cc</span><span class="p">,</span> <span class="n">Bz_cc</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">compute_dt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">CFL</span><span class="o">=</span><span class="mf">0.4</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute timestep based on CFL condition.&quot;&quot;&quot;</span>
        <span class="n">rho</span><span class="p">,</span> <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">Bx</span><span class="p">,</span> <span class="n">By</span><span class="p">,</span> <span class="n">Bz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">primitive_variables</span><span class="p">()</span>

        <span class="c1"># Fast magnetosonic speed</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gamma</span> <span class="o">*</span> <span class="n">p</span> <span class="o">/</span> <span class="n">rho</span><span class="p">)</span>
        <span class="n">va</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">Bx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">By</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">Bz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">rho</span><span class="p">)</span>
        <span class="n">cf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">cs</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">va</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="n">dt_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vx</span><span class="p">)</span> <span class="o">+</span> <span class="n">cf</span><span class="p">)</span>
        <span class="n">dt_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">vy</span><span class="p">)</span> <span class="o">+</span> <span class="n">cf</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">CFL</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">dt_x</span><span class="p">,</span> <span class="n">dt_y</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_divergence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check divergence of B (should be ~0).&quot;&quot;&quot;</span>
        <span class="n">div_B</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Bx</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">+</span> \
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">By</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">By</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">div_B</span><span class="p">))</span>
</code></pre></div>

<h3 id="82-ct-update-for-magnetic-field">8.2 CT Update for Magnetic Field<a class="header-link" href="#82-ct-update-for-magnetic-field" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update_magnetic_field_CT</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update magnetic field using Constrained Transport.&quot;&quot;&quot;</span>
    <span class="c1"># Compute electric field Ez at cell corners (edges in 2D)</span>
    <span class="c1"># Ez = vx * By - vy * Bx</span>

    <span class="c1"># Need velocities and B fields at corners</span>
    <span class="c1"># Simple averaging (can be improved with Riemann solver values)</span>

    <span class="c1"># Average vx to y-edges</span>
    <span class="n">vx_avg_y</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">mx</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>
    <span class="n">vx_avg_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">vx_avg_y</span><span class="p">,</span> <span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>  <span class="c1"># Periodic</span>

    <span class="c1"># Average vy to x-edges</span>
    <span class="n">vy_avg_x</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">my</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">my</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="n">vy_avg_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">vy_avg_x</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>

    <span class="c1"># Average Bx to corners (from faces)</span>
    <span class="n">Bx_corner</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Bx</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">Bx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="n">Bx_corner</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">Bx_corner</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>

    <span class="c1"># Average By to corners (from faces)</span>
    <span class="n">By_corner</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">By</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">By</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>
    <span class="n">By_corner</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">By_corner</span><span class="p">,</span> <span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;wrap&#39;</span><span class="p">)</span>

    <span class="c1"># Compute Ez at corners</span>
    <span class="c1"># This is simplified; production codes use Riemann solver at faces</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Ez</span> <span class="o">=</span> <span class="n">vx_avg_y</span> <span class="o">*</span> <span class="n">By_corner</span> <span class="o">-</span> <span class="n">vy_avg_x</span> <span class="o">*</span> <span class="n">Bx_corner</span>

    <span class="c1"># Update Bx using Ez (discrete Faraday&#39;s law)</span>
    <span class="c1"># ‚àÇBx/‚àÇt = -‚àÇEz/‚àÇy</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_dt</span><span class="p">()</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">Bx</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ez</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ez</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Update By</span>
    <span class="c1"># ‚àÇBy/‚àÇt = ‚àÇEz/‚àÇx</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">By</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">dt</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ez</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ez</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
</code></pre></div>

<h3 id="83-full-2d-mhd-solver-simplified">8.3 Full 2D MHD Solver (Simplified)<a class="header-link" href="#83-full-2d-mhd-solver-simplified" title="Permanent link">&para;</a></h3>
<p>Due to the complexity of a full 2D MHD solver with Riemann solvers, CT, and higher-order reconstruction, here we provide a conceptual skeleton. Production codes like Athena, FLASH, and Pluto implement these in thousands of lines.</p>
<p><strong>Simplified algorithm</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Single timestep using operator splitting.&quot;&quot;&quot;</span>
    <span class="c1"># Step 1: Half step in x direction</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">step_x</span><span class="p">(</span><span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Step 2: Full step in y direction</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">step_y</span><span class="p">(</span><span class="n">dt</span><span class="p">)</span>

    <span class="c1"># Step 3: Half step in x direction</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">step_x</span><span class="p">(</span><span class="n">dt</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Update magnetic field using CT</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">update_magnetic_field_CT</span><span class="p">()</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>

<span class="k">def</span><span class="w"> </span><span class="nf">step_x</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;1D sweep in x direction (simplified).&quot;&quot;&quot;</span>
    <span class="c1"># For each j, solve 1D Riemann problems along x</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ny</span><span class="p">):</span>
        <span class="c1"># Extract 1D slice</span>
        <span class="n">rho_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rho</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
        <span class="n">mx_1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mx</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span>
        <span class="c1"># ... (other variables)</span>

        <span class="c1"># Reconstruct, solve Riemann problem, update</span>
        <span class="c1"># (Reuse 1D MHD solver)</span>

        <span class="c1"># Update conserved variables</span>
        <span class="c1"># self.rho[:, j] = ...</span>
        <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">step_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;1D sweep in y direction.&quot;&quot;&quot;</span>
    <span class="c1"># Similar to step_x but along y</span>
    <span class="k">pass</span>
</code></pre></div>

<p><strong>Note</strong>: Implementing a robust 2D MHD solver requires:
- 1D Riemann solver (HLL, HLLD, etc.)
- Reconstruction (PLM, WENO)
- CT electric field calculation from Riemann solver face states
- Boundary conditions
- Source terms (gravity, etc., if applicable)</p>
<p>For educational purposes, we demonstrate the Orszag-Tang vortex setup and a simple forward-Euler update.</p>
<h3 id="84-orszag-tang-vortex-setup">8.4 Orszag-Tang Vortex Setup<a class="header-link" href="#84-orszag-tang-vortex-setup" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">init_orszag_tang</span><span class="p">(</span><span class="n">mhd</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">5</span><span class="o">/</span><span class="mi">3</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize Orszag-Tang vortex.&quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">mhd</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">mhd</span><span class="o">.</span><span class="n">Y</span>

    <span class="c1"># Density and pressure</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">rho</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">gamma</span><span class="o">**</span><span class="mi">2</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">gamma</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>

    <span class="c1"># Velocity</span>
    <span class="n">vx</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">Y</span><span class="p">)</span>
    <span class="n">vy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">vz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">vx</span><span class="p">)</span>

    <span class="n">mhd</span><span class="o">.</span><span class="n">mx</span> <span class="o">=</span> <span class="n">mhd</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">vx</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">my</span> <span class="o">=</span> <span class="n">mhd</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">vy</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">mz</span> <span class="o">=</span> <span class="n">mhd</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">vz</span>

    <span class="c1"># Magnetic field (staggered grid)</span>
    <span class="c1"># Bx at (i-1/2, j)</span>
    <span class="n">X_Bx</span><span class="p">,</span> <span class="n">Y_Bx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">x_Bx</span><span class="p">,</span> <span class="n">mhd</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">Bx</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">Y_Bx</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="c1"># By at (i, j-1/2)</span>
    <span class="n">X_By</span><span class="p">,</span> <span class="n">Y_By</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">mhd</span><span class="o">.</span><span class="n">y_By</span><span class="p">,</span> <span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">By</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">X_By</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="c1"># Bz (cell-centered, zero)</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">Bz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Total energy</span>
    <span class="n">Bx_cc</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">Bx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">mhd</span><span class="o">.</span><span class="n">Bx</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>
    <span class="n">By_cc</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">By</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mhd</span><span class="o">.</span><span class="n">By</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="n">B2</span> <span class="o">=</span> <span class="n">Bx_cc</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">By_cc</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">mhd</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="n">gamma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">mhd</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">vx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">vy</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">vz</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">B2</span>

<span class="c1"># Initialize</span>
<span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span> <span class="o">=</span> <span class="mi">128</span><span class="p">,</span> <span class="mi">128</span>
<span class="n">mhd</span> <span class="o">=</span> <span class="n">MHD2D</span><span class="p">(</span><span class="n">Nx</span><span class="p">,</span> <span class="n">Ny</span><span class="p">,</span> <span class="n">Lx</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">Ly</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">5</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="n">init_orszag_tang</span><span class="p">(</span><span class="n">mhd</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Orszag-Tang vortex initialized on </span><span class="si">{</span><span class="n">Nx</span><span class="si">}</span><span class="s2">√ó</span><span class="si">{</span><span class="n">Ny</span><span class="si">}</span><span class="s2"> grid&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Initial div(B) max: </span><span class="si">{</span><span class="n">mhd</span><span class="o">.</span><span class="n">check_divergence</span><span class="p">()</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="85-simple-forward-euler-update-for-demonstration">8.5 Simple Forward Euler Update (for demonstration)<a class="header-link" href="#85-simple-forward-euler-update-for-demonstration" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">simple_update</span><span class="p">(</span><span class="n">mhd</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplified forward Euler update (NOT recommended for production).</span>
<span class="sd">    For demonstration only.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rho</span><span class="p">,</span> <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">Bx</span><span class="p">,</span> <span class="n">By</span><span class="p">,</span> <span class="n">Bz</span> <span class="o">=</span> <span class="n">mhd</span><span class="o">.</span><span class="n">primitive_variables</span><span class="p">()</span>

    <span class="c1"># Compute fluxes (very simplified, ignoring Riemann solver)</span>
    <span class="c1"># This will NOT capture shocks correctly!</span>

    <span class="c1"># Flux in x direction (at i+1/2, j)</span>
    <span class="n">Fx_rho</span> <span class="o">=</span> <span class="n">mhd</span><span class="o">.</span><span class="n">mx</span>  <span class="c1"># rho * vx</span>
    <span class="c1"># ... (other flux components)</span>

    <span class="c1"># Update conserved variables (forward Euler, very crude)</span>
    <span class="c1"># drho/dt = -(dFx/dx + dFy/dy)</span>

    <span class="c1"># For proper implementation, use Riemann solver at each face</span>
    <span class="c1"># This is just a placeholder</span>

    <span class="c1"># Update magnetic field via CT</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">update_magnetic_field_CT</span><span class="p">()</span>

    <span class="n">mhd</span><span class="o">.</span><span class="n">t</span> <span class="o">+=</span> <span class="n">dt</span>

<span class="c1"># Note: This is NOT a working solver, just a skeleton</span>
<span class="c1"># For actual simulation, use established codes or implement full Riemann solver</span>
</code></pre></div>

<h3 id="86-visualization">8.6 Visualization<a class="header-link" href="#86-visualization" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">plot_orszag_tang</span><span class="p">(</span><span class="n">mhd</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Plot density and magnetic field.&quot;&quot;&quot;</span>
    <span class="n">rho</span><span class="p">,</span> <span class="n">vx</span><span class="p">,</span> <span class="n">vy</span><span class="p">,</span> <span class="n">vz</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">Bx</span><span class="p">,</span> <span class="n">By</span><span class="p">,</span> <span class="n">Bz</span> <span class="o">=</span> <span class="n">mhd</span><span class="o">.</span><span class="n">primitive_variables</span><span class="p">()</span>

    <span class="n">fig</span><span class="p">,</span> <span class="p">(</span><span class="n">ax1</span><span class="p">,</span> <span class="n">ax2</span><span class="p">)</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>

    <span class="c1"># Density</span>
    <span class="n">im1</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">mhd</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">rho</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Density at t = </span><span class="si">{</span><span class="n">mhd</span><span class="o">.</span><span class="n">t</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">im1</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax1</span><span class="p">)</span>

    <span class="c1"># Magnetic field lines</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">mhd</span><span class="o">.</span><span class="n">Y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Bx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">By</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span> <span class="n">levels</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;plasma&#39;</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">streamplot</span><span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">X</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">mhd</span><span class="o">.</span><span class="n">Y</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Bx</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">By</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;white&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">density</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Magnetic Field at t = </span><span class="si">{</span><span class="n">mhd</span><span class="o">.</span><span class="n">t</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">14</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
    <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>

    <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;orszag_tang_t</span><span class="si">{</span><span class="n">mhd</span><span class="o">.</span><span class="n">t</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1">.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">)</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="n">plot_orszag_tang</span><span class="p">(</span><span class="n">mhd</span><span class="p">)</span>
</code></pre></div>

<h3 id="87-kelvin-helmholtz-instability-setup">8.7 Kelvin-Helmholtz Instability Setup<a class="header-link" href="#87-kelvin-helmholtz-instability-setup" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">init_kelvin_helmholtz</span><span class="p">(</span><span class="n">mhd</span><span class="p">,</span> <span class="n">V0</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">dv</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">B0</span><span class="o">=</span><span class="mf">0.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize Kelvin-Helmholtz instability.&quot;&quot;&quot;</span>
    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">mhd</span><span class="o">.</span><span class="n">X</span><span class="p">,</span> <span class="n">mhd</span><span class="o">.</span><span class="n">Y</span>

    <span class="c1"># Density (uniform)</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">rho</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">1.0</span>

    <span class="c1"># Pressure (uniform)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">rho</span><span class="p">)</span>

    <span class="c1"># Velocity shear</span>
    <span class="n">vx</span> <span class="o">=</span> <span class="o">-</span><span class="n">V0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">Y</span> <span class="o">/</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">vy</span> <span class="o">=</span> <span class="n">dv</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">X</span><span class="p">)</span>
    <span class="n">vz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">vx</span><span class="p">)</span>

    <span class="n">mhd</span><span class="o">.</span><span class="n">mx</span> <span class="o">=</span> <span class="n">mhd</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">vx</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">my</span> <span class="o">=</span> <span class="n">mhd</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">vy</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">mz</span> <span class="o">=</span> <span class="n">mhd</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="n">vz</span>

    <span class="c1"># Magnetic field (uniform in x)</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">Bx</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">B0</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">By</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>
    <span class="n">mhd</span><span class="o">.</span><span class="n">Bz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="c1"># Total energy</span>
    <span class="n">Bx_cc</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">Bx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">mhd</span><span class="o">.</span><span class="n">Bx</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>
    <span class="n">By_cc</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">By</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">mhd</span><span class="o">.</span><span class="n">By</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:])</span>
    <span class="n">B2</span> <span class="o">=</span> <span class="n">Bx_cc</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">By_cc</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">mhd</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="n">p</span> <span class="o">/</span> <span class="p">(</span><span class="n">mhd</span><span class="o">.</span><span class="n">gamma</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">mhd</span><span class="o">.</span><span class="n">rho</span> <span class="o">*</span> <span class="p">(</span><span class="n">vx</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">vy</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">B2</span>

<span class="c1"># Initialize KH instability</span>
<span class="n">mhd_kh</span> <span class="o">=</span> <span class="n">MHD2D</span><span class="p">(</span><span class="n">Nx</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Ny</span><span class="o">=</span><span class="mi">256</span><span class="p">,</span> <span class="n">Lx</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">Ly</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">gamma</span><span class="o">=</span><span class="mi">5</span><span class="o">/</span><span class="mi">3</span><span class="p">)</span>
<span class="n">init_kelvin_helmholtz</span><span class="p">(</span><span class="n">mhd_kh</span><span class="p">,</span> <span class="n">V0</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">a</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">dv</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">B0</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Kelvin-Helmholtz initialized: V0=1.0, B0=0.5&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Alfv√©n speed: vA = </span><span class="si">{</span><span class="mf">0.5</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2"> (should stabilize if vA &gt; V0)&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="88-production-quality-codes">8.8 Production-Quality Codes<a class="header-link" href="#88-production-quality-codes" title="Permanent link">&para;</a></h3>
<p>For actual research, use established MHD codes:</p>
<p><strong>Athena++</strong>: https://github.com/PrincetonUniversity/athena
- C++, modern AMR (adaptive mesh refinement)
- MHD, radiation, GR options
- CT for divergence-free B</p>
<p><strong>PLUTO</strong>: http://plutocode.ph.unito.it/
- Modular, supports various physics modules
- MHD, relativistic MHD, radiation
- Multiple Riemann solvers, CT</p>
<p><strong>FLASH</strong>: https://flash.rochester.edu/
- Large-scale astrophysical simulations
- AMR, MHD, hydrodynamics
- Widely used for supernova, star formation</p>
<p><strong>Example</strong>: Running Athena for Orszag-Tang vortex:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Athena input file (athinput.orszag_tang)</span>
&lt;problem&gt;
<span class="nv">problem_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>OrszagTang
<span class="nv">gamma</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span>.666667

&lt;mesh&gt;
<span class="nv">nx1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">256</span>
<span class="nv">nx2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">256</span>
<span class="nv">x1min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>.0
<span class="nv">x1max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span>.0
<span class="nv">x2min</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>.0
<span class="nv">x2max</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span>.0
<span class="nv">ix1_bc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>periodic
<span class="nv">ox1_bc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>periodic
<span class="nv">ix2_bc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>periodic
<span class="nv">ox2_bc</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>periodic

&lt;hydro&gt;
<span class="nv">evolution</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>mhd

&lt;time&gt;
<span class="nv">tlim</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">0</span>.5
</code></pre></div>

<p>Run:</p>
<div class="highlight"><pre><span></span><code>./athena<span class="w"> </span>-i<span class="w"> </span>athinput.orszag_tang
</code></pre></div>

<h2 id="9-advanced-topics">9. Advanced Topics<a class="header-link" href="#9-advanced-topics" title="Permanent link">&para;</a></h2>
<h3 id="91-adaptive-mesh-refinement-amr">9.1 Adaptive Mesh Refinement (AMR)<a class="header-link" href="#91-adaptive-mesh-refinement-amr" title="Permanent link">&para;</a></h3>
<p>AMR dynamically refines the grid in regions of interest (shocks, current sheets) and coarsens elsewhere, saving computational cost.</p>
<p><strong>Challenges in MHD AMR</strong>:
- Preserving $\nabla \cdot B = 0$ across refinement boundaries
- Prolongation and restriction operators for staggered fields</p>
<p><strong>Solutions</strong>:
- Flux correction at coarse-fine boundaries
- Divergence-preserving prolongation (e.g., Balsara's method)</p>
<h3 id="92-divergence-cleaning">9.2 Divergence Cleaning<a class="header-link" href="#92-divergence-cleaning" title="Permanent link">&para;</a></h3>
<p>Alternative to CT: Allow non-zero $\nabla \cdot B$ but add a damping mechanism.</p>
<p><strong>Hyperbolic divergence cleaning</strong> (Dedner et al. 2002):</p>
<p>Add an auxiliary scalar field $\psi$ and evolve:</p>
<div class="highlight"><pre><span></span><code>‚àÇB/‚àÇt + ‚àáœà = ... (usual MHD terms)
‚àÇœà/‚àÇt + c_h¬≤ ‚àá¬∑B = -c_h¬≤ œà / œÑ
</code></pre></div>

<p>where $c_h$ is a cleaning speed (typically $c_h \sim c_{fast}$) and $\tau$ is a damping timescale.</p>
<p>This propagates divergence errors out of the domain as waves.</p>
<p><strong>Pros</strong>: Works on unstructured grids, easier to implement than CT
<strong>Cons</strong>: Does not guarantee $\nabla \cdot B = 0$ exactly, requires tuning parameters</p>
<h3 id="93-positivity-preserving-methods">9.3 Positivity-Preserving Methods<a class="header-link" href="#93-positivity-preserving-methods" title="Permanent link">&para;</a></h3>
<p>Ensuring $\rho > 0$ and $p > 0$ after each update is critical for stability.</p>
<p><strong>Techniques</strong>:
- Limiting reconstructed states to physical range
- Adjusting fluxes to prevent negative density/pressure
- Positivity-preserving Riemann solvers</p>
<h3 id="94-high-order-methods">9.4 High-Order Methods<a class="header-link" href="#94-high-order-methods" title="Permanent link">&para;</a></h3>
<p>Beyond second-order:
- <strong>WENO5</strong>: 5th-order reconstruction
- <strong>Discontinuous Galerkin (DG)</strong>: High-order within cells, coupled via fluxes
- <strong>Spectral methods</strong>: For smooth problems (not ideal for shocks)</p>
<p>Trade-off: Higher order reduces numerical dissipation but increases cost and complexity.</p>
<h2 id="10-summary">10. Summary<a class="header-link" href="#10-summary" title="Permanent link">&para;</a></h2>
<p>This lesson covered advanced numerical techniques for 2D MHD:</p>
<ol>
<li><strong>2D MHD equations</strong>: Extension from 1D, 8 conserved variables in 2D</li>
<li><strong>Finite volume method</strong>: Cell-centered discretization, semi-discrete form</li>
<li><strong>Dimensional splitting</strong>: Strang splitting (second-order), reuses 1D solvers</li>
<li><strong>Unsplit methods</strong>: CTU for multidimensional coupling</li>
<li><strong>Constrained Transport</strong>: Staggered grid (Yee mesh), preserves $\nabla \cdot B = 0$ exactly</li>
<li><strong>Higher-order reconstruction</strong>: PLM (limiters), WENO (5th order)</li>
<li><strong>Orszag-Tang vortex</strong>: Benchmark problem, turbulent MHD</li>
<li><strong>Kelvin-Helmholtz instability</strong>: Magnetic field stabilizes shear layer</li>
<li><strong>Python implementation</strong>: Skeleton code for 2D MHD with CT</li>
</ol>
<p>For production simulations, use established codes (Athena, PLUTO, FLASH) that have been extensively tested and optimized.</p>
<h2 id="practice-problems">Practice Problems<a class="header-link" href="#practice-problems" title="Permanent link">&para;</a></h2>
<ol>
<li>
<p><strong>CFL condition</strong>: For a 2D MHD simulation with $\Delta x = \Delta y = 0.01$, fast magnetosonic speed $c_f = 2$, and maximum flow velocity $|v| = 1$, calculate the maximum timestep for $CFL = 0.5$.</p>
</li>
<li>
<p><strong>Divergence preservation</strong>: Explain why the standard finite volume method for updating $B$ does not preserve $\nabla \cdot B = 0$, but Constrained Transport does. Sketch the Yee mesh and show where $B_x$, $B_y$, and $E_z$ are located.</p>
</li>
<li>
<p><strong>Orszag-Tang vortex</strong>: Why is the Orszag-Tang vortex a good test problem for 2D MHD codes? What physical processes does it test (list at least 3)?</p>
</li>
<li>
<p><strong>Kelvin-Helmholtz stabilization</strong>: For a shear layer with $V_0 = 2$ m/s, $\rho = 1$ kg/m¬≥, calculate the minimum magnetic field $B_0$ required to suppress the KH instability (i.e., $v_A \geq V_0$). Express in Tesla (assume vacuum permeability $\mu_0 = 4\pi \times 10^{-7}$ H/m).</p>
</li>
<li>
<p><strong>PLM reconstruction</strong>: Given cell-centered values $U_{i-1} = 1.0$, $U_i = 1.5$, $U_{i+1} = 2.5$, compute the slope $\sigma_i$ using (a) centered difference, (b) minmod limiter. What are the left and right states at the cell interface $i+1/2$?</p>
</li>
<li>
<p><strong>CT electric field</strong>: In Constrained Transport, the electric field $E_z$ at a cell corner is computed from velocities and magnetic fields at adjacent faces. Write the formula for $E_z(i, j)$ in terms of $v_x$, $v_y$, $B_x$, $B_y$ at the four surrounding face centers. (Assume simple averaging.)</p>
</li>
<li>
<p><strong>Dimensional splitting error</strong>: Strang splitting ($L_x^{1/2} L_y L_x^{1/2}$) is second-order accurate in time. What is the order of accuracy if you use simple splitting ($L_x L_y$)? Why is Strang splitting preferred?</p>
</li>
<li>
<p><strong>WENO advantage</strong>: WENO schemes are 5th-order accurate in smooth regions but reduce to lower order near discontinuities. Why is this beneficial compared to always using 2nd-order PLM?</p>
</li>
<li>
<p><strong>AMR refinement criterion</strong>: In an MHD simulation, you want to refine the grid near current sheets. Propose a criterion based on $|\\nabla \\times B|$ to trigger refinement. Write the condition mathematically.</p>
</li>
<li>
<p><strong>Computational cost</strong>: Compare the computational cost (operations per timestep) of a 2D MHD simulation on a $256 \times 256$ grid versus a 1D simulation with 256 cells, assuming the same physics and Riemann solver. Estimate the ratio (ignoring constants).</p>
</li>
</ol>
<hr />
<p><strong>Previous</strong>: <a href="./14_Space_Weather.md">Space Weather MHD</a> | <strong>Next</strong>: <a href="./16_Relativistic_MHD.md">Relativistic MHD</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/MHD/14_Space_Weather.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">14. Space Weather MHD</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/MHD/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/MHD/16_Relativistic_MHD.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">16. Relativistic MHD</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}