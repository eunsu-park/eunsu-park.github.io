{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Concurrency & Parallelism - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Programming/">Programming</a>
    <span class="separator">/</span>
    <span class="current">Concurrency & Parallelism</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Concurrency & Parallelism</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Programming/11_Debugging_and_Profiling.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Debugging & Profiling</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Programming/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Programming/13_API_Design.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">API Design Principles</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#concurrency-vs-parallelism">Concurrency vs Parallelism</a><ul>
<li><a href="#concurrency-dealing-with-many-things-at-once">Concurrency: Dealing with Many Things at Once</a></li>
<li><a href="#parallelism-doing-many-things-at-once">Parallelism: Doing Many Things at Once</a></li>
<li><a href="#rob-pike-concurrency-is-not-parallelism">Rob Pike: "Concurrency is Not Parallelism"</a></li>
</ul>
</li>
<li><a href="#why-concurrency">Why Concurrency?</a><ul>
<li><a href="#1-responsive-uis">1. Responsive UIs</a></li>
<li><a href="#2-efficient-io">2. Efficient I/O</a></li>
<li><a href="#3-utilizing-multi-core-cpus">3. Utilizing Multi-Core CPUs</a></li>
</ul>
</li>
<li><a href="#processes-vs-threads">Processes vs Threads</a><ul>
<li><a href="#process">Process</a></li>
<li><a href="#thread">Thread</a></li>
<li><a href="#green-threads-goroutines-virtual-threads">Green Threads / Goroutines / Virtual Threads</a></li>
</ul>
</li>
<li><a href="#thread-based-concurrency">Thread-Based Concurrency</a><ul>
<li><a href="#shared-state-problems">Shared State Problems</a></li>
<li><a href="#synchronization-mutexeslocks">Synchronization: Mutexes/Locks</a></li>
<li><a href="#semaphores">Semaphores</a></li>
<li><a href="#deadlock">Deadlock</a></li>
<li><a href="#producer-consumer-problem">Producer-Consumer Problem</a></li>
<li><a href="#reader-writer-problem">Reader-Writer Problem</a></li>
</ul>
</li>
<li><a href="#asyncawait-pattern">Async/Await Pattern</a><ul>
<li><a href="#event-loop-single-threaded-concurrency">Event Loop: Single-Threaded Concurrency</a></li>
<li><a href="#promisesfutures-representing-eventual-values">Promises/Futures: Representing Eventual Values</a></li>
<li><a href="#asyncawait-syntax">Async/Await Syntax</a></li>
<li><a href="#when-to-use-async-vs-threads">When to Use Async vs Threads</a></li>
</ul>
</li>
<li><a href="#message-passing">Message Passing</a><ul>
<li><a href="#channels-go-rust">Channels (Go, Rust)</a></li>
<li><a href="#actor-model-erlang-akka">Actor Model (Erlang, Akka)</a></li>
<li><a href="#csp-communicating-sequential-processes">CSP (Communicating Sequential Processes)</a></li>
</ul>
</li>
<li><a href="#parallel-patterns">Parallel Patterns</a><ul>
<li><a href="#map-reduce">Map-Reduce</a></li>
<li><a href="#fork-join">Fork-Join</a></li>
<li><a href="#pipeline">Pipeline</a></li>
<li><a href="#thread-pool-worker-pool">Thread Pool / Worker Pool</a></li>
</ul>
</li>
<li><a href="#common-pitfalls">Common Pitfalls</a><ul>
<li><a href="#1-race-conditions-check-then-act">1. Race Conditions (Check-Then-Act)</a></li>
<li><a href="#2-deadlock">2. Deadlock</a></li>
<li><a href="#3-livelock">3. Livelock</a></li>
<li><a href="#4-starvation">4. Starvation</a></li>
<li><a href="#5-false-sharing-cache-lines">5. False Sharing (Cache Lines)</a></li>
</ul>
</li>
<li><a href="#immutability-as-a-concurrency-strategy">Immutability as a Concurrency Strategy</a></li>
<li><a href="#lock-free-data-structures">Lock-Free Data Structures</a></li>
<li><a href="#summary">Summary</a></li>
<li><a href="#exercises">Exercises</a><ul>
<li><a href="#exercise-1-identify-race-conditions">Exercise 1: Identify Race Conditions</a></li>
<li><a href="#exercise-2-implement-producer-consumer">Exercise 2: Implement Producer-Consumer</a></li>
<li><a href="#exercise-3-asyncawait-for-io">Exercise 3: Async/Await for I/O</a></li>
<li><a href="#exercise-4-parallel-map-reduce">Exercise 4: Parallel Map-Reduce</a></li>
<li><a href="#exercise-5-deadlock-scenario">Exercise 5: Deadlock Scenario</a></li>
</ul>
</li>
<li><a href="#navigation">Navigation</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="concurrency-parallelism">Concurrency &amp; Parallelism<a class="header-link" href="#concurrency-parallelism" title="Permanent link">&para;</a></h1>
<blockquote>
<p><strong>Topic</strong>: Programming
<strong>Lesson</strong>: 12 of 16
<strong>Prerequisites</strong>: Functions and Methods, Error Handling, Debugging and Profiling
<strong>Objective</strong>: Understand the difference between concurrency and parallelism, master threads, async/await, message passing, learn parallel patterns, and avoid common pitfalls like race conditions and deadlocks.</p>
</blockquote>
<hr />
<h2 id="introduction">Introduction<a class="header-link" href="#introduction" title="Permanent link">&para;</a></h2>
<p>Modern applications must handle many tasks simultaneously: responsive user interfaces, network I/O, database queries, background processing. Concurrency and parallelism are essential tools for building such systems.</p>
<p>However, concurrent programming is notoriously difficult. Race conditions, deadlocks, and data corruption are common pitfalls. This lesson gives you the mental models, patterns, and practical techniques to write correct concurrent code.</p>
<hr />
<h2 id="concurrency-vs-parallelism">Concurrency vs Parallelism<a class="header-link" href="#concurrency-vs-parallelism" title="Permanent link">&para;</a></h2>
<p>These terms are often confused, but they represent different concepts:</p>
<h3 id="concurrency-dealing-with-many-things-at-once">Concurrency: Dealing with Many Things at Once<a class="header-link" href="#concurrency-dealing-with-many-things-at-once" title="Permanent link">&para;</a></h3>
<p><strong>Concurrency is about structure</strong> ‚Äì how you organize your program to handle multiple tasks.</p>
<p><strong>Example:</strong> A single chef (one CPU core) preparing multiple dishes:</p>
<div class="highlight"><pre><span></span><code><span class="nv">Chef</span><span class="w"> </span><span class="nv">switches</span><span class="w"> </span><span class="nv">between</span><span class="w"> </span><span class="nv">tasks</span>:
<span class="mi">1</span>.<span class="w"> </span><span class="nv">Chop</span><span class="w"> </span><span class="nv">vegetables</span><span class="w"> </span><span class="ss">(</span><span class="k">pause</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">let</span><span class="w"> </span><span class="nv">water</span><span class="w"> </span><span class="nv">boil</span><span class="ss">)</span>
<span class="mi">2</span>.<span class="w"> </span><span class="nv">Stir</span><span class="w"> </span><span class="nv">sauce</span><span class="w"> </span><span class="ss">(</span><span class="k">pause</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="nv">pasta</span><span class="w"> </span><span class="nv">cooks</span><span class="ss">)</span>
<span class="mi">3</span>.<span class="w"> </span><span class="nv">Plate</span><span class="w"> </span><span class="nv">first</span><span class="w"> </span><span class="nv">dish</span><span class="w"> </span><span class="ss">(</span><span class="k">pause</span><span class="w"> </span><span class="k">while</span><span class="w"> </span><span class="nv">second</span><span class="w"> </span><span class="nv">dish</span><span class="w"> </span><span class="nv">cooks</span><span class="ss">)</span>

<span class="nv">One</span><span class="w"> </span><span class="nv">chef</span>,<span class="w"> </span><span class="nv">many</span><span class="w"> </span><span class="nv">tasks</span>,<span class="w"> </span><span class="nv">context</span><span class="w"> </span><span class="nv">switching</span><span class="w"> </span><span class="nv">between</span><span class="w"> </span><span class="nv">them</span>
</code></pre></div>

<p><strong>In code:</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># Concurrent: Single thread handles multiple tasks by switching</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">make_coffee</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Grinding beans...&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Wait for grinding (yield control)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Brewing...&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Wait for brewing (yield control)</span>
    <span class="k">return</span> <span class="s2">&quot;Coffee ready&quot;</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">make_toast</span><span class="p">():</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Toasting bread...&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>  <span class="c1"># Wait for toasting (yield control)</span>
    <span class="k">return</span> <span class="s2">&quot;Toast ready&quot;</span>

<span class="c1"># Run concurrently: single thread switches between tasks during waits</span>
<span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="n">make_coffee</span><span class="p">(),</span> <span class="n">make_toast</span><span class="p">())</span>
</code></pre></div>

<h3 id="parallelism-doing-many-things-at-once">Parallelism: Doing Many Things at Once<a class="header-link" href="#parallelism-doing-many-things-at-once" title="Permanent link">&para;</a></h3>
<p><strong>Parallelism is about execution</strong> ‚Äì actually running multiple computations simultaneously on multiple CPU cores.</p>
<p><strong>Example:</strong> Multiple chefs (multiple CPU cores) preparing dishes simultaneously:</p>
<div class="highlight"><pre><span></span><code>Chef 1: Chops vegetables
Chef 2: Stirs sauce          } All at the same time
Chef 3: Plates dishes
</code></pre></div>

<p><strong>In code:</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># Parallel: Multiple processes run on multiple CPU cores</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span>

<span class="k">def</span><span class="w"> </span><span class="nf">expensive_computation</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="c1"># Run in parallel: multiple CPU cores work simultaneously</span>
<span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
    <span class="n">results</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">expensive_computation</span><span class="p">,</span> <span class="p">[</span><span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">,</span> <span class="mi">10</span><span class="o">**</span><span class="mi">7</span><span class="p">])</span>
</code></pre></div>

<h3 id="rob-pike-concurrency-is-not-parallelism">Rob Pike: "Concurrency is Not Parallelism"<a class="header-link" href="#rob-pike-concurrency-is-not-parallelism" title="Permanent link">&para;</a></h3>
<p><a href="https://go.dev/blog/waza-talk">Rob Pike's famous talk</a> explains:
- <strong>Concurrency:</strong> A way to structure your program (design)
- <strong>Parallelism:</strong> Simultaneous execution (runtime)</p>
<p>You can have:
- <strong>Concurrency without parallelism:</strong> Single core, context switching
- <strong>Parallelism without concurrency:</strong> SIMD operations (same instruction, multiple data)
- <strong>Both:</strong> Multi-threaded program on multi-core CPU</p>
<hr />
<h2 id="why-concurrency">Why Concurrency?<a class="header-link" href="#why-concurrency" title="Permanent link">&para;</a></h2>
<h3 id="1-responsive-uis">1. Responsive UIs<a class="header-link" href="#1-responsive-uis" title="Permanent link">&para;</a></h3>
<p>Without concurrency, long-running operations freeze the UI:</p>
<div class="highlight"><pre><span></span><code><span class="c1">// BAD: Blocks UI thread</span>
<span class="nx">button</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">expensiveComputation</span><span class="p">();</span><span class="w">  </span><span class="c1">// UI freezes!</span>
<span class="w">    </span><span class="nx">displayResult</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// GOOD: Offload to background</span>
<span class="nx">button</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s1">&#39;click&#39;</span><span class="p">,</span><span class="w"> </span><span class="k">async</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">runInBackground</span><span class="p">(</span><span class="nx">expensiveComputation</span><span class="p">);</span><span class="w">  </span><span class="c1">// UI stays responsive</span>
<span class="w">    </span><span class="nx">displayResult</span><span class="p">(</span><span class="nx">result</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div>

<h3 id="2-efficient-io">2. Efficient I/O<a class="header-link" href="#2-efficient-io" title="Permanent link">&para;</a></h3>
<p>While waiting for I/O (network, disk, database), the CPU can do other work:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Sequential: Waits for each request (slow)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">fetch_all</span><span class="p">(</span><span class="n">urls</span><span class="p">):</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">:</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">))</span>  <span class="c1"># Wait for response</span>
    <span class="k">return</span> <span class="n">results</span>
<span class="c1"># Total time: sum of all requests</span>

<span class="c1"># Concurrent: Overlaps I/O waits (fast)</span>
<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_all</span><span class="p">(</span><span class="n">urls</span><span class="p">):</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">fetch</span><span class="p">(</span><span class="n">url</span><span class="p">)</span> <span class="k">for</span> <span class="n">url</span> <span class="ow">in</span> <span class="n">urls</span><span class="p">]</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span><span class="o">*</span><span class="n">tasks</span><span class="p">)</span>  <span class="c1"># All requests in parallel</span>
<span class="c1"># Total time: max of all requests (not sum!)</span>
</code></pre></div>

<h3 id="3-utilizing-multi-core-cpus">3. Utilizing Multi-Core CPUs<a class="header-link" href="#3-utilizing-multi-core-cpus" title="Permanent link">&para;</a></h3>
<p>Modern CPUs have multiple cores. Sequential code uses only one core:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Uses 1 core</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_data</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">expensive_function</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>

<span class="c1"># Uses all cores</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span>
<span class="k">def</span><span class="w"> </span><span class="nf">process_data_parallel</span><span class="p">(</span><span class="n">data</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">expensive_function</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="processes-vs-threads">Processes vs Threads<a class="header-link" href="#processes-vs-threads" title="Permanent link">&para;</a></h2>
<h3 id="process">Process<a class="header-link" href="#process" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Independent memory space</strong>: Each process has its own memory</li>
<li><strong>Heavier</strong>: Creating/destroying is expensive</li>
<li><strong>Safer</strong>: Crash in one process doesn't affect others</li>
<li><strong>Communication</strong>: Must use IPC (pipes, sockets, shared memory)</li>
</ul>
<p><strong>Example: Python multiprocessing</strong></p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Process</span>

<span class="k">def</span><span class="w"> </span><span class="nf">worker</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Worker </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> starting&quot;</span><span class="p">)</span>
    <span class="c1"># Do work</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Worker </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> done&quot;</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,))</span>
    <span class="n">p2</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,))</span>

    <span class="n">p1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

    <span class="n">p1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>  <span class="c1"># Wait for completion</span>
    <span class="n">p2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></div>

<h3 id="thread">Thread<a class="header-link" href="#thread" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>Shared memory space</strong>: All threads see the same memory</li>
<li><strong>Lighter</strong>: Creating/destroying is cheap</li>
<li><strong>Dangerous</strong>: Shared state requires synchronization</li>
<li><strong>Communication</strong>: Direct memory access (but requires locking)</li>
</ul>
<p><strong>Example: Python threading</strong></p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Thread</span>

<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># Shared between threads!</span>

<span class="k">def</span><span class="w"> </span><span class="nf">worker</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">counter</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Worker </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> starting&quot;</span><span class="p">)</span>
    <span class="c1"># Do work</span>
    <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># DANGER: Race condition!</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Worker </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> done&quot;</span><span class="p">)</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,))</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;B&quot;</span><span class="p">,))</span>

<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Counter: </span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># May be 1 instead of 2!</span>
</code></pre></div>

<p><strong>Java threads:</strong></p>
<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">Worker</span><span class="w"> </span><span class="kd">extends</span><span class="w"> </span><span class="n">Thread</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="nf">Worker</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">this</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="nd">@Override</span>
<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">run</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Worker &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; starting&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="c1">// Do work</span>
<span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&quot;Worker &quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&quot; done&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Usage</span>
<span class="n">Worker</span><span class="w"> </span><span class="n">w1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Worker</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">);</span>
<span class="n">Worker</span><span class="w"> </span><span class="n">w2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Worker</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">);</span>
<span class="n">w1</span><span class="p">.</span><span class="na">start</span><span class="p">();</span>
<span class="n">w2</span><span class="p">.</span><span class="na">start</span><span class="p">();</span>
<span class="n">w1</span><span class="p">.</span><span class="na">join</span><span class="p">();</span>
<span class="n">w2</span><span class="p">.</span><span class="na">join</span><span class="p">();</span>
</code></pre></div>

<p><strong>C++ threads (C++11):</strong></p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;iostream&gt;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;thread&gt;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">worker</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Worker &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; starting</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// Do work</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;Worker &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t1</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;A&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="n">std</span><span class="o">::</span><span class="kr">thread</span><span class="w"> </span><span class="n">t2</span><span class="p">(</span><span class="n">worker</span><span class="p">,</span><span class="w"> </span><span class="s">&quot;B&quot;</span><span class="p">);</span>

<span class="w">    </span><span class="n">t1</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="w">    </span><span class="n">t2</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="green-threads-goroutines-virtual-threads">Green Threads / Goroutines / Virtual Threads<a class="header-link" href="#green-threads-goroutines-virtual-threads" title="Permanent link">&para;</a></h3>
<p>Some languages provide lightweight threads scheduled by the runtime, not the OS:</p>
<ul>
<li><strong>Go:</strong> Goroutines (thousands of goroutines on a few OS threads)</li>
<li><strong>Erlang:</strong> Processes (millions of lightweight processes)</li>
<li><strong>Java 21+:</strong> Virtual threads (lightweight threads)</li>
</ul>
<p><strong>Go example:</strong></p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="s">&quot;fmt&quot;</span>
<span class="w">    </span><span class="s">&quot;time&quot;</span>
<span class="p">)</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">worker</span><span class="p">(</span><span class="nx">name</span><span class="w"> </span><span class="kt">string</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Worker %s starting\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="p">)</span>
<span class="w">    </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
<span class="w">    </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Printf</span><span class="p">(</span><span class="s">&quot;Worker %s done\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">name</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">worker</span><span class="p">(</span><span class="s">&quot;A&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1">// Launch goroutine</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">worker</span><span class="p">(</span><span class="s">&quot;B&quot;</span><span class="p">)</span><span class="w">  </span><span class="c1">// Launch goroutine</span>

<span class="w">    </span><span class="nx">time</span><span class="p">.</span><span class="nx">Sleep</span><span class="p">(</span><span class="mi">2</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span><span class="w">  </span><span class="c1">// Wait for goroutines</span>
<span class="p">}</span>
</code></pre></div>

<hr />
<h2 id="thread-based-concurrency">Thread-Based Concurrency<a class="header-link" href="#thread-based-concurrency" title="Permanent link">&para;</a></h2>
<h3 id="shared-state-problems">Shared State Problems<a class="header-link" href="#shared-state-problems" title="Permanent link">&para;</a></h3>
<p><strong>Race condition:</strong> Multiple threads access shared data without synchronization, leading to unpredictable results.</p>
<p><strong>Example:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>

<span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">counter</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">):</span>
        <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># Three operations: read, increment, write</span>

<span class="c1"># Run two threads</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Thread</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">increment</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">increment</span><span class="p">)</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Counter: </span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Expected: 200000, Actual: varies (e.g., 153421)</span>
</code></pre></div>

<p><strong>Why?</strong></p>
<div class="highlight"><pre><span></span><code>Thread 1: read counter (0)
Thread 2: read counter (0)
Thread 1: increment (0 + 1 = 1)
Thread 2: increment (0 + 1 = 1)
Thread 1: write counter (1)
Thread 2: write counter (1)  # Overwrites Thread 1&#39;s write!
# Both increments happened, but counter is only 1
</code></pre></div>

<h3 id="synchronization-mutexeslocks">Synchronization: Mutexes/Locks<a class="header-link" href="#synchronization-mutexeslocks" title="Permanent link">&para;</a></h3>
<p><strong>Mutex (Mutual Exclusion):</strong> Only one thread can hold the lock at a time.</p>
<p><strong>Python:</strong></p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">Lock</span>

<span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">():</span>
    <span class="k">global</span> <span class="n">counter</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100000</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">lock</span><span class="p">:</span>  <span class="c1"># Acquire lock</span>
            <span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Lock released</span>

<span class="n">t1</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">increment</span><span class="p">)</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">increment</span><span class="p">)</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Counter: </span><span class="si">{</span><span class="n">counter</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Always 200000</span>
</code></pre></div>

<p><strong>Java:</strong></p>
<div class="highlight"><pre><span></span><code><span class="kd">class</span> <span class="nc">Counter</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Object</span><span class="w"> </span><span class="n">lock</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Object</span><span class="p">();</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">increment</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">synchronized</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Acquire lock</span>
<span class="w">            </span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span><span class="w">  </span><span class="c1">// Release lock</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">getCount</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="kd">synchronized</span><span class="p">(</span><span class="n">lock</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">count</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>C++:</strong></p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;mutex&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="w"> </span><span class="n">mtx</span><span class="p">;</span>
<span class="kt">int</span><span class="w"> </span><span class="n">counter</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">increment</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">100000</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span><span class="w"> </span><span class="n">lock</span><span class="p">(</span><span class="n">mtx</span><span class="p">);</span><span class="w">  </span><span class="c1">// RAII: acquires lock</span>
<span class="w">        </span><span class="n">counter</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span><span class="w">  </span><span class="c1">// Lock released when lock_guard goes out of scope</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="semaphores">Semaphores<a class="header-link" href="#semaphores" title="Permanent link">&para;</a></h3>
<p><strong>Semaphore:</strong> Allows N threads to access a resource simultaneously.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Semaphore</span>

<span class="c1"># Only 3 threads can access the resource at once</span>
<span class="n">semaphore</span> <span class="o">=</span> <span class="n">Semaphore</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">worker</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">semaphore</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>  <span class="c1"># Wait if 3 threads are already inside</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: Accessing resource&quot;</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: Done&quot;</span><span class="p">)</span>
    <span class="n">semaphore</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>  <span class="c1"># Allow another thread to enter</span>

<span class="c1"># Launch 10 threads, but only 3 run concurrently</span>
<span class="n">threads</span> <span class="o">=</span> <span class="p">[</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">worker</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;T</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">threads</span><span class="p">:</span>
    <span class="n">t</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></div>

<h3 id="deadlock">Deadlock<a class="header-link" href="#deadlock" title="Permanent link">&para;</a></h3>
<p><strong>Deadlock:</strong> Two or more threads wait for each other, and none can proceed.</p>
<p><strong>Example:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">lock1</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
<span class="n">lock2</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">thread1</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">lock1</span><span class="p">:</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># Give thread2 time to acquire lock2</span>
        <span class="k">with</span> <span class="n">lock2</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Thread 1 got both locks&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">thread2</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">lock2</span><span class="p">:</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>  <span class="c1"># Give thread1 time to acquire lock1</span>
        <span class="k">with</span> <span class="n">lock1</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Thread 2 got both locks&quot;</span><span class="p">)</span>

<span class="c1"># Deadlock!</span>
<span class="c1"># Thread 1: holds lock1, waits for lock2</span>
<span class="c1"># Thread 2: holds lock2, waits for lock1</span>
<span class="c1"># Neither can proceed</span>
</code></pre></div>

<p><strong>Four conditions for deadlock (all must be true):</strong>
1. <strong>Mutual exclusion:</strong> Resource can't be shared
2. <strong>Hold and wait:</strong> Thread holds resources while waiting for others
3. <strong>No preemption:</strong> Resources can't be forcibly taken
4. <strong>Circular wait:</strong> T1 waits for T2, T2 waits for T1</p>
<p><strong>Prevention strategies:</strong>
- <strong>Lock ordering:</strong> Always acquire locks in the same order
- <strong>Timeouts:</strong> Use <code>try_lock</code> with timeout
- <strong>Avoid holding multiple locks:</strong> Redesign to need only one lock at a time</p>
<p><strong>Fix with lock ordering:</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">thread1</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">lock1</span><span class="p">:</span>  <span class="c1"># Acquire lock1 first</span>
        <span class="k">with</span> <span class="n">lock2</span><span class="p">:</span>  <span class="c1"># Then lock2</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Thread 1 got both locks&quot;</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">thread2</span><span class="p">():</span>
    <span class="k">with</span> <span class="n">lock1</span><span class="p">:</span>  <span class="c1"># Acquire lock1 first (same order!)</span>
        <span class="k">with</span> <span class="n">lock2</span><span class="p">:</span>  <span class="c1"># Then lock2</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Thread 2 got both locks&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="producer-consumer-problem">Producer-Consumer Problem<a class="header-link" href="#producer-consumer-problem" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Producers generate data, consumers process it. Need thread-safe queue.</p>
<p><strong>Python:</strong></p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">queue</span><span class="w"> </span><span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">time</span>

<span class="n">queue</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">(</span><span class="n">maxsize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">producer</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">item</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>  <span class="c1"># Thread-safe: blocks if queue is full</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> produced </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">consumer</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">item</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>  <span class="c1"># Thread-safe: blocks if queue is empty</span>
        <span class="k">if</span> <span class="n">item</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># Poison pill to stop</span>
            <span class="k">break</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> consumed </span><span class="si">{</span><span class="n">item</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">queue</span><span class="o">.</span><span class="n">task_done</span><span class="p">()</span>

<span class="c1"># Start producers and consumers</span>
<span class="n">producers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">producer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;P</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">consumers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">consumer</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;C</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">producers</span><span class="p">:</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">consumers</span><span class="p">:</span>
    <span class="n">c</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>

<span class="c1"># Wait for producers</span>
<span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">producers</span><span class="p">:</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="c1"># Send poison pills to stop consumers</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">consumers</span><span class="p">:</span>
    <span class="n">queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

<span class="c1"># Wait for consumers</span>
<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">consumers</span><span class="p">:</span>
    <span class="n">c</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
</code></pre></div>

<h3 id="reader-writer-problem">Reader-Writer Problem<a class="header-link" href="#reader-writer-problem" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Multiple readers can read simultaneously, but writers need exclusive access.</p>
<p><strong>Python (using threading.RLock):</strong></p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Thread</span><span class="p">,</span> <span class="n">RLock</span>

<span class="k">class</span><span class="w"> </span><span class="nc">ReadWriteLock</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">readers</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_lock</span> <span class="o">=</span> <span class="n">RLock</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">acquire_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">readers</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">readers</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>  <span class="c1"># First reader blocks writers</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">release_read</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">readers</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">readers</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>  <span class="c1"># Last reader unblocks writers</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">acquire_write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_lock</span><span class="o">.</span><span class="n">acquire</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">release_write</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write_lock</span><span class="o">.</span><span class="n">release</span><span class="p">()</span>

<span class="c1"># Usage</span>
<span class="n">data</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">rw_lock</span> <span class="o">=</span> <span class="n">ReadWriteLock</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">reader</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="n">rw_lock</span><span class="o">.</span><span class="n">acquire_read</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> reading: </span><span class="si">{</span><span class="n">data</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">rw_lock</span><span class="o">.</span><span class="n">release_read</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">writer</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
    <span class="n">rw_lock</span><span class="o">.</span><span class="n">acquire_write</span><span class="p">()</span>
    <span class="k">global</span> <span class="n">data</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> writing: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">value</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.1</span><span class="p">)</span>
    <span class="n">rw_lock</span><span class="o">.</span><span class="n">release_write</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="asyncawait-pattern">Async/Await Pattern<a class="header-link" href="#asyncawait-pattern" title="Permanent link">&para;</a></h2>
<p>Async/await provides concurrency without threads: a single thread handles multiple tasks by yielding during I/O waits.</p>
<h3 id="event-loop-single-threaded-concurrency">Event Loop: Single-Threaded Concurrency<a class="header-link" href="#event-loop-single-threaded-concurrency" title="Permanent link">&para;</a></h3>
<p><strong>Event loop:</strong> Runs one task at a time, but switches between tasks when they're waiting.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Conceptual event loop</span>
<span class="n">tasks</span> <span class="o">=</span> <span class="p">[</span><span class="n">task1</span><span class="p">(),</span> <span class="n">task2</span><span class="p">(),</span> <span class="n">task3</span><span class="p">()]</span>
<span class="k">while</span> <span class="n">tasks</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">is_waiting</span><span class="p">():</span>
            <span class="k">continue</span>  <span class="c1"># Skip this task, it&#39;s waiting for I/O</span>
        <span class="n">task</span><span class="o">.</span><span class="n">run_until_wait</span><span class="p">()</span>  <span class="c1"># Run until it waits again</span>
        <span class="k">if</span> <span class="n">task</span><span class="o">.</span><span class="n">is_done</span><span class="p">():</span>
            <span class="n">tasks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">task</span><span class="p">)</span>
</code></pre></div>

<h3 id="promisesfutures-representing-eventual-values">Promises/Futures: Representing Eventual Values<a class="header-link" href="#promisesfutures-representing-eventual-values" title="Permanent link">&para;</a></h3>
<p><strong>Promise (JavaScript) / Future (Python):</strong> Represents a value that will be available in the future.</p>
<p><strong>States:</strong>
- <strong>Pending:</strong> Not yet resolved
- <strong>Fulfilled:</strong> Successfully resolved with a value
- <strong>Rejected:</strong> Failed with an error</p>
<h3 id="asyncawait-syntax">Async/Await Syntax<a class="header-link" href="#asyncawait-syntax" title="Permanent link">&para;</a></h3>
<p><strong>Python:</strong></p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">asyncio</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">fetch_data</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fetching </span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">...&quot;</span><span class="p">)</span>
    <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># Simulate network I/O (yields control)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fetched </span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;Data from </span><span class="si">{</span><span class="n">url</span><span class="si">}</span><span class="s2">&quot;</span>

<span class="k">async</span> <span class="k">def</span><span class="w"> </span><span class="nf">main</span><span class="p">():</span>
    <span class="c1"># Sequential: 6 seconds</span>
    <span class="n">data1</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_data</span><span class="p">(</span><span class="s2">&quot;http://example.com/1&quot;</span><span class="p">)</span>
    <span class="n">data2</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_data</span><span class="p">(</span><span class="s2">&quot;http://example.com/2&quot;</span><span class="p">)</span>
    <span class="n">data3</span> <span class="o">=</span> <span class="k">await</span> <span class="n">fetch_data</span><span class="p">(</span><span class="s2">&quot;http://example.com/3&quot;</span><span class="p">)</span>

    <span class="c1"># Concurrent: 2 seconds (all run together)</span>
    <span class="n">results</span> <span class="o">=</span> <span class="k">await</span> <span class="n">asyncio</span><span class="o">.</span><span class="n">gather</span><span class="p">(</span>
        <span class="n">fetch_data</span><span class="p">(</span><span class="s2">&quot;http://example.com/1&quot;</span><span class="p">),</span>
        <span class="n">fetch_data</span><span class="p">(</span><span class="s2">&quot;http://example.com/2&quot;</span><span class="p">),</span>
        <span class="n">fetch_data</span><span class="p">(</span><span class="s2">&quot;http://example.com/3&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>

<span class="n">asyncio</span><span class="o">.</span><span class="n">run</span><span class="p">(</span><span class="n">main</span><span class="p">())</span>
</code></pre></div>

<p><strong>JavaScript:</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">fetchData</span><span class="p">(</span><span class="nx">url</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Fetching </span><span class="si">${</span><span class="nx">url</span><span class="si">}</span><span class="sb">...`</span><span class="p">);</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="ow">new</span><span class="w"> </span><span class="nb">Promise</span><span class="p">(</span><span class="nx">resolve</span><span class="w"> </span><span class="p">=&gt;</span><span class="w"> </span><span class="nx">setTimeout</span><span class="p">(</span><span class="nx">resolve</span><span class="p">,</span><span class="w"> </span><span class="mf">2000</span><span class="p">));</span><span class="w">  </span><span class="c1">// Simulate delay</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="sb">`Fetched </span><span class="si">${</span><span class="nx">url</span><span class="si">}</span><span class="sb">`</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="sb">`Data from </span><span class="si">${</span><span class="nx">url</span><span class="si">}</span><span class="sb">`</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">async</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Sequential: 6 seconds</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">data1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetchData</span><span class="p">(</span><span class="s1">&#39;http://example.com/1&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">data2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetchData</span><span class="p">(</span><span class="s1">&#39;http://example.com/2&#39;</span><span class="p">);</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">data3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nx">fetchData</span><span class="p">(</span><span class="s1">&#39;http://example.com/3&#39;</span><span class="p">);</span>

<span class="w">    </span><span class="c1">// Concurrent: 2 seconds</span>
<span class="w">    </span><span class="kd">const</span><span class="w"> </span><span class="nx">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="nb">Promise</span><span class="p">.</span><span class="nx">all</span><span class="p">([</span>
<span class="w">        </span><span class="nx">fetchData</span><span class="p">(</span><span class="s1">&#39;http://example.com/1&#39;</span><span class="p">),</span>
<span class="w">        </span><span class="nx">fetchData</span><span class="p">(</span><span class="s1">&#39;http://example.com/2&#39;</span><span class="p">),</span>
<span class="w">        </span><span class="nx">fetchData</span><span class="p">(</span><span class="s1">&#39;http://example.com/3&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="p">]);</span>
<span class="w">    </span><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">results</span><span class="p">);</span>
<span class="p">}</span>

<span class="nx">main</span><span class="p">();</span>
</code></pre></div>

<p><strong>Rust:</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">tokio</span><span class="p">::</span><span class="n">time</span><span class="p">::{</span><span class="n">sleep</span><span class="p">,</span><span class="w"> </span><span class="n">Duration</span><span class="p">};</span>

<span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">fetch_data</span><span class="p">(</span><span class="n">url</span><span class="p">:</span><span class="w"> </span><span class="kp">&amp;</span><span class="kt">str</span><span class="p">)</span><span class="w"> </span><span class="p">-&gt;</span><span class="w"> </span><span class="nb">String</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Fetching {}...&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">url</span><span class="p">);</span>
<span class="w">    </span><span class="n">sleep</span><span class="p">(</span><span class="n">Duration</span><span class="p">::</span><span class="n">from_secs</span><span class="p">(</span><span class="mi">2</span><span class="p">)).</span><span class="k">await</span><span class="p">;</span><span class="w">  </span><span class="c1">// Yields control</span>
<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Fetched {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">url</span><span class="p">);</span>
<span class="w">    </span><span class="fm">format!</span><span class="p">(</span><span class="s">&quot;Data from {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">url</span><span class="p">)</span>
<span class="p">}</span>

<span class="cp">#[tokio::main]</span>
<span class="k">async</span><span class="w"> </span><span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Concurrent</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">data1</span><span class="p">,</span><span class="w"> </span><span class="n">data2</span><span class="p">,</span><span class="w"> </span><span class="n">data3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">tokio</span><span class="p">::</span><span class="n">join</span><span class="o">!</span><span class="p">(</span>
<span class="w">        </span><span class="n">fetch_data</span><span class="p">(</span><span class="s">&quot;http://example.com/1&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">fetch_data</span><span class="p">(</span><span class="s">&quot;http://example.com/2&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">fetch_data</span><span class="p">(</span><span class="s">&quot;http://example.com/3&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">);</span>

<span class="w">    </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;{}, {}, {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">data1</span><span class="p">,</span><span class="w"> </span><span class="n">data2</span><span class="p">,</span><span class="w"> </span><span class="n">data3</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>C# (.NET):</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">using</span><span class="w"> </span><span class="nn">System</span><span class="p">;</span>
<span class="k">using</span><span class="w"> </span><span class="nn">System.Threading.Tasks</span><span class="p">;</span>

<span class="k">async</span><span class="w"> </span><span class="n">Task</span><span class="o">&lt;</span><span class="kt">string</span><span class="o">&gt;</span><span class="w"> </span><span class="n">FetchData</span><span class="p">(</span><span class="kt">string</span><span class="w"> </span><span class="n">url</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&quot;Fetching {url}...&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">await</span><span class="w"> </span><span class="n">Task</span><span class="p">.</span><span class="n">Delay</span><span class="p">(</span><span class="mi">2000</span><span class="p">);</span><span class="w">  </span><span class="c1">// Simulate delay</span>
<span class="w">    </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&quot;Fetched {url}&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="s">$&quot;Data from {url}&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">async</span><span class="w"> </span><span class="n">Task</span><span class="w"> </span><span class="nf">Main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="c1">// Concurrent</span>
<span class="w">    </span><span class="kt">var</span><span class="w"> </span><span class="n">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">await</span><span class="w"> </span><span class="n">Task</span><span class="p">.</span><span class="n">WhenAll</span><span class="p">(</span>
<span class="w">        </span><span class="n">FetchData</span><span class="p">(</span><span class="s">&quot;http://example.com/1&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">FetchData</span><span class="p">(</span><span class="s">&quot;http://example.com/2&quot;</span><span class="p">),</span>
<span class="w">        </span><span class="n">FetchData</span><span class="p">(</span><span class="s">&quot;http://example.com/3&quot;</span><span class="p">)</span>
<span class="w">    </span><span class="p">);</span>

<span class="w">    </span><span class="k">foreach</span><span class="w"> </span><span class="p">(</span><span class="kt">var</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">results</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="when-to-use-async-vs-threads">When to Use Async vs Threads<a class="header-link" href="#when-to-use-async-vs-threads" title="Permanent link">&para;</a></h3>
<p><strong>Use async/await when:</strong>
- I/O-bound tasks (network, disk, database)
- You need to handle many concurrent operations (thousands of connections)
- You want to avoid threading overhead</p>
<p><strong>Use threads when:</strong>
- CPU-bound tasks (computation-heavy)
- You need true parallelism
- You're interfacing with thread-based APIs</p>
<p><strong>Example: I/O-bound (async wins)</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># Fetching 1000 URLs</span>
<span class="c1"># Threads: 1000 threads = high memory, context-switching overhead</span>
<span class="c1"># Async: Single thread, 1000 concurrent tasks = low overhead</span>
</code></pre></div>

<p><strong>Example: CPU-bound (threads/processes win)</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># Computing 1000 expensive calculations</span>
<span class="c1"># Async: Single core, sequential execution</span>
<span class="c1"># Threads/processes: Multiple cores, parallel execution</span>
</code></pre></div>

<hr />
<h2 id="message-passing">Message Passing<a class="header-link" href="#message-passing" title="Permanent link">&para;</a></h2>
<p>Instead of sharing memory (and dealing with locks), threads/processes communicate by sending messages.</p>
<h3 id="channels-go-rust">Channels (Go, Rust)<a class="header-link" href="#channels-go-rust" title="Permanent link">&para;</a></h3>
<p><strong>Go:</strong></p>
<div class="highlight"><pre><span></span><code><span class="kn">package</span><span class="w"> </span><span class="nx">main</span>

<span class="kn">import</span><span class="w"> </span><span class="s">&quot;fmt&quot;</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">producer</span><span class="p">(</span><span class="nx">ch</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="w"> </span><span class="p">&lt;</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="nx">i</span><span class="o">++</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="nx">ch</span><span class="w"> </span><span class="o">&lt;-</span><span class="w"> </span><span class="nx">i</span><span class="w">  </span><span class="c1">// Send to channel</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="nb">close</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span><span class="w">  </span><span class="c1">// Signal no more data</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">consumer</span><span class="p">(</span><span class="nx">ch</span><span class="w"> </span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">value</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="k">range</span><span class="w"> </span><span class="nx">ch</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Receive from channel</span>
<span class="w">        </span><span class="nx">fmt</span><span class="p">.</span><span class="nx">Println</span><span class="p">(</span><span class="s">&quot;Received:&quot;</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span><span class="w"> </span><span class="nx">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">ch</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nb">make</span><span class="p">(</span><span class="kd">chan</span><span class="w"> </span><span class="kt">int</span><span class="p">)</span>
<span class="w">    </span><span class="k">go</span><span class="w"> </span><span class="nx">producer</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
<span class="w">    </span><span class="nx">consumer</span><span class="p">(</span><span class="nx">ch</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Rust:</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
<span class="k">use</span><span class="w"> </span><span class="n">std</span><span class="p">::</span><span class="n">sync</span><span class="p">::</span><span class="n">mpsc</span><span class="p">;</span><span class="w">  </span><span class="c1">// Multiple Producer, Single Consumer</span>

<span class="k">fn</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kd">let</span><span class="w"> </span><span class="p">(</span><span class="n">tx</span><span class="p">,</span><span class="w"> </span><span class="n">rx</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">mpsc</span><span class="p">::</span><span class="n">channel</span><span class="p">();</span>

<span class="w">    </span><span class="n">thread</span><span class="p">::</span><span class="n">spawn</span><span class="p">(</span><span class="k">move</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="mi">0</span><span class="o">..</span><span class="mi">5</span><span class="w"> </span><span class="p">{</span>
<span class="w">            </span><span class="n">tx</span><span class="p">.</span><span class="n">send</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">unwrap</span><span class="p">();</span><span class="w">  </span><span class="c1">// Send to channel</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">});</span>

<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">received</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">rx</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="c1">// Receive from channel</span>
<span class="w">        </span><span class="fm">println!</span><span class="p">(</span><span class="s">&quot;Received: {}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">received</span><span class="p">);</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Benefits:</strong>
- No shared state ‚Üí no locks needed
- Clear ownership (in Rust, channel owns the data)
- Easier to reason about</p>
<h3 id="actor-model-erlang-akka">Actor Model (Erlang, Akka)<a class="header-link" href="#actor-model-erlang-akka" title="Permanent link">&para;</a></h3>
<p><strong>Actor:</strong> Isolated entity that:
- Has private state
- Communicates only via messages
- Processes messages sequentially</p>
<p><strong>Erlang example:</strong></p>
<div class="highlight"><pre><span></span><code><span class="c">% Define an actor</span>
<span class="nf">counter_actor</span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="n">counter_loop</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span>

<span class="nf">counter_loop</span><span class="p">(</span><span class="nv">Count</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">    </span><span class="k">receive</span>
<span class="w">        </span><span class="p">{</span><span class="n">increment</span><span class="p">,</span><span class="w"> </span><span class="nv">From</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="nv">NewCount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Count</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span>
<span class="w">            </span><span class="nv">From</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="nv">NewCount</span><span class="p">},</span>
<span class="w">            </span><span class="n">counter_loop</span><span class="p">(</span><span class="nv">NewCount</span><span class="p">);</span>
<span class="w">        </span><span class="p">{</span><span class="nb">get</span><span class="p">,</span><span class="w"> </span><span class="nv">From</span><span class="p">}</span><span class="w"> </span><span class="o">-&gt;</span>
<span class="w">            </span><span class="nv">From</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="n">count</span><span class="p">,</span><span class="w"> </span><span class="nv">Count</span><span class="p">},</span>
<span class="w">            </span><span class="n">counter_loop</span><span class="p">(</span><span class="nv">Count</span><span class="p">)</span>
<span class="w">    </span><span class="k">end</span><span class="p">.</span>

<span class="c">% Start the actor</span>
<span class="nv">Pid</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">spawn</span><span class="p">(</span><span class="k">fun</span><span class="w"> </span><span class="n">counter_actor</span><span class="o">/</span><span class="mi">0</span><span class="p">),</span>

<span class="c">% Send messages</span>
<span class="nv">Pid</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="n">increment</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p">()},</span>
<span class="nv">Pid</span><span class="w"> </span><span class="o">!</span><span class="w"> </span><span class="p">{</span><span class="nb">get</span><span class="p">,</span><span class="w"> </span><span class="n">self</span><span class="p">()}.</span>
</code></pre></div>

<h3 id="csp-communicating-sequential-processes">CSP (Communicating Sequential Processes)<a class="header-link" href="#csp-communicating-sequential-processes" title="Permanent link">&para;</a></h3>
<p><strong>Go's concurrency model:</strong> Goroutines communicate via channels (CSP).</p>
<p><strong>Slogan:</strong> "Don't communicate by sharing memory; share memory by communicating."</p>
<hr />
<h2 id="parallel-patterns">Parallel Patterns<a class="header-link" href="#parallel-patterns" title="Permanent link">&para;</a></h2>
<h3 id="map-reduce">Map-Reduce<a class="header-link" href="#map-reduce" title="Permanent link">&para;</a></h3>
<p><strong>Map:</strong> Apply function to each element (in parallel)
<strong>Reduce:</strong> Aggregate results</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">multiprocessing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Pool</span>

<span class="k">def</span><span class="w"> </span><span class="nf">square</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span>

<span class="k">def</span><span class="w"> </span><span class="nf">sum_squares</span><span class="p">(</span><span class="n">numbers</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">()</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="c1"># Map: square each number in parallel</span>
        <span class="n">squared</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">numbers</span><span class="p">)</span>

    <span class="c1"># Reduce: sum the results</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">squared</span><span class="p">)</span>

<span class="n">numbers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">))</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">sum_squares</span><span class="p">(</span><span class="n">numbers</span><span class="p">)</span>
</code></pre></div>

<h3 id="fork-join">Fork-Join<a class="header-link" href="#fork-join" title="Permanent link">&para;</a></h3>
<p><strong>Fork:</strong> Divide task into subtasks
<strong>Execute:</strong> Run subtasks in parallel
<strong>Join:</strong> Combine results</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">merge_sort_parallel</span><span class="p">(</span><span class="n">arr</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">arr</span>

    <span class="n">mid</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arr</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">left</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[:</span><span class="n">mid</span><span class="p">]</span>
    <span class="n">right</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="n">mid</span><span class="p">:]</span>

    <span class="c1"># Fork: Create parallel tasks</span>
    <span class="k">with</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="k">as</span> <span class="n">pool</span><span class="p">:</span>
        <span class="n">sorted_left</span><span class="p">,</span> <span class="n">sorted_right</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">merge_sort_parallel</span><span class="p">,</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">])</span>

    <span class="c1"># Join: Merge results</span>
    <span class="k">return</span> <span class="n">merge</span><span class="p">(</span><span class="n">sorted_left</span><span class="p">,</span> <span class="n">sorted_right</span><span class="p">)</span>
</code></pre></div>

<h3 id="pipeline">Pipeline<a class="header-link" href="#pipeline" title="Permanent link">&para;</a></h3>
<p><strong>Pipeline:</strong> Data flows through stages, each stage processes in parallel.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Stage 1: Read files</span>
<span class="c1"># Stage 2: Parse data</span>
<span class="c1"># Stage 3: Process data</span>
<span class="c1"># Stage 4: Write results</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">queue</span><span class="w"> </span><span class="kn">import</span> <span class="n">Queue</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Thread</span>

<span class="k">def</span><span class="w"> </span><span class="nf">stage1_read</span><span class="p">(</span><span class="n">output_queue</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">filename</span> <span class="ow">in</span> <span class="n">filenames</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">read_file</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">output_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
    <span class="n">output_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>  <span class="c1"># Signal end</span>

<span class="k">def</span><span class="w"> </span><span class="nf">stage2_parse</span><span class="p">(</span><span class="n">input_queue</span><span class="p">,</span> <span class="n">output_queue</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">input_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">parsed</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">output_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">parsed</span><span class="p">)</span>
    <span class="n">output_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">stage3_process</span><span class="p">(</span><span class="n">input_queue</span><span class="p">,</span> <span class="n">output_queue</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">input_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">processed</span> <span class="o">=</span> <span class="n">process</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">output_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">processed</span><span class="p">)</span>
    <span class="n">output_queue</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">stage4_write</span><span class="p">(</span><span class="n">input_queue</span><span class="p">):</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">input_queue</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">break</span>
        <span class="n">write_result</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="c1"># Connect stages with queues</span>
<span class="n">q1</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
<span class="n">q2</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
<span class="n">q3</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>

<span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">stage1_read</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q1</span><span class="p">,))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">stage2_parse</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q1</span><span class="p">,</span> <span class="n">q2</span><span class="p">))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">stage3_process</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q2</span><span class="p">,</span> <span class="n">q3</span><span class="p">))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">stage4_write</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q3</span><span class="p">,))</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
</code></pre></div>

<h3 id="thread-pool-worker-pool">Thread Pool / Worker Pool<a class="header-link" href="#thread-pool-worker-pool" title="Permanent link">&para;</a></h3>
<p><strong>Idea:</strong> Pre-create threads, assign tasks from a queue.</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">concurrent.futures</span><span class="w"> </span><span class="kn">import</span> <span class="n">ThreadPoolExecutor</span>

<span class="k">def</span><span class="w"> </span><span class="nf">task</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span>

<span class="c1"># Create thread pool with 4 workers</span>
<span class="k">with</span> <span class="n">ThreadPoolExecutor</span><span class="p">(</span><span class="n">max_workers</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span> <span class="k">as</span> <span class="n">executor</span><span class="p">:</span>
    <span class="c1"># Submit tasks</span>
    <span class="n">futures</span> <span class="o">=</span> <span class="p">[</span><span class="n">executor</span><span class="o">.</span><span class="n">submit</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">100</span><span class="p">)]</span>

    <span class="c1"># Get results</span>
    <span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="n">future</span><span class="o">.</span><span class="n">result</span><span class="p">()</span> <span class="k">for</span> <span class="n">future</span> <span class="ow">in</span> <span class="n">futures</span><span class="p">]</span>

<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="common-pitfalls">Common Pitfalls<a class="header-link" href="#common-pitfalls" title="Permanent link">&para;</a></h2>
<h3 id="1-race-conditions-check-then-act">1. Race Conditions (Check-Then-Act)<a class="header-link" href="#1-race-conditions-check-then-act" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># BAD: Race condition</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">file_exists</span><span class="p">(</span><span class="s2">&quot;output.txt&quot;</span><span class="p">):</span>  <span class="c1"># Thread 1 checks</span>
    <span class="c1"># Thread 2 also checks (file still doesn&#39;t exist)</span>
    <span class="n">create_file</span><span class="p">(</span><span class="s2">&quot;output.txt&quot;</span><span class="p">)</span>  <span class="c1"># Both threads create the file!</span>

<span class="c1"># GOOD: Atomic operation</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">create_file_exclusive</span><span class="p">(</span><span class="s2">&quot;output.txt&quot;</span><span class="p">)</span>  <span class="c1"># Fails if file exists</span>
<span class="k">except</span> <span class="ne">FileExistsError</span><span class="p">:</span>
    <span class="k">pass</span>
</code></pre></div>

<h3 id="2-deadlock">2. Deadlock<a class="header-link" href="#2-deadlock" title="Permanent link">&para;</a></h3>
<p>(See earlier section)</p>
<h3 id="3-livelock">3. Livelock<a class="header-link" href="#3-livelock" title="Permanent link">&para;</a></h3>
<p><strong>Livelock:</strong> Threads keep changing state in response to each other, but make no progress.</p>
<p><strong>Example:</strong></p>
<div class="highlight"><pre><span></span><code>Person A and Person B meet in a narrow hallway.
A steps left to let B pass.
B steps right to let A pass.
Now they&#39;re blocking each other again.
A steps right.
B steps left.
Repeat forever...
</code></pre></div>

<p><strong>Prevention:</strong> Add randomness to retry logic.</p>
<h3 id="4-starvation">4. Starvation<a class="header-link" href="#4-starvation" title="Permanent link">&para;</a></h3>
<p><strong>Starvation:</strong> A thread never gets a chance to run because others keep taking priority.</p>
<p><strong>Example:</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># High-priority threads keep getting the lock</span>
<span class="c1"># Low-priority thread waits forever</span>
</code></pre></div>

<p><strong>Prevention:</strong> Use fair locks that guarantee eventual access.</p>
<h3 id="5-false-sharing-cache-lines">5. False Sharing (Cache Lines)<a class="header-link" href="#5-false-sharing-cache-lines" title="Permanent link">&para;</a></h3>
<p><strong>Problem:</strong> Two threads access different variables, but they're on the same cache line, causing cache invalidation.</p>
<div class="highlight"><pre><span></span><code><span class="c1">// BAD: Both on same cache line (typically 64 bytes)</span>
<span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">counter1</span><span class="p">;</span><span class="w">  </span><span class="c1">// Thread 1 modifies</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">counter2</span><span class="p">;</span><span class="w">  </span><span class="c1">// Thread 2 modifies</span>
<span class="p">}</span><span class="w"> </span><span class="n">shared_data</span><span class="p">;</span>

<span class="c1">// Every write by Thread 1 invalidates Thread 2&#39;s cache (and vice versa)</span>

<span class="c1">// GOOD: Pad to separate cache lines</span>
<span class="k">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">counter1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">char</span><span class="w"> </span><span class="n">padding</span><span class="p">[</span><span class="mi">60</span><span class="p">];</span><span class="w">  </span><span class="c1">// Ensure counter2 is on different cache line</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">counter2</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">shared_data</span><span class="p">;</span>
</code></pre></div>

<hr />
<h2 id="immutability-as-a-concurrency-strategy">Immutability as a Concurrency Strategy<a class="header-link" href="#immutability-as-a-concurrency-strategy" title="Permanent link">&para;</a></h2>
<p><strong>Immutable data can be safely shared between threads without locks.</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1"># Mutable (requires locking)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Counter</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">lock</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>

<span class="c1"># Immutable (no locking needed)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ImmutableCounter</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">=</span> <span class="n">count</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">ImmutableCounter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Returns new instance</span>

<span class="c1"># Usage</span>
<span class="n">counter</span> <span class="o">=</span> <span class="n">ImmutableCounter</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">counter</span> <span class="o">=</span> <span class="n">counter</span><span class="o">.</span><span class="n">increment</span><span class="p">()</span>  <span class="c1"># New object, old one unchanged</span>
</code></pre></div>

<p><strong>Functional programming languages</strong> (Haskell, Clojure, Erlang) use immutability extensively for safe concurrency.</p>
<hr />
<h2 id="lock-free-data-structures">Lock-Free Data Structures<a class="header-link" href="#lock-free-data-structures" title="Permanent link">&para;</a></h2>
<p><strong>Lock-free:</strong> Use atomic operations (compare-and-swap) instead of locks.</p>
<p><strong>Example: Atomic counter</strong></p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">threading</span><span class="w"> </span><span class="kn">import</span> <span class="n">Thread</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">ctypes</span>

<span class="k">class</span><span class="w"> </span><span class="nc">AtomicCounter</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_value</span> <span class="o">=</span> <span class="n">ctypes</span><span class="o">.</span><span class="n">c_int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">increment</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># This is conceptual; Python doesn&#39;t have true CAS</span>
        <span class="c1"># In C++: std::atomic&lt;int&gt;</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">old_value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">.</span><span class="n">value</span>
            <span class="n">new_value</span> <span class="o">=</span> <span class="n">old_value</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="c1"># Compare-and-swap: update only if value hasn&#39;t changed</span>
            <span class="k">if</span> <span class="n">compare_and_swap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">,</span> <span class="n">old_value</span><span class="p">,</span> <span class="n">new_value</span><span class="p">):</span>
                <span class="k">break</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="o">.</span><span class="n">value</span>
</code></pre></div>

<p><strong>C++ atomic example:</strong></p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;atomic&gt;</span>

<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">counter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">increment</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">counter</span><span class="p">.</span><span class="n">fetch_add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span><span class="w">  </span><span class="c1">// Atomic increment</span>
<span class="p">}</span>
</code></pre></div>

<p><strong>Benefits:</strong>
- No locks ‚Üí no deadlocks
- Better performance in low-contention scenarios</p>
<p><strong>Drawbacks:</strong>
- Complex to implement correctly
- ABA problem (value changes A‚ÜíB‚ÜíA, CAS thinks nothing changed)</p>
<hr />
<h2 id="summary">Summary<a class="header-link" href="#summary" title="Permanent link">&para;</a></h2>
<p><strong>Key Principles:</strong></p>
<ol>
<li><strong>Concurrency ‚â† Parallelism</strong> ‚Äì Structure vs execution</li>
<li><strong>Shared state is dangerous</strong> ‚Äì Locks or immutability required</li>
<li><strong>Locks introduce complexity</strong> ‚Äì Deadlocks, ordering, performance</li>
<li><strong>Message passing &gt; shared memory</strong> ‚Äì In many cases</li>
<li><strong>Async for I/O, threads for CPU</strong> ‚Äì Choose the right tool</li>
<li><strong>Immutability helps</strong> ‚Äì No locks needed</li>
<li><strong>Test thoroughly</strong> ‚Äì Concurrency bugs are rare and hard to reproduce</li>
</ol>
<p><strong>Mental Model:</strong>
- <strong>Threads:</strong> Shared memory, requires synchronization, can run in parallel
- <strong>Async/await:</strong> Single thread, cooperative multitasking, I/O-bound
- <strong>Message passing:</strong> No shared state, isolated actors/processes</p>
<hr />
<h2 id="exercises">Exercises<a class="header-link" href="#exercises" title="Permanent link">&para;</a></h2>
<h3 id="exercise-1-identify-race-conditions">Exercise 1: Identify Race Conditions<a class="header-link" href="#exercise-1-identify-race-conditions" title="Permanent link">&para;</a></h3>
<p>Find and fix the race condition:</p>
<div class="highlight"><pre><span></span><code><span class="n">balance</span> <span class="o">=</span> <span class="mi">1000</span>

<span class="k">def</span><span class="w"> </span><span class="nf">withdraw</span><span class="p">(</span><span class="n">amount</span><span class="p">):</span>
    <span class="k">global</span> <span class="n">balance</span>
    <span class="k">if</span> <span class="n">balance</span> <span class="o">&gt;=</span> <span class="n">amount</span><span class="p">:</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.01</span><span class="p">)</span>  <span class="c1"># Simulate processing time</span>
        <span class="n">balance</span> <span class="o">-=</span> <span class="n">amount</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="c1"># Two threads withdraw simultaneously</span>
<span class="n">t1</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">withdraw</span><span class="p">(</span><span class="mi">600</span><span class="p">))</span>
<span class="n">t2</span> <span class="o">=</span> <span class="n">Thread</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">withdraw</span><span class="p">(</span><span class="mi">600</span><span class="p">))</span>
<span class="n">t1</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
<span class="n">t1</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
<span class="n">t2</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>

<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Balance: </span><span class="si">{</span><span class="n">balance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>  <span class="c1"># Should be 1000 or 400, never -200!</span>
</code></pre></div>

<h3 id="exercise-2-implement-producer-consumer">Exercise 2: Implement Producer-Consumer<a class="header-link" href="#exercise-2-implement-producer-consumer" title="Permanent link">&para;</a></h3>
<p>Implement a thread-safe producer-consumer system where:
- 3 producers generate random numbers (1-100)
- 2 consumers compute the sum
- Print the final sum after all numbers are processed</p>
<p>Use a queue and appropriate synchronization.</p>
<h3 id="exercise-3-asyncawait-for-io">Exercise 3: Async/Await for I/O<a class="header-link" href="#exercise-3-asyncawait-for-io" title="Permanent link">&para;</a></h3>
<p>Rewrite this sequential code to use async/await:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">fetch_user</span><span class="p">(</span><span class="n">user_id</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Simulate network delay</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">user_id</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;User</span><span class="si">{</span><span class="n">user_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">}</span>

<span class="k">def</span><span class="w"> </span><span class="nf">fetch_orders</span><span class="p">(</span><span class="n">user_id</span><span class="p">):</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Simulate network delay</span>
    <span class="k">return</span> <span class="p">[{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="mi">100</span><span class="p">},</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="mi">200</span><span class="p">}]</span>

<span class="k">def</span><span class="w"> </span><span class="nf">get_user_with_orders</span><span class="p">(</span><span class="n">user_id</span><span class="p">):</span>
    <span class="n">user</span> <span class="o">=</span> <span class="n">fetch_user</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
    <span class="n">orders</span> <span class="o">=</span> <span class="n">fetch_orders</span><span class="p">(</span><span class="n">user_id</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;user&quot;</span><span class="p">:</span> <span class="n">user</span><span class="p">,</span> <span class="s2">&quot;orders&quot;</span><span class="p">:</span> <span class="n">orders</span><span class="p">}</span>

<span class="c1"># Takes 2 seconds (sequential)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">get_user_with_orders</span><span class="p">(</span><span class="mi">123</span><span class="p">)</span>
</code></pre></div>

<p>Optimize to run in 1 second using asyncio.</p>
<h3 id="exercise-4-parallel-map-reduce">Exercise 4: Parallel Map-Reduce<a class="header-link" href="#exercise-4-parallel-map-reduce" title="Permanent link">&para;</a></h3>
<p>Implement a parallel word count:
- Input: List of text files
- Output: Dictionary of word frequencies
- Use multiprocessing to process files in parallel</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">word_count</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
    <span class="c1"># Map: Count words in each file (parallel)</span>
    <span class="c1"># Reduce: Combine counts</span>
    <span class="k">pass</span>
</code></pre></div>

<h3 id="exercise-5-deadlock-scenario">Exercise 5: Deadlock Scenario<a class="header-link" href="#exercise-5-deadlock-scenario" title="Permanent link">&para;</a></h3>
<p>This code has a potential deadlock. Fix it:</p>
<div class="highlight"><pre><span></span><code><span class="n">lock_a</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>
<span class="n">lock_b</span> <span class="o">=</span> <span class="n">Lock</span><span class="p">()</span>

<span class="k">def</span><span class="w"> </span><span class="nf">transfer_a_to_b</span><span class="p">(</span><span class="n">amount</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">lock_a</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">lock_b</span><span class="p">:</span>
            <span class="c1"># Transfer from A to B</span>
            <span class="k">pass</span>

<span class="k">def</span><span class="w"> </span><span class="nf">transfer_b_to_a</span><span class="p">(</span><span class="n">amount</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">lock_b</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">lock_a</span><span class="p">:</span>
            <span class="c1"># Transfer from B to A</span>
            <span class="k">pass</span>

<span class="c1"># If both run simultaneously, deadlock occurs</span>
</code></pre></div>

<hr />
<h2 id="navigation">Navigation<a class="header-link" href="#navigation" title="Permanent link">&para;</a></h2>
<p><strong>Previous Lesson</strong>: <a href="11_Debugging_and_Profiling.md">11_Debugging_and_Profiling.md</a>
<strong>Next Lesson</strong>: <a href="13_Performance_Optimization.md">13_Performance_Optimization.md</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Programming/11_Debugging_and_Profiling.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Debugging & Profiling</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Programming/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Programming/13_API_Design.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">API Design Principles</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}