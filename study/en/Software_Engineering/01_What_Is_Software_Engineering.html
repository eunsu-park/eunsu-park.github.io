{% raw %}
<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 1: What Is Software Engineering - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/en/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/en/" class="nav-item ">
                    <span class="nav-icon">üè†</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">üíª</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/en/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" selected>
                        English
                    </option>
                    
                    <option value="ko" >
                        ÌïúÍµ≠Ïñ¥
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">‚òÄÔ∏è</span>
                    <span class="theme-icon dark">üåô</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/en/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/en/Software_Engineering/">Software Engineering</a>
    <span class="separator">/</span>
    <span class="current">Lesson 1: What Is Software Engineering</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 1: What Is Software Engineering</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Software_Engineering/00_Overview.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Software Engineering</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Software_Engineering/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Software_Engineering/02_Software_Development_Life_Cycle.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 2: Software Development Life Cycle</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#1-definitions-and-scope">1. Definitions and Scope</a><ul>
<li><a href="#what-is-software-engineering">What Is Software Engineering?</a></li>
<li><a href="#software-engineering-vs-programming">Software Engineering vs. Programming</a></li>
<li><a href="#software-engineering-vs-computer-science">Software Engineering vs. Computer Science</a></li>
</ul>
</li>
<li><a href="#2-the-software-crisis">2. The Software Crisis</a><ul>
<li><a href="#historical-context-nato-1968">Historical Context: NATO 1968</a></li>
<li><a href="#the-continuing-challenge">The Continuing Challenge</a></li>
</ul>
</li>
<li><a href="#3-why-software-is-hard-brookss-four-properties">3. Why Software Is Hard: Brooks's Four Properties</a><ul>
<li><a href="#31-complexity">3.1 Complexity</a></li>
<li><a href="#32-conformity">3.2 Conformity</a></li>
<li><a href="#33-changeability">3.3 Changeability</a></li>
<li><a href="#34-invisibility">3.4 Invisibility</a></li>
</ul>
</li>
<li><a href="#4-types-of-software">4. Types of Software</a><ul>
<li><a href="#41-systems-software">4.1 Systems Software</a></li>
<li><a href="#42-application-software">4.2 Application Software</a></li>
<li><a href="#43-embedded-software">4.3 Embedded Software</a></li>
<li><a href="#44-web-software">4.4 Web Software</a></li>
<li><a href="#45-mobile-software">4.5 Mobile Software</a></li>
<li><a href="#46-ai-and-machine-learning-systems">4.6 AI and Machine Learning Systems</a></li>
</ul>
</li>
<li><a href="#5-core-principles-of-software-engineering">5. Core Principles of Software Engineering</a><ul>
<li><a href="#51-rigor-and-formality">5.1 Rigor and Formality</a></li>
<li><a href="#52-separation-of-concerns">5.2 Separation of Concerns</a></li>
<li><a href="#53-modularity">5.3 Modularity</a></li>
<li><a href="#54-abstraction">5.4 Abstraction</a></li>
<li><a href="#55-anticipation-of-change">5.5 Anticipation of Change</a></li>
<li><a href="#56-generality">5.6 Generality</a></li>
<li><a href="#57-incrementality">5.7 Incrementality</a></li>
</ul>
</li>
<li><a href="#6-brief-history-of-software-engineering">6. Brief History of Software Engineering</a></li>
<li><a href="#7-professional-roles-in-software-engineering">7. Professional Roles in Software Engineering</a></li>
<li><a href="#8-summary">8. Summary</a></li>
<li><a href="#practice-exercises">Practice Exercises</a></li>
<li><a href="#further-reading">Further Reading</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-1-what-is-software-engineering">Lesson 1: What Is Software Engineering<a class="header-link" href="#lesson-1-what-is-software-engineering" title="Permanent link">&para;</a></h1>
<p><strong>Previous</strong>: <a href="./00_Overview.md">Overview</a> | <strong>Next</strong>: <a href="./02_Software_Development_Life_Cycle.md">Software Development Life Cycle</a></p>
<hr />
<p>Software engineering is the disciplined application of engineering principles to the design, development, testing, deployment, and maintenance of software. It is more than writing code ‚Äî it is a body of knowledge, a set of processes, and a professional practice aimed at producing software that is reliable, efficient, and maintainable at scale.</p>
<p><strong>Difficulty</strong>: ‚≠ê‚≠ê</p>
<p><strong>Prerequisites</strong>:
- Some programming experience in any language
- Familiarity with the basic idea of software projects</p>
<p><strong>Learning Objectives</strong>:
- Define software engineering and distinguish it from programming and computer science
- Explain the origins and significance of the software crisis
- Describe the essential characteristics of software that make it challenging to engineer
- Identify the major categories of software systems
- List the core principles that guide software engineering practice
- Recognize the professional roles found in software engineering teams</p>
<hr />
<h2 id="1-definitions-and-scope">1. Definitions and Scope<a class="header-link" href="#1-definitions-and-scope" title="Permanent link">&para;</a></h2>
<h3 id="what-is-software-engineering">What Is Software Engineering?<a class="header-link" href="#what-is-software-engineering" title="Permanent link">&para;</a></h3>
<p>The term "software engineering" was first used publicly at the 1968 NATO Science Committee conference in Garmisch, Germany, deliberately chosen to be provocative ‚Äî to suggest that software development should be held to the same standards of rigor and discipline as other engineering fields.</p>
<p>Several authoritative definitions have been offered over the decades:</p>
<p><strong>IEEE (Institute of Electrical and Electronics Engineers)</strong>:</p>
<blockquote>
<p>"The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is, the application of engineering to software."
‚Äî IEEE Standard 610.12-1990</p>
</blockquote>
<p><strong>Sommerville</strong>:</p>
<blockquote>
<p>"Software engineering is an engineering discipline that is concerned with all aspects of software production from the early stages of system specification through to maintaining the system after it has gone into use."</p>
</blockquote>
<p><strong>Pressman</strong>:</p>
<blockquote>
<p>"Software engineering encompasses a process, a collection of methods (practice), and an array of tools that allow professionals to build high-quality computer software."</p>
</blockquote>
<p>What these definitions share is an emphasis on <strong>all aspects of production</strong> ‚Äî not just coding, but specification, design, testing, maintenance, and the organizational and managerial concerns that surround them.</p>
<h3 id="software-engineering-vs-programming">Software Engineering vs. Programming<a class="header-link" href="#software-engineering-vs-programming" title="Permanent link">&para;</a></h3>
<p>Programming is a necessary component of software engineering, but the two are not synonymous.</p>
<table>
<thead>
<tr>
<th>Dimension</th>
<th>Programming</th>
<th>Software Engineering</th>
</tr>
</thead>
<tbody>
<tr>
<td>Scope</td>
<td>Writing code to solve a problem</td>
<td>The entire lifecycle of software production</td>
</tr>
<tr>
<td>Time horizon</td>
<td>Hours to days</td>
<td>Months to years</td>
</tr>
<tr>
<td>Team size</td>
<td>Typically individual</td>
<td>Often 5 to 500+ people</td>
</tr>
<tr>
<td>Primary concern</td>
<td>Making it work</td>
<td>Making it work, maintainably, reliably, on schedule</td>
</tr>
<tr>
<td>Key artifacts</td>
<td>Source code</td>
<td>Code, specifications, designs, tests, plans, docs</td>
</tr>
<tr>
<td>Key skills</td>
<td>Language proficiency, algorithms</td>
<td>Process, communication, estimation, risk management</td>
</tr>
<tr>
<td>Success metric</td>
<td>Code runs correctly</td>
<td>Project delivered on time, budget, with required quality</td>
</tr>
</tbody>
</table>
<p>A useful analogy: <strong>programming is to software engineering as bricklaying is to civil engineering</strong>. Bricklaying is an essential craft, but civil engineering also encompasses structural analysis, project management, materials science, regulatory compliance, and long-term maintenance planning.</p>
<h3 id="software-engineering-vs-computer-science">Software Engineering vs. Computer Science<a class="header-link" href="#software-engineering-vs-computer-science" title="Permanent link">&para;</a></h3>
<p>Computer science and software engineering are related but distinct disciplines:</p>
<ul>
<li><strong>Computer Science</strong> is primarily concerned with the <em>theory</em> underlying computation: algorithms, data structures, formal languages, complexity theory, logic, and the mathematical foundations of computing.</li>
<li><strong>Software Engineering</strong> is primarily concerned with the <em>practice</em> of producing software systems: how to organize the development process, manage teams, ensure quality, and deliver products that meet user needs.</li>
</ul>
<p>In practice, a software engineer draws on computer science theory but is ultimately evaluated on whether software gets built and delivered reliably.</p>
<hr />
<h2 id="2-the-software-crisis">2. The Software Crisis<a class="header-link" href="#2-the-software-crisis" title="Permanent link">&para;</a></h2>
<h3 id="historical-context-nato-1968">Historical Context: NATO 1968<a class="header-link" href="#historical-context-nato-1968" title="Permanent link">&para;</a></h3>
<p>By the late 1960s, it became apparent that the software industry was in trouble. Large software projects were routinely:</p>
<ul>
<li><strong>Over budget</strong>: Costs far exceeded estimates</li>
<li><strong>Late</strong>: Schedules slipped by months or years</li>
<li><strong>Unreliable</strong>: Delivered systems contained serious defects</li>
<li><strong>Unmaintainable</strong>: Code was so complex that adding new features was prohibitively difficult</li>
<li><strong>Cancelled</strong>: Many projects were abandoned entirely after consuming significant resources</li>
</ul>
<p>Notable examples from that era include the IBM OS/360 operating system project, which Fred Brooks documented in his 1975 book <em>The Mythical Man-Month</em>. OS/360 was massively over budget and late, despite employing thousands of programmers.</p>
<p>The 1968 NATO conference coined the term "software crisis" to describe this state of affairs. Edsger Dijkstra, Tony Hoare, and others argued that software development needed to become a true engineering discipline with formal methods, systematic processes, and measurable outcomes.</p>
<h3 id="the-continuing-challenge">The Continuing Challenge<a class="header-link" href="#the-continuing-challenge" title="Permanent link">&para;</a></h3>
<p>Decades later, many of the original problems persist. The Standish Group's CHAOS Report has tracked software project outcomes since 1994:</p>
<div class="highlight"><pre><span></span><code><span class="c">CHAOS Report (approximate historical averages):</span>
<span class="nb">+------------------+------------------+</span>
<span class="c">| Outcome          | % of Projects    |</span>
<span class="nb">+------------------+------------------+</span>
<span class="c">| Successful       | ~30%             |</span>
<span class="c">| (on time</span><span class="nt">,</span><span class="c"> budget</span><span class="nt">,</span><span class="c">|                  |</span>
<span class="c">|  full features)  |                  |</span>
<span class="nb">+------------------+------------------+</span>
<span class="c">| Challenged       | ~50%             |</span>
<span class="c">| (late</span><span class="nt">,</span><span class="c"> over      |                  |</span>
<span class="c">|  budget</span><span class="nt">,</span><span class="c"> reduced |                  |</span>
<span class="c">|  features)       |                  |</span>
<span class="nb">+------------------+------------------+</span>
<span class="c">| Failed           | ~20%             |</span>
<span class="c">| (cancelled or    |                  |</span>
<span class="c">|  never used)     |                  |</span>
<span class="nb">+------------------+------------------+</span>
</code></pre></div>

<p>Software engineering as a discipline exists precisely to improve these statistics.</p>
<hr />
<h2 id="3-why-software-is-hard-brookss-four-properties">3. Why Software Is Hard: Brooks's Four Properties<a class="header-link" href="#3-why-software-is-hard-brookss-four-properties" title="Permanent link">&para;</a></h2>
<p>In <em>No Silver Bullet</em> (1986), Fred Brooks identified four essential properties of software that make it inherently difficult to engineer, arguing that there is no single technique that will dramatically improve software productivity.</p>
<h3 id="31-complexity">3.1 Complexity<a class="header-link" href="#31-complexity" title="Permanent link">&para;</a></h3>
<p>Software systems contain more states than any other human artifact of comparable size. A simple program with 300 boolean variables has $2^{300}$ possible states ‚Äî far more than the number of atoms in the observable universe. This complexity is essential, not accidental: it reflects the complexity of the real-world problems software must solve.</p>
<p>This essential complexity means:
- You cannot fully test all possible states
- Changes in one part of a system may have unexpected effects elsewhere
- Understanding a large codebase takes significant time and effort</p>
<h3 id="32-conformity">3.2 Conformity<a class="header-link" href="#32-conformity" title="Permanent link">&para;</a></h3>
<p>Unlike physics, which has laws that software can rely on, software must conform to the arbitrary decisions of humans ‚Äî regulatory requirements, business rules, hardware interfaces, legacy APIs, and organizational conventions. These constraints are often inconsistent, poorly documented, and subject to change.</p>
<p>Software cannot appeal to nature. It must conform to whatever the world demands, no matter how illogical.</p>
<h3 id="33-changeability">3.3 Changeability<a class="header-link" href="#33-changeability" title="Permanent link">&para;</a></h3>
<p>Software is expected to change constantly. Because software is perceived as "soft" (easy to change compared to hardware), stakeholders routinely demand modifications after delivery. Every successful software system is subject to pressure for change, and every change carries the risk of introducing defects.</p>
<p>This is in contrast to physical engineering artifacts: a bridge built to specification is not typically required to be redesigned to add a new lane next month.</p>
<h3 id="34-invisibility">3.4 Invisibility<a class="header-link" href="#34-invisibility" title="Permanent link">&para;</a></h3>
<p>Software has no physical form. Unlike a building (where you can see structural problems) or a mechanical device (where you can measure tolerances), software is invisible. Diagrams and documentation are imperfect representations. This makes it difficult to visualize the structure of a system, communicate its architecture, or spot problems before they manifest at runtime.</p>
<hr />
<h2 id="4-types-of-software">4. Types of Software<a class="header-link" href="#4-types-of-software" title="Permanent link">&para;</a></h2>
<p>Software engineering methods must be adapted to the type of software being built. Major categories include:</p>
<h3 id="41-systems-software">4.1 Systems Software<a class="header-link" href="#41-systems-software" title="Permanent link">&para;</a></h3>
<p>Infrastructure-level software that provides services to other software. Examples: operating systems, compilers, device drivers, database engines, runtime environments.</p>
<p>Characteristics: performance-critical, close to hardware, long lifespans, high reliability requirements.</p>
<h3 id="42-application-software">4.2 Application Software<a class="header-link" href="#42-application-software" title="Permanent link">&para;</a></h3>
<p>Software that performs tasks directly for end users. Examples: word processors, spreadsheets, accounting systems, ERP systems.</p>
<p>Characteristics: large user bases, evolving requirements, usability as a primary concern.</p>
<h3 id="43-embedded-software">4.3 Embedded Software<a class="header-link" href="#43-embedded-software" title="Permanent link">&para;</a></h3>
<p>Software that controls hardware devices. Examples: firmware in medical devices, automotive control units, industrial machinery, consumer electronics.</p>
<p>Characteristics: strict resource constraints (memory, CPU), real-time requirements, safety-critical, difficult to update after deployment.</p>
<h3 id="44-web-software">4.4 Web Software<a class="header-link" href="#44-web-software" title="Permanent link">&para;</a></h3>
<p>Software delivered and accessed through web browsers. Examples: e-commerce platforms, social networks, web APIs, SaaS applications.</p>
<p>Characteristics: rapid change cycles, heterogeneous client environments, network and security concerns, scalability requirements.</p>
<h3 id="45-mobile-software">4.5 Mobile Software<a class="header-link" href="#45-mobile-software" title="Permanent link">&para;</a></h3>
<p>Applications for smartphones and tablets. Examples: iOS/Android apps, cross-platform mobile apps.</p>
<p>Characteristics: constrained resources, intermittent connectivity, platform fragmentation, frequent OS updates.</p>
<h3 id="46-ai-and-machine-learning-systems">4.6 AI and Machine Learning Systems<a class="header-link" href="#46-ai-and-machine-learning-systems" title="Permanent link">&para;</a></h3>
<p>Software whose behavior is learned from data rather than explicitly programmed. Examples: recommendation engines, image classifiers, language models, autonomous systems.</p>
<p>Characteristics: non-deterministic behavior, data dependencies, model versioning, explainability concerns, different testing paradigms.</p>
<hr />
<h2 id="5-core-principles-of-software-engineering">5. Core Principles of Software Engineering<a class="header-link" href="#5-core-principles-of-software-engineering" title="Permanent link">&para;</a></h2>
<p>Over decades of practice and research, a set of enduring principles has emerged that guide good software engineering regardless of the specific methodology used.</p>
<h3 id="51-rigor-and-formality">5.1 Rigor and Formality<a class="header-link" href="#51-rigor-and-formality" title="Permanent link">&para;</a></h3>
<p>Software should be developed with sufficient rigor ‚Äî precise specifications, systematic testing, documented designs. The appropriate level of formality depends on the domain: safety-critical systems (avionics, medical devices) warrant formal mathematical verification; a startup prototype may need only basic documentation.</p>
<h3 id="52-separation-of-concerns">5.2 Separation of Concerns<a class="header-link" href="#52-separation-of-concerns" title="Permanent link">&para;</a></h3>
<p>Divide a complex system into parts, each addressing a distinct concern. This principle manifests at every level:
- <strong>Module level</strong>: Each module has a single, well-defined responsibility
- <strong>Architectural level</strong>: Separate presentation, business logic, and data layers
- <strong>Process level</strong>: Separate requirements from design, design from implementation</p>
<p>Separation of concerns reduces cognitive load and enables teams to work on different parts simultaneously.</p>
<h3 id="53-modularity">5.3 Modularity<a class="header-link" href="#53-modularity" title="Permanent link">&para;</a></h3>
<p>Organize software into discrete, independently developable, testable, and replaceable modules. Well-designed modules have:
- <strong>High cohesion</strong>: Related functionality is grouped together
- <strong>Low coupling</strong>: Modules depend on each other as little as possible</p>
<h3 id="54-abstraction">5.4 Abstraction<a class="header-link" href="#54-abstraction" title="Permanent link">&para;</a></h3>
<p>Expose only what is necessary; hide implementation details. Abstraction allows engineers to work at the appropriate level ‚Äî a developer using a database driver does not need to understand disk block allocation algorithms.</p>
<p>Layers of abstraction are fundamental to managing complexity in large systems.</p>
<h3 id="55-anticipation-of-change">5.5 Anticipation of Change<a class="header-link" href="#55-anticipation-of-change" title="Permanent link">&para;</a></h3>
<p>Software will change. Good software engineering designs for change by:
- Identifying likely sources of variation and isolating them behind interfaces
- Avoiding hardcoded constants and magic numbers
- Writing clear, documented code that others can understand and modify
- Designing databases and APIs for extensibility</p>
<h3 id="56-generality">5.6 Generality<a class="header-link" href="#56-generality" title="Permanent link">&para;</a></h3>
<p>Where practical, prefer general solutions over special-case solutions. A general-purpose sorting function is more valuable than a function that sorts only one specific data structure.</p>
<p>However, premature generality can lead to over-engineering. The principle must be balanced against simplicity.</p>
<h3 id="57-incrementality">5.7 Incrementality<a class="header-link" href="#57-incrementality" title="Permanent link">&para;</a></h3>
<p>Build and deliver software in increments rather than attempting to complete the entire system before any part is released. Incremental delivery:
- Provides early feedback from real users
- Reduces the risk of building the wrong thing
- Allows value to be delivered before the project is "done"</p>
<p>This principle underlies both iterative development models and modern agile methods.</p>
<hr />
<h2 id="6-brief-history-of-software-engineering">6. Brief History of Software Engineering<a class="header-link" href="#6-brief-history-of-software-engineering" title="Permanent link">&para;</a></h2>
<div class="highlight"><pre><span></span><code><span class="nv">Timeline</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">Software</span><span class="w"> </span><span class="nv">Engineering</span>

<span class="mi">1948</span><span class="o">-</span><span class="mi">1960</span><span class="nv">s</span><span class="w">  </span><span class="nv">Early</span><span class="w"> </span><span class="nv">programming</span>
<span class="w">            </span>‚îú‚îÄ<span class="w"> </span><span class="nv">Machine</span><span class="w"> </span><span class="nv">code</span><span class="w"> </span>‚Üí<span class="w"> </span><span class="nv">assembly</span><span class="w"> </span>‚Üí<span class="w"> </span><span class="nv">high</span><span class="o">-</span><span class="nv">level</span><span class="w"> </span><span class="nv">languages</span><span class="w"> </span><span class="ss">(</span><span class="nv">FORTRAN</span><span class="w"> </span><span class="mi">1957</span>,<span class="w"> </span><span class="nv">COBOL</span><span class="w"> </span><span class="mi">1959</span><span class="ss">)</span>
<span class="w">            </span>‚îú‚îÄ<span class="w"> </span><span class="nv">Programs</span><span class="w"> </span><span class="nv">written</span><span class="w"> </span><span class="nv">by</span><span class="w"> </span><span class="nv">mathematicians</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">scientists</span>
<span class="w">            </span>‚îî‚îÄ<span class="w"> </span><span class="nv">Software</span><span class="w"> </span><span class="s2">&quot;crises&quot;</span><span class="w"> </span><span class="nv">begin</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nv">appear</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="nv">projects</span><span class="w"> </span><span class="nv">grow</span>

<span class="mi">1968</span><span class="w">        </span><span class="nv">NATO</span><span class="w"> </span><span class="nv">Conference</span>,<span class="w"> </span><span class="nv">Garmisch</span>
<span class="w">            </span>‚îú‚îÄ<span class="w"> </span><span class="nv">Term</span><span class="w"> </span><span class="s2">&quot;software engineering&quot;</span><span class="w"> </span><span class="nv">coined</span>
<span class="w">            </span>‚îú‚îÄ<span class="w"> </span><span class="nv">Software</span><span class="w"> </span><span class="nv">crisis</span><span class="w"> </span><span class="nv">recognized</span><span class="w"> </span><span class="nv">as</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">discipline</span><span class="o">-</span><span class="nv">level</span><span class="w"> </span><span class="nv">problem</span>
<span class="w">            </span>‚îî‚îÄ<span class="w"> </span><span class="k">Call</span><span class="w"> </span><span class="nl">for</span><span class="w"> </span><span class="nv">systematic</span>,<span class="w"> </span><span class="nv">engineered</span><span class="w"> </span><span class="nv">approach</span>

<span class="mi">1970</span><span class="nv">s</span><span class="w">       </span><span class="nv">Process</span><span class="w"> </span><span class="nv">models</span><span class="w"> </span><span class="nv">emerge</span>
<span class="w">            </span>‚îú‚îÄ<span class="w"> </span><span class="nv">Royce</span><span class="w"> </span><span class="nv">describes</span><span class="w"> </span><span class="nv">Waterfall</span><span class="w"> </span><span class="nv">model</span><span class="w"> </span><span class="ss">(</span><span class="mi">1970</span><span class="ss">)</span>
<span class="w">            </span>‚îú‚îÄ<span class="w"> </span><span class="nv">Structured</span><span class="w"> </span><span class="nv">programming</span><span class="w"> </span><span class="ss">(</span><span class="nv">Dijkstra</span>,<span class="w"> </span><span class="nv">Wirth</span><span class="ss">)</span>
<span class="w">            </span>‚îú‚îÄ<span class="w"> </span><span class="nv">Jackson</span><span class="w"> </span><span class="nv">Structured</span><span class="w"> </span><span class="nv">Design</span>,<span class="w"> </span><span class="nv">Yourdon</span><span class="o">-</span><span class="nv">DeMarco</span><span class="w"> </span><span class="nv">SA</span><span class="o">/</span><span class="nv">SD</span>
<span class="w">            </span>‚îî‚îÄ<span class="w"> </span><span class="nv">Unix</span><span class="w"> </span><span class="nv">developed</span><span class="w"> </span><span class="nv">at</span><span class="w"> </span><span class="nv">Bell</span><span class="w"> </span><span class="nv">Labs</span>

<span class="mi">1980</span><span class="nv">s</span><span class="w">       </span><span class="nv">Maturation</span>
<span class="w">            </span>‚îú‚îÄ<span class="w"> </span><span class="nv">Boehm</span><span class="err">&#39;s Spiral model (1988)</span>
<span class="err">            ‚îú‚îÄ COCOMO estimation model</span>
<span class="err">            ‚îú‚îÄ SEI and CMM (Capability Maturity Model)</span>
<span class="err">            ‚îú‚îÄ IEEE software engineering standards</span>
<span class="err">            ‚îî‚îÄ Object-oriented design (Booch, Rumbaugh, Jacobson)</span>

<span class="err">1990s       Objects, patterns, and web</span>
<span class="err">            ‚îú‚îÄ UML standardized (1997)</span>
<span class="err">            ‚îú‚îÄ Design Patterns &quot;Gang of Four&quot; (1994)</span>
<span class="err">            ‚îú‚îÄ World Wide Web transforms software distribution</span>
<span class="err">            ‚îú‚îÄ Extreme Programming (XP) introduced (Beck, 1996)</span>
<span class="err">            ‚îî‚îÄ CMMI released (2000)</span>

<span class="err">2001        Agile Manifesto</span>
<span class="err">            ‚îú‚îÄ Scrum, XP, Kanban gain widespread adoption</span>
<span class="err">            ‚îú‚îÄ Lightweight processes replace heavyweight ones</span>
<span class="err">            ‚îî‚îÄ Iterative, customer-centric development becomes mainstream</span>

<span class="err">2010s       DevOps and cloud</span>
<span class="err">            ‚îú‚îÄ DevOps movement formalizes dev-ops collaboration</span>
<span class="err">            ‚îú‚îÄ Continuous integration/continuous delivery (CI/CD)</span>
<span class="err">            ‚îú‚îÄ Microservices architecture</span>
<span class="err">            ‚îú‚îÄ Infrastructure as code</span>
<span class="err">            ‚îî‚îÄ Cloud platforms (AWS, GCP, Azure) change deployment model</span>

<span class="err">2020s       AI-assisted engineering</span>
<span class="err">            ‚îú‚îÄ Large language models assist with code generation</span>
<span class="err">            ‚îú‚îÄ AI/ML systems raise new engineering challenges</span>
<span class="err">            ‚îú‚îÄ Platform engineering and developer experience (DevEx)</span>
<span class="err">            ‚îî‚îÄ Software supply chain security as a discipline</span>
</code></pre></div>

<hr />
<h2 id="7-professional-roles-in-software-engineering">7. Professional Roles in Software Engineering<a class="header-link" href="#7-professional-roles-in-software-engineering" title="Permanent link">&para;</a></h2>
<p>Modern software engineering teams include a range of specialized roles:</p>
<table>
<thead>
<tr>
<th>Role</th>
<th>Primary Responsibilities</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Software Engineer / Developer</strong></td>
<td>Design, implement, test, and maintain code</td>
</tr>
<tr>
<td><strong>Software Architect</strong></td>
<td>Define system structure, major technology choices, cross-cutting concerns</td>
</tr>
<tr>
<td><strong>Product Manager (PM)</strong></td>
<td>Define what to build; own the product roadmap; represent business and user needs</td>
</tr>
<tr>
<td><strong>Project Manager</strong></td>
<td>Plan, schedule, and track project progress; manage risk and resources</td>
</tr>
<tr>
<td><strong>QA Engineer / Test Engineer</strong></td>
<td>Design and execute tests; maintain test infrastructure; report defects</td>
</tr>
<tr>
<td><strong>DevOps / Platform Engineer</strong></td>
<td>Build and maintain CI/CD pipelines, infrastructure, and deployment systems</td>
</tr>
<tr>
<td><strong>Site Reliability Engineer (SRE)</strong></td>
<td>Ensure system reliability and availability in production; define SLOs</td>
</tr>
<tr>
<td><strong>Technical Writer</strong></td>
<td>Create and maintain documentation for developers and end users</td>
</tr>
<tr>
<td><strong>Business Analyst</strong></td>
<td>Bridge business needs and technical implementation; write requirements</td>
</tr>
<tr>
<td><strong>UX Designer</strong></td>
<td>Design user interfaces and user experiences</td>
</tr>
<tr>
<td><strong>Security Engineer</strong></td>
<td>Identify and mitigate security vulnerabilities; define secure coding standards</td>
</tr>
<tr>
<td><strong>Data Engineer</strong></td>
<td>Build data pipelines and infrastructure; manage data quality</td>
</tr>
</tbody>
</table>
<p>In small organizations, one person may wear multiple hats. In large organizations, these roles are more clearly delineated. Understanding all of these roles ‚Äî even if you only occupy one ‚Äî makes you a more effective collaborator.</p>
<hr />
<h2 id="8-summary">8. Summary<a class="header-link" href="#8-summary" title="Permanent link">&para;</a></h2>
<p>Software engineering is the application of systematic, disciplined, and quantifiable approaches to software development. It emerged as a response to the "software crisis" of the 1960s, when large software projects routinely failed to deliver on time, on budget, or with sufficient quality.</p>
<p>Key takeaways:
- Software engineering is broader than programming: it encompasses the entire lifecycle and all organizational concerns
- Software is inherently complex due to its <strong>complexity</strong>, <strong>conformity</strong>, <strong>changeability</strong>, and <strong>invisibility</strong> (Brooks)
- Core principles ‚Äî separation of concerns, modularity, abstraction, incrementality ‚Äî apply across all methodologies
- Different types of software (embedded, web, AI) require different engineering approaches
- The field has evolved continuously from the 1960s through today's AI-assisted development era</p>
<hr />
<h2 id="practice-exercises">Practice Exercises<a class="header-link" href="#practice-exercises" title="Permanent link">&para;</a></h2>
<p><strong>Exercise 1</strong>: Compare and contrast software engineering with civil engineering. Identify three similarities and three fundamental differences. Which of Brooks's four properties has no direct analog in civil engineering?</p>
<p><strong>Exercise 2</strong>: You are a sole developer maintaining a personal script that automates your email sorting. Identify which software engineering principles you should still apply, and which are less critical at this scale. Justify your reasoning.</p>
<p><strong>Exercise 3</strong>: Look up one well-known software project failure (examples: HealthCare.gov 2013 launch, Ariane 5 Flight 501, Knight Capital incident 2012). Write a one-page analysis: What went wrong? Which software engineering principles were violated? What could have been done differently?</p>
<p><strong>Exercise 4</strong>: Interview (or research online) someone who works in a software engineering role you are unfamiliar with (e.g., QA engineer, technical writer, SRE). Describe their day-to-day responsibilities and how their work intersects with software developers.</p>
<p><strong>Exercise 5</strong>: Brooks claimed in 1986 that there is "no silver bullet" ‚Äî no single development, technique, or management practice that will produce a tenfold improvement in productivity. Review arguments for and against this claim in light of modern developments (AI code assistants, cloud infrastructure, mature frameworks). Do you agree or disagree? Provide evidence.</p>
<hr />
<h2 id="further-reading">Further Reading<a class="header-link" href="#further-reading" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Fred Brooks</strong>, <em>The Mythical Man-Month: Essays on Software Engineering</em> (Anniversary Edition, 1995) ‚Äî A foundational text on the human and organizational aspects of software engineering</li>
<li><strong>Fred Brooks</strong>, "No Silver Bullet: Essence and Accident in Software Engineering" (1986) ‚Äî IEEE Computer, Vol. 20, No. 4</li>
<li><strong>Ian Sommerville</strong>, <em>Software Engineering</em> (10th ed., 2015) ‚Äî Comprehensive academic textbook</li>
<li><strong>Roger Pressman</strong>, <em>Software Engineering: A Practitioner's Approach</em> (8th ed., 2014) ‚Äî Practitioner-oriented coverage</li>
<li><strong>NATO 1968 Conference Report</strong>: Available at http://homepages.cs.ncl.ac.uk/brian.randell/NATO/nato1968.PDF</li>
<li><strong>ACM/IEEE-CS Software Engineering Body of Knowledge (SWEBOK)</strong>: https://www.computer.org/education/bodies-of-knowledge/software-engineering</li>
</ul>
<hr />
<p><strong>Previous</strong>: <a href="./00_Overview.md">Overview</a> | <strong>Next</strong>: <a href="./02_Software_Development_Life_Cycle.md">Software Development Life Cycle</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/en/Software_Engineering/00_Overview.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Software Engineering</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">üîó</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/en/Software_Engineering/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">üìã</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/en/Software_Engineering/02_Software_Development_Life_Cycle.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 2: Software Development Life Cycle</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">‚Üë</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'en';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}