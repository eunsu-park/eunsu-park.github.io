# Kubernetes Ingress for external HTTP/HTTPS access
# Requires an Ingress Controller (nginx, traefik, etc.)

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: flask-app-ingress
  labels:
    app: flask-app
  annotations:
    # Ingress class (for multiple ingress controllers)
    kubernetes.io/ingress.class: "nginx"

    # NGINX specific annotations
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "true"
    nginx.ingress.kubernetes.io/force-ssl-redirect: "true"

    # CORS configuration
    nginx.ingress.kubernetes.io/enable-cors: "true"
    nginx.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, OPTIONS"
    nginx.ingress.kubernetes.io/cors-allow-origin: "https://example.com"

    # Rate limiting
    nginx.ingress.kubernetes.io/limit-rps: "100"
    nginx.ingress.kubernetes.io/limit-connections: "50"

    # Timeouts
    nginx.ingress.kubernetes.io/proxy-connect-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-send-timeout: "60"
    nginx.ingress.kubernetes.io/proxy-read-timeout: "60"

    # Client body size limit
    nginx.ingress.kubernetes.io/proxy-body-size: "10m"

    # Connection upgrade (for WebSockets)
    nginx.ingress.kubernetes.io/proxy-upgrade: "true"

    # Custom headers
    nginx.ingress.kubernetes.io/configuration-snippet: |
      more_set_headers "X-Frame-Options: DENY";
      more_set_headers "X-Content-Type-Options: nosniff";
      more_set_headers "X-XSS-Protection: 1; mode=block";

    # cert-manager for automatic TLS certificate
    cert-manager.io/cluster-issuer: "letsencrypt-prod"

    # Additional annotations for other ingress controllers:
    #
    # Traefik:
    # traefik.ingress.kubernetes.io/router.middlewares: default-compress@kubernetescrd
    #
    # AWS ALB:
    # alb.ingress.kubernetes.io/scheme: internet-facing
    # alb.ingress.kubernetes.io/target-type: ip
    # alb.ingress.kubernetes.io/certificate-arn: arn:aws:acm:region:account:certificate/xxx
    #
    # GCP:
    # kubernetes.io/ingress.global-static-ip-name: "web-static-ip"

spec:
  # TLS configuration
  tls:
  - hosts:
    - flask-app.example.com
    - api.example.com
    secretName: flask-app-tls  # TLS certificate secret

  # Routing rules
  rules:
  # -------------------------------------------------------------------------
  # Rule 1: Main domain
  # -------------------------------------------------------------------------
  - host: flask-app.example.com
    http:
      paths:
      # Default path
      - path: /
        pathType: Prefix
        backend:
          service:
            name: flask-app
            port:
              number: 80

      # Health check endpoint
      - path: /health
        pathType: Exact
        backend:
          service:
            name: flask-app
            port:
              number: 80

  # -------------------------------------------------------------------------
  # Rule 2: API subdomain with path-based routing
  # -------------------------------------------------------------------------
  - host: api.example.com
    http:
      paths:
      # API v1
      - path: /v1
        pathType: Prefix
        backend:
          service:
            name: flask-app
            port:
              number: 80

      # API v2 (example of routing to different service)
      # - path: /v2
      #   pathType: Prefix
      #   backend:
      #     service:
      #       name: flask-app-v2
      #       port:
      #         number: 80

  # -------------------------------------------------------------------------
  # Rule 3: Catch-all for unmatched hosts (optional)
  # -------------------------------------------------------------------------
  # - http:
  #     paths:
  #     - path: /
  #       pathType: Prefix
  #       backend:
  #         service:
  #           name: default-backend
  #           port:
  #             number: 80

---
# TLS Secret (if not using cert-manager)
# Create manually or use cert-manager for automatic certificate management
#
# apiVersion: v1
# kind: Secret
# metadata:
#   name: flask-app-tls
#   namespace: default
# type: kubernetes.io/tls
# data:
#   tls.crt: <base64-encoded-certificate>
#   tls.key: <base64-encoded-private-key>

---
# IngressClass (Kubernetes 1.18+)
# Defines which ingress controller to use
apiVersion: networking.k8s.io/v1
kind: IngressClass
metadata:
  name: nginx
  annotations:
    ingressclass.kubernetes.io/is-default-class: "true"
spec:
  controller: k8s.io/ingress-nginx

---
# Usage Instructions:
#
# 1. Install NGINX Ingress Controller:
#    kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/cloud/deploy.yaml
#
# 2. Install cert-manager (for TLS):
#    kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml
#
# 3. Create ClusterIssuer for Let's Encrypt:
#    See: https://cert-manager.io/docs/configuration/acme/
#
# 4. Apply this ingress:
#    kubectl apply -f ingress.yaml
#
# 5. Get ingress details:
#    kubectl get ingress flask-app-ingress
#    kubectl describe ingress flask-app-ingress
#
# 6. Test locally (update /etc/hosts):
#    <INGRESS_IP> flask-app.example.com api.example.com
#
# 7. Verify TLS certificate:
#    kubectl get certificate flask-app-tls
#    kubectl describe certificate flask-app-tls
#
# Path types:
# - Exact: Exact match only
# - Prefix: Matches based on URL path prefix (most common)
# - ImplementationSpecific: Ingress controller specific
