{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë ˆìŠ¨ 8: ì˜ë¯¸ ë¶„ì„(Semantic Analysis) - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">ğŸ </span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">ğŸ’»</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        í•œêµ­ì–´
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">â˜€ï¸</span>
                    <span class="theme-icon dark">ğŸŒ™</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Compiler_Design/">Compiler Design</a>
    <span class="separator">/</span>
    <span class="current">ë ˆìŠ¨ 8: ì˜ë¯¸ ë¶„ì„(Semantic Analysis)</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>ë ˆìŠ¨ 8: ì˜ë¯¸ ë¶„ì„(Semantic Analysis)</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Compiler_Design/07_Abstract_Syntax_Trees.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">ë ˆìŠ¨ 7: ì¶”ìƒ êµ¬ë¬¸ íŠ¸ë¦¬(Abstract Syntax Trees)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Compiler_Design/09_Intermediate_Representations.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">ë ˆìŠ¨ 9: ì¤‘ê°„ í‘œí˜„(Intermediate Representations)</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#_1">í•™ìŠµ ëª©í‘œ</a></li>
<li><a href="#1">1. ì†Œê°œ: ì˜ë¯¸ ë¶„ì„ì˜ ì—­í• </a><ul>
<li><a href="#11">1.1 íŒŒì‹±ì´ í™•ì¸í•  ìˆ˜ ì—†ëŠ” ê²ƒë“¤</a></li>
<li><a href="#12">1.2 ì˜ë¯¸ ë¶„ì„ íŒŒì´í”„ë¼ì¸</a></li>
</ul>
</li>
<li><a href="#2-attribute-grammars">2. ì†ì„± ë¬¸ë²•(Attribute Grammars)</a><ul>
<li><a href="#21">2.1 ê°œë…</a></li>
<li><a href="#22-s-s-attributed-grammars">2.2 S-ì†ì„± ë¬¸ë²•(S-Attributed Grammars)</a></li>
<li><a href="#23-l-l-attributed-grammars">2.3 L-ì†ì„± ë¬¸ë²•(L-Attributed Grammars)</a></li>
<li><a href="#24">2.4 ë¹„êµ</a></li>
</ul>
</li>
<li><a href="#3-symbol-tables">3. ì‹¬ë²Œ í…Œì´ë¸”(Symbol Tables)</a><ul>
<li><a href="#31">3.1 ëª©ì </a></li>
<li><a href="#32-scope-management">3.2 ìŠ¤ì½”í”„ ê´€ë¦¬(Scope Management)</a></li>
<li><a href="#33">3.3 êµ¬í˜„ ì „ëµ</a></li>
<li><a href="#34">3.4 ì™„ì „í•œ êµ¬í˜„</a></li>
</ul>
</li>
<li><a href="#4-type-systems">4. íƒ€ì… ì‹œìŠ¤í…œ(Type Systems)</a><ul>
<li><a href="#41-static-vs-dynamic-typing">4.1 ì •ì  íƒ€ì…ê³¼ ë™ì  íƒ€ì…(Static vs Dynamic Typing)</a></li>
<li><a href="#42-strong-vs-weak-typing">4.2 ê°•í•œ íƒ€ì…ê³¼ ì•½í•œ íƒ€ì…(Strong vs Weak Typing)</a></li>
<li><a href="#43">4.3 íƒ€ì… ì‹œìŠ¤í…œ ì„¤ê³„ ìŠ¤í™íŠ¸ëŸ¼</a></li>
</ul>
</li>
<li><a href="#5-type-checking">5. íƒ€ì… ê²€ì‚¬(Type Checking)</a><ul>
<li><a href="#51">5.1 íƒ€ì… ê²€ì‚¬ ê·œì¹™</a></li>
<li><a href="#52">5.2 íƒ€ì… ê²€ì‚¬ê¸° êµ¬í˜„</a></li>
</ul>
</li>
<li><a href="#6-type-inference">6. íƒ€ì… ì¶”ë¡ (Type Inference)</a><ul>
<li><a href="#61-local-type-inference">6.1 ì§€ì—­ íƒ€ì… ì¶”ë¡ (Local Type Inference)</a></li>
<li><a href="#62-hindley-milner-type-inference">6.2 íŒë“¤ë¦¬-ë°€ë„ˆ íƒ€ì… ì¶”ë¡ (Hindley-Milner Type Inference)</a></li>
<li><a href="#63-unification-algorithm">6.3 ë‹¨ì¼í™” ì•Œê³ ë¦¬ì¦˜(Unification Algorithm)</a></li>
</ul>
</li>
<li><a href="#7-type-compatibility-and-coercion">7. íƒ€ì… í˜¸í™˜ì„±ê³¼ ê°•ì œ ë³€í™˜(Type Compatibility and Coercion)</a><ul>
<li><a href="#71">7.1 íƒ€ì… í˜¸í™˜ì„± ê·œì¹™</a></li>
<li><a href="#72-implicit-coercion">7.2 ì•”ë¬µì  ê°•ì œ ë³€í™˜(Implicit Coercion)</a></li>
</ul>
</li>
<li><a href="#8-overloading-resolution">8. ì˜¤ë²„ë¡œë”© í•´ê²°(Overloading Resolution)</a><ul>
<li><a href="#81">8.1 ì˜¤ë²„ë¡œë”©ì´ë€?</a></li>
<li><a href="#82">8.2 í•´ê²° ì•Œê³ ë¦¬ì¦˜</a></li>
</ul>
</li>
<li><a href="#9-declaration-processing">9. ì„ ì–¸ ì²˜ë¦¬(Declaration Processing)</a><ul>
<li><a href="#91-forward-references">9.1 ì „ë°© ì°¸ì¡°(Forward References)</a></li>
<li><a href="#92-2-two-pass-strategy">9.2 2-íŒ¨ìŠ¤ ì „ëµ(Two-Pass Strategy)</a></li>
<li><a href="#93-topological-sorting">9.3 ìœ„ìƒ ì •ë ¬(Topological Sorting)</a></li>
</ul>
</li>
<li><a href="#10-semantic-error-reporting">10. ì˜ë¯¸ ì˜¤ë¥˜ ë³´ê³ (Semantic Error Reporting)</a><ul>
<li><a href="#101">10.1 ì˜¤ë¥˜ ë²”ì£¼</a></li>
<li><a href="#102-error-recovery">10.2 íƒ€ì… ê²€ì‚¬ì—ì„œì˜ ì˜¤ë¥˜ ë³µêµ¬(Error Recovery)</a></li>
<li><a href="#103">10.3 ìœ ìš©í•œ ì˜¤ë¥˜ ë©”ì‹œì§€</a></li>
</ul>
</li>
<li><a href="#11_1">11. ìš”ì•½</a></li>
<li><a href="#_2">ì—°ìŠµ ë¬¸ì œ</a><ul>
<li><a href="#1_1">ì—°ìŠµ 1: ì‹¬ë²Œ í…Œì´ë¸” í™•ì¥</a></li>
<li><a href="#2">ì—°ìŠµ 2: ì™„ì „í•œ íƒ€ì… ê²€ì‚¬ê¸°</a></li>
<li><a href="#3">ì—°ìŠµ 3: íƒ€ì… ì¶”ë¡ </a></li>
<li><a href="#4">ì—°ìŠµ 4: ì˜ë¯¸ ì˜¤ë¥˜ ì¹´íƒˆë¡œê·¸</a></li>
<li><a href="#5">ì—°ìŠµ 5: ì œë„¤ë¦­ì„ ì‚¬ìš©í•œ ì˜¤ë²„ë¡œë”©</a></li>
<li><a href="#6-control-flow-analysis">ì—°ìŠµ 6: ì œì–´ íë¦„ ë¶„ì„(Control Flow Analysis)</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="8-semantic-analysis">ë ˆìŠ¨ 8: ì˜ë¯¸ ë¶„ì„(Semantic Analysis)<a class="header-link" href="#8-semantic-analysis" title="Permanent link">&para;</a></h1>
<h2 id="_1">í•™ìŠµ ëª©í‘œ<a class="header-link" href="#_1" title="Permanent link">&para;</a></h2>
<p>ì´ ë ˆìŠ¨ì„ ì™„ë£Œí•˜ë©´ ë‹¤ìŒì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:</p>
<ol>
<li>ì»´íŒŒì¼ íŒŒì´í”„ë¼ì¸ì—ì„œ ì˜ë¯¸ ë¶„ì„(semantic analysis)ì˜ ì—­í• ì„ <strong>ì„¤ëª…</strong>í•  ìˆ˜ ìˆë‹¤</li>
<li>S-ì†ì„±(S-attributed) ë¬¸ë²•ê³¼ L-ì†ì„±(L-attributed) ë¬¸ë²•ì„ ì‚¬ìš©í•˜ëŠ” êµ¬ë¬¸ ì§€í–¥ ë²ˆì—­(syntax-directed translation)ì„ <strong>êµ¬ë³„</strong>í•  ìˆ˜ ìˆë‹¤</li>
<li>í•´ì‹œ í…Œì´ë¸”ì„ ì‚¬ìš©í•˜ì—¬ ì ì ˆí•œ ìŠ¤ì½”í”„ ê´€ë¦¬(scope management)ê°€ ìˆëŠ” ì‹¬ë²Œ í…Œì´ë¸”(symbol table)ì„ <strong>êµ¬í˜„</strong>í•  ìˆ˜ ìˆë‹¤</li>
<li>ì •ì /ë™ì , ê°•/ì•½ íƒ€ì… ì‹œìŠ¤í…œ(type system)ì„ <strong>ì„¤ëª…</strong>í•  ìˆ˜ ìˆë‹¤</li>
<li>í‘œí˜„ì‹, ë¬¸ì¥, í•¨ìˆ˜ì— ëŒ€í•œ íƒ€ì… ê²€ì‚¬(type checking) ê·œì¹™ì„ <strong>êµ¬í˜„</strong>í•  ìˆ˜ ìˆë‹¤</li>
<li>íŒë“¤ë¦¬-ë°€ë„ˆ(Hindley-Milner) íƒ€ì… ì¶”ë¡ (type inference)ì˜ ê¸°ì´ˆë¥¼ <strong>ì´í•´</strong>í•  ìˆ˜ ìˆë‹¤</li>
<li>íƒ€ì… í˜¸í™˜ì„±(type compatibility), ê°•ì œ ë³€í™˜(coercion), ì˜¤ë²„ë¡œë”© í•´ê²°(overloading resolution), ì„ ì–¸ ì²˜ë¦¬ë¥¼ <strong>ë‹¤ë£°</strong> ìˆ˜ ìˆë‹¤</li>
<li>ëª…í™•í•œ ë©”ì‹œì§€ì™€ ì†ŒìŠ¤ ìœ„ì¹˜ë¥¼ í¬í•¨í•œ ì˜ë¯¸ ì˜¤ë¥˜ë¥¼ <strong>ë³´ê³ </strong>í•  ìˆ˜ ìˆë‹¤</li>
</ol>
<hr />
<h2 id="1">1. ì†Œê°œ: ì˜ë¯¸ ë¶„ì„ì˜ ì—­í• <a class="header-link" href="#1" title="Permanent link">&para;</a></h2>
<p>íŒŒì„œ(parser)ê°€ ASTë¥¼ ìƒì„±í•œ í›„, ì»´íŒŒì¼ëŸ¬ëŠ” í”„ë¡œê·¸ë¨ì´ <strong>ì˜ë¯¸ ìˆëŠ”ì§€</strong> ê²€ì¦í•´ì•¼ í•©ë‹ˆë‹¤ -- ë‹¨ìˆœíˆ êµ¬ë¬¸ì ìœ¼ë¡œ ì˜¬ë°”ë¥¸ ê²ƒë¿ë§Œ ì•„ë‹ˆë¼ ì˜ë¯¸ì ìœ¼ë¡œë„ ìœ íš¨í•´ì•¼ í•©ë‹ˆë‹¤. ì˜ë¯¸ ë¶„ì„ì€ êµ¬ë¬¸ê³¼ ì½”ë“œ ìƒì„±(code generation) ì‚¬ì´ì˜ ê°„ê·¹ì„ ë©”ì›Œì¤ë‹ˆë‹¤.</p>
<h3 id="11">1.1 íŒŒì‹±ì´ í™•ì¸í•  ìˆ˜ ì—†ëŠ” ê²ƒë“¤<a class="header-link" href="#11" title="Permanent link">&para;</a></h3>
<p>íŒŒì‹±ì€ í”„ë¡œê·¸ë¨ì´ ë¬¸ë²•ì„ ë”°ë¥´ëŠ”ì§€ í™•ì¸í•˜ì§€ë§Œ, ë§ì€ ì¤‘ìš”í•œ ì†ì„±ë“¤ì€ ë¬¸ë²•ì˜ ë²”ìœ„ë¥¼ ë²—ì–´ë‚©ë‹ˆë‹¤:</p>
<table>
<thead>
<tr>
<th>ì†ì„±</th>
<th>ìœ„ë°˜ ì˜ˆì‹œ</th>
<th>ê°ì§€ ì£¼ì²´</th>
</tr>
</thead>
<tbody>
<tr>
<td>ë³€ìˆ˜ ì‚¬ìš© ì „ ì„ ì–¸</td>
<td><code>x = y + 1;</code> (y ë¯¸ì„ ì–¸)</td>
<td>ì˜ë¯¸ ë¶„ì„</td>
</tr>
<tr>
<td>íƒ€ì… í˜¸í™˜ì„±</td>
<td><code>"hello" + 42</code> (ë¬¸ìì—´ + ì •ìˆ˜)</td>
<td>íƒ€ì… ê²€ì‚¬ê¸°</td>
</tr>
<tr>
<td>í•¨ìˆ˜ ì¸ì ìˆ˜</td>
<td><code>f(1, 2)</code> (fê°€ 3ê°œ ì¸ìë¥¼ ë°›ì„ ë•Œ)</td>
<td>íƒ€ì… ê²€ì‚¬ê¸°</td>
</tr>
<tr>
<td>ë°˜í™˜ íƒ€ì…</td>
<td><code>fn foo() -&gt; int { return "hi"; }</code></td>
<td>íƒ€ì… ê²€ì‚¬ê¸°</td>
</tr>
<tr>
<td>ë£¨í”„ ì™¸ë¶€ì˜ break</td>
<td>ì „ì—­ ìŠ¤ì½”í”„ì—ì„œ <code>break;</code></td>
<td>ì˜ë¯¸ ë¶„ì„</td>
</tr>
<tr>
<td>ì¤‘ë³µ ì„ ì–¸</td>
<td>ê°™ì€ ìŠ¤ì½”í”„ì—ì„œ <code>let x = 1; let x = 2;</code></td>
<td>ì‹¬ë²Œ í…Œì´ë¸”</td>
</tr>
<tr>
<td>ì ‘ê·¼ ì œì–´</td>
<td>private í•„ë“œ ì½ê¸°</td>
<td>ì˜ë¯¸ ë¶„ì„</td>
</tr>
</tbody>
</table>
<h3 id="12">1.2 ì˜ë¯¸ ë¶„ì„ íŒŒì´í”„ë¼ì¸<a class="header-link" href="#12" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>            AST (íŒŒì„œë¡œë¶€í„°)
             â”‚
             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ì´ë¦„ í•´ê²°         â”‚  ì‹¬ë²Œ í…Œì´ë¸” êµ¬ì¶•,
    â”‚  (ìŠ¤ì½”í”„ ë¶„ì„)      â”‚  ì‹ë³„ì í•´ê²°
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  íƒ€ì… ê²€ì‚¬ /        â”‚  íƒ€ì… ì •í™•ì„± ê²€ì¦,
    â”‚  íƒ€ì… ì¶”ë¡           â”‚  ASTì— íƒ€ì… ì£¼ì„ ì¶”ê°€
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  ê¸°íƒ€ ê²€ì‚¬          â”‚  ì œì–´ íë¦„, ë„ë‹¬ ê°€ëŠ¥ì„±,
    â”‚                    â”‚  ì´ˆê¸°í™” ë“±
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
        ì£¼ì„ì´ ë‹¬ë¦° AST
    (IR ìƒì„± ì¤€ë¹„ ì™„ë£Œ)
</code></pre></div>

<hr />
<h2 id="2-attribute-grammars">2. ì†ì„± ë¬¸ë²•(Attribute Grammars)<a class="header-link" href="#2-attribute-grammars" title="Permanent link">&para;</a></h2>
<h3 id="21">2.1 ê°œë…<a class="header-link" href="#21" title="Permanent link">&para;</a></h3>
<p><strong>ì†ì„± ë¬¸ë²•(attribute grammar)</strong>ì€ ë¬¸ë§¥ ììœ  ë¬¸ë²•(context-free grammar)ì— ë¬¸ë²• ê¸°í˜¸(grammar symbol)ì— ë¶€ì°©ëœ <strong>ì†ì„±(attribute)</strong>ê³¼ ì†ì„±ì„ ê³„ì‚°í•˜ëŠ” ë°©ë²•ì„ ì •ì˜í•˜ëŠ” <strong>ì˜ë¯¸ ê·œì¹™(semantic rule)</strong>ì„ ì¶”ê°€í•˜ì—¬ í™•ì¥í•©ë‹ˆë‹¤. ì´ í˜•ì‹ì€ ì˜ë¯¸ ë¶„ì„ì„ ì •ì˜í•˜ëŠ” ì—„ë°€í•œ ë°©ë²•ì„ ì œê³µí•©ë‹ˆë‹¤.</p>
<p>ê° ë¬¸ë²• ê¸°í˜¸ $X$ëŠ” ë‹¤ìŒì„ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤:
- <strong>í•©ì„± ì†ì„±(Synthesized attributes)</strong>: $X$ì˜ ìì‹ë“¤ì˜ ì†ì„±ìœ¼ë¡œ ê³„ì‚°ë©ë‹ˆë‹¤ (ì •ë³´ê°€ ìœ„ë¡œ íë¦„)
- <strong>ìƒì† ì†ì„±(Inherited attributes)</strong>: $X$ì˜ ë¶€ëª¨ë‚˜ í˜•ì œì˜ ì†ì„±ìœ¼ë¡œ ê³„ì‚°ë©ë‹ˆë‹¤ (ì •ë³´ê°€ ì•„ë˜ë¡œ íë¦„)</p>
<h3 id="22-s-s-attributed-grammars">2.2 S-ì†ì„± ë¬¸ë²•(S-Attributed Grammars)<a class="header-link" href="#22-s-s-attributed-grammars" title="Permanent link">&para;</a></h3>
<p><strong>S-ì†ì„± ë¬¸ë²•(S-attributed grammar)</strong>ì€ <strong>í•©ì„±</strong> ì†ì„±ë§Œ ì‚¬ìš©í•©ë‹ˆë‹¤. ì •ë³´ëŠ” ì—„ê²©í•˜ê²Œ ì•„ë˜ì—ì„œ ìœ„ë¡œ íë¦…ë‹ˆë‹¤. ì´ê²ƒì´ ê°€ì¥ ë‹¨ìˆœí•˜ë©° ë‹¨ì¼ í›„ìœ„ ìˆœíšŒ(post-order traversal)ë¡œ í‰ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<p><strong>ì˜ˆì‹œ: í•©ì„±ëœ <code>val</code> ì†ì„±ì„ ê°€ì§„ ê³„ì‚°ê¸°</strong></p>
<p>$$
\begin{aligned}
E &\to E_1 + T & \quad E.\text{val} &= E_1.\text{val} + T.\text{val} \\
E &\to T & \quad E.\text{val} &= T.\text{val} \\
T &\to T_1 * F & \quad T.\text{val} &= T_1.\text{val} \times F.\text{val} \\
T &\to F & \quad T.\text{val} &= F.\text{val} \\
F &\to (\ E\ ) & \quad F.\text{val} &= E.\text{val} \\
F &\to \textbf{num} & \quad F.\text{val} &= \textbf{num}.\text{lexval}
\end{aligned}
$$</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">S-Attributed Grammar Evaluation</span>

<span class="sd">Demonstrates synthesized attribute computation</span>
<span class="sd">for a simple expression evaluator.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">evaluate_s_attributed</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Post-order evaluation (S-attributed).</span>
<span class="sd">    All attributes are synthesized (flow bottom-up).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">match</span> <span class="n">node</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="n">value</span><span class="o">=</span><span class="n">v</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">v</span>

        <span class="k">case</span> <span class="n">BinaryExpr</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">l</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">r</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">evaluate_s_attributed</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span> <span class="n">evaluate_s_attributed</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="k">case</span> <span class="n">BinaryExpr</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="n">l</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="n">r</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">evaluate_s_attributed</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">*</span> <span class="n">evaluate_s_attributed</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="k">case</span><span class="w"> </span><span class="k">_</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported node: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="23-l-l-attributed-grammars">2.3 L-ì†ì„± ë¬¸ë²•(L-Attributed Grammars)<a class="header-link" href="#23-l-l-attributed-grammars" title="Permanent link">&para;</a></h3>
<p><strong>L-ì†ì„± ë¬¸ë²•(L-attributed grammar)</strong>ì€ ìƒì† ì†ì„±ì„ í—ˆìš©í•˜ì§€ë§Œ, ì œì•½ì´ ìˆìŠµë‹ˆë‹¤: ìƒì„± ê·œì¹™ $A \to X_1 X_2 \cdots X_n$ì—ì„œ $X_i$ì˜ ìƒì† ì†ì„±ì€ ë‹¤ìŒì—ë§Œ ì˜ì¡´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤:</p>
<ol>
<li>$A$ì˜ ìƒì† ì†ì„± (ë¶€ëª¨)</li>
<li>$X_1, X_2, \ldots, X_{i-1}$ì˜ ì†ì„± (í•©ì„± ë˜ëŠ” ìƒì†) (ì™¼ìª½ í˜•ì œë“¤)</li>
</ol>
<p>ì´ë¡œì¨ ì†ì„±ì„ ë‹¨ì¼ <strong>ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½</strong> ìˆœíšŒë¡œ ê³„ì‚°í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<p><strong>ì˜ˆì‹œ: ìƒì†ëœ íƒ€ì… ì†ì„±ì„ ê°€ì§„ íƒ€ì… ì„ ì–¸</strong></p>
<p>$$
\begin{aligned}
D &\to T\ L & \quad L.\text{type} &= T.\text{type} \\
T &\to \textbf{int} & \quad T.\text{type} &= \text{integer} \\
T &\to \textbf{float} & \quad T.\text{type} &= \text{float} \\
L &\to L_1 ,\ \textbf{id} & \quad L_1.\text{type} &= L.\text{type}; \quad \text{addtype}(\textbf{id}, L.\text{type}) \\
L &\to \textbf{id} & \quad & \text{addtype}(\textbf{id}, L.\text{type})
\end{aligned}
$$</p>
<p>ì—¬ê¸°ì„œ <code>L.type</code>ì€ ì„ ì–¸ëœ íƒ€ì…ì„ ê° ì‹ë³„ìì—ê²Œ ì „ë‹¬í•˜ë©´ì„œ ì™¼ìª½ì—ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ íë¥´ëŠ” <strong>ìƒì†</strong> ì†ì„±ì…ë‹ˆë‹¤.</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">process_declaration</span><span class="p">(</span><span class="n">type_node</span><span class="p">,</span> <span class="n">id_list</span><span class="p">,</span> <span class="n">symbol_table</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    L-attributed evaluation: the type flows from left (T) to right (L).</span>

<span class="sd">    For &quot;int x, y, z&quot;:</span>
<span class="sd">      T.type = int         (synthesized)</span>
<span class="sd">      L.type = T.type      (inherited from left sibling)</span>
<span class="sd">      addtype(x, int)      (uses inherited type)</span>
<span class="sd">      addtype(y, int)</span>
<span class="sd">      addtype(z, int)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">declared_type</span> <span class="o">=</span> <span class="n">resolve_type</span><span class="p">(</span><span class="n">type_node</span><span class="p">)</span>  <span class="c1"># synthesized from T</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">id_list</span><span class="p">:</span>
        <span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">declared_type</span><span class="p">)</span>  <span class="c1"># inherited to L</span>
</code></pre></div>

<h3 id="24">2.4 ë¹„êµ<a class="header-link" href="#24" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>ì†ì„±</th>
<th>S-ì†ì„±</th>
<th>L-ì†ì„±</th>
</tr>
</thead>
<tbody>
<tr>
<td>ì†ì„± ë°©í–¥</td>
<td>ì•„ë˜ì—ì„œ ìœ„ë¡œë§Œ</td>
<td>ì•„ë˜ì—ì„œ ìœ„ë¡œ + ì œí•œëœ ìœ„ì—ì„œ ì•„ë˜ë¡œ</td>
</tr>
<tr>
<td>í‰ê°€ ìˆœì„œ</td>
<td>í›„ìœ„ ìˆœì„œ</td>
<td>ì™¼ìª½-ì˜¤ë¥¸ìª½ ê¹Šì´ ìš°ì„ </td>
</tr>
<tr>
<td>ë³µì¡ë„</td>
<td>ë” ë‹¨ìˆœ</td>
<td>ë” ìœ ì—°</td>
</tr>
<tr>
<td>LR íŒŒì„œ</td>
<td>ì§ì ‘ ì§€ì›</td>
<td>ì ì‘ í•„ìš”</td>
</tr>
<tr>
<td>LL íŒŒì„œ</td>
<td>ì§€ì›ë¨</td>
<td>ì§ì ‘ ì§€ì›</td>
</tr>
<tr>
<td>ì‚¬ìš© ì‚¬ë¡€</td>
<td>í‘œí˜„ì‹ í‰ê°€, ì½”ë“œ ìƒì„±</td>
<td>íƒ€ì… ì „íŒŒ, ìŠ¤ì½”í”„ ê´€ë¦¬</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="3-symbol-tables">3. ì‹¬ë²Œ í…Œì´ë¸”(Symbol Tables)<a class="header-link" href="#3-symbol-tables" title="Permanent link">&para;</a></h2>
<h3 id="31">3.1 ëª©ì <a class="header-link" href="#31" title="Permanent link">&para;</a></h3>
<p><strong>ì‹¬ë²Œ í…Œì´ë¸”(symbol table)</strong>ì€ ì´ë¦„(ì‹ë³„ì)ì„ í•´ë‹¹ ì†ì„±(íƒ€ì…, ìŠ¤ì½”í”„, ë©”ëª¨ë¦¬ ìœ„ì¹˜ ë“±)ì— ë§¤í•‘í•˜ëŠ” ìë£Œêµ¬ì¡°ì…ë‹ˆë‹¤. ì˜ë¯¸ ë¶„ì„ì˜ í•µì‹¬ êµ¬ì¡°ì…ë‹ˆë‹¤.</p>
<p>ì»´íŒŒì¼ëŸ¬ê°€ ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš°ë¥¼ ë§Œë‚  ë•Œë§ˆë‹¤:
- <strong>ì„ ì–¸</strong> (<code>let x: int = 5</code>): ìƒˆ í•­ëª©ì„ ì¶”ê°€
- <strong>ì°¸ì¡°</strong> (<code>print(x)</code>): ê¸°ì¡´ í•­ëª©ì„ ì¡°íšŒ</p>
<h3 id="32-scope-management">3.2 ìŠ¤ì½”í”„ ê´€ë¦¬(Scope Management)<a class="header-link" href="#32-scope-management" title="Permanent link">&para;</a></h3>
<p>ëŒ€ë¶€ë¶„ì˜ ì–¸ì–´ëŠ” <strong>ì¤‘ì²© ìŠ¤ì½”í”„(nested scopes)</strong>ë¥¼ ì§€ì›í•©ë‹ˆë‹¤: ë¸”ë¡ì€ ë‚´ë¶€ ë¸”ë¡ì„ í¬í•¨í•  ìˆ˜ ìˆìœ¼ë©°, ê°ê° ì™¸ë¶€ ìŠ¤ì½”í”„ì˜ ì„ ì–¸ì„ ê°€ë¦´ ìˆ˜ ìˆëŠ” ìì²´ ì„ ì–¸ì„ ê°€ì§‘ë‹ˆë‹¤.</p>
<div class="highlight"><pre><span></span><code>fn outer() {
    let x = 1;           // scope level 1
    {
        let y = 2;       // scope level 2
        let x = 10;      // shadows outer x
        {
            let z = 3;   // scope level 3
            print(x);    // resolves to inner x (= 10)
        }
        // z is no longer visible
    }
    // y and inner x are no longer visible
    print(x);            // resolves to outer x (= 1)
}
</code></pre></div>

<h3 id="33">3.3 êµ¬í˜„ ì „ëµ<a class="header-link" href="#33" title="Permanent link">&para;</a></h3>
<p><strong>ì „ëµ 1: ì—°ì‡„ í•´ì‹œ í…Œì´ë¸” (ìŠ¤ì½”í”„ ìŠ¤íƒ)</strong></p>
<p>ê° ìŠ¤ì½”í”„ëŠ” ìì²´ í•´ì‹œ í…Œì´ë¸”ì„ ê°€ì§‘ë‹ˆë‹¤. ì¡°íšŒëŠ” ê°€ì¥ ì•ˆìª½ ìŠ¤ì½”í”„ì—ì„œ ë°”ê¹¥ìª½ìœ¼ë¡œ íƒìƒ‰í•©ë‹ˆë‹¤.</p>
<div class="highlight"><pre><span></span><code><span class="err">ìŠ¤ì½”í”„</span><span class="w"> </span><span class="err">ìŠ¤íƒ</span><span class="o">:</span>

<span class="w">    </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">Scope</span><span class="w"> </span><span class="mi">3</span><span class="w">      </span><span class="err">â”‚</span><span class="w"> </span><span class="err">â†</span><span class="w"> </span><span class="err">í˜„ì¬</span><span class="w"> </span><span class="err">ìŠ¤ì½”í”„</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span><span class="w">     </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="w">           </span><span class="err">â”‚</span><span class="w"> </span><span class="n">parent</span>
<span class="w">    </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">Scope</span><span class="w"> </span><span class="mi">2</span><span class="w">      </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span><span class="w">     </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span><span class="w">     </span><span class="err">â”‚</span><span class="w">  </span><span class="p">(</span><span class="n">Scope</span><span class="w"> </span><span class="mi">1</span><span class="err">ì˜</span><span class="w"> </span><span class="n">xë¥¼</span><span class="w"> </span><span class="err">ê°€ë¦¼</span><span class="p">)</span>
<span class="w">    </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜</span>
<span class="w">           </span><span class="err">â”‚</span><span class="w"> </span><span class="n">parent</span>
<span class="w">    </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">Scope</span><span class="w"> </span><span class="mi">1</span><span class="w">      </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">int</span><span class="w">     </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
</code></pre></div>

<p><strong>ì „ëµ 2: ìŠ¤ì½”í”„ ë§ˆì»¤ê°€ ìˆëŠ” ë‹¨ì¼ í•´ì‹œ í…Œì´ë¸”</strong></p>
<p>í•˜ë‚˜ì˜ í•´ì‹œ í…Œì´ë¸”ì„ ì‚¬ìš©í•˜ë˜ ìŠ¤ì½”í”„ ë§ˆì»¤ì˜ ìŠ¤íƒì„ ìœ ì§€í•©ë‹ˆë‹¤. ìŠ¤ì½”í”„ë¥¼ ì¢…ë£Œí•  ë•Œ, ë§ˆì§€ë§‰ ë§ˆì»¤ ì´í›„ì— ì¶”ê°€ëœ ëª¨ë“  í•­ëª©ì„ ì œê±°í•©ë‹ˆë‹¤.</p>
<h3 id="34">3.4 ì™„ì „í•œ êµ¬í˜„<a class="header-link" href="#34" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Symbol Table with Scope Management</span>

<span class="sd">Implements a chained-scope symbol table using hash tables.</span>
<span class="sd">Each scope has its own dictionary, and lookup walks up the chain.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">enum</span><span class="w"> </span><span class="kn">import</span> <span class="n">Enum</span><span class="p">,</span> <span class="n">auto</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Any</span>


<span class="c1"># â”€â”€â”€ Types â”€â”€â”€</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TypeKind</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">INT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">FLOAT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">BOOL</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">STRING</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">VOID</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">FUNC</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">LIST</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">ERROR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>      <span class="c1"># special type for error recovery</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Type</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Represents a type in the type system.&quot;&quot;&quot;</span>
    <span class="n">kind</span><span class="p">:</span> <span class="n">TypeKind</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">kind</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">FuncType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Function type: (param_types) -&gt; return_type.&quot;&quot;&quot;</span>
    <span class="n">kind</span><span class="p">:</span> <span class="n">TypeKind</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">FUNC</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">param_types</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="p">()</span>
    <span class="n">return_type</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">VOID</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">params</span> <span class="o">=</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">params</span><span class="si">}</span><span class="s2">) -&gt; </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">return_type</span><span class="si">}</span><span class="s2">&quot;</span>


<span class="nd">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">ListType</span><span class="p">(</span><span class="n">Type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;List type: list[element_type].&quot;&quot;&quot;</span>
    <span class="n">kind</span><span class="p">:</span> <span class="n">TypeKind</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">LIST</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="n">element_type</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span>
        <span class="n">default_factory</span><span class="o">=</span><span class="k">lambda</span><span class="p">:</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;list[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">element_type</span><span class="si">}</span><span class="s2">]&quot;</span>


<span class="c1"># Commonly used types</span>
<span class="n">INT_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">)</span>
<span class="n">FLOAT_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">)</span>
<span class="n">BOOL_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">BOOL</span><span class="p">)</span>
<span class="n">STRING_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">STRING</span><span class="p">)</span>
<span class="n">VOID_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">VOID</span><span class="p">)</span>
<span class="n">ERROR_TYPE</span> <span class="o">=</span> <span class="n">Type</span><span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>


<span class="c1"># â”€â”€â”€ Symbol â”€â”€â”€</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SymbolKind</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
    <span class="n">VARIABLE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">FUNCTION</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">PARAMETER</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">TYPE_ALIAS</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>


<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Symbol</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a named entity in the program.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        name: the identifier</span>
<span class="sd">        type: the entity&#39;s type</span>
<span class="sd">        kind: variable, function, parameter, etc.</span>
<span class="sd">        scope_level: nesting depth where defined</span>
<span class="sd">        is_mutable: whether the binding can be reassigned</span>
<span class="sd">        is_initialized: whether a value has been assigned</span>
<span class="sd">        loc: source location of the declaration</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="nb">type</span><span class="p">:</span> <span class="n">Type</span>
    <span class="n">kind</span><span class="p">:</span> <span class="n">SymbolKind</span>
    <span class="n">scope_level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">is_mutable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">is_initialized</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">loc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># SourceLocation</span>


<span class="c1"># â”€â”€â”€ Scope â”€â”€â”€</span>

<span class="nd">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Scope</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A single scope level containing symbol definitions.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        symbols: hash table mapping names to symbols</span>
<span class="sd">        parent: enclosing scope (None for global scope)</span>
<span class="sd">        level: nesting depth (0 = global)</span>
<span class="sd">        name: optional scope name (function name, block, etc.)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">symbols</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">parent</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Scope</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">level</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&lt;anonymous&gt;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">define</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">symbol</span><span class="p">:</span> <span class="n">Symbol</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a new symbol in this scope.</span>

<span class="sd">        Returns the previous symbol if there was a duplicate</span>
<span class="sd">        in THIS scope (not parent scopes), or None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">existing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">symbol</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="p">[</span><span class="n">symbol</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbol</span>
        <span class="n">symbol</span><span class="o">.</span><span class="n">scope_level</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">level</span>
        <span class="k">return</span> <span class="n">existing</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Look up a symbol in THIS scope only (no parent chain).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Look up a symbol, searching up the scope chain.</span>

<span class="sd">        Returns the first matching symbol found (innermost scope wins).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">while</span> <span class="n">scope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">sym</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">all_symbols</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return all symbols defined in this scope.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>


<span class="c1"># â”€â”€â”€ Symbol Table â”€â”€â”€</span>

<span class="k">class</span><span class="w"> </span><span class="nc">SymbolTable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manages a stack of scopes for name resolution.</span>

<span class="sd">    Usage:</span>
<span class="sd">        table = SymbolTable()</span>
<span class="sd">        table.define(&quot;x&quot;, INT_TYPE, SymbolKind.VARIABLE)</span>

<span class="sd">        table.enter_scope(&quot;if-body&quot;)</span>
<span class="sd">        table.define(&quot;y&quot;, BOOL_TYPE, SymbolKind.VARIABLE)</span>
<span class="sd">        table.define(&quot;x&quot;, FLOAT_TYPE, SymbolKind.VARIABLE)  # shadows outer x</span>

<span class="sd">        sym = table.lookup(&quot;x&quot;)  # finds inner x (float)</span>
<span class="sd">        table.exit_scope()</span>

<span class="sd">        sym = table.lookup(&quot;x&quot;)  # finds outer x (int)</span>
<span class="sd">        sym = table.lookup(&quot;y&quot;)  # None (out of scope)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span> <span class="o">=</span> <span class="n">Scope</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;&lt;global&gt;&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">global_scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">scope_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">level</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">enter_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&lt;block&gt;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Enter a new nested scope.&quot;&quot;&quot;</span>
        <span class="n">new_scope</span> <span class="o">=</span> <span class="n">Scope</span><span class="p">(</span>
            <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="n">new_scope</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">exit_scope</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Scope</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exit the current scope and return to the enclosing scope.</span>

<span class="sd">        Returns the exited scope (useful for inspecting its symbols).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot exit global scope&quot;</span><span class="p">)</span>
        <span class="n">exited</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">return</span> <span class="n">exited</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">define</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="nb">type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
        <span class="n">kind</span><span class="p">:</span> <span class="n">SymbolKind</span> <span class="o">=</span> <span class="n">SymbolKind</span><span class="o">.</span><span class="n">VARIABLE</span><span class="p">,</span>
        <span class="n">mutable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">initialized</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">loc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Symbol</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Define a new symbol in the current scope.</span>

<span class="sd">        Reports an error if the name is already defined in the</span>
<span class="sd">        current scope (not parent scopes -- shadowing is allowed).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">symbol</span> <span class="o">=</span> <span class="n">Symbol</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="nb">type</span><span class="p">,</span>
            <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span>
            <span class="n">scope_level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">scope_level</span><span class="p">,</span>
            <span class="n">is_mutable</span><span class="o">=</span><span class="n">mutable</span><span class="p">,</span>
            <span class="n">is_initialized</span><span class="o">=</span><span class="n">initialized</span><span class="p">,</span>
            <span class="n">loc</span><span class="o">=</span><span class="n">loc</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">existing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">existing</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Duplicate definition: &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; is already defined &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;in scope &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(previous definition at </span><span class="si">{</span><span class="n">existing</span><span class="o">.</span><span class="n">loc</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">symbol</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Look up a symbol by name, searching from current to global scope.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">lookup_local</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Symbol</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Look up a symbol in the current scope only.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span><span class="o">.</span><span class="n">lookup_local</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">loc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Symbol</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Resolve a name reference, reporting an error if not found.</span>

<span class="sd">        Returns the symbol if found, or a dummy ERROR symbol.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sym</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Undefined name: &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; is not defined &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(referenced at </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">Symbol</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                <span class="nb">type</span><span class="o">=</span><span class="n">ERROR_TYPE</span><span class="p">,</span>
                <span class="n">kind</span><span class="o">=</span><span class="n">SymbolKind</span><span class="o">.</span><span class="n">VARIABLE</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">sym</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">print_scopes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Debug: print all scopes and their symbols.&quot;&quot;&quot;</span>
        <span class="n">scope</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_scope</span>
        <span class="k">while</span> <span class="n">scope</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Scope &#39;</span><span class="si">{</span><span class="n">scope</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; (level </span><span class="si">{</span><span class="n">scope</span><span class="o">.</span><span class="n">level</span><span class="si">}</span><span class="s2">):&quot;</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">sym</span> <span class="ow">in</span> <span class="n">scope</span><span class="o">.</span><span class="n">symbols</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">mut</span> <span class="o">=</span> <span class="s2">&quot;mut&quot;</span> <span class="k">if</span> <span class="n">sym</span><span class="o">.</span><span class="n">is_mutable</span> <span class="k">else</span> <span class="s2">&quot;const&quot;</span>
                <span class="n">init</span> <span class="o">=</span> <span class="s2">&quot;init&quot;</span> <span class="k">if</span> <span class="n">sym</span><span class="o">.</span><span class="n">is_initialized</span> <span class="k">else</span> <span class="s2">&quot;uninit&quot;</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">kind</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">mut</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">init</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="n">scope</span> <span class="o">=</span> <span class="n">scope</span><span class="o">.</span><span class="n">parent</span>


<span class="c1"># â”€â”€â”€ Demo â”€â”€â”€</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">table</span> <span class="o">=</span> <span class="n">SymbolTable</span><span class="p">()</span>

    <span class="c1"># Global scope</span>
    <span class="n">table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;print&quot;</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">(</span>
        <span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">STRING_TYPE</span><span class="p">,),</span> <span class="n">return_type</span><span class="o">=</span><span class="n">VOID_TYPE</span>
    <span class="p">),</span> <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="n">table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Enter function scope</span>
    <span class="n">table</span><span class="o">.</span><span class="n">enter_scope</span><span class="p">(</span><span class="s2">&quot;main&quot;</span><span class="p">)</span>
    <span class="n">table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">FLOAT_TYPE</span><span class="p">,</span> <span class="n">SymbolKind</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">BOOL_TYPE</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># shadows global x</span>

    <span class="c1"># Enter block scope</span>
    <span class="n">table</span><span class="o">.</span><span class="n">enter_scope</span><span class="p">(</span><span class="s2">&quot;if-body&quot;</span><span class="p">)</span>
    <span class="n">table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="n">STRING_TYPE</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Current scope state:&quot;</span><span class="p">)</span>
    <span class="n">table</span><span class="o">.</span><span class="n">print_scopes</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="c1"># Lookups</span>
    <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;print&quot;</span><span class="p">,</span> <span class="s2">&quot;w&quot;</span><span class="p">]:</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sym</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> -&gt; </span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2"> (level </span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">scope_level</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2"> -&gt; UNDEFINED&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Errors:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># Exit scopes</span>
    <span class="n">table</span><span class="o">.</span><span class="n">exit_scope</span><span class="p">()</span>
    <span class="n">table</span><span class="o">.</span><span class="n">exit_scope</span><span class="p">()</span>

    <span class="c1"># Now x refers to global int again</span>
    <span class="n">sym</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">lookup</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">After exiting scopes: x -&gt; </span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p><strong>ì˜ˆìƒ ì¶œë ¥:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">Current</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="n">state</span><span class="p">:</span>
<span class="n">Scope</span><span class="w"> </span><span class="s1">&#39;if-body&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">2</span><span class="p">):</span>
<span class="w">  </span><span class="n">z</span><span class="p">:</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">(</span><span class="n">VARIABLE</span><span class="p">,</span><span class="w"> </span><span class="n">mut</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="p">)</span>
<span class="n">Scope</span><span class="w"> </span><span class="s1">&#39;main&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">1</span><span class="p">):</span>
<span class="w">  </span><span class="n">y</span><span class="p">:</span><span class="w"> </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="p">(</span><span class="n">PARAMETER</span><span class="p">,</span><span class="w"> </span><span class="n">mut</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="p">)</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="p">(</span><span class="n">VARIABLE</span><span class="p">,</span><span class="w"> </span><span class="n">mut</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="p">)</span>
<span class="n">Scope</span><span class="w"> </span><span class="s1">&#39;&lt;global&gt;&#39;</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">0</span><span class="p">):</span>
<span class="w">  </span><span class="nb">print</span><span class="p">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="p">(</span><span class="n">FUNCTION</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="p">,</span><span class="w"> </span><span class="n">uninit</span><span class="p">)</span>
<span class="w">  </span><span class="n">x</span><span class="p">:</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="w"> </span><span class="p">(</span><span class="n">VARIABLE</span><span class="p">,</span><span class="w"> </span><span class="n">mut</span><span class="p">,</span><span class="w"> </span><span class="n">init</span><span class="p">)</span>

<span class="w">  </span><span class="n">z</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span>
<span class="w">  </span><span class="n">y</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb nb-Type">float</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb nb-Type">bool</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="nb">print</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb nb-Type">void</span><span class="w"> </span><span class="p">(</span><span class="n">level</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span>
<span class="w">  </span><span class="n">w</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">UNDEFINED</span>

<span class="n">Errors</span><span class="p">:</span>
<span class="w">  </span><span class="n">Undefined</span><span class="w"> </span><span class="n">name</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;w&#39;</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">defined</span><span class="w"> </span><span class="p">(</span><span class="n">referenced</span><span class="w"> </span><span class="n">at</span><span class="w"> </span><span class="n">None</span><span class="p">)</span>

<span class="n">After</span><span class="w"> </span><span class="n">exiting</span><span class="w"> </span><span class="n">scopes</span><span class="p">:</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nb nb-Type">int</span>
</code></pre></div>

<hr />
<h2 id="4-type-systems">4. íƒ€ì… ì‹œìŠ¤í…œ(Type Systems)<a class="header-link" href="#4-type-systems" title="Permanent link">&para;</a></h2>
<h3 id="41-static-vs-dynamic-typing">4.1 ì •ì  íƒ€ì…ê³¼ ë™ì  íƒ€ì…(Static vs Dynamic Typing)<a class="header-link" href="#41-static-vs-dynamic-typing" title="Permanent link">&para;</a></h3>
<p><strong>ì •ì  íƒ€ì…(static typing)</strong>ì€ <strong>ì»´íŒŒì¼ ì‹œê°„</strong>ì— íƒ€ì…ì„ ê²€ì‚¬í•©ë‹ˆë‹¤. ëª¨ë“  í‘œí˜„ì‹ì€ í”„ë¡œê·¸ë¨ì´ ì‹¤í–‰ë˜ê¸° ì „ì— ì•Œë ¤ì§„ íƒ€ì…ì„ ê°€ì§‘ë‹ˆë‹¤.</p>
<table>
<thead>
<tr>
<th>ì–¸ì–´</th>
<th>íƒ€ì… ë°©ì‹</th>
</tr>
</thead>
<tbody>
<tr>
<td>C, C++, Java, Rust, Go, Haskell</td>
<td>ì •ì </td>
</tr>
<tr>
<td>Python, JavaScript, Ruby, Lisp</td>
<td>ë™ì </td>
</tr>
<tr>
<td>TypeScript, Mypy, Dart</td>
<td>ì ì§„ì  íƒ€ì…(gradual typing) (ì •ì  + ë™ì )</td>
</tr>
</tbody>
</table>
<p><strong>ë™ì  íƒ€ì…(dynamic typing)</strong>ì€ <strong>ëŸ°íƒ€ì„</strong>ì— íƒ€ì…ì„ ê²€ì‚¬í•©ë‹ˆë‹¤. ë³€ìˆ˜ëŠ” ì–´ë–¤ íƒ€ì…ì˜ ê°’ë„ ë‹´ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Static typing (pseudo-code)</span>
<span class="n">let</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>         <span class="c1"># COMPILE ERROR: type mismatch</span>

<span class="c1"># Dynamic typing (Python)</span>
<span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>
<span class="n">x</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span>         <span class="c1"># OK at runtime</span>
</code></pre></div>

<h3 id="42-strong-vs-weak-typing">4.2 ê°•í•œ íƒ€ì…ê³¼ ì•½í•œ íƒ€ì…(Strong vs Weak Typing)<a class="header-link" href="#42-strong-vs-weak-typing" title="Permanent link">&para;</a></h3>
<p><strong>ê°•í•œ íƒ€ì…(strong typing)</strong>ì€ ì•”ë¬µì  íƒ€ì… ë³€í™˜ì´ ì œí•œë¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤. í˜¸í™˜ë˜ì§€ ì•ŠëŠ” íƒ€ì…ì— ëŒ€í•œ ì—°ì‚°ì€ ì˜¤ë¥˜ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.</p>
<p><strong>ì•½í•œ íƒ€ì…(weak typing)</strong>ì€ ì•”ë¬µì  ë³€í™˜(ê°•ì œ ë³€í™˜)ì´ ììœ ë¡­ê²Œ ë°œìƒí•¨ì„ ì˜ë¯¸í•©ë‹ˆë‹¤.</p>
<table>
<thead>
<tr>
<th></th>
<th>ê°•í•œ íƒ€ì…</th>
<th>ì•½í•œ íƒ€ì…</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ì •ì </strong></td>
<td>Rust, Haskell, Java</td>
<td>C, C++</td>
</tr>
<tr>
<td><strong>ë™ì </strong></td>
<td>Python, Ruby</td>
<td>JavaScript, PHP</td>
</tr>
</tbody>
</table>
<p><strong>ì•½í•œ íƒ€ì…ì˜ ì˜ˆì‹œ (JavaScript):</strong></p>
<div class="highlight"><pre><span></span><code><span class="s2">&quot;5&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">3</span><span class="w">       </span><span class="c1">// &quot;53&quot; (number coerced to string)</span>
<span class="s2">&quot;5&quot;</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mf">3</span><span class="w">       </span><span class="c1">// 2    (string coerced to number)</span>
<span class="kc">true</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="kc">true</span><span class="w">   </span><span class="c1">// 2    (booleans coerced to numbers)</span>
</code></pre></div>

<p><strong>ê°•í•œ íƒ€ì…ì˜ ì˜ˆì‹œ (Python):</strong></p>
<div class="highlight"><pre><span></span><code><span class="s2">&quot;5&quot;</span> <span class="o">+</span> <span class="mi">3</span>       <span class="c1"># TypeError: can only concatenate str to str</span>
<span class="kc">True</span> <span class="o">+</span> <span class="kc">True</span>   <span class="c1"># 2 (bool is a subclass of int -- deliberate design)</span>
</code></pre></div>

<h3 id="43">4.3 íƒ€ì… ì‹œìŠ¤í…œ ì„¤ê³„ ìŠ¤í™íŠ¸ëŸ¼<a class="header-link" href="#43" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="w">    </span><span class="err">â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">           </span><span class="nx">Type</span><span class="w"> </span><span class="nx">System</span><span class="w"> </span><span class="nx">Design</span><span class="w"> </span><span class="nx">Space</span><span class="w">                   </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">                                                      </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">Weak</span><span class="w"> </span><span class="err">â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–º</span><span class="w"> </span><span class="nx">Strong</span><span class="w">  </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">                                                      </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">   </span><span class="nx">C</span><span class="w">         </span><span class="nx">Java</span><span class="w">       </span><span class="nx">Haskell</span><span class="w">     </span><span class="nx">Rust</span><span class="w">              </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">   </span><span class="err">â”‚</span><span class="w">          </span><span class="err">â”‚</span><span class="w">           </span><span class="err">â”‚</span><span class="w">          </span><span class="err">â”‚</span><span class="w">                 </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">   </span><span class="err">â–¼</span><span class="w">          </span><span class="err">â–¼</span><span class="w">           </span><span class="err">â–¼</span><span class="w">          </span><span class="err">â–¼</span><span class="w">                 </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">implicit</span><span class="w">   </span><span class="nx">some</span><span class="w">        </span><span class="nx">no</span><span class="w">         </span><span class="nx">no</span><span class="w"> </span><span class="nx">implicit</span><span class="w">       </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">casts</span><span class="w">      </span><span class="nx">coercion</span><span class="w">    </span><span class="nx">coercion</span><span class="w">   </span><span class="nx">conversion</span><span class="w">        </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">                                    </span><span class="o">+</span><span class="w"> </span><span class="nx">ownership</span><span class="w">       </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">                                                      </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">JavaScript</span><span class="w">  </span><span class="nx">Python</span><span class="w">     </span><span class="nx">OCaml</span><span class="w">                        </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">   </span><span class="err">â”‚</span><span class="w">          </span><span class="err">â”‚</span><span class="w">           </span><span class="err">â”‚</span><span class="w">                            </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">   </span><span class="err">â–¼</span><span class="w">          </span><span class="err">â–¼</span><span class="w">           </span><span class="err">â–¼</span><span class="w">                            </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">lots</span><span class="w"> </span><span class="nx">of</span><span class="w">    </span><span class="nx">few</span><span class="w">         </span><span class="nx">no</span><span class="w">                           </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â”‚</span><span class="w">  </span><span class="nx">coercion</span><span class="w">   </span><span class="nx">coercion</span><span class="w">    </span><span class="nx">coercion</span><span class="w">                     </span><span class="err">â”‚</span>
<span class="w">    </span><span class="err">â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</span>
</code></pre></div>

<hr />
<h2 id="5-type-checking">5. íƒ€ì… ê²€ì‚¬(Type Checking)<a class="header-link" href="#5-type-checking" title="Permanent link">&para;</a></h2>
<h3 id="51">5.1 íƒ€ì… ê²€ì‚¬ ê·œì¹™<a class="header-link" href="#51" title="Permanent link">&para;</a></h3>
<p>íƒ€ì… ê²€ì‚¬ëŠ” ì—°ì‚°ì´ í˜¸í™˜ ê°€ëŠ¥í•œ íƒ€ì…ì˜ í”¼ì—°ì‚°ìì— ì ìš©ë˜ëŠ”ì§€ ê²€ì¦í•©ë‹ˆë‹¤. íƒ€ì… ê²€ì‚¬ ê·œì¹™ì„ <strong>íŒë‹¨(judgment)</strong>ìœ¼ë¡œ í‘œí˜„í•©ë‹ˆë‹¤:</p>
<p>$$\Gamma \vdash e : \tau$$</p>
<p>"íƒ€ì… í™˜ê²½(type environment) $\Gamma$ í•˜ì—ì„œ, í‘œí˜„ì‹ $e$ëŠ” íƒ€ì… $\tau$ë¥¼ ê°€ì§„ë‹¤"ë¡œ ì½ìŠµë‹ˆë‹¤.</p>
<p><strong>í•µì‹¬ íƒ€ì… ê·œì¹™ (ë°˜í˜•ì‹ì  í‘œí˜„):</strong></p>
<p>$$
\frac{}{\Gamma \vdash n : \text{int}} \quad (\text{Int Literal})
$$</p>
<p>$$
\frac{}{\Gamma \vdash \text{true} : \text{bool}} \quad (\text{Bool Literal})
$$</p>
<p>$$
\frac{x : \tau \in \Gamma}{\Gamma \vdash x : \tau} \quad (\text{Variable})
$$</p>
<p>$$
\frac{\Gamma \vdash e_1 : \text{int} \quad \Gamma \vdash e_2 : \text{int}}{\Gamma \vdash e_1 + e_2 : \text{int}} \quad (\text{Int Addition})
$$</p>
<p>$$
\frac{\Gamma \vdash e_1 : \tau_1 \quad \Gamma \vdash e_2 : \tau_2 \quad \tau_1 = \tau_2 \quad \tau_1 \in \{\text{int}, \text{float}\}}{\Gamma \vdash e_1 < e_2 : \text{bool}} \quad (\text{Comparison})
$$</p>
<p>$$
\frac{\Gamma \vdash e : \text{bool} \quad \Gamma \vdash s_1 : \text{ok} \quad \Gamma \vdash s_2 : \text{ok}}{\Gamma \vdash \textbf{if}\ (e)\ s_1\ \textbf{else}\ s_2 : \text{ok}} \quad (\text{If Statement})
$$</p>
<p>$$
\frac{\Gamma \vdash f : (\tau_1, \ldots, \tau_n) \to \tau_r \quad \Gamma \vdash e_i : \tau_i \text{ for } i = 1 \ldots n}{\Gamma \vdash f(e_1, \ldots, e_n) : \tau_r} \quad (\text{Function Call})
$$</p>
<h3 id="52">5.2 íƒ€ì… ê²€ì‚¬ê¸° êµ¬í˜„<a class="header-link" href="#52" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Type Checker Implementation</span>

<span class="sd">Walks the AST, verifies type correctness, and annotates</span>
<span class="sd">nodes with their resolved types.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">dataclasses</span><span class="w"> </span><span class="kn">import</span> <span class="n">dataclass</span><span class="p">,</span> <span class="n">field</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TypeChecker</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs type checking on an AST.</span>

<span class="sd">    Uses the symbol table for name resolution and type lookup.</span>
<span class="sd">    Reports type errors with source locations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span> <span class="o">=</span> <span class="n">SymbolTable</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Register built-in functions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_register_builtins</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_register_builtins</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Register built-in functions in the global scope.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="s2">&quot;print&quot;</span><span class="p">,</span>
            <span class="n">FuncType</span><span class="p">(</span><span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">STRING_TYPE</span><span class="p">,),</span> <span class="n">return_type</span><span class="o">=</span><span class="n">VOID_TYPE</span><span class="p">),</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span>
            <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="s2">&quot;len&quot;</span><span class="p">,</span>
            <span class="n">FuncType</span><span class="p">(</span><span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">STRING_TYPE</span><span class="p">,),</span> <span class="n">return_type</span><span class="o">=</span><span class="n">INT_TYPE</span><span class="p">),</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span>
            <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="s2">&quot;str&quot;</span><span class="p">,</span>
            <span class="n">FuncType</span><span class="p">(</span><span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">INT_TYPE</span><span class="p">,),</span> <span class="n">return_type</span><span class="o">=</span><span class="n">STRING_TYPE</span><span class="p">),</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span>
            <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Record a type error.&quot;&quot;&quot;</span>
        <span class="n">loc_str</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot; at </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">loc</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;TypeError</span><span class="si">{</span><span class="n">loc_str</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">message</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_program</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">program</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Type-check an entire program.</span>

<span class="sd">        Returns True if no type errors were found.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">program</span><span class="o">.</span><span class="n">statements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_stmt</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>

    <span class="c1"># â”€â”€â”€ Expression Type Checking â”€â”€â”€</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Type-check an expression and return its type.</span>

<span class="sd">        This is the core of the type checker. Each expression</span>
<span class="sd">        form has specific typing rules.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">INT_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">FloatLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">FLOAT_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BoolLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BOOL_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">StringLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">STRING_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">NilLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">VOID_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_identifier</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_binary</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">UnaryExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_unary</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">CallExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_call</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IndexExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_index</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IfExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">ListExpr</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_list_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown expression type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_identifier</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a variable reference.&quot;&quot;&quot;</span>
        <span class="n">sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span>
            <span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Propagate symbol table errors</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">sym</span><span class="o">.</span><span class="n">is_initialized</span> <span class="ow">and</span> <span class="n">sym</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; may not be initialized&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">sym</span><span class="o">.</span><span class="n">type</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_binary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Type-check a binary expression.</span>

<span class="sd">        Rules:</span>
<span class="sd">        - Arithmetic (+, -, *, /, %, **): both operands numeric, result is</span>
<span class="sd">          the wider type (int &lt; float)</span>
<span class="sd">        - String concatenation (+): both operands string, result string</span>
<span class="sd">        - Comparison (&lt;, &gt;, &lt;=, &gt;=): both operands numeric, result bool</span>
<span class="sd">        - Equality (==, !=): operands same type, result bool</span>
<span class="sd">        - Logical (and, or): both operands bool, result bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">left_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="n">right_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

        <span class="c1"># Skip further checking if either side has errors</span>
        <span class="k">if</span> <span class="n">left_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">right_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="n">op</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span>

        <span class="c1"># Arithmetic operators</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">SUB</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">DIV</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MOD</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">POW</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="c1"># String concatenation</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">op</span> <span class="o">==</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span>
                <span class="ow">and</span> <span class="n">left_type</span> <span class="o">==</span> <span class="n">STRING_TYPE</span>
                <span class="ow">and</span> <span class="n">right_type</span> <span class="o">==</span> <span class="n">STRING_TYPE</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="n">STRING_TYPE</span>

            <span class="c1"># Numeric operations</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">left_type</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">right_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wider_numeric</span><span class="p">(</span><span class="n">left_type</span><span class="p">,</span> <span class="n">right_type</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Operator &#39;</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39; not supported for types &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">left_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">right_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="c1"># Comparison operators</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LT</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LE</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">left_type</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">right_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">BOOL_TYPE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot compare &#39;</span><span class="si">{</span><span class="n">left_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">right_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="c1"># Equality operators</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">EQ</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">NE</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_types_compatible</span><span class="p">(</span><span class="n">left_type</span><span class="p">,</span> <span class="n">right_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">BOOL_TYPE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot compare &#39;</span><span class="si">{</span><span class="n">left_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">right_type</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;for equality&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="c1"># Logical operators</span>
        <span class="k">if</span> <span class="n">op</span> <span class="ow">in</span> <span class="p">(</span><span class="n">BinOpKind</span><span class="o">.</span><span class="n">AND</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">OR</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">left_type</span> <span class="o">==</span> <span class="n">BOOL_TYPE</span> <span class="ow">and</span> <span class="n">right_type</span> <span class="o">==</span> <span class="n">BOOL_TYPE</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BOOL_TYPE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Logical operator &#39;</span><span class="si">{</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39; requires bool operands, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got &#39;</span><span class="si">{</span><span class="n">left_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">right_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown operator: </span><span class="si">{</span><span class="n">op</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ERROR_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_unary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a unary expression.&quot;&quot;&quot;</span>
        <span class="n">operand_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">operand_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NEG</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">operand_type</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">operand_type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unary &#39;-&#39; requires numeric operand, got &#39;</span><span class="si">{</span><span class="n">operand_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="o">==</span> <span class="n">UnaryOpKind</span><span class="o">.</span><span class="n">NOT</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">operand_type</span> <span class="o">==</span> <span class="n">BOOL_TYPE</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">BOOL_TYPE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unary &#39;not&#39; requires bool operand, got &#39;</span><span class="si">{</span><span class="n">operand_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">return</span> <span class="n">ERROR_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Type-check a function call.</span>

<span class="sd">        Verifies that:</span>
<span class="sd">        1. The callee has a function type</span>
<span class="sd">        2. The number of arguments matches</span>
<span class="sd">        3. Each argument type matches the parameter type</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">callee_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">callee</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">callee_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callee_type</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">callee</span><span class="si">}</span><span class="s2">&#39; is not callable &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;(type is &#39;</span><span class="si">{</span><span class="n">callee_type</span><span class="si">}</span><span class="s2">&#39;)&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="c1"># Check argument count</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">callee_type</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span>
        <span class="n">actual</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">arguments</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">expected</span> <span class="o">!=</span> <span class="n">actual</span><span class="p">:</span>
            <span class="n">callee_name</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">expr</span><span class="o">.</span><span class="n">callee</span><span class="o">.</span><span class="n">name</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">callee</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">)</span> <span class="k">else</span> <span class="s2">&quot;function&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">callee_name</span><span class="si">}</span><span class="s2">&#39; expects </span><span class="si">{</span><span class="n">expected</span><span class="si">}</span><span class="s2"> argument(s), &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;got </span><span class="si">{</span><span class="n">actual</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="c1"># Check argument types</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">param_type</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">arguments</span><span class="p">,</span> <span class="n">callee_type</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">arg_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_assignable</span><span class="p">(</span><span class="n">param_type</span><span class="p">,</span> <span class="n">arg_type</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Argument </span><span class="si">{</span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">: expected &#39;</span><span class="si">{</span><span class="n">param_type</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;got &#39;</span><span class="si">{</span><span class="n">arg_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="n">callee_type</span><span class="o">.</span><span class="n">return_type</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check an index expression: a[i].&quot;&quot;&quot;</span>
        <span class="n">obj_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">idx_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">idx_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj_type</span><span class="p">,</span> <span class="n">ListType</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">idx_type</span> <span class="o">!=</span> <span class="n">INT_TYPE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;List index must be int, got &#39;</span><span class="si">{</span><span class="n">idx_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">obj_type</span><span class="o">.</span><span class="n">element_type</span>

        <span class="k">if</span> <span class="n">obj_type</span> <span class="o">==</span> <span class="n">STRING_TYPE</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">idx_type</span> <span class="o">!=</span> <span class="n">INT_TYPE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;String index must be int, got &#39;</span><span class="si">{</span><span class="n">idx_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">STRING_TYPE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Type &#39;</span><span class="si">{</span><span class="n">obj_type</span><span class="si">}</span><span class="s2">&#39; does not support indexing&quot;</span><span class="p">,</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">ERROR_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_if_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a conditional expression.&quot;&quot;&quot;</span>
        <span class="n">cond_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="n">then_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">then_expr</span><span class="p">)</span>
        <span class="n">else_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">else_expr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">BOOL_TYPE</span> <span class="ow">and</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Condition must be bool, got &#39;</span><span class="si">{</span><span class="n">cond_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">then_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">else_type</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">if</span> <span class="n">then_type</span> <span class="o">!=</span> <span class="n">else_type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;If branches have different types: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">then_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">else_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">return</span> <span class="n">then_type</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_list_expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a list literal.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">expr</span><span class="o">.</span><span class="n">elements</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ListType</span><span class="p">(</span><span class="n">element_type</span><span class="o">=</span><span class="n">VOID_TYPE</span><span class="p">)</span>  <span class="c1"># empty list</span>

        <span class="n">elem_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">elem_type</span> <span class="ow">and</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span> <span class="ow">and</span> <span class="n">elem_type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;List elements have inconsistent types: &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">elem_type</span><span class="si">}</span><span class="s2">&#39; and &#39;</span><span class="si">{</span><span class="n">t</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="n">ERROR_TYPE</span>

        <span class="k">return</span> <span class="n">ListType</span><span class="p">(</span><span class="n">element_type</span><span class="o">=</span><span class="n">elem_type</span><span class="p">)</span>

    <span class="c1"># â”€â”€â”€ Statement Type Checking â”€â”€â”€</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">check_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a statement.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">LetStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_let</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">AssignStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_assign</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">ExprStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">expr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">PrintStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">IfStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_if_stmt</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">WhileStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_while</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">Block</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_block</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">FuncDecl</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_func_decl</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">ReturnStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_return</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="n">ForStmt</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_for</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unknown statement type: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_let</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a let declaration.&quot;&quot;&quot;</span>
        <span class="n">declared_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">type_ann</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">declared_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">type_ann</span><span class="p">)</span>

        <span class="n">init_type</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">initializer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">init_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">initializer</span><span class="p">)</span>

        <span class="c1"># Determine the variable&#39;s type</span>
        <span class="k">if</span> <span class="n">declared_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">init_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_assignable</span><span class="p">(</span><span class="n">declared_type</span><span class="p">,</span> <span class="n">init_type</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot assign &#39;</span><span class="si">{</span><span class="n">init_type</span><span class="si">}</span><span class="s2">&#39; to variable &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">stmt</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; of type &#39;</span><span class="si">{</span><span class="n">declared_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
            <span class="n">var_type</span> <span class="o">=</span> <span class="n">declared_type</span>
        <span class="k">elif</span> <span class="n">declared_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">var_type</span> <span class="o">=</span> <span class="n">declared_type</span>
        <span class="k">elif</span> <span class="n">init_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">var_type</span> <span class="o">=</span> <span class="n">init_type</span>  <span class="c1"># type inference from initializer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Variable &#39;</span><span class="si">{</span><span class="n">stmt</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; has no type annotation &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;and no initializer&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">var_type</span> <span class="o">=</span> <span class="n">ERROR_TYPE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="n">stmt</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">var_type</span><span class="p">,</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">VARIABLE</span><span class="p">,</span>
            <span class="n">initialized</span><span class="o">=</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">initializer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">loc</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check an assignment statement.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="n">sym</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span>
                <span class="n">stmt</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">sym</span><span class="o">.</span><span class="n">is_mutable</span> <span class="ow">and</span> <span class="n">sym</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot assign to immutable variable &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">stmt</span><span class="o">.</span><span class="n">target</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>

            <span class="n">value_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_assignable</span><span class="p">(</span><span class="n">sym</span><span class="o">.</span><span class="n">type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot assign &#39;</span><span class="si">{</span><span class="n">value_type</span><span class="si">}</span><span class="s2">&#39; to &#39;</span><span class="si">{</span><span class="n">sym</span><span class="o">.</span><span class="n">type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>

            <span class="n">sym</span><span class="o">.</span><span class="n">is_initialized</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Complex assignment target (e.g., a[i] = ...)</span>
            <span class="n">target_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
            <span class="n">value_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_assignable</span><span class="p">(</span><span class="n">target_type</span><span class="p">,</span> <span class="n">value_type</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot assign &#39;</span><span class="si">{</span><span class="n">value_type</span><span class="si">}</span><span class="s2">&#39; to &#39;</span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_if_stmt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check an if statement.&quot;&quot;&quot;</span>
        <span class="n">cond_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">BOOL_TYPE</span> <span class="ow">and</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;If condition must be bool, got &#39;</span><span class="si">{</span><span class="n">cond_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_check_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">then_body</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">else_body</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">else_body</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_while</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a while loop.&quot;&quot;&quot;</span>
        <span class="n">cond_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">condition</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">BOOL_TYPE</span> <span class="ow">and</span> <span class="n">cond_type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;While condition must be bool, got &#39;</span><span class="si">{</span><span class="n">cond_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_for</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a for loop.&quot;&quot;&quot;</span>
        <span class="n">iter_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">iterable</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">iter_type</span><span class="p">,</span> <span class="n">ListType</span><span class="p">):</span>
            <span class="n">elem_type</span> <span class="o">=</span> <span class="n">iter_type</span><span class="o">.</span><span class="n">element_type</span>
        <span class="k">elif</span> <span class="n">iter_type</span> <span class="o">==</span> <span class="n">STRING_TYPE</span><span class="p">:</span>
            <span class="n">elem_type</span> <span class="o">=</span> <span class="n">STRING_TYPE</span>
        <span class="k">elif</span> <span class="n">iter_type</span> <span class="o">!=</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Cannot iterate over type &#39;</span><span class="si">{</span><span class="n">iter_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">elem_type</span> <span class="o">=</span> <span class="n">ERROR_TYPE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elem_type</span> <span class="o">=</span> <span class="n">ERROR_TYPE</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">enter_scope</span><span class="p">(</span><span class="s2">&quot;for-body&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="n">stmt</span><span class="o">.</span><span class="n">var_name</span><span class="p">,</span> <span class="n">elem_type</span><span class="p">,</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">VARIABLE</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_check_block</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">exit_scope</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">block</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a block of statements.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">enter_scope</span><span class="p">(</span><span class="s2">&quot;block&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">stmt</span> <span class="ow">in</span> <span class="n">block</span><span class="o">.</span><span class="n">statements</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_stmt</span><span class="p">(</span><span class="n">stmt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">exit_scope</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_func_decl</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a function declaration.&quot;&quot;&quot;</span>
        <span class="c1"># Resolve parameter types</span>
        <span class="n">param_types</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">param</span><span class="o">.</span><span class="n">type_ann</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">type_ann</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Parameter &#39;</span><span class="si">{</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39; has no type annotation&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">param</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">ERROR_TYPE</span>
            <span class="n">param_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

        <span class="c1"># Resolve return type</span>
        <span class="n">return_type</span> <span class="o">=</span> <span class="n">VOID_TYPE</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">return_type</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">return_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>

        <span class="c1"># Define function in current scope</span>
        <span class="n">func_type</span> <span class="o">=</span> <span class="n">FuncType</span><span class="p">(</span>
            <span class="n">param_types</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">param_types</span><span class="p">),</span>
            <span class="n">return_type</span><span class="o">=</span><span class="n">return_type</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
            <span class="n">stmt</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func_type</span><span class="p">,</span>
            <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span> <span class="n">mutable</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">loc</span><span class="o">=</span><span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Check body in new scope</span>
        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">body</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prev_return</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span> <span class="o">=</span> <span class="n">return_type</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">enter_scope</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fn:</span><span class="si">{</span><span class="n">stmt</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">param</span><span class="p">,</span> <span class="n">pt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="n">param_types</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
                    <span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">pt</span><span class="p">,</span>
                    <span class="n">SymbolKind</span><span class="o">.</span><span class="n">PARAMETER</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stmt</span><span class="o">.</span><span class="n">body</span><span class="o">.</span><span class="n">statements</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">check_stmt</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">symbol_table</span><span class="o">.</span><span class="n">exit_scope</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span> <span class="o">=</span> <span class="n">prev_return</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_return</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stmt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Type-check a return statement.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Return statement outside of function&quot;</span><span class="p">,</span>
                <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">stmt</span><span class="o">.</span><span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_expr</span><span class="p">(</span><span class="n">stmt</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_assignable</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">value_type</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Return type mismatch: expected &#39;</span><span class="si">{</span><span class="n">expected</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;got &#39;</span><span class="si">{</span><span class="n">value_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span> <span class="o">!=</span> <span class="n">VOID_TYPE</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Function should return &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">current_function_return_type</span><span class="si">}</span><span class="s2">&#39;, &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;but return has no value&quot;</span><span class="p">,</span>
                    <span class="nb">getattr</span><span class="p">(</span><span class="n">stmt</span><span class="p">,</span> <span class="s1">&#39;loc&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
                <span class="p">)</span>

    <span class="c1"># â”€â”€â”€ Type Resolution Helpers â”€â”€â”€</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_resolve_type_annotation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ann</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a type annotation AST node to a Type.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">):</span>
            <span class="n">type_map</span> <span class="o">=</span> <span class="p">{</span>
                <span class="s2">&quot;int&quot;</span><span class="p">:</span> <span class="n">INT_TYPE</span><span class="p">,</span>
                <span class="s2">&quot;float&quot;</span><span class="p">:</span> <span class="n">FLOAT_TYPE</span><span class="p">,</span>
                <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="n">BOOL_TYPE</span><span class="p">,</span>
                <span class="s2">&quot;string&quot;</span><span class="p">:</span> <span class="n">STRING_TYPE</span><span class="p">,</span>
                <span class="s2">&quot;void&quot;</span><span class="p">:</span> <span class="n">VOID_TYPE</span><span class="p">,</span>
            <span class="p">}</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">type_map</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">t</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown type: &#39;</span><span class="si">{</span><span class="n">ann</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ERROR_TYPE</span>
            <span class="k">return</span> <span class="n">t</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">ListType</span><span class="p">):</span>
            <span class="n">elem_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">element_type</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ListType</span><span class="p">(</span><span class="n">element_type</span><span class="o">=</span><span class="n">elem_t</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">):</span>
            <span class="n">params</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">ann</span><span class="o">.</span><span class="n">param_types</span>
            <span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolve_type_annotation</span><span class="p">(</span><span class="n">ann</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">FuncType</span><span class="p">(</span><span class="n">param_types</span><span class="o">=</span><span class="n">params</span><span class="p">,</span> <span class="n">return_type</span><span class="o">=</span><span class="n">ret</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported type annotation: </span><span class="si">{</span><span class="nb">type</span><span class="p">(</span><span class="n">ann</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">ERROR_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_is_numeric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">kind</span> <span class="ow">in</span> <span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">,</span> <span class="n">TypeKind</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_wider_numeric</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Type</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the wider of two numeric types (int &lt; float).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">FLOAT_TYPE</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">==</span> <span class="n">FLOAT_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FLOAT_TYPE</span>
        <span class="k">return</span> <span class="n">INT_TYPE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_type_assignable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if source type can be assigned to target type.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">source</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Don&#39;t cascade errors</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">source</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># Implicit widening: int -&gt; float</span>
        <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">FLOAT_TYPE</span> <span class="ow">and</span> <span class="n">source</span> <span class="o">==</span> <span class="n">INT_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_types_compatible</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check if two types can be compared for equality.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">a</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">b</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">==</span> <span class="n">b</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_numeric</span><span class="p">(</span><span class="n">b</span><span class="p">))</span>


<span class="c1"># â”€â”€â”€ Demo â”€â”€â”€</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Build AST for a program with type errors</span>
    <span class="n">program</span> <span class="o">=</span> <span class="n">Program</span><span class="p">(</span><span class="n">statements</span><span class="o">=</span><span class="p">[</span>
        <span class="c1"># let x: int = 42;</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">),</span> <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">42</span><span class="p">)),</span>
        <span class="c1"># let y: string = &quot;hello&quot;;</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">),</span> <span class="n">StringLiteral</span><span class="p">(</span><span class="s2">&quot;hello&quot;</span><span class="p">)),</span>
        <span class="c1"># let z = x + y;  -- TYPE ERROR: int + string</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span> <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">),</span>
        <span class="p">)),</span>
        <span class="c1"># fn add(a: int, b: int) -&gt; int { return a + b; }</span>
        <span class="n">FuncDecl</span><span class="p">(</span>
            <span class="s2">&quot;add&quot;</span><span class="p">,</span>
            <span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">)),</span>
             <span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))],</span>
            <span class="n">SimpleType</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">),</span>
            <span class="n">Block</span><span class="p">([</span>
                <span class="n">ReturnStmt</span><span class="p">(</span><span class="n">BinaryExpr</span><span class="p">(</span>
                    <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
                    <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span>
                <span class="p">))</span>
            <span class="p">]),</span>
        <span class="p">),</span>
        <span class="c1"># let result = add(1, &quot;two&quot;);  -- TYPE ERROR: string for int param</span>
        <span class="n">LetStmt</span><span class="p">(</span><span class="s2">&quot;result&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">CallExpr</span><span class="p">(</span>
            <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">),</span>
            <span class="p">[</span><span class="n">IntLiteral</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">StringLiteral</span><span class="p">(</span><span class="s2">&quot;two&quot;</span><span class="p">)],</span>
        <span class="p">)),</span>
        <span class="c1"># if (x) { ... }  -- TYPE ERROR: int used as bool</span>
        <span class="n">IfStmt</span><span class="p">(</span>
            <span class="n">condition</span><span class="o">=</span><span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span>
            <span class="n">then_body</span><span class="o">=</span><span class="n">Block</span><span class="p">([</span>
                <span class="n">PrintStmt</span><span class="p">(</span><span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)),</span>
            <span class="p">]),</span>
        <span class="p">),</span>
    <span class="p">])</span>

    <span class="n">checker</span> <span class="o">=</span> <span class="n">TypeChecker</span><span class="p">()</span>
    <span class="n">success</span> <span class="o">=</span> <span class="n">checker</span><span class="o">.</span><span class="n">check_program</span><span class="p">(</span><span class="n">program</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Type check </span><span class="si">{</span><span class="s1">&#39;passed&#39;</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">success</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="s1">&#39;FAILED&#39;</span><span class="si">}</span><span class="s2">!&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">checker</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Found </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">checker</span><span class="o">.</span><span class="n">errors</span><span class="p">)</span><span class="si">}</span><span class="s2"> error(s):&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="n">checker</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">err</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<p><strong>ì˜ˆìƒ ì¶œë ¥:</strong></p>
<div class="highlight"><pre><span></span><code><span class="nx">Type</span><span class="w"> </span><span class="nx">check</span><span class="w"> </span><span class="nx">FAILED</span><span class="p">!</span>

<span class="nx">Found</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="nx">error</span><span class="p">(</span><span class="nx">s</span><span class="p">):</span>
<span class="w">  </span><span class="nx">TypeError</span><span class="p">:</span><span class="w"> </span><span class="nx">Operator</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="nx">supported</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">types</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">int</span><span class="err">&#39;</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="err">&#39;</span><span class="kt">string</span><span class="err">&#39;</span>
<span class="w">  </span><span class="nx">TypeError</span><span class="p">:</span><span class="w"> </span><span class="nx">Argument</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span><span class="w"> </span><span class="nx">expected</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">int</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">got</span><span class="w"> </span><span class="err">&#39;</span><span class="kt">string</span><span class="err">&#39;</span>
<span class="w">  </span><span class="nx">TypeError</span><span class="p">:</span><span class="w"> </span><span class="nx">If</span><span class="w"> </span><span class="nx">condition</span><span class="w"> </span><span class="nx">must</span><span class="w"> </span><span class="nx">be</span><span class="w"> </span><span class="kt">bool</span><span class="p">,</span><span class="w"> </span><span class="nx">got</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">int</span><span class="err">&#39;</span>
</code></pre></div>

<hr />
<h2 id="6-type-inference">6. íƒ€ì… ì¶”ë¡ (Type Inference)<a class="header-link" href="#6-type-inference" title="Permanent link">&para;</a></h2>
<h3 id="61-local-type-inference">6.1 ì§€ì—­ íƒ€ì… ì¶”ë¡ (Local Type Inference)<a class="header-link" href="#61-local-type-inference" title="Permanent link">&para;</a></h3>
<p>ê°€ì¥ ë‹¨ìˆœí•œ í˜•íƒœì˜ íƒ€ì… ì¶”ë¡ : ì´ˆê¸°í™” ì‹ìœ¼ë¡œë¶€í„° ë³€ìˆ˜ì˜ íƒ€ì…ì„ ì¶”ë¡ í•©ë‹ˆë‹¤.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># The type checker already supports this:</span>
<span class="n">let</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>           <span class="c1"># inferred as int</span>
<span class="n">let</span> <span class="n">y</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>         <span class="c1"># inferred as float</span>
<span class="n">let</span> <span class="n">z</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">;</span>        <span class="c1"># inferred as float (int + float -&gt; float)</span>
<span class="n">let</span> <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;hello&quot;</span><span class="p">;</span>    <span class="c1"># inferred as string</span>
</code></pre></div>

<p>ì´ê²ƒì€ TypeScript, Kotlin, Rust, Goê°€ ë³€ìˆ˜ ì„ ì–¸ì— ì‚¬ìš©í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤.</p>
<h3 id="62-hindley-milner-type-inference">6.2 íŒë“¤ë¦¬-ë°€ë„ˆ íƒ€ì… ì¶”ë¡ (Hindley-Milner Type Inference)<a class="header-link" href="#62-hindley-milner-type-inference" title="Permanent link">&para;</a></h3>
<p><strong>íŒë“¤ë¦¬-ë°€ë„ˆ(HM)</strong> íƒ€ì… ì¶”ë¡ ì€ ë” ê°•ë ¥í•©ë‹ˆë‹¤: ì–´ë…¸í…Œì´ì…˜ ì—†ì´ í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ì™€ ë°˜í™˜ íƒ€ì…ì˜ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. Haskell, OCaml, F#, ê·¸ë¦¬ê³  (ì œí•œëœ í˜•íƒœë¡œ) Rustì—ì„œ ì‚¬ìš©ë©ë‹ˆë‹¤.</p>
<p><strong>í•µì‹¬ ì•„ì´ë””ì–´:</strong> <strong>íƒ€ì… ë³€ìˆ˜(type variables)</strong>ì™€ <strong>ë‹¨ì¼í™”(unification)</strong>ë¥¼ ì‚¬ìš©í•˜ì—¬ íƒ€ì…ì„ ê²°ì •í•©ë‹ˆë‹¤.</p>
<p>$$
\frac{\Gamma, x:\alpha \vdash e : \tau}{\Gamma \vdash \lambda x.e : \alpha \to \tau}
$$</p>
<p>ë§¤ê°œë³€ìˆ˜ $x$ì˜ íƒ€ì…ì„ ëª¨ë¥¼ ê²½ìš°, ì‹ ì„ í•œ íƒ€ì… ë³€ìˆ˜ $\alpha$ë¥¼ í• ë‹¹í•˜ê³  ë‹¨ì¼í™”ê°€ êµ¬ì²´ì ì¸ íƒ€ì…ì„ ê²°ì •í•˜ê²Œ í•©ë‹ˆë‹¤.</p>
<h3 id="63-unification-algorithm">6.3 ë‹¨ì¼í™” ì•Œê³ ë¦¬ì¦˜(Unification Algorithm)<a class="header-link" href="#63-unification-algorithm" title="Permanent link">&para;</a></h3>
<p><strong>ë‹¨ì¼í™”(unification)</strong>ëŠ” ë‘ íƒ€ì…ì„ ê°™ê²Œ ë§Œë“œëŠ” ì¹˜í™˜(substitution) $\sigma$ë¥¼ ì°¾ìŠµë‹ˆë‹¤: $\sigma(\tau_1) = \sigma(\tau_2)$.</p>
<div class="highlight"><pre><span></span><code><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Simplified Hindley-Milner Type Inference</span>

<span class="sd">Implements type variables and unification for basic</span>
<span class="sd">type inference without explicit annotations.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">TypeVar</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A type variable that can be unified with other types.&quot;&quot;&quot;</span>

    <span class="n">_counter</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">TypeVar</span><span class="o">.</span><span class="n">_counter</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;T</span><span class="si">{</span><span class="n">TypeVar</span><span class="o">.</span><span class="n">_counter</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="s2">&quot;InferType&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;InferType&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Follow the chain of bindings to find the actual type.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
            <span class="n">resolved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span> <span class="o">=</span> <span class="n">resolved</span>  <span class="c1"># path compression</span>
            <span class="k">return</span> <span class="n">resolved</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">bound_to</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">resolved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">resolved</span> <span class="ow">is</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;?</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">resolved</span><span class="p">)</span>


<span class="c1"># For HM inference, types are:</span>
<span class="n">InferType</span> <span class="o">=</span> <span class="n">TypeVar</span> <span class="o">|</span> <span class="n">Type</span> <span class="o">|</span> <span class="n">FuncType</span>


<span class="k">def</span><span class="w"> </span><span class="nf">unify</span><span class="p">(</span><span class="n">t1</span><span class="p">:</span> <span class="n">InferType</span><span class="p">,</span> <span class="n">t2</span><span class="p">:</span> <span class="n">InferType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Unify two types, binding type variables as needed.</span>

<span class="sd">    Returns True if unification succeeds, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Resolve any bound type variables</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
        <span class="n">t1</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
        <span class="n">t2</span> <span class="o">=</span> <span class="n">t2</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>

    <span class="c1"># Same type variable: trivially unified</span>
    <span class="k">if</span> <span class="n">t1</span> <span class="ow">is</span> <span class="n">t2</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># One is a type variable: bind it</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">occurs_in</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>  <span class="c1"># Occurs check: prevent infinite types</span>
        <span class="n">t1</span><span class="o">.</span><span class="n">bound_to</span> <span class="o">=</span> <span class="n">t2</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">occurs_in</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">t1</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">t2</span><span class="o">.</span><span class="n">bound_to</span> <span class="o">=</span> <span class="n">t1</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="c1"># Both are concrete types: must be the same kind</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">Type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">Type</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">t1</span> <span class="o">==</span> <span class="n">t2</span>

    <span class="c1"># Both are function types: unify parameter and return types</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t2</span><span class="o">.</span><span class="n">param_types</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">param_types</span><span class="p">,</span> <span class="n">t2</span><span class="o">.</span><span class="n">param_types</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">unify</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">unify</span><span class="p">(</span><span class="n">t1</span><span class="o">.</span><span class="n">return_type</span><span class="p">,</span> <span class="n">t2</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>

    <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span><span class="w"> </span><span class="nf">occurs_in</span><span class="p">(</span><span class="n">var</span><span class="p">:</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">InferType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Occurs check: does type variable `var` appear in type `t`?</span>

<span class="sd">    This prevents creating infinite types like T = T -&gt; T.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">t</span> <span class="ow">is</span> <span class="n">var</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">FuncType</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">param_types</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">occurs_in</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">pt</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">occurs_in</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="c1"># â”€â”€â”€ Simple Type Inferencer â”€â”€â”€</span>

<span class="k">class</span><span class="w"> </span><span class="nc">TypeInferencer</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simple Hindley-Milner style type inference.</span>

<span class="sd">    Assigns type variables to unknown types and uses</span>
<span class="sd">    unification to determine concrete types.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">:</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">InferType</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">fresh_var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TypeVar</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a fresh type variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">TypeVar</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">infer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">InferType</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Infer the type of an expression.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">IntLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">INT_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BoolLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">BOOL_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">StringLiteral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">STRING_TYPE</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">Identifier</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Undefined: </span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">BinaryExpr</span><span class="p">):</span>
            <span class="n">left_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">right_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">SUB</span><span class="p">,</span>
                <span class="n">BinOpKind</span><span class="o">.</span><span class="n">MUL</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">DIV</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="c1"># Both sides must be the same numeric type</span>
                <span class="n">result_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">unify</span><span class="p">(</span><span class="n">left_t</span><span class="p">,</span> <span class="n">result_var</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Type error in left operand of &#39;</span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                    <span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">unify</span><span class="p">(</span><span class="n">right_t</span><span class="p">,</span> <span class="n">result_var</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Type error in right operand of &#39;</span><span class="si">{</span><span class="n">expr</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">result_var</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>

            <span class="k">elif</span> <span class="n">expr</span><span class="o">.</span><span class="n">op</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="n">BinOpKind</span><span class="o">.</span><span class="n">EQ</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LT</span><span class="p">,</span>
                <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">LE</span><span class="p">,</span> <span class="n">BinOpKind</span><span class="o">.</span><span class="n">GE</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">unify</span><span class="p">(</span><span class="n">left_t</span><span class="p">,</span> <span class="n">right_t</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Comparison type mismatch&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">BOOL_TYPE</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">LambdaExpr</span><span class="p">):</span>
            <span class="c1"># Î»(x, y) =&gt; body</span>
            <span class="n">param_vars</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
                <span class="n">tv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">env</span><span class="p">[</span><span class="n">param</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tv</span>
                <span class="n">param_vars</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tv</span><span class="p">)</span>

            <span class="n">body_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">FuncType</span><span class="p">(</span>
                <span class="n">param_types</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">)</span> <span class="k">else</span> <span class="n">v</span>
                    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">param_vars</span>
                <span class="p">),</span>
                <span class="n">return_type</span><span class="o">=</span><span class="p">(</span>
                    <span class="n">body_type</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">body_type</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">)</span> <span class="k">else</span> <span class="n">body_type</span>
                <span class="p">),</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">CallExpr</span><span class="p">):</span>
            <span class="n">func_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">callee</span><span class="p">)</span>
            <span class="n">arg_types</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">arguments</span><span class="p">]</span>

            <span class="n">ret_var</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>
            <span class="n">expected_func</span> <span class="o">=</span> <span class="n">FuncType</span><span class="p">(</span>
                <span class="n">param_types</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">arg_types</span><span class="p">),</span>
                <span class="n">return_type</span><span class="o">=</span><span class="n">ret_var</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">unify</span><span class="p">(</span><span class="n">func_type</span><span class="p">,</span> <span class="n">expected_func</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Function call type mismatch&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">ret_var</span><span class="o">.</span><span class="n">resolve</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fresh_var</span><span class="p">()</span>


<span class="c1"># â”€â”€â”€ Demo â”€â”€â”€</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">inferencer</span> <span class="o">=</span> <span class="n">TypeInferencer</span><span class="p">()</span>

    <span class="c1"># Infer type of: fn(x) =&gt; x + 1</span>
    <span class="c1"># Expected: (int) -&gt; int</span>
    <span class="n">expr</span> <span class="o">=</span> <span class="n">LambdaExpr</span><span class="p">(</span>
        <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)],</span>
        <span class="n">body</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
            <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">),</span>
            <span class="n">IntLiteral</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="n">result_type</span> <span class="o">=</span> <span class="n">inferencer</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fn(x) =&gt; x + 1 : </span><span class="si">{</span><span class="n">result_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="c1"># Output: fn(x) =&gt; x + 1 : (int) -&gt; int</span>

    <span class="c1"># Infer: fn(a, b) =&gt; a + b</span>
    <span class="c1"># Expected: (?T, ?T) -&gt; ?T  (polymorphic)</span>
    <span class="n">inferencer2</span> <span class="o">=</span> <span class="n">TypeInferencer</span><span class="p">()</span>
    <span class="n">expr2</span> <span class="o">=</span> <span class="n">LambdaExpr</span><span class="p">(</span>
        <span class="n">params</span><span class="o">=</span><span class="p">[</span><span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span> <span class="n">Parameter</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">)],</span>
        <span class="n">body</span><span class="o">=</span><span class="n">BinaryExpr</span><span class="p">(</span>
            <span class="n">BinOpKind</span><span class="o">.</span><span class="n">ADD</span><span class="p">,</span>
            <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">),</span>
            <span class="n">Identifier</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span>

    <span class="n">result_type2</span> <span class="o">=</span> <span class="n">inferencer2</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">expr2</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;fn(a, b) =&gt; a + b : </span><span class="si">{</span><span class="n">result_type2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="7-type-compatibility-and-coercion">7. íƒ€ì… í˜¸í™˜ì„±ê³¼ ê°•ì œ ë³€í™˜(Type Compatibility and Coercion)<a class="header-link" href="#7-type-compatibility-and-coercion" title="Permanent link">&para;</a></h2>
<h3 id="71">7.1 íƒ€ì… í˜¸í™˜ì„± ê·œì¹™<a class="header-link" href="#71" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>ê·œì¹™</th>
<th>ì„¤ëª…</th>
<th>ì˜ˆì‹œ</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ë™ì¼ì„±(Identity)</strong></td>
<td>ê°™ì€ íƒ€ì…ì€ í•­ìƒ í˜¸í™˜ë¨</td>
<td><code>int</code> = <code>int</code></td>
</tr>
<tr>
<td><strong>í™•ì¥(Widening)</strong></td>
<td>ë” ì‘ì€ ìˆ˜ì¹˜ íƒ€ì…ì´ ë” í° íƒ€ì…ì— ë§ìŒ</td>
<td><code>int</code> -&gt; <code>float</code></td>
</tr>
<tr>
<td><strong>ì„œë¸Œíƒ€ì´í•‘(Subtyping)</strong></td>
<td>ì„œë¸Œíƒ€ì…ì€ ìŠˆí¼íƒ€ì…ê³¼ í˜¸í™˜ë¨</td>
<td><code>Cat</code> -&gt; <code>Animal</code></td>
</tr>
<tr>
<td><strong>êµ¬ì¡°ì (Structural)</strong></td>
<td>ê°™ì€ êµ¬ì¡° = í˜¸í™˜ë¨</td>
<td><code>{x: int, y: int}</code> = <code>{x: int, y: int}</code></td>
</tr>
<tr>
<td><strong>ëª…ëª©ì (Nominal)</strong></td>
<td>ê°™ì€ ì´ë¦„ = í˜¸í™˜ë¨</td>
<td>Java í´ë˜ìŠ¤ íƒ€ì…</td>
</tr>
</tbody>
</table>
<h3 id="72-implicit-coercion">7.2 ì•”ë¬µì  ê°•ì œ ë³€í™˜(Implicit Coercion)<a class="header-link" href="#72-implicit-coercion" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">can_coerce</span><span class="p">(</span><span class="n">source</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check if source can be implicitly coerced to target.</span>

<span class="sd">    Coercion rules (ordered by safety):</span>
<span class="sd">    1. int -&gt; float    (widening, safe)</span>
<span class="sd">    2. int -&gt; string   (via str(), if language supports it)</span>
<span class="sd">    3. float -&gt; int    (narrowing, UNSAFE -- not allowed implicitly)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">COERCION_TABLE</span> <span class="o">=</span> <span class="p">{</span>
        <span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">,</span> <span class="n">TypeKind</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">):</span> <span class="kc">True</span><span class="p">,</span>   <span class="c1"># safe widening</span>
        <span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">,</span> <span class="n">TypeKind</span><span class="o">.</span><span class="n">BOOL</span><span class="p">):</span> <span class="kc">False</span><span class="p">,</span>    <span class="c1"># no implicit</span>
        <span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">FLOAT</span><span class="p">,</span> <span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">):</span> <span class="kc">False</span><span class="p">,</span>   <span class="c1"># narrowing, rejected</span>
        <span class="p">(</span><span class="n">TypeKind</span><span class="o">.</span><span class="n">BOOL</span><span class="p">,</span> <span class="n">TypeKind</span><span class="o">.</span><span class="n">INT</span><span class="p">):</span> <span class="kc">True</span><span class="p">,</span>     <span class="c1"># true=1, false=0</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">source</span> <span class="o">==</span> <span class="n">target</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">return</span> <span class="n">COERCION_TABLE</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
        <span class="p">(</span><span class="n">source</span><span class="o">.</span><span class="n">kind</span><span class="p">,</span> <span class="n">target</span><span class="o">.</span><span class="n">kind</span><span class="p">),</span> <span class="kc">False</span>
    <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">insert_coercion</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">source_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">target_type</span><span class="p">:</span> <span class="n">Type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Wrap an expression in an explicit coercion node if needed.</span>

<span class="sd">    This makes the implicit coercion explicit in the AST,</span>
<span class="sd">    which simplifies code generation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">source_type</span> <span class="o">==</span> <span class="n">target_type</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">expr</span>

    <span class="k">if</span> <span class="n">can_coerce</span><span class="p">(</span><span class="n">source_type</span><span class="p">,</span> <span class="n">target_type</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">CallExpr</span><span class="p">(</span>
            <span class="n">callee</span><span class="o">=</span><span class="n">Identifier</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;__coerce_</span><span class="si">{</span><span class="n">source_type</span><span class="si">}</span><span class="s2">_to_</span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span>
            <span class="n">arguments</span><span class="o">=</span><span class="p">[</span><span class="n">expr</span><span class="p">],</span>
        <span class="p">)</span>

    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;Cannot coerce &#39;</span><span class="si">{</span><span class="n">source_type</span><span class="si">}</span><span class="s2">&#39; to &#39;</span><span class="si">{</span><span class="n">target_type</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
    <span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="8-overloading-resolution">8. ì˜¤ë²„ë¡œë”© í•´ê²°(Overloading Resolution)<a class="header-link" href="#8-overloading-resolution" title="Permanent link">&para;</a></h2>
<h3 id="81">8.1 ì˜¤ë²„ë¡œë”©ì´ë€?<a class="header-link" href="#81" title="Permanent link">&para;</a></h3>
<p><strong>ì˜¤ë²„ë¡œë”©(overloading)</strong>ì€ ì—¬ëŸ¬ í•¨ìˆ˜(ë˜ëŠ” ì—°ì‚°ì)ê°€ ë™ì¼í•œ ì´ë¦„ì„ ê³µìœ í•˜ì§€ë§Œ ì„œë¡œ ë‹¤ë¥¸ ë§¤ê°œë³€ìˆ˜ íƒ€ì…ì„ ê°€ì§ˆ ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤. ì»´íŒŒì¼ëŸ¬ëŠ” ì¸ì íƒ€ì…ì„ ê¸°ë°˜ìœ¼ë¡œ ì–´ë–¤ ë²„ì „ì„ í˜¸ì¶œí• ì§€ í•´ê²°í•´ì•¼ í•©ë‹ˆë‹¤.</p>
<h3 id="82">8.2 í•´ê²° ì•Œê³ ë¦¬ì¦˜<a class="header-link" href="#82" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">resolve_overload</span><span class="p">(</span>
    <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="n">arg_types</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">Type</span><span class="p">],</span>
    <span class="n">candidates</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="n">FuncType</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FuncType</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resolve an overloaded function call.</span>

<span class="sd">    Strategy:</span>
<span class="sd">    1. Find exact matches</span>
<span class="sd">    2. If no exact match, find matches with implicit coercion</span>
<span class="sd">    3. If multiple matches, prefer the most specific one</span>
<span class="sd">    4. If still ambiguous, report an error</span>

<span class="sd">    Returns the resolved function type, or None if ambiguous/no match.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Phase 1: Exact matches</span>
    <span class="n">exact</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_types</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">p</span> <span class="o">==</span> <span class="n">a</span> <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">param_types</span><span class="p">,</span> <span class="n">arg_types</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">exact</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exact</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">exact</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">exact</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># ambiguous</span>

    <span class="c1"># Phase 2: Matches with coercion</span>
    <span class="n">coercible</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">candidate</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">param_types</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">arg_types</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span>
            <span class="n">can_coerce</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">param_types</span><span class="p">,</span> <span class="n">arg_types</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="n">coercible</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coercible</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">coercible</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Phase 3: Most specific match</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">coercible</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># Prefer the candidate requiring fewer coercions</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">coercion_count</span><span class="p">(</span><span class="n">candidate</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
                <span class="mi">0</span> <span class="k">if</span> <span class="n">p</span> <span class="o">==</span> <span class="n">a</span> <span class="k">else</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">p</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">candidate</span><span class="o">.</span><span class="n">param_types</span><span class="p">,</span> <span class="n">arg_types</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">coercible</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">coercion_count</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coercion_count</span><span class="p">(</span><span class="n">coercible</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">coercion_count</span><span class="p">(</span><span class="n">coercible</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="k">return</span> <span class="n">coercible</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># no match or ambiguous</span>


<span class="c1"># â”€â”€â”€ Example â”€â”€â”€</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="c1"># Overloaded &quot;add&quot; function</span>
    <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">FuncType</span><span class="p">(</span><span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">INT_TYPE</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">),</span> <span class="n">return_type</span><span class="o">=</span><span class="n">INT_TYPE</span><span class="p">),</span>
        <span class="n">FuncType</span><span class="p">(</span>
            <span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">FLOAT_TYPE</span><span class="p">,</span> <span class="n">FLOAT_TYPE</span><span class="p">),</span>
            <span class="n">return_type</span><span class="o">=</span><span class="n">FLOAT_TYPE</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">FuncType</span><span class="p">(</span>
            <span class="n">param_types</span><span class="o">=</span><span class="p">(</span><span class="n">STRING_TYPE</span><span class="p">,</span> <span class="n">STRING_TYPE</span><span class="p">),</span>
            <span class="n">return_type</span><span class="o">=</span><span class="n">STRING_TYPE</span><span class="p">,</span>
        <span class="p">),</span>
    <span class="p">]</span>

    <span class="c1"># add(1, 2) -&gt; exact match: (int, int) -&gt; int</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">resolve_overload</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_TYPE</span><span class="p">,</span> <span class="n">INT_TYPE</span><span class="p">],</span> <span class="n">candidates</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;add(int, int) resolves to: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># add(1, 2.0) -&gt; coercion match: (float, float) -&gt; float</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">resolve_overload</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_TYPE</span><span class="p">,</span> <span class="n">FLOAT_TYPE</span><span class="p">],</span> <span class="n">candidates</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;add(int, float) resolves to: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="c1"># add(&quot;a&quot;, &quot;b&quot;) -&gt; exact match: (string, string) -&gt; string</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">resolve_overload</span><span class="p">(</span>
        <span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">STRING_TYPE</span><span class="p">,</span> <span class="n">STRING_TYPE</span><span class="p">],</span> <span class="n">candidates</span>
    <span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;add(string, string) resolves to: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># add(1, &quot;b&quot;) -&gt; no match</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">resolve_overload</span><span class="p">(</span><span class="s2">&quot;add&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">INT_TYPE</span><span class="p">,</span> <span class="n">STRING_TYPE</span><span class="p">],</span> <span class="n">candidates</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;add(int, string) resolves to: </span><span class="si">{</span><span class="n">result</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="9-declaration-processing">9. ì„ ì–¸ ì²˜ë¦¬(Declaration Processing)<a class="header-link" href="#9-declaration-processing" title="Permanent link">&para;</a></h2>
<h3 id="91-forward-references">9.1 ì „ë°© ì°¸ì¡°(Forward References)<a class="header-link" href="#91-forward-references" title="Permanent link">&para;</a></h3>
<p>ë§ì€ ì–¸ì–´ë“¤ì€ ì†ŒìŠ¤ì—ì„œ ë‚˜ì¤‘ì— ë“±ì¥í•˜ëŠ” ì´ë¦„ì„ ì°¸ì¡°í•˜ëŠ” ì„ ì–¸ì„ í—ˆìš©í•©ë‹ˆë‹¤:</p>
<div class="highlight"><pre><span></span><code><span class="nt">fn</span><span class="w"> </span><span class="nt">is_even</span><span class="o">(</span><span class="nt">n</span><span class="o">:</span><span class="w"> </span><span class="nt">int</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">if</span><span class="w"> </span><span class="err">(n</span><span class="w"> </span><span class="err">==</span><span class="w"> </span><span class="err">0)</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">true</span><span class="p">;</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="err">is_odd(n</span><span class="w"> </span><span class="err">-</span><span class="w"> </span><span class="err">1)</span><span class="p">;</span><span class="w">      </span><span class="err">//</span><span class="w"> </span><span class="err">forward</span><span class="w"> </span><span class="err">reference</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">is_odd</span>
<span class="p">}</span>

<span class="nt">fn</span><span class="w"> </span><span class="nt">is_odd</span><span class="o">(</span><span class="nt">n</span><span class="o">:</span><span class="w"> </span><span class="nt">int</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">bool</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="err">if</span><span class="w"> </span><span class="err">(n</span><span class="w"> </span><span class="err">==</span><span class="w"> </span><span class="err">0)</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">false</span><span class="p">;</span>
<span class="w">    </span><span class="err">return</span><span class="w"> </span><span class="err">is_even(n</span><span class="w"> </span><span class="err">-</span><span class="w"> </span><span class="err">1)</span><span class="p">;</span><span class="w">     </span><span class="err">//</span><span class="w"> </span><span class="err">backward</span><span class="w"> </span><span class="err">reference</span><span class="w"> </span><span class="err">to</span><span class="w"> </span><span class="err">is_even</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="92-2-two-pass-strategy">9.2 2-íŒ¨ìŠ¤ ì „ëµ(Two-Pass Strategy)<a class="header-link" href="#92-2-two-pass-strategy" title="Permanent link">&para;</a></h3>
<p>ì „ë°© ì°¸ì¡°ë¥¼ ì²˜ë¦¬í•˜ê¸° ìœ„í•´ ì„ ì–¸ì— ëŒ€í•´ ë‘ ë²ˆì˜ íŒ¨ìŠ¤ë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">check_declarations_two_pass</span><span class="p">(</span><span class="n">declarations</span><span class="p">:</span> <span class="nb">list</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Two-pass declaration processing.</span>

<span class="sd">    Pass 1: Register all names and their types (signatures)</span>
<span class="sd">    Pass 2: Check function bodies (using all registered names)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">symbol_table</span> <span class="o">=</span> <span class="n">SymbolTable</span><span class="p">()</span>

    <span class="c1"># Pass 1: Register signatures</span>
    <span class="k">for</span> <span class="n">decl</span> <span class="ow">in</span> <span class="n">declarations</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">FuncDecl</span><span class="p">):</span>
            <span class="n">param_types</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">decl</span><span class="o">.</span><span class="n">params</span><span class="p">:</span>
                <span class="n">pt</span> <span class="o">=</span> <span class="n">resolve_type_annotation</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">type_ann</span><span class="p">)</span>
                <span class="n">param_types</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>

            <span class="n">return_type</span> <span class="o">=</span> <span class="n">VOID_TYPE</span>
            <span class="k">if</span> <span class="n">decl</span><span class="o">.</span><span class="n">return_type</span><span class="p">:</span>
                <span class="n">return_type</span> <span class="o">=</span> <span class="n">resolve_type_annotation</span><span class="p">(</span><span class="n">decl</span><span class="o">.</span><span class="n">return_type</span><span class="p">)</span>

            <span class="n">func_type</span> <span class="o">=</span> <span class="n">FuncType</span><span class="p">(</span>
                <span class="n">param_types</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">param_types</span><span class="p">),</span>
                <span class="n">return_type</span><span class="o">=</span><span class="n">return_type</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
                <span class="n">decl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">func_type</span><span class="p">,</span>
                <span class="n">SymbolKind</span><span class="o">.</span><span class="n">FUNCTION</span><span class="p">,</span> <span class="n">initialized</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">LetStmt</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">decl</span><span class="o">.</span><span class="n">type_ann</span><span class="p">:</span>
                <span class="n">var_type</span> <span class="o">=</span> <span class="n">resolve_type_annotation</span><span class="p">(</span><span class="n">decl</span><span class="o">.</span><span class="n">type_ann</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">var_type</span> <span class="o">=</span> <span class="n">ERROR_TYPE</span>  <span class="c1"># Need initializer for inference</span>
            <span class="n">symbol_table</span><span class="o">.</span><span class="n">define</span><span class="p">(</span>
                <span class="n">decl</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">var_type</span><span class="p">,</span> <span class="n">SymbolKind</span><span class="o">.</span><span class="n">VARIABLE</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="c1"># Pass 2: Check bodies</span>
    <span class="k">for</span> <span class="n">decl</span> <span class="ow">in</span> <span class="n">declarations</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">FuncDecl</span><span class="p">)</span> <span class="ow">and</span> <span class="n">decl</span><span class="o">.</span><span class="n">body</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_function_body</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">symbol_table</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">LetStmt</span><span class="p">)</span> <span class="ow">and</span> <span class="n">decl</span><span class="o">.</span><span class="n">initializer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">check_initializer</span><span class="p">(</span><span class="n">decl</span><span class="p">,</span> <span class="n">symbol_table</span><span class="p">)</span>
</code></pre></div>

<h3 id="93-topological-sorting">9.3 ìœ„ìƒ ì •ë ¬(Topological Sorting)<a class="header-link" href="#93-topological-sorting" title="Permanent link">&para;</a></h3>
<p>ì„œë¡œ ì˜ì¡´í•˜ëŠ” ë¹„í•¨ìˆ˜ ì„ ì–¸ì˜ ê²½ìš°, ìœ„ìƒ ì •ë ¬ì€ ì„ ì–¸ì´ ì˜ì¡´ì„± ìˆœì„œë¡œ ì²˜ë¦¬ë˜ë„ë¡ ë³´ì¥í•©ë‹ˆë‹¤:</p>
<div class="highlight"><pre><span></span><code><span class="n">let</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">// depends on b</span>
<span class="n">let</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w">       </span><span class="c1">// no dependencies</span>
<span class="n">let</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">;</span><span class="w">    </span><span class="c1">// depends on a and b</span>

<span class="n">Dependency</span><span class="w"> </span><span class="nf">graph</span><span class="o">:</span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">b</span>
<span class="w">  </span><span class="n">c</span><span class="w"> </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">b</span>

<span class="n">Topological</span><span class="w"> </span><span class="n">order</span><span class="o">:</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">c</span>
</code></pre></div>

<hr />
<h2 id="10-semantic-error-reporting">10. ì˜ë¯¸ ì˜¤ë¥˜ ë³´ê³ (Semantic Error Reporting)<a class="header-link" href="#10-semantic-error-reporting" title="Permanent link">&para;</a></h2>
<h3 id="101">10.1 ì˜¤ë¥˜ ë²”ì£¼<a class="header-link" href="#101" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>ë²”ì£¼</th>
<th>ì˜ˆì‹œ</th>
<th>ì‹¬ê°ë„</th>
</tr>
</thead>
<tbody>
<tr>
<td>ì •ì˜ë˜ì§€ ì•Šì€ ì´ë¦„</td>
<td>xê°€ ì •ì˜ë˜ì§€ ì•Šì€ ìƒíƒœì—ì„œ <code>print(x)</code></td>
<td>ì˜¤ë¥˜</td>
</tr>
<tr>
<td>íƒ€ì… ë¶ˆì¼ì¹˜</td>
<td><code>"hello" + 42</code></td>
<td>ì˜¤ë¥˜</td>
</tr>
<tr>
<td>ì˜ëª»ëœ ì¸ì ìˆ˜</td>
<td><code>f(1, 2)</code> (fëŠ” 1ê°œ ì¸ìë¥¼ ë°›ìŒ)</td>
<td>ì˜¤ë¥˜</td>
</tr>
<tr>
<td>ì¤‘ë³µ ì •ì˜</td>
<td><code>let x = 1; let x = 2;</code></td>
<td>ì˜¤ë¥˜ (ë˜ëŠ” ê²½ê³ )</td>
</tr>
<tr>
<td>ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë³€ìˆ˜</td>
<td><code>let x = 5;</code> (xê°€ ì½íˆì§€ ì•ŠìŒ)</td>
<td>ê²½ê³ </td>
</tr>
<tr>
<td>ë„ë‹¬ ë¶ˆê°€ëŠ¥í•œ ì½”ë“œ</td>
<td><code>return</code> í›„ì˜ ì½”ë“œ</td>
<td>ê²½ê³ </td>
</tr>
<tr>
<td>ì•”ë¬µì  ì¶•ì†Œ</td>
<td><code>let x: int = 3.14;</code></td>
<td>ê²½ê³  (ë˜ëŠ” ì˜¤ë¥˜)</td>
</tr>
<tr>
<td>ê°€ë¦¼(Shadowing)</td>
<td>ë‚´ë¶€ <code>x</code>ê°€ ì™¸ë¶€ <code>x</code>ë¥¼ ê°€ë¦¼</td>
<td>ì •ë³´/ê²½ê³ </td>
</tr>
</tbody>
</table>
<h3 id="102-error-recovery">10.2 íƒ€ì… ê²€ì‚¬ì—ì„œì˜ ì˜¤ë¥˜ ë³µêµ¬(Error Recovery)<a class="header-link" href="#102-error-recovery" title="Permanent link">&para;</a></h3>
<p>íƒ€ì… ê²€ì‚¬ê¸°ëŠ” ì˜¤ë¥˜ í›„ì—ë„ ê³„ì† ì§„í–‰í•˜ì—¬ í•œ ë²ˆì˜ íŒ¨ìŠ¤ì—ì„œ ê°€ëŠ¥í•œ ë§ì€ ë¬¸ì œë¥¼ ë³´ê³ í•´ì•¼ í•©ë‹ˆë‹¤. í•µì‹¬ ê¸°ë²•ì€ <strong>ì˜¤ë¥˜ íƒ€ì…(error type)</strong>ì…ë‹ˆë‹¤:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># ERROR_TYPE acts as a &quot;universal&quot; type that is compatible with everything.</span>
<span class="c1"># This prevents cascading errors.</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_type_assignable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">source</span><span class="p">:</span> <span class="n">Type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">target</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span> <span class="ow">or</span> <span class="n">source</span> <span class="o">==</span> <span class="n">ERROR_TYPE</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">True</span>  <span class="c1"># Suppress cascading errors</span>
    <span class="c1"># ... normal checking</span>
</code></pre></div>

<h3 id="103">10.3 ìœ ìš©í•œ ì˜¤ë¥˜ ë©”ì‹œì§€<a class="header-link" href="#103" title="Permanent link">&para;</a></h3>
<p>ì¢‹ì€ ì»´íŒŒì¼ëŸ¬ ì˜¤ë¥˜ëŠ” ë‹¤ìŒê³¼ ê°™ì•„ì•¼ í•©ë‹ˆë‹¤:</p>
<ol>
<li><strong>ì •í™•í•¨</strong>: ë¬¸ì œì˜ ì •í™•í•œ ìœ„ì¹˜ë¥¼ ê°€ë¦¬í‚´</li>
<li><strong>ëª…í™•í•¨</strong>: ë¬´ì—‡ì´ ì˜ëª»ë˜ì—ˆëŠ”ì§€ í‰ì´í•œ ì–¸ì–´ë¡œ ì„¤ëª…í•¨</li>
<li><strong>ìœ ìš©í•¨</strong>: ë¬¸ì œë¥¼ ìˆ˜ì •í•˜ëŠ” ë°©ë²•ì„ ì œì•ˆí•¨</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">DiagnosticFormatter</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Format semantic errors with context and suggestions.&quot;&quot;&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">type_mismatch</span><span class="p">(</span>
        <span class="n">expected</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
        <span class="n">actual</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
        <span class="n">context</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">loc</span><span class="p">,</span>
        <span class="n">source_lines</span><span class="p">:</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;error: type mismatch in </span><span class="si">{</span><span class="n">context</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;  --&gt; </span><span class="si">{</span><span class="n">loc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">loc</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">loc</span><span class="o">.</span><span class="n">line</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">source_lines</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">source_lines</span><span class="p">[</span><span class="n">loc</span><span class="o">.</span><span class="n">line</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   |&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">loc</span><span class="o">.</span><span class="n">line</span><span class="si">:</span><span class="s2">&gt;3</span><span class="si">}</span><span class="s2"> | </span><span class="si">{</span><span class="n">line</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;   | </span><span class="si">{</span><span class="s1">&#39; &#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">loc</span><span class="o">.</span><span class="n">column</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="s1">&#39;~&#39;</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">loc</span><span class="o">.</span><span class="n">end_column</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">loc</span><span class="o">.</span><span class="n">column</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   = expected: </span><span class="si">{</span><span class="n">expected</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;   = found:    </span><span class="si">{</span><span class="n">actual</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Suggestions</span>
        <span class="k">if</span> <span class="n">expected</span> <span class="o">==</span> <span class="n">INT_TYPE</span> <span class="ow">and</span> <span class="n">actual</span> <span class="o">==</span> <span class="n">FLOAT_TYPE</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;   = help: use an explicit cast: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;int(value)&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">expected</span> <span class="o">==</span> <span class="n">STRING_TYPE</span> <span class="ow">and</span> <span class="n">actual</span> <span class="o">==</span> <span class="n">INT_TYPE</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;   = help: convert to string: &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;str(value)&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
</code></pre></div>

<p><strong>í˜•ì‹í™”ëœ ì˜¤ë¥˜ ì˜ˆì‹œ:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">error</span><span class="o">:</span><span class="w"> </span><span class="n">type</span><span class="w"> </span><span class="n">mismatch</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="kd">function</span><span class="w"> </span><span class="n">argument</span>
<span class="w">  </span><span class="o">--&gt;</span><span class="w"> </span><span class="n">main</span><span class="o">.</span><span class="na">lang</span><span class="o">:</span><span class="mi">15</span><span class="o">:</span><span class="mi">20</span>
<span class="w">   </span><span class="o">|</span>
<span class="w"> </span><span class="mi">15</span><span class="w"> </span><span class="o">|</span><span class="w">     </span><span class="n">let</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">add</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="s2">&quot;two&quot;</span><span class="o">);</span>
<span class="w">   </span><span class="o">|</span><span class="w">                       </span><span class="o">~~~~~</span>
<span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">expected</span><span class="o">:</span><span class="w"> </span><span class="n">int</span>
<span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">found</span><span class="o">:</span><span class="w">    </span><span class="n">string</span>
<span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="n">help</span><span class="o">:</span><span class="w"> </span><span class="n">convert</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">int</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">possible</span><span class="o">:</span><span class="w"> </span><span class="n">int</span><span class="o">(</span><span class="s2">&quot;two&quot;</span><span class="o">)</span>
</code></pre></div>

<hr />
<h2 id="11_1">11. ìš”ì•½<a class="header-link" href="#11_1" title="Permanent link">&para;</a></h2>
<p>ì˜ë¯¸ ë¶„ì„(semantic analysis)ì€ êµ¬ë¬¸ì  ì •í™•ì„±(íŒŒì‹±)ê³¼ ì˜ë¯¸ ìˆëŠ” í”„ë¡œê·¸ë¨ ë™ì‘(ì½”ë“œ ìƒì„±) ì‚¬ì´ì˜ ë‹¤ë¦¬ì…ë‹ˆë‹¤. í”„ë¡œê·¸ë¨ì´ ì˜ë¯¸ ìˆëŠ”ì§€ ê²€ì¦í•©ë‹ˆë‹¤: ì´ë¦„ì´ ì •ì˜ë˜ì–´ ìˆê³ , íƒ€ì…ì´ ì¼ê´€ë˜ë©°, ì–¸ì–´ ê·œì¹™ì„ ë”°ë¥´ëŠ”ì§€.</p>
<p><strong>í•µì‹¬ ê°œë…:</strong></p>
<table>
<thead>
<tr>
<th>ê°œë…</th>
<th>ì„¤ëª…</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ì†ì„± ë¬¸ë²•(Attribute grammars)</strong></td>
<td>ì˜ë¯¸ ì •ë³´ê°€ íŒŒìŠ¤ íŠ¸ë¦¬ì—ì„œ íë¥´ëŠ” ë°©ì‹ì„ í˜•ì‹í™”í•¨</td>
</tr>
<tr>
<td><strong>S-ì†ì„±(S-attributed)</strong></td>
<td>í•©ì„± ì†ì„±ë§Œ ì‚¬ìš©; ì•„ë˜ì—ì„œ ìœ„ë¡œ í‰ê°€</td>
</tr>
<tr>
<td><strong>L-ì†ì„±(L-attributed)</strong></td>
<td>í•©ì„± + ì™¼ìª½-ì˜¤ë¥¸ìª½ ìƒì†; ë‹¨ì¼ íŒ¨ìŠ¤ í‰ê°€</td>
</tr>
<tr>
<td><strong>ì‹¬ë²Œ í…Œì´ë¸”(Symbol table)</strong></td>
<td>ì´ë¦„ì„ íƒ€ì…, ìŠ¤ì½”í”„, ì†ì„±ì— ë§¤í•‘</td>
</tr>
<tr>
<td><strong>ìŠ¤ì½”í”„ ê´€ë¦¬(Scope management)</strong></td>
<td>ê°€ë¦¼ì´ ìˆëŠ” ì¤‘ì²© ìŠ¤ì½”í”„ë¥¼ ìœ„í•œ ì—°ì‡„ í•´ì‹œ í…Œì´ë¸”</td>
</tr>
<tr>
<td><strong>íƒ€ì… ê²€ì‚¬(Type checking)</strong></td>
<td>ì—°ì‚°ì´ í˜¸í™˜ ê°€ëŠ¥í•œ íƒ€ì…ì— ì ìš©ë˜ëŠ”ì§€ ê²€ì¦</td>
</tr>
<tr>
<td><strong>íƒ€ì… ì¶”ë¡ (Type inference)</strong></td>
<td>ì‚¬ìš©ë²•ìœ¼ë¡œë¶€í„° íƒ€ì… ì¶”ë¡  (ì§€ì—­ ì¶”ë¡  ë˜ëŠ” HM ë‹¨ì¼í™”)</td>
</tr>
<tr>
<td><strong>ê°•ì œ ë³€í™˜(Coercion)</strong></td>
<td>ì•”ë¬µì  íƒ€ì… ë³€í™˜ (ì˜ˆ: intì—ì„œ floatìœ¼ë¡œ)</td>
</tr>
<tr>
<td><strong>ì˜¤ë²„ë¡œë”©(Overloading)</strong></td>
<td>ì—¬ëŸ¬ í›„ë³´ ì¤‘ ì˜¬ë°”ë¥¸ í•¨ìˆ˜ í•´ê²°</td>
</tr>
<tr>
<td><strong>ì˜¤ë¥˜ ë³µêµ¬(Error recovery)</strong></td>
<td>ì—°ì‡„ íƒ€ì… ì˜¤ë¥˜ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•œ ERROR_TYPE ì‚¬ìš©</td>
</tr>
</tbody>
</table>
<p><strong>ì„¤ê³„ ê°€ì´ë“œë¼ì¸:</strong></p>
<ol>
<li>ì „ë°© ì°¸ì¡°ë¥¼ ìœ„í•´ 2-íŒ¨ìŠ¤ ì ‘ê·¼ ë°©ì‹ ì‚¬ìš© (ì„ ì–¸ ë“±ë¡, ê·¸ ë‹¤ìŒ ë³¸ë¬¸ ê²€ì‚¬)</li>
<li>ì—°ì‡„ ì˜¤ë¥˜ë¥¼ ì–µì œí•˜ëŠ” ì˜¤ë¥˜ íƒ€ì… ì„¤ê³„</li>
<li>ì •í™•í•œ ì˜¤ë¥˜ ë³´ê³ ë¥¼ ìœ„í•´ ì „ì²´ì ìœ¼ë¡œ ì†ŒìŠ¤ ìœ„ì¹˜ ì¶”ì </li>
<li>ë†€ë¼ì›€ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ ê°•ì œ ë³€í™˜ ê·œì¹™ì„ ëª…ì‹œì ì´ê³  ìµœì†Œí•œìœ¼ë¡œ ìœ ì§€</li>
<li>ëª…ì‹œì  íƒ€ì… ì–´ë…¸í…Œì´ì…˜ê³¼ ì§€ì—­ íƒ€ì… ì¶”ë¡  ëª¨ë‘ ì§€ì›</li>
<li>ë‹¨ì¼ íŒ¨ìŠ¤ì—ì„œ ëª¨ë“  ì˜¤ë¥˜ë¥¼ ë³´ê³  (ì²« ë²ˆì§¸ ì˜¤ë¥˜ì—ì„œ ì¤‘ë‹¨í•˜ì§€ ì•ŠìŒ)</li>
</ol>
<hr />
<h2 id="_2">ì—°ìŠµ ë¬¸ì œ<a class="header-link" href="#_2" title="Permanent link">&para;</a></h2>
<h3 id="1_1">ì—°ìŠµ 1: ì‹¬ë²Œ í…Œì´ë¸” í™•ì¥<a class="header-link" href="#1_1" title="Permanent link">&para;</a></h3>
<p><code>SymbolTable</code> í´ë˜ìŠ¤ë¥¼ í™•ì¥í•˜ì—¬ ë‹¤ìŒì„ ì¶”ì í•˜ì„¸ìš”:</p>
<ol>
<li><strong>ì‚¬ìš©ë˜ì§€ ì•ŠëŠ” ë³€ìˆ˜</strong>: íƒ€ì… ê²€ì‚¬ í›„, ì •ì˜ë˜ì—ˆì§€ë§Œ ì°¸ì¡°ë˜ì§€ ì•Šì€ ë³€ìˆ˜ë¥¼ ë³´ê³ </li>
<li><strong>ê°€ë¦¼ ê²½ê³ </strong>: ë‚´ë¶€ ìŠ¤ì½”í”„ ë³€ìˆ˜ê°€ ì™¸ë¶€ ìŠ¤ì½”í”„ ë³€ìˆ˜ë¥¼ ê°€ë¦´ ë•Œ ë³´ê³ </li>
<li><strong>ìƒìˆ˜ ì „íŒŒ</strong>: ì–´ë–¤ ë³€ìˆ˜ê°€ ì•Œë ¤ì§„ ìƒìˆ˜ì— ë°”ì¸ë”©ë˜ì–´ ìˆëŠ”ì§€ ì¶”ì </li>
</ol>
<h3 id="2">ì—°ìŠµ 2: ì™„ì „í•œ íƒ€ì… ê²€ì‚¬ê¸°<a class="header-link" href="#2" title="Permanent link">&para;</a></h3>
<p>ë‹¤ìŒ ì¶”ê°€ êµ¬ì¡°ë¥¼ ì²˜ë¦¬í•˜ë„ë¡ íƒ€ì… ê²€ì‚¬ê¸°ë¥¼ í™•ì¥í•˜ì„¸ìš”:</p>
<ol>
<li>ë°°ì—´/ë¦¬ìŠ¤íŠ¸ ì—°ì‚°: <code>append</code>, <code>pop</code>, <code>len</code></li>
<li>ë¬¸ìì—´ ì—°ì‚°: <code>+</code> (ì—°ê²°), <code>len</code>, ì¸ë±ì‹±</li>
<li>ë³µí•© í• ë‹¹: <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code></li>
<li>ì‚¼í•­ ì—°ì‚°ì: <code>cond ? then_expr : else_expr</code></li>
</ol>
<p>ê° ì—°ì‚°ì— ëŒ€í•œ ì ì ˆí•œ íƒ€ì… ê²€ì‚¬ë¥¼ ë³´ì¥í•˜ê³  ìœ íš¨í•œ í”„ë¡œê·¸ë¨ê³¼ ë¬´íš¨í•œ í”„ë¡œê·¸ë¨ ëª¨ë‘ì— ëŒ€í•œ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ë¥¼ ì‘ì„±í•˜ì„¸ìš”.</p>
<h3 id="3">ì—°ìŠµ 3: íƒ€ì… ì¶”ë¡ <a class="header-link" href="#3" title="Permanent link">&para;</a></h3>
<p>ë‹¤ìŒì„ ì²˜ë¦¬í•˜ëŠ” ì§€ì—­ íƒ€ì… ì¶”ë¡ ì„ êµ¬í˜„í•˜ì„¸ìš”:</p>
<div class="highlight"><pre><span></span><code><span class="n">let</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span><span class="w">                 </span><span class="o">//</span><span class="w"> </span><span class="n">inferred</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nc">int</span>
<span class="n">let</span><span class="w"> </span><span class="n">y</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">[</span><span class="n">1, 2, 3</span><span class="o">]</span><span class="p">;</span><span class="w">         </span><span class="o">//</span><span class="w"> </span><span class="n">inferred</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">list</span><span class="o">[</span><span class="n">int</span><span class="o">]</span>
<span class="n">let</span><span class="w"> </span><span class="n">z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">inferred</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="p">(</span><span class="nc">int</span><span class="p">)</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="nc">int</span>
<span class="n">let</span><span class="w"> </span><span class="n">w</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="k">true</span><span class="w"> </span><span class="k">then</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">inferred</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nc">int</span>
</code></pre></div>

<p>ì¶”ë¡ ì´ ì‹¤íŒ¨í•  ë•Œ ìœ ìš©í•œ ì˜¤ë¥˜ë¥¼ ìƒì„±í•´ì•¼ í•©ë‹ˆë‹¤ (ì˜ˆ: <code>let a = [];</code> -- ë¹ˆ ë¦¬ìŠ¤íŠ¸ì˜ ì›ì†Œ íƒ€ì…ì„ ì¶”ë¡ í•  ìˆ˜ ì—†ìŒ).</p>
<h3 id="4">ì—°ìŠµ 4: ì˜ë¯¸ ì˜¤ë¥˜ ì¹´íƒˆë¡œê·¸<a class="header-link" href="#4" title="Permanent link">&para;</a></h3>
<p>ìµœì†Œ 15ê°œì˜ ë‹¤ë¥¸ ì˜ë¯¸ ì˜¤ë¥˜ë¥¼ ì‹¤í–‰í•˜ëŠ” í…ŒìŠ¤íŠ¸ ìŠ¤ìœ„íŠ¸ë¥¼ ì‘ì„±í•˜ì„¸ìš”. ê° ì˜¤ë¥˜ì— ëŒ€í•´ ë‹¤ìŒì„ ì‘ì„±í•˜ì„¸ìš”:</p>
<ol>
<li>ì˜¤ë¥˜ë¥¼ ìœ ë°œí•˜ëŠ” ìµœì†Œ í”„ë¡œê·¸ë¨</li>
<li>ì˜ˆìƒ ì˜¤ë¥˜ ë©”ì‹œì§€</li>
<li>ìˆ˜ì •ëœ ë²„ì „ì˜ í”„ë¡œê·¸ë¨</li>
</ol>
<p>í¬í•¨í•  ì˜¤ë¥˜ ì˜ˆì‹œ: ì •ì˜ë˜ì§€ ì•Šì€ ë³€ìˆ˜, í• ë‹¹ì—ì„œ íƒ€ì… ë¶ˆì¼ì¹˜, ì˜ëª»ëœ ì¸ì ìˆ˜, í•¨ìˆ˜ ì™¸ë¶€ì˜ return, ë£¨í”„ ì™¸ë¶€ì˜ break, ì¤‘ë³µ í•¨ìˆ˜ ë§¤ê°œë³€ìˆ˜ ì´ë¦„, ì¬ê·€ì  íƒ€ì… ì •ì˜.</p>
<h3 id="5">ì—°ìŠµ 5: ì œë„¤ë¦­ì„ ì‚¬ìš©í•œ ì˜¤ë²„ë¡œë”©<a class="header-link" href="#5" title="Permanent link">&para;</a></h3>
<p>ë‹¨ìˆœ ì œë„¤ë¦­ì„ ì²˜ë¦¬í•˜ë„ë¡ ì˜¤ë²„ë¡œë”© í•´ê²°ì„ í™•ì¥í•˜ì„¸ìš”:</p>
<div class="highlight"><pre><span></span><code><span class="nt">fn</span><span class="w"> </span><span class="nt">identity</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">&gt;(</span><span class="nt">x</span><span class="o">:</span><span class="w"> </span><span class="nt">T</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="o">&gt;</span><span class="w"> </span><span class="nt">T</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">x</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>
<span class="nt">fn</span><span class="w"> </span><span class="nt">pair</span><span class="o">&lt;</span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">U</span><span class="o">&gt;(</span><span class="nt">a</span><span class="o">:</span><span class="w"> </span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">b</span><span class="o">:</span><span class="w"> </span><span class="nt">U</span><span class="o">)</span><span class="w"> </span><span class="nt">-</span><span class="o">&gt;</span><span class="w"> </span><span class="o">(</span><span class="nt">T</span><span class="o">,</span><span class="w"> </span><span class="nt">U</span><span class="o">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="err">(a,</span><span class="w"> </span><span class="err">b)</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="nt">identity</span><span class="o">(</span><span class="nt">5</span><span class="o">)</span><span class="w">          </span><span class="o">//</span><span class="w"> </span><span class="nt">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">int</span><span class="o">,</span><span class="w"> </span><span class="nt">returns</span><span class="w"> </span><span class="nt">int</span>
<span class="nt">identity</span><span class="o">(</span><span class="s2">&quot;hello&quot;</span><span class="o">)</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="nt">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">string</span><span class="o">,</span><span class="w"> </span><span class="nt">returns</span><span class="w"> </span><span class="nt">string</span>
<span class="nt">pair</span><span class="o">(</span><span class="nt">1</span><span class="o">,</span><span class="w"> </span><span class="s2">&quot;two&quot;</span><span class="o">)</span><span class="w">       </span><span class="o">//</span><span class="w"> </span><span class="nt">T</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">int</span><span class="o">,</span><span class="w"> </span><span class="nt">U</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">string</span><span class="o">,</span><span class="w"> </span><span class="nt">returns</span><span class="w"> </span><span class="o">(</span><span class="nt">int</span><span class="o">,</span><span class="w"> </span><span class="nt">string</span><span class="o">)</span>
</code></pre></div>

<p>ì œë„¤ë¦­ ì¸ìŠ¤í„´ìŠ¤í™” ë¡œì§ì„ êµ¬í˜„í•˜ì„¸ìš”: <code>identity(5)</code>ë¥¼ í˜¸ì¶œí•  ë•Œ <code>T = int</code>ë¥¼ ê²°ì •í•˜ê³  ë°˜í™˜ íƒ€ì…ì´ <code>int</code>ì¸ì§€ ê²€ì¦í•©ë‹ˆë‹¤.</p>
<h3 id="6-control-flow-analysis">ì—°ìŠµ 6: ì œì–´ íë¦„ ë¶„ì„(Control Flow Analysis)<a class="header-link" href="#6-control-flow-analysis" title="Permanent link">&para;</a></h3>
<p>ë‹¤ìŒì„ ê²€ì‚¬í•˜ëŠ” ì˜ë¯¸ ë¶„ì„ íŒ¨ìŠ¤ë¥¼ êµ¬í˜„í•˜ì„¸ìš”:</p>
<ol>
<li>ë¹„-void ë°˜í™˜ íƒ€ì…ì„ ê°€ì§„ ëª¨ë“  í•¨ìˆ˜ê°€ ëª¨ë“  ê²½ë¡œì—ì„œ ë°˜í™˜í•˜ëŠ”ì§€</li>
<li><code>break</code>ì™€ <code>continue</code>ê°€ ë£¨í”„ ë‚´ë¶€ì—ì„œë§Œ ë‚˜íƒ€ë‚˜ëŠ”ì§€</li>
<li><code>return</code> í›„ì˜ ì½”ë“œê°€ ë„ë‹¬ ë¶ˆê°€ëŠ¥í•œì§€ (ê²½ê³  ë°œìƒ)</li>
<li>ë³€ìˆ˜ê°€ ëª¨ë“  ê²½ë¡œì—ì„œ ì‚¬ìš© ì „ì— ì´ˆê¸°í™”ë˜ëŠ”ì§€</li>
</ol>
<p>ì´ë¥¼ ìœ„í•´ ê° í•¨ìˆ˜ì˜ ì œì–´ íë¦„ ê·¸ë˜í”„ë¥¼ ë¶„ì„í•´ì•¼ í•©ë‹ˆë‹¤. if-elseì™€ while ë£¨í”„ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë‹¨ìˆœí™”ëœ ë²„ì „ìœ¼ë¡œ ì‹œì‘í•˜ì„¸ìš”.</p>
<hr />
<p><a href="./07_Abstract_Syntax_Trees.md">ì´ì „: 07_Abstract_Syntax_Trees.md</a> | <a href="./09_Intermediate_Representations.md">ë‹¤ìŒ: 09_Intermediate_Representations.md</a> | <a href="./00_Overview.md">ê°œìš”</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Compiler_Design/07_Abstract_Syntax_Trees.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">ë ˆìŠ¨ 7: ì¶”ìƒ êµ¬ë¬¸ íŠ¸ë¦¬(Abstract Syntax Trees)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">ğŸ”—</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Compiler_Design/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">ğŸ“‹</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Compiler_Design/09_Intermediate_Representations.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">ë ˆìŠ¨ 9: ì¤‘ê°„ í‘œí˜„(Intermediate Representations)</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">â†‘</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}