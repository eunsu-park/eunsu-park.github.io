{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 06: 정규화 (1NF ~ BCNF) - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Database_Theory/">Database Theory</a>
    <span class="separator">/</span>
    <span class="current">Lesson 06: 정규화 (1NF ~ BCNF)</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 06: 정규화 (1NF ~ BCNF)</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/05_Functional_Dependencies.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 05: 함수 종속성(Functional Dependencies)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/07_Advanced_Normalization.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 07: 고급 정규화(Advanced Normalization)</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#1-introduction">1. 소개(Introduction)</a><ul>
<li><a href="#11">1.1 문제: 잘못된 스키마 설계</a></li>
<li><a href="#12-data-anomalies">1.2 데이터 이상 현상(Data Anomalies)</a><ul>
<li><a href="#update-anomaly">갱신 이상(Update Anomaly)</a></li>
<li><a href="#insertion-anomaly">삽입 이상(Insertion Anomaly)</a></li>
<li><a href="#deletion-anomaly">삭제 이상(Deletion Anomaly)</a></li>
</ul>
</li>
<li><a href="#13-fd">1.3 근본 원인: FD 위반으로 인한 중복</a></li>
<li><a href="#14">1.4 정규화의 목표</a></li>
</ul>
</li>
<li><a href="#2-1first-normal-form-1nf">2. 제1정규형(First Normal Form, 1NF)</a><ul>
<li><a href="#21">2.1 정의</a></li>
<li><a href="#22">2.2 위반과 수정</a></li>
<li><a href="#23-1nf">2.3 1NF와 관계형 모델</a></li>
</ul>
</li>
<li><a href="#3-2second-normal-form-2nf">3. 제2정규형(Second Normal Form, 2NF)</a><ul>
<li><a href="#31-partial-dependency">3.1 부분 종속성(Partial Dependency)</a></li>
<li><a href="#32">3.2 정의</a></li>
<li><a href="#33">3.3 예시</a></li>
<li><a href="#34-2nf">3.4 2NF에 대한 형식적 테스트</a></li>
</ul>
</li>
<li><a href="#4-3third-normal-form-3nf">4. 제3정규형(Third Normal Form, 3NF)</a><ul>
<li><a href="#41-transitive-dependency">4.1 전이 종속성(Transitive Dependency)</a></li>
<li><a href="#42">4.2 정의</a></li>
<li><a href="#43">4.3 예시</a></li>
<li><a href="#44">4.4 "주요 속성" 예외의 중요성</a></li>
</ul>
</li>
<li><a href="#5-boyce-codd-boyce-codd-normal-form-bcnf">5. Boyce-Codd 정규형(Boyce-Codd Normal Form, BCNF)</a><ul>
<li><a href="#51">5.1 정의</a></li>
<li><a href="#52-3nf-vs-bcnf">5.2 관계: 3NF vs BCNF</a></li>
<li><a href="#53-3nf-bcnf">5.3 예시: 3NF이지만 BCNF가 아님</a></li>
<li><a href="#54-3nf-bcnf">5.4 3NF와 BCNF가 다를 때</a></li>
</ul>
</li>
<li><a href="#6-decomposition-properties">6. 분해 속성(Decomposition Properties)</a><ul>
<li><a href="#61-lossless-join-property">6.1 무손실 조인 속성(Lossless-Join Property)</a><ul>
<li><a href="#_1">이진 분해 테스트</a></li>
<li><a href="#_2">예시</a></li>
<li><a href="#_3">무손실 조인이 중요한 이유</a></li>
</ul>
</li>
<li><a href="#62-dependency-preservation">6.2 종속성 보존(Dependency Preservation)</a><ul>
<li><a href="#_4">종속성 보존이 중요한 이유</a></li>
<li><a href="#_5">예시</a></li>
</ul>
</li>
<li><a href="#63">6.3 둘 다 가질 수 있는가?</a></li>
</ul>
</li>
<li><a href="#7-n-">7. 무손실 조인 테스트 알고리즘 (n-원 분해용)</a><ul>
<li><a href="#71-chase-test">7.1 알고리즘 (체이스 테스트, Chase Test)</a></li>
<li><a href="#72">7.2 작업 예제</a></li>
</ul>
</li>
<li><a href="#8-3nf">8. 3NF 합성 알고리즘</a><ul>
<li><a href="#81">8.1 알고리즘</a></li>
<li><a href="#82">8.2 각 단계가 중요한 이유</a></li>
<li><a href="#83">8.3 작업 예제</a></li>
</ul>
</li>
<li><a href="#9-bcnf">9. BCNF 분해 알고리즘</a><ul>
<li><a href="#91">9.1 알고리즘</a></li>
<li><a href="#92">9.2 작업 예제</a></li>
<li><a href="#93-bcnf-vs-3nf">9.3 BCNF vs 3NF: 트레이드오프</a></li>
</ul>
</li>
<li><a href="#10-bcnf">10. 완전한 작업 예제: 비정규화에서 BCNF까지</a><ul>
<li><a href="#101">10.1 시나리오</a></li>
<li><a href="#102-1nf">10.2 1NF 확인</a></li>
<li><a href="#103-2nf">10.3 2NF 확인</a></li>
<li><a href="#104-3nf">10.4 3NF 확인</a></li>
<li><a href="#105-bcnf">10.5 BCNF 확인</a></li>
<li><a href="#106">10.6 분해 요약</a></li>
</ul>
</li>
<li><a href="#11-sql">11. SQL에서의 정규화</a><ul>
<li><a href="#111">11.1 정규화된 스키마 구현</a></li>
<li><a href="#112">11.2 쿼리를 통한 정규화 검증</a></li>
</ul>
</li>
<li><a href="#12">12. 정규형 요약</a><ul>
<li><a href="#_6">의사결정 흐름도</a></li>
</ul>
</li>
<li><a href="#13-exercises">13. 연습 문제(Exercises)</a><ul>
<li><a href="#1">연습 문제 1: 정규형 식별</a></li>
<li><a href="#2-3nf">연습 문제 2: 3NF 합성</a></li>
<li><a href="#3-bcnf">연습 문제 3: BCNF 분해</a></li>
<li><a href="#4-lossless-join">연습 문제 4: 무손실 조인(Lossless-Join) 검증</a></li>
<li><a href="#5-full-normalization">연습 문제 5: 완전 정규화(Full Normalization)</a></li>
<li><a href="#6-anomaly">연습 문제 6: 이상(Anomaly) 식별</a></li>
</ul>
</li>
<li><a href="#14-summary">14. 요약(Summary)</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-06-1nf-bcnf">Lesson 06: 정규화 (1NF ~ BCNF)<a class="header-link" href="#lesson-06-1nf-bcnf" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./05_Functional_Dependencies.md">05_Functional_Dependencies.md</a> | <strong>다음</strong>: <a href="./07_Advanced_Normalization.md">07_Advanced_Normalization.md</a></p>
<hr />
<blockquote>
<p><strong>주제</strong>: 데이터베이스 이론(Database Theory)
<strong>레슨</strong>: 16개 중 6번째
<strong>선수 지식</strong>: 함수 종속성, 속성 폐쇄, 최소 커버 (Lesson 05)
<strong>목표</strong>: 1NF부터 BCNF까지의 정규화 이해, 분해 알고리즘 마스터, 무손실 조인과 종속성 보존 속성 검증, 실제 스키마에 정규화 적용</p>
</blockquote>
<h2 id="1-introduction">1. 소개(Introduction)<a class="header-link" href="#1-introduction" title="Permanent link">&para;</a></h2>
<p>정규화(Normalization)는 관계형 데이터베이스 스키마를 중복을 줄이고 특정 유형의 데이터 이상 현상을 제거하기 위해 조직하는 과정입니다. Edgar F. Codd가 1970년에 도입한 이 방법은 스키마 설계에 대한 체계적이고 이론 기반의 접근 방식을 제공합니다.</p>
<h3 id="11">1.1 문제: 잘못된 스키마 설계<a class="header-link" href="#11" title="Permanent link">&para;</a></h3>
<p>대학을 위한 단일 릴레이션 설계를 고려해보세요:</p>
<div class="highlight"><pre><span></span><code><span class="nx">UniversityCourse</span><span class="p">(</span>
<span class="w">    </span><span class="nx">student_id</span><span class="p">,</span><span class="w"> </span><span class="nx">student_name</span><span class="p">,</span><span class="w"> </span><span class="nx">student_addr</span><span class="p">,</span>
<span class="w">    </span><span class="nx">course_id</span><span class="p">,</span><span class="w"> </span><span class="nx">course_title</span><span class="p">,</span><span class="w"> </span><span class="nx">dept_name</span><span class="p">,</span><span class="w"> </span><span class="nx">dept_building</span><span class="p">,</span>
<span class="w">    </span><span class="nx">instructor_id</span><span class="p">,</span><span class="w"> </span><span class="nx">instructor_name</span><span class="p">,</span>
<span class="w">    </span><span class="nx">grade</span><span class="p">,</span><span class="w"> </span><span class="nx">semester</span>
<span class="p">)</span>
</code></pre></div>

<p>이 "범용 릴레이션"은 모든 것을 하나의 테이블에 저장합니다. 간단한 쿼리에는 작동하지만 심각한 문제를 겪습니다.</p>
<h3 id="12-data-anomalies">1.2 데이터 이상 현상(Data Anomalies)<a class="header-link" href="#12-data-anomalies" title="Permanent link">&para;</a></h3>
<h4 id="update-anomaly">갱신 이상(Update Anomaly)<a class="header-link" href="#update-anomaly" title="Permanent link">&para;</a></h4>
<p>컴퓨터 과학부가 새 건물로 이사하면, <code>dept_name = 'Computer Science'</code>인 <strong>모든 행</strong>에서 <code>dept_building</code>을 업데이트해야 합니다. 단 하나의 행이라도 놓치면 데이터가 불일치해집니다.</p>
<div class="highlight"><pre><span></span><code>변경 전:
| course_id | dept_name | dept_building |
|-----------|-----------|---------------|
| CS101     | CS        | Watson Hall   |
| CS201     | CS        | Watson Hall   |    ← 모든 행을 업데이트해야 함
| CS301     | CS        | Watson Hall   |

첫 번째 행만 업데이트하면:
| CS101     | CS        | Taylor Hall   |    ← 업데이트됨
| CS201     | CS        | Watson Hall   |    ← 불일치!
| CS301     | CS        | Watson Hall   |    ← 불일치!
</code></pre></div>

<h4 id="insertion-anomaly">삽입 이상(Insertion Anomaly)<a class="header-link" href="#insertion-anomaly" title="Permanent link">&para;</a></h4>
<p>학생이 그 부서의 과목 중 하나에 등록하지 않는 한, 새 부서(예: 이름과 건물)를 기록할 수 없습니다. <code>student_id</code>가 기본 키의 일부이기 때문입니다.</p>
<h4 id="deletion-anomaly">삭제 이상(Deletion Anomaly)<a class="header-link" href="#deletion-anomaly" title="Permanent link">&para;</a></h4>
<p>과목에 등록한 마지막 학생이 탈퇴하면, 등록 데이터뿐만 아니라 과목 제목, 강사 배정, 부서 정보도 잃게 됩니다.</p>
<h3 id="13-fd">1.3 근본 원인: FD 위반으로 인한 중복<a class="header-link" href="#13-fd" title="Permanent link">&para;</a></h3>
<p>세 가지 이상 현상은 모두 동일한 근본 원인에서 비롯됩니다: <strong>키의 일부에만 의존하거나 비키 속성에 의존하는 속성이 중복되어 저장됩니다</strong>. 정규화는 함수 종속성에 의해 안내되는 체계적인 분해를 통해 이러한 중복을 제거합니다.</p>
<h3 id="14">1.4 정규화의 목표<a class="header-link" href="#14" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>중복 제거</strong>: 각 사실은 정확히 한 번만 저장됩니다</li>
<li><strong>이상 방지</strong>: 업데이트, 삽입, 삭제가 깔끔합니다</li>
<li><strong>정보 보존</strong>: 분해 중에 데이터가 손실되지 않습니다(무손실 조인)</li>
<li><strong>제약 조건 보존</strong>: FD가 여전히 강제 가능합니다(종속성 보존)</li>
</ol>
<hr />
<h2 id="2-1first-normal-form-1nf">2. 제1정규형(First Normal Form, 1NF)<a class="header-link" href="#2-1first-normal-form-1nf" title="Permanent link">&para;</a></h2>
<h3 id="21">2.1 정의<a class="header-link" href="#21" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: 릴레이션이 다음을 만족하면 <strong>제1정규형(1NF)</strong>에 있습니다:
1. 모든 속성이 <strong>원자적(atomic)</strong> (분할 불가능한) 값만 포함
2. <strong>반복 그룹</strong>이나 배열이 없음
3. 각 행이 고유하게 식별 가능 (기본 키 있음)</p>
</blockquote>
<p>1NF는 관계형 모델에서 유효한 릴레이션이 되기 위한 기본 요구사항입니다.</p>
<h3 id="22">2.2 위반과 수정<a class="header-link" href="#22" title="Permanent link">&para;</a></h3>
<p><strong>위반 1: 비원자적 값</strong></p>
<div class="highlight"><pre><span></span><code>| student_id | name       | phone_numbers          |
|------------|------------|------------------------|
| 101        | Alice      | 555-1234, 555-5678     |    ← 다중값!
| 102        | Bob        | 555-9999               |
</code></pre></div>

<p><strong>수정</strong>: 각 전화번호에 대해 별도의 행을 만들거나 별도의 테이블 생성:</p>
<div class="highlight"><pre><span></span><code>Student(student_id, name)
StudentPhone(student_id, phone_number)

| student_id | phone_number |
|------------|--------------|
| 101        | 555-1234     |
| 101        | 555-5678     |
| 102        | 555-9999     |
</code></pre></div>

<p><strong>위반 2: 반복 그룹</strong></p>
<div class="highlight"><pre><span></span><code>| order_id | item1  | qty1 | item2  | qty2 | item3  | qty3 |
|----------|--------|------|--------|------|--------|------|
| 1001     | Pen    | 5    | Paper  | 10   | NULL   | NULL |
</code></pre></div>

<p><strong>수정</strong>: 두 테이블로 정규화:</p>
<div class="highlight"><pre><span></span><code>Order(order_id, order_date, customer_id)
OrderItem(order_id, item_name, quantity)
</code></pre></div>

<h3 id="23-1nf">2.3 1NF와 관계형 모델<a class="header-link" href="#23-1nf" title="Permanent link">&para;</a></h3>
<p>엄격한 관계형 이론에서 릴레이션은 정의상 1NF에 있습니다 — 관계형 모델은 비원자적 도메인을 허용하지 않습니다. 그러나 실제로 많은 시스템이 배열(PostgreSQL <code>int[]</code>), JSON 컬럼, 쉼표로 구분된 값을 허용합니다. 성능에는 유용할 수 있지만 이들은 1NF의 정신을 위반하고 FD 기반 추론을 어렵게 만듭니다.</p>
<hr />
<h2 id="3-2second-normal-form-2nf">3. 제2정규형(Second Normal Form, 2NF)<a class="header-link" href="#3-2second-normal-form-2nf" title="Permanent link">&para;</a></h2>
<h3 id="31-partial-dependency">3.1 부분 종속성(Partial Dependency)<a class="header-link" href="#31-partial-dependency" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: <strong>부분 종속성</strong>은 비주요 속성(어떤 후보 키의 일부가 아닌 속성)이 후보 키의 <strong>진부분집합</strong>에 함수적으로 종속될 때 존재합니다.</p>
</blockquote>
<p>즉, 어떤 속성이 키 전체가 아닌 키의 <em>일부</em>에만 의존합니다.</p>
<h3 id="32">3.2 정의<a class="header-link" href="#32" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: 릴레이션이 다음을 만족하면 <strong>제2정규형(2NF)</strong>에 있습니다:
1. 1NF에 있고,
2. 모든 비주요 속성이 모든 후보 키에 <strong>완전 함수적으로 종속</strong> (부분 종속성 없음)</p>
</blockquote>
<p>참고: 2NF는 후보 키가 복합(하나 이상의 속성을 가짐)일 때만 관련이 있습니다. 모든 후보 키가 단일 속성이면 릴레이션은 자동으로 2NF에 있습니다.</p>
<h3 id="33">3.3 예시<a class="header-link" href="#33" title="Permanent link">&para;</a></h3>
<p>다음을 고려하세요:</p>
<div class="highlight"><pre><span></span><code>StudentCourse(student_id, course_id, student_name, grade)
</code></pre></div>

<p>후보 키: {student_id, course_id}</p>
<p>FD:
- {student_id, course_id} → grade (완전 종속성)
- student_id → student_name (부분 종속성! student_name은 키의 일부에만 의존)</p>
<p>이것은 2NF를 위반합니다.</p>
<p><strong>2NF를 달성하기 위한 분해:</strong></p>
<div class="highlight"><pre><span></span><code>Student(student_id, student_name)
    키: {student_id}
    FD: student_id → student_name

Enrollment(student_id, course_id, grade)
    키: {student_id, course_id}
    FD: {student_id, course_id} → grade
</code></pre></div>

<h3 id="34-2nf">3.4 2NF에 대한 형식적 테스트<a class="header-link" href="#34-2nf" title="Permanent link">&para;</a></h3>
<p>각 후보 키 K와 각 비주요 속성 A에 대해:
1. X ⊂ K인 진부분집합 X가 존재하여 X → A인지 확인
2. 그러한 부분 종속성이 존재하면 릴레이션은 2NF에 없음</p>
<hr />
<h2 id="4-3third-normal-form-3nf">4. 제3정규형(Third Normal Form, 3NF)<a class="header-link" href="#4-3third-normal-form-3nf" title="Permanent link">&para;</a></h2>
<h3 id="41-transitive-dependency">4.1 전이 종속성(Transitive Dependency)<a class="header-link" href="#41-transitive-dependency" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: <strong>전이 종속성</strong>은 비주요 속성 A가 다른 비주요 속성 B에 의존하고, B는 후보 키 K에 의존할 때 존재합니다:</p>
<p>K → B → A, 여기서 B는 슈퍼키가 아니고 A는 어떤 후보 키의 일부가 아닙니다.</p>
</blockquote>
<h3 id="42">4.2 정의<a class="header-link" href="#42" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: 릴레이션 스키마 R이 A가 단일 속성인 모든 비자명한 함수 종속성 X → A에 대해 다음을 만족하면 <strong>제3정규형(3NF)</strong>에 있습니다:
1. X가 R의 슈퍼키, <strong>또는</strong>
2. A가 <strong>주요 속성</strong>(어떤 후보 키의 멤버)</p>
</blockquote>
<p>동등하게: 어떤 비주요 속성도 어떤 후보 키에 전이적으로 종속되지 않습니다.</p>
<h3 id="43">4.3 예시<a class="header-link" href="#43" title="Permanent link">&para;</a></h3>
<p>다음을 고려하세요:</p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, dept_id, dept_name, dept_location)
</code></pre></div>

<p>후보 키: {emp_id}</p>
<p>FD:
- emp_id → dept_id, dept_name, dept_location
- dept_id → dept_name, dept_location</p>
<p>종속성 emp_id → dept_name은 dept_id를 통해 전이적입니다:
- emp_id → dept_id → dept_name</p>
<p>이것은 3NF를 위반합니다. dept_name이 dept_id(비슈퍼키)에 의존하고 dept_name이 주요 속성이 아니기 때문입니다.</p>
<p><strong>3NF를 달성하기 위한 분해:</strong></p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, dept_id)
    키: {emp_id}
    FD: emp_id → dept_id

Department(dept_id, dept_name, dept_location)
    키: {dept_id}
    FD: dept_id → dept_name, dept_location
</code></pre></div>

<h3 id="44">4.4 "주요 속성" 예외의 중요성<a class="header-link" href="#44" title="Permanent link">&para;</a></h3>
<p>3NF의 "A가 주요 속성"이라는 조건은 BCNF와 구별되는 것입니다. 이 예외는 결정자가 슈퍼키가 아니더라도 종속자가 후보 키의 일부인 특정 FD를 허용합니다. 이 예외가 3NF 분해를 항상 종속성 보존으로 만드는 것입니다(BCNF와는 달리).</p>
<hr />
<h2 id="5-boyce-codd-boyce-codd-normal-form-bcnf">5. Boyce-Codd 정규형(Boyce-Codd Normal Form, BCNF)<a class="header-link" href="#5-boyce-codd-boyce-codd-normal-form-bcnf" title="Permanent link">&para;</a></h2>
<h3 id="51">5.1 정의<a class="header-link" href="#51" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: 릴레이션 스키마 R이 모든 비자명한 함수 종속성 X → Y에 대해 다음을 만족하면 <strong>Boyce-Codd 정규형(BCNF)</strong>에 있습니다:</p>
<p>X가 R의 슈퍼키입니다.</p>
</blockquote>
<p>BCNF는 3NF보다 엄격하게 강합니다. "주요 속성" 예외를 제거합니다: <strong>모든</strong> 결정자가 슈퍼키여야 합니다. 마침표.</p>
<h3 id="52-3nf-vs-bcnf">5.2 관계: 3NF vs BCNF<a class="header-link" href="#52-3nf-vs-bcnf" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>BCNF ⊂ 3NF ⊂ 2NF ⊂ 1NF

모든 BCNF 릴레이션은 3NF에 있습니다.
모든 3NF 릴레이션은 2NF에 있습니다.
모든 2NF 릴레이션은 1NF에 있습니다.

하지만 그 역은 아닙니다.
</code></pre></div>

<h3 id="53-3nf-bcnf">5.3 예시: 3NF이지만 BCNF가 아님<a class="header-link" href="#53-3nf-bcnf" title="Permanent link">&para;</a></h3>
<p>다음을 고려하세요:</p>
<div class="highlight"><pre><span></span><code>TeachingAssignment(student_id, course, instructor)
</code></pre></div>

<p>비즈니스 규칙:
- 각 강사는 정확히 하나의 과목을 가르침: instructor → course
- 각 학생은 과목당 정확히 한 명의 강사를 가짐: {student_id, course} → instructor
- 학생은 주어진 과목에 대해 한 명의 강사만 가질 수 있음</p>
<p>후보 키: {student_id, course}와 {student_id, instructor}</p>
<p>FD:
- {student_id, course} → instructor
- {student_id, instructor} → course
- instructor → course</p>
<p>instructor → course에 대한 3NF 확인:
- instructor는 슈퍼키가 아님 ✗
- course는 주요 속성(후보 키 {student_id, course}의 일부) ✓</p>
<p>따라서 릴레이션은 <strong>3NF</strong>에 있습니다(3NF 정의의 조건 2가 만족됨).</p>
<p>instructor → course에 대한 BCNF 확인:
- instructor는 슈퍼키가 아님 ✗</p>
<p>따라서 릴레이션은 <strong>BCNF에 없습니다</strong>.</p>
<h3 id="54-3nf-bcnf">5.4 3NF와 BCNF가 다를 때<a class="header-link" href="#54-3nf-bcnf" title="Permanent link">&para;</a></h3>
<p>3NF와 BCNF는 다음의 경우에만 다릅니다:
1. 여러 개의 중첩된 후보 키가 있고,
2. 비슈퍼키 속성이 후보 키의 일부를 결정함</p>
<p>실제로 이 상황은 상대적으로 드뭅니다. 3NF에 있는 대부분의 릴레이션은 BCNF에도 있습니다.</p>
<hr />
<h2 id="6-decomposition-properties">6. 분해 속성(Decomposition Properties)<a class="header-link" href="#6-decomposition-properties" title="Permanent link">&para;</a></h2>
<p>릴레이션을 더 높은 정규형을 달성하기 위해 분해할 때, 분해가 "좋은"지 확인해야 합니다. 두 가지 중요한 속성이 "좋음"의 의미를 정의합니다.</p>
<h3 id="61-lossless-join-property">6.1 무손실 조인 속성(Lossless-Join Property)<a class="header-link" href="#61-lossless-join-property" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: R을 R₁, R₂, ..., Rₙ으로 분해할 때 R의 모든 합법적 인스턴스 r에 대해 다음을 만족하면 <strong>무손실 조인 속성</strong>을 가집니다:</p>
<p>r = π_{R₁}(r) ⋈ π_{R₂}(r) ⋈ ... ⋈ π_{Rₙ}(r)</p>
</blockquote>
<p>즉, 분해된 릴레이션을 자연 조인하여 원래 릴레이션을 재구성할 수 있습니다. 정보가 손실되지 않습니다.</p>
<h4 id="_1">이진 분해 테스트<a class="header-link" href="#_1" title="Permanent link">&para;</a></h4>
<p>R을 R₁과 R₂로 분해하는 경우:</p>
<blockquote>
<p><strong>정리</strong>: 분해가 무손실 조인이 되려면 다음 중 하나가 만족되어야 합니다:</p>
<p>(R₁ ∩ R₂) → (R₁ - R₂) ∈ F⁺, 또는
(R₁ ∩ R₂) → (R₂ - R₁) ∈ F⁺</p>
</blockquote>
<p>공통 속성이 한 쪽의 모든 속성을 함수적으로 결정해야 합니다. 동등하게, 공통 속성이 분해된 릴레이션 중 적어도 하나의 슈퍼키여야 합니다.</p>
<h4 id="_2">예시<a class="header-link" href="#_2" title="Permanent link">&para;</a></h4>
<p>Employee(emp_id, dept_id, dept_name)을 다음과 같이 분해:
- R₁(emp_id, dept_id)와 R₂(dept_id, dept_name)</p>
<p>공통 속성: {dept_id}
R₂ - R₁ = {dept_name}</p>
<p>dept_id → dept_name이 F⁺에 있는가? 예!</p>
<p>따라서 이 분해는 무손실 조인입니다. ✓</p>
<h4 id="_3">무손실 조인이 중요한 이유<a class="header-link" href="#_3" title="Permanent link">&para;</a></h4>
<p>무손실 조인 속성이 없으면 분해된 테이블을 조인할 때 <strong>허위 튜플(spurious tuples)</strong> — 원래 릴레이션에 존재하지 않았던 행 — 이 생성됩니다:</p>
<div class="highlight"><pre><span></span><code>원본:
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |
| 4 | 2 | 5 |

R1(A,B)와 R2(B,C)로 분해:
R1:          R2:
| A | B |    | B | C |
|---|---|    |---|---|
| 1 | 2 |    | 2 | 3 |
| 4 | 2 |    | 2 | 5 |

R1 ⋈ R2:
| A | B | C |
|---|---|---|
| 1 | 2 | 3 |    ← 원본 ✓
| 1 | 2 | 5 |    ← 허위! ✗
| 4 | 2 | 3 |    ← 허위! ✗
| 4 | 2 | 5 |    ← 원본 ✓
</code></pre></div>

<p>여기서 B는 A나 C를 결정하지 않으므로 분해는 손실(무손실이 아님)입니다.</p>
<h3 id="62-dependency-preservation">6.2 종속성 보존(Dependency Preservation)<a class="header-link" href="#62-dependency-preservation" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: R을 R₁, R₂, ..., Rₙ으로 분해할 때 다음을 만족하면 <strong>종속성 보존</strong>입니다:</p>
<p>(F₁ ∪ F₂ ∪ ... ∪ Fₙ)⁺ = F⁺</p>
<p>여기서 Fᵢ는 Rᵢ의 속성만 포함하는 F⁺의 FD 집합입니다.</p>
</blockquote>
<p>더 간단하게: 원래 F의 모든 FD를 테이블 조인 없이 개별 분해된 릴레이션 내의 제약 조건을 확인하여 검증할 수 있습니다.</p>
<h4 id="_4">종속성 보존이 중요한 이유<a class="header-link" href="#_4" title="Permanent link">&para;</a></h4>
<p>분해가 종속성 보존이 아니면 일부 FD는 여러 테이블을 조인해야만 강제할 수 있습니다 — 이것은 비용이 많이 들고 종종 비실용적입니다. 종속성 보존이 없으면 DBMS는 데이터 무결성을 효율적으로 유지할 수 없습니다.</p>
<h4 id="_5">예시<a class="header-link" href="#_5" title="Permanent link">&para;</a></h4>
<p>R(A, B, C)에 F = { A → B, B → C }가 있음</p>
<p>R₁(A, C)와 R₂(B, C)로 분해.</p>
<p>R₁의 FD: A → B를 강제할 수 있는가? 아니오 — B가 R₁에 없음.
R₂의 FD: A → B를 강제할 수 있는가? 아니오 — A가 R₂에 없음.</p>
<p>FD A → B가 <strong>보존되지 않습니다</strong>. 이를 확인하려면 R₁과 R₂를 조인해야 합니다.</p>
<p>더 나은 분해: R₁(A, B)와 R₂(B, C) — 이것은 A → B와 B → C 모두 보존합니다.</p>
<h3 id="63">6.3 둘 다 가질 수 있는가?<a class="header-link" href="#63" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>정규형</th>
<th style="text-align: center;">무손실 조인</th>
<th style="text-align: center;">종속성 보존</th>
</tr>
</thead>
<tbody>
<tr>
<td>3NF</td>
<td style="text-align: center;">항상 달성 가능 ✓</td>
<td style="text-align: center;">항상 달성 가능 ✓</td>
</tr>
<tr>
<td>BCNF</td>
<td style="text-align: center;">항상 달성 가능 ✓</td>
<td style="text-align: center;"><strong>항상은 아님</strong> ✗</td>
</tr>
</tbody>
</table>
<p>이것이 핵심 트레이드오프입니다: BCNF는 더 엄격한 정규형이지만 달성하면 종속성 보존을 희생할 수 있습니다. 3NF는 두 속성을 모두 보장합니다.</p>
<hr />
<h2 id="7-n-">7. 무손실 조인 테스트 알고리즘 (n-원 분해용)<a class="header-link" href="#7-n-" title="Permanent link">&para;</a></h2>
<p>두 개 이상의 릴레이션으로 분해하는 경우 테이블 알고리즘을 사용합니다.</p>
<h3 id="71-chase-test">7.1 알고리즘 (체이스 테스트, Chase Test)<a class="header-link" href="#71-chase-test" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="nl">ALGORITHM</span><span class="p">:</span><span class="w"> </span><span class="n">LosslessJoinTest</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="w"> </span><span class="n">F</span><span class="p">,</span><span class="w"> </span><span class="err">{</span><span class="n">R₁</span><span class="p">,</span><span class="w"> </span><span class="n">R₂</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">Rₙ</span><span class="err">}</span><span class="p">)</span>
<span class="k">INPUT</span><span class="err">:</span><span class="w">  </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">{</span><span class="n">A₁</span><span class="p">,</span><span class="w"> </span><span class="n">A₂</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">Aₘ</span><span class="err">}</span><span class="w"> </span><span class="p">(</span><span class="n">m개</span><span class="w"> </span><span class="n">속성</span><span class="p">)</span>
<span class="w">        </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="n">집합</span>
<span class="w">        </span><span class="err">{</span><span class="n">R₁</span><span class="p">,</span><span class="w"> </span><span class="n">R₂</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">Rₙ</span><span class="err">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">분해</span>
<span class="k">OUTPUT</span><span class="err">:</span><span class="w"> </span><span class="n">무손실</span><span class="w"> </span><span class="n">조인이면</span><span class="w"> </span><span class="k">TRUE</span><span class="p">,</span><span class="w"> </span><span class="n">아니면</span><span class="w"> </span><span class="k">FALSE</span>

<span class="n">단계</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">m</span><span class="w"> </span><span class="n">행렬</span><span class="w"> </span><span class="n">생성</span><span class="p">.</span>
<span class="w">        </span><span class="n">행</span><span class="w"> </span><span class="n">i는</span><span class="w"> </span><span class="n">Rᵢ에</span><span class="w"> </span><span class="n">대응</span><span class="p">,</span><span class="w"> </span><span class="n">열</span><span class="w"> </span><span class="n">j는</span><span class="w"> </span><span class="n">속성</span><span class="w"> </span><span class="n">Aⱼ에</span><span class="w"> </span><span class="n">대응</span><span class="p">.</span>

<span class="n">단계</span><span class="w"> </span><span class="mi">2</span><span class="err">:</span><span class="w"> </span><span class="n">행렬</span><span class="w"> </span><span class="nl">초기화</span><span class="p">:</span>
<span class="w">        </span><span class="n">Aⱼ</span><span class="w"> </span><span class="err">∈</span><span class="w"> </span><span class="n">Rᵢ이면</span><span class="w"> </span><span class="n">entry</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">aⱼ</span><span class="w"> </span><span class="p">(</span><span class="n">구별</span><span class="w"> </span><span class="n">기호</span><span class="p">)</span>
<span class="w">        </span><span class="n">아니면</span><span class="w"> </span><span class="n">entry</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="n">j</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bᵢⱼ</span><span class="w"> </span><span class="p">(</span><span class="n">첨자</span><span class="w"> </span><span class="n">기호</span><span class="p">)</span>

<span class="n">단계</span><span class="w"> </span><span class="mi">3</span><span class="err">:</span><span class="w"> </span><span class="n">REPEAT</span>
<span class="w">            </span><span class="k">FOR</span><span class="w"> </span><span class="k">EACH</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="p">(</span><span class="n">X</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">Y</span><span class="p">)</span><span class="w"> </span><span class="ow">IN</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="n">DO</span>
<span class="w">                </span><span class="n">X의</span><span class="w"> </span><span class="n">모든</span><span class="w"> </span><span class="n">열에서</span><span class="w"> </span><span class="n">일치하는</span><span class="w"> </span><span class="n">모든</span><span class="w"> </span><span class="n">행</span><span class="w"> </span><span class="n">찾기</span>
<span class="w">                </span><span class="n">그러한</span><span class="w"> </span><span class="n">행들에</span><span class="w"> </span><span class="n">대해</span><span class="w"> </span><span class="n">Y</span><span class="o">-</span><span class="n">열을</span><span class="w"> </span><span class="n">동일하게</span><span class="w"> </span><span class="nl">만들기</span><span class="p">:</span>
<span class="w">                    </span><span class="n">Y의</span><span class="w"> </span><span class="n">어떤</span><span class="w"> </span><span class="n">열에</span><span class="w"> </span><span class="n">대해</span><span class="w"> </span><span class="n">어떤</span><span class="w"> </span><span class="n">행이</span><span class="w"> </span><span class="n">aⱼ를</span><span class="w"> </span><span class="n">가지면</span><span class="w"> </span><span class="n">모든</span><span class="w"> </span><span class="n">일치하는</span><span class="w"> </span><span class="n">행을</span><span class="w"> </span><span class="n">aⱼ로</span><span class="w"> </span><span class="n">설정</span>
<span class="w">                    </span><span class="n">아니면</span><span class="w"> </span><span class="n">하나의</span><span class="w"> </span><span class="n">bᵢⱼ를</span><span class="w"> </span><span class="n">선택하고</span><span class="w"> </span><span class="n">모든</span><span class="w"> </span><span class="n">일치하는</span><span class="w"> </span><span class="n">행을</span><span class="w"> </span><span class="n">그</span><span class="w"> </span><span class="n">값으로</span><span class="w"> </span><span class="n">설정</span>
<span class="w">            </span><span class="k">END</span><span class="w"> </span><span class="k">FOR</span>
<span class="w">        </span><span class="n">UNTIL</span><span class="w"> </span><span class="n">변경</span><span class="w"> </span><span class="n">발생하지</span><span class="w"> </span><span class="n">않음</span>

<span class="n">단계</span><span class="w"> </span><span class="mi">4</span><span class="err">:</span><span class="w"> </span><span class="n">어떤</span><span class="w"> </span><span class="n">행이</span><span class="w"> </span><span class="n">모든</span><span class="w"> </span><span class="n">구별</span><span class="w"> </span><span class="n">기호를</span><span class="w"> </span><span class="n">가지면</span><span class="w"> </span><span class="p">(</span><span class="n">a₁</span><span class="p">,</span><span class="w"> </span><span class="n">a₂</span><span class="p">,</span><span class="w"> </span><span class="p">...,</span><span class="w"> </span><span class="n">aₘ</span><span class="p">),</span><span class="w"> </span><span class="k">TRUE</span><span class="w"> </span><span class="n">반환</span><span class="p">.</span>
<span class="w">        </span><span class="n">아니면</span><span class="w"> </span><span class="k">FALSE</span><span class="w"> </span><span class="n">반환</span><span class="p">.</span>
</code></pre></div>

<h3 id="72">7.2 작업 예제<a class="header-link" href="#72" title="Permanent link">&para;</a></h3>
<p>R(A, B, C, D, E), F = { A → C, B → C, C → D, DE → C, CE → A }</p>
<p>분해: R₁(A, D), R₂(A, B), R₃(B, E), R₄(C, D, E), R₅(A, E)</p>
<p><strong>단계 1-2: 초기 행렬</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>R₁</td>
<td>a₁</td>
<td>b₁₂</td>
<td>b₁₃</td>
<td>a₄</td>
<td>b₁₅</td>
</tr>
<tr>
<td>R₂</td>
<td>a₁</td>
<td>a₂</td>
<td>b₂₃</td>
<td>b₂₄</td>
<td>b₂₅</td>
</tr>
<tr>
<td>R₃</td>
<td>b₃₁</td>
<td>a₂</td>
<td>b₃₃</td>
<td>b₃₄</td>
<td>a₅</td>
</tr>
<tr>
<td>R₄</td>
<td>b₄₁</td>
<td>b₄₂</td>
<td>a₃</td>
<td>a₄</td>
<td>a₅</td>
</tr>
<tr>
<td>R₅</td>
<td>a₁</td>
<td>b₅₂</td>
<td>b₅₃</td>
<td>b₅₄</td>
<td>a₅</td>
</tr>
</tbody>
</table>
<p><strong>단계 3: FD를 반복적으로 적용</strong></p>
<p>A → C 적용: 동일한 A 값을 가진 행.
- R₁, R₂, R₅ 행이 A = a₁을 가짐. C 열을 동일하게 만들기.
  - R₁: b₁₃, R₂: b₂₃, R₅: b₅₃. 구별 기호 없음. 모두에 대해 b₁₃ 선택.
  - R₁: b₁₃, R₂: b₁₃, R₅: b₁₃</p>
<p>B → C 적용: R₂, R₃ 행이 B = a₂를 가짐.
- R₂: b₁₃, R₃: b₃₃. b₁₃ 선택.
- R₃: b₁₃</p>
<p>C → D 적용: 동일한 C 값을 가진 행.
- R₁, R₂, R₃, R₅ 행이 모두 C = b₁₃을 가짐. R₄는 C = a₃ (다름).
  - R₁: a₄, R₂: b₂₄, R₃: b₃₄, R₅: b₅₄. R₁이 구별된 a₄를 가짐. 모두 a₄로 설정.
  - R₂: a₄, R₃: a₄, R₅: a₄</p>
<p>DE → C 적용: 동일한 D와 E 값을 가진 행.
- R₃: D=a₄, E=a₅; R₄: D=a₄, E=a₅; R₅: D=a₄, E=a₅.
  - 이 행들이 DE에서 일치. C를 동일하게: R₃: b₁₃, R₄: a₃, R₅: b₁₃. R₄가 a₃를 가짐. 모두 a₃로 설정.
  - R₃: a₃, R₅: a₃.</p>
<p>CE → A 적용: 동일한 C와 E를 가진 행.
- R₃: C=a₃, E=a₅; R₄: C=a₃, E=a₅; R₅: C=a₃, E=a₅.
  - R₅가 A=a₁ (구별됨). R₃: a₁, R₄: a₁로 설정.</p>
<p>이제 A → C 재적용: R₁,R₂,R₃,R₄,R₅ 행이 A=a₁을 가짐.
- C 값: R₁=b₁₃, R₂=b₁₃, R₃=a₃, R₄=a₃, R₅=a₃. a₃가 있음. 모두 a₃로 설정.
- R₁=a₃, R₂=a₃.</p>
<p>C → D를 모든 행에 재적용 (이제 모두 C=a₃): 이미 모두 D=a₄. 변경 없음.</p>
<p>R₅ 행 확인: A=a₁, B=b₅₂, C=a₃, D=a₄, E=a₅. 여전히 B에 대해 b₅₂ 있음.</p>
<p>B → C 적용: R₂가 B=a₂, R₃이 B=a₂를 가짐. 둘 다 이미 C=a₃. 변경 없음.</p>
<p>확인: R₃ 행 = (a₁, a₂, a₃, a₄, a₅) — <strong>모든 구별 기호!</strong></p>
<p><strong>결과: 분해는 무손실 조인입니다. ✓</strong></p>
<hr />
<h2 id="8-3nf">8. 3NF 합성 알고리즘<a class="header-link" href="#8-3nf" title="Permanent link">&para;</a></h2>
<p>3NF 합성 알고리즘은 <strong>무손실 조인</strong>과 <strong>종속성 보존</strong> 모두를 가진 분해를 생성합니다.</p>
<h3 id="81">8.1 알고리즘<a class="header-link" href="#81" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="n">NF_Synthesis</span><span class="o">(</span><span class="n">R</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="o">)</span>
<span class="n">INPUT</span><span class="o">:</span><span class="w">  </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">릴레이션</span><span class="w"> </span><span class="err">스키마</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="err">집합</span>
<span class="n">OUTPUT</span><span class="o">:</span><span class="w"> </span><span class="err">무손실</span><span class="w"> </span><span class="err">조인과</span><span class="w"> </span><span class="err">종속성</span><span class="w"> </span><span class="err">보존을</span><span class="w"> </span><span class="err">가진</span><span class="w"> </span><span class="mi">3</span><span class="n">NF</span><span class="w"> </span><span class="err">분해</span><span class="w"> </span><span class="o">{</span><span class="n">R₁</span><span class="o">,</span><span class="w"> </span><span class="n">R₂</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">Rₙ</span><span class="o">}</span>

<span class="err">단계</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span><span class="w"> </span><span class="n">F의</span><span class="w"> </span><span class="err">최소</span><span class="w"> </span><span class="err">커버</span><span class="w"> </span><span class="n">F_min</span><span class="w"> </span><span class="err">계산</span><span class="o">.</span>

<span class="err">단계</span><span class="w"> </span><span class="mi">2</span><span class="o">:</span><span class="w"> </span><span class="n">F_min의</span><span class="w"> </span><span class="err">각</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">A에</span><span class="w"> </span><span class="err">대해</span><span class="o">:</span>
<span class="w">            </span><span class="err">릴레이션</span><span class="w"> </span><span class="err">스키마</span><span class="w"> </span><span class="n">Rᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">∪</span><span class="w"> </span><span class="o">{</span><span class="n">A</span><span class="o">}</span><span class="w"> </span><span class="err">생성</span>
<span class="w">        </span><span class="err">동일한</span><span class="w"> </span><span class="n">LHS를</span><span class="w"> </span><span class="err">가진</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="err">그룹화</span><span class="o">:</span>
<span class="w">            </span><span class="n">X</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">A₁</span><span class="o">,</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">A₂</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">Aₖ가</span><span class="w"> </span><span class="err">모두</span><span class="w"> </span><span class="err">동일한</span><span class="w"> </span><span class="n">X를</span><span class="w"> </span><span class="err">가지면</span><span class="o">,</span>
<span class="w">            </span><span class="err">하나의</span><span class="w"> </span><span class="err">스키마</span><span class="w"> </span><span class="n">Rᵢ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">∪</span><span class="w"> </span><span class="o">{</span><span class="n">A₁</span><span class="o">,</span><span class="w"> </span><span class="n">A₂</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">Aₖ</span><span class="o">}</span><span class="w"> </span><span class="err">생성</span>

<span class="err">단계</span><span class="w"> </span><span class="mi">3</span><span class="o">:</span><span class="w"> </span><span class="err">스키마</span><span class="w"> </span><span class="err">중</span><span class="w"> </span><span class="err">어느</span><span class="w"> </span><span class="err">것도</span><span class="w"> </span><span class="n">R의</span><span class="w"> </span><span class="err">후보</span><span class="w"> </span><span class="err">키를</span><span class="w"> </span><span class="err">포함하지</span><span class="w"> </span><span class="err">않으면</span><span class="o">,</span>
<span class="w">        </span><span class="err">스키마</span><span class="w"> </span><span class="n">Rₖ</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">R의</span><span class="w"> </span><span class="err">임의의</span><span class="w"> </span><span class="err">후보</span><span class="w"> </span><span class="err">키</span><span class="w"> </span><span class="err">추가</span><span class="o">.</span>

<span class="err">단계</span><span class="w"> </span><span class="mi">4</span><span class="o">:</span><span class="w"> </span><span class="err">다른</span><span class="w"> </span><span class="err">스키마</span><span class="w"> </span><span class="n">Rⱼ의</span><span class="w"> </span><span class="err">부분집합인</span><span class="w"> </span><span class="err">스키마</span><span class="w"> </span><span class="n">Rᵢ</span><span class="w"> </span><span class="err">제거</span><span class="o">.</span>

<span class="n">RETURN</span><span class="w"> </span><span class="o">{</span><span class="n">R₁</span><span class="o">,</span><span class="w"> </span><span class="n">R₂</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">Rₙ</span><span class="o">}</span>
</code></pre></div>

<h3 id="82">8.2 각 단계가 중요한 이유<a class="header-link" href="#82" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>단계 1</strong> (최소 커버): 중복 FD가 추가 테이블을 생성하지 않도록 보장</li>
<li><strong>단계 2</strong> (LHS 그룹당 하나의 테이블): 각 FD를 직접 보존</li>
<li><strong>단계 3</strong> (필요한 경우 키 추가): 무손실 조인 속성 보장</li>
<li><strong>단계 4</strong> (부분집합 제거): 중복 테이블 제거</li>
</ul>
<h3 id="83">8.3 작업 예제<a class="header-link" href="#83" title="Permanent link">&para;</a></h3>
<p>R(A, B, C, D, E, H)에 다음이 있음:</p>
<div class="highlight"><pre><span></span><code>F = { A → BC,  E → HA,  B → D }
</code></pre></div>

<p><strong>단계 1: 최소 커버 계산</strong></p>
<p>RHS 분해:</p>
<div class="highlight"><pre><span></span><code>F = { A → B, A → C, E → H, E → A, B → D }
</code></pre></div>

<p>불필요한 LHS 확인: 모든 LHS가 단일 속성. 단순화할 것 없음.</p>
<p>중복 FD 확인:
- A → B: 제거. 나머지 하에서 {A}⁺ = {A, C} ∪ ... = {A, C}. B ∉ {A}⁺. 유지.
- A → C: 제거. 나머지 하에서 {A}⁺ = {A, B, D} (A→B, B→D를 통해). C ∉ {A}⁺. 유지.
- E → H: 제거. 나머지 하에서 {E}⁺ = {E, A, B, C, D} (E→A, A→B, A→C, B→D를 통해). H ∉ {E}⁺. 유지.
- E → A: 제거. 나머지 하에서 {E}⁺ = {E, H}. A ∉ {E}⁺. 유지.
- B → D: 제거. 나머지 하에서 {B}⁺ = {B}. D ∉ {B}⁺. 유지.</p>
<p>최소 커버:</p>
<div class="highlight"><pre><span></span><code>F_min = { A → B, A → C, E → H, E → A, B → D }
</code></pre></div>

<p><strong>단계 2: LHS로 그룹화하고 스키마 생성</strong></p>
<table>
<thead>
<tr>
<th>LHS</th>
<th>FD</th>
<th>스키마</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>A → B, A → C</td>
<td>R₁(A, B, C)</td>
</tr>
<tr>
<td>E</td>
<td>E → H, E → A</td>
<td>R₂(E, H, A)</td>
</tr>
<tr>
<td>B</td>
<td>B → D</td>
<td>R₃(B, D)</td>
</tr>
</tbody>
</table>
<p><strong>단계 3: 후보 키 확인</strong></p>
<p>{E}⁺ = {E, H, A, B, C, D} = 모든 속성 계산. 따라서 {E}가 후보 키.</p>
<p>E가 어떤 스키마에 있는가? R₂가 E를 포함. R₂의 키는 E. ✓ (후보 키 존재.)</p>
<p><strong>단계 4: 부분집합 스키마 제거</strong></p>
<p>어느 것도 다른 것의 부분집합이 아님.</p>
<p><strong>최종 분해:</strong></p>
<div class="highlight"><pre><span></span><code>R₁(A, B, C)    — 키: {A}
R₂(E, H, A)    — 키: {E}
R₃(B, D)       — 키: {B}
</code></pre></div>

<p>모두 3NF ✓, 무손실 조인 ✓, 종속성 보존 ✓.</p>
<hr />
<h2 id="9-bcnf">9. BCNF 분해 알고리즘<a class="header-link" href="#9-bcnf" title="Permanent link">&para;</a></h2>
<h3 id="91">9.1 알고리즘<a class="header-link" href="#91" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">BCNF_Decomposition</span><span class="o">(</span><span class="n">R</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="o">)</span>
<span class="n">INPUT</span><span class="o">:</span><span class="w">  </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">릴레이션</span><span class="w"> </span><span class="err">스키마</span><span class="o">,</span><span class="w"> </span><span class="n">F</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="err">집합</span>
<span class="n">OUTPUT</span><span class="o">:</span><span class="w"> </span><span class="err">무손실</span><span class="w"> </span><span class="err">조인을</span><span class="w"> </span><span class="err">가진</span><span class="w"> </span><span class="n">BCNF</span><span class="w"> </span><span class="err">릴레이션으로</span><span class="w"> </span><span class="err">분해</span>

<span class="n">result</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="o">{</span><span class="n">R</span><span class="o">}</span>

<span class="n">WHILE</span><span class="w"> </span><span class="n">result에</span><span class="w"> </span><span class="n">BCNF에</span><span class="w"> </span><span class="err">없는</span><span class="w"> </span><span class="n">Rᵢ가</span><span class="w"> </span><span class="err">존재</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">Rᵢ에서</span><span class="w"> </span><span class="n">BCNF를</span><span class="w"> </span><span class="err">위반하는</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="err">찾기</span>
<span class="w">    </span><span class="o">(</span><span class="err">즉</span><span class="o">,</span><span class="w"> </span><span class="n">X가</span><span class="w"> </span><span class="n">Rᵢ의</span><span class="w"> </span><span class="err">슈퍼키가</span><span class="w"> </span><span class="err">아니고</span><span class="o">,</span><span class="w"> </span><span class="n">Y</span><span class="w"> </span><span class="err">⊄</span><span class="w"> </span><span class="n">X</span><span class="o">)</span>

<span class="w">    </span><span class="n">F에</span><span class="w"> </span><span class="err">대해</span><span class="w"> </span><span class="n">X</span><span class="err">⁺</span><span class="w"> </span><span class="err">계산</span>

<span class="w">    </span><span class="n">Rᵢ를</span><span class="w"> </span><span class="err">다음으로</span><span class="w"> </span><span class="err">대체</span><span class="o">:</span>
<span class="w">        </span><span class="n">R₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="err">⁺</span><span class="w"> </span><span class="err">∩</span><span class="w"> </span><span class="n">attributes</span><span class="o">(</span><span class="n">Rᵢ</span><span class="o">)</span><span class="w">    </span><span class="o">(</span><span class="n">Rᵢ</span><span class="w"> </span><span class="err">내에서</span><span class="w"> </span><span class="n">X가</span><span class="w"> </span><span class="err">결정하는</span><span class="w"> </span><span class="err">모든</span><span class="w"> </span><span class="err">것</span><span class="o">)</span>
<span class="w">        </span><span class="n">R₂</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">∪</span><span class="w"> </span><span class="o">(</span><span class="n">attributes</span><span class="o">(</span><span class="n">Rᵢ</span><span class="o">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X</span><span class="err">⁺</span><span class="o">)</span><span class="w">   </span><span class="o">(</span><span class="n">X</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">결정하지</span><span class="w"> </span><span class="err">않는</span><span class="w"> </span><span class="err">것</span><span class="o">)</span>
<span class="n">END</span><span class="w"> </span><span class="n">WHILE</span>

<span class="n">RETURN</span><span class="w"> </span><span class="n">result</span>
</code></pre></div>

<p>핵심 분해 단계는 Rᵢ를 다음으로 분할합니다:
- R₁: (Rᵢ 내에서) X가 결정하는 모든 속성 — X는 R₁의 키
- R₂: X + 나머지 속성 — X는 R₁로 돌아가는 외래 키</p>
<p>이것은 무손실 조인을 보장합니다 (R₁ ∩ R₂ = X, 그리고 X → R₁).</p>
<h3 id="92">9.2 작업 예제<a class="header-link" href="#92" title="Permanent link">&para;</a></h3>
<p>R(A, B, C, D)에 F = { AB → C, C → B, AB → D }가 있음</p>
<p><strong>단계 1: R이 BCNF에 있는가?</strong></p>
<p>후보 키: {A, B} ({A,B}⁺ = {A,B,C,D}).
또한 {A, C}가 후보 키 ({A,C}⁺: C→B는 {A,B,C}를 제공, AB→D는 {A,B,C,D}를 제공).</p>
<p>FD 확인:
- AB → C: {A,B}는 슈퍼키. ✓
- C → B: {C}⁺ = {C, B}. C는 슈퍼키가 아님. <strong>BCNF 위반!</strong>
- AB → D: {A,B}는 슈퍼키. ✓</p>
<p><strong>단계 2: C → B에서 분해</strong></p>
<p>{C}⁺ ∩ {A,B,C,D} = {B, C} ∩ {A,B,C,D} = {B, C} 계산</p>
<ul>
<li>R₁ = {B, C}에 FD: C → B (키: C)</li>
<li>R₂ = {C} ∪ ({A,B,C,D} - {B,C}) = {A, C, D}</li>
</ul>
<p>R₂(A, C, D)에 FD 투영:
- AB → C는 관련 없음 (B ∉ R₂)
- C → B는 관련 없음 (B ∉ R₂)
- AB → D는... 확인 필요: 투영된 FD 하에서 R₂에 대한 {A,C}⁺. C→B는 R₂에 없음. 하지만 원본에서: AC → D? {A,C}⁺ = {A,C,B,D} (C→B, AB→D). 따라서 AC → D가 성립. R₂의 키는 {A, C}.
- 확인: AC가 R₂의 슈퍼키인가? R₂로 제한된 {A,C}⁺ = {A,C,D}. 예. ✓</p>
<p><strong>단계 3: R₁과 R₂ 확인</strong></p>
<ul>
<li>R₁(B, C), FD: C → B. 키: {C}. C는 슈퍼키. BCNF ✓</li>
<li>R₂(A, C, D), FD: AC → D. 키: {A, C}. AC는 슈퍼키. BCNF ✓</li>
</ul>
<p><strong>최종 BCNF 분해:</strong></p>
<div class="highlight"><pre><span></span><code>R₁(B, C)      — 키: {C}
R₂(A, C, D)   — 키: {A, C}
</code></pre></div>

<p><strong>종속성 보존 확인:</strong>
- AB → C: R₁이나 R₂ 단독으로 확인 불가 (A와 B가 같은 테이블에 없음). <strong>보존되지 않음!</strong>
- C → B: R₁에 있음. ✓
- AB → D: 직접 보존되지 않지만, AC → D는 R₂에 있음.</p>
<p>이것은 BCNF 트레이드오프를 보여줍니다: BCNF를 달성했지만 FD AB → C를 잃었습니다.</p>
<h3 id="93-bcnf-vs-3nf">9.3 BCNF vs 3NF: 트레이드오프<a class="header-link" href="#93-bcnf-vs-3nf" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>속성</th>
<th style="text-align: center;">3NF 합성</th>
<th style="text-align: center;">BCNF 분해</th>
</tr>
</thead>
<tbody>
<tr>
<td>무손실 조인</td>
<td style="text-align: center;">✓ 항상</td>
<td style="text-align: center;">✓ 항상</td>
</tr>
<tr>
<td>종속성 보존</td>
<td style="text-align: center;">✓ 항상</td>
<td style="text-align: center;">✗ 항상은 아님</td>
</tr>
<tr>
<td>중복 제거</td>
<td style="text-align: center;">좋음 (최소)</td>
<td style="text-align: center;">최상 (FD로부터 없음)</td>
</tr>
<tr>
<td>선호하는 경우</td>
<td style="text-align: center;">종속성 보존이 중요할 때</td>
<td style="text-align: center;">최소 중복이 중요할 때</td>
</tr>
</tbody>
</table>
<p><strong>실용적 지침</strong>:
- BCNF 분해부터 시작
- 종속성 보존이 실패하면 3NF로 후퇴
- 실제로 대부분의 스키마는 종속성을 잃지 않고 BCNF를 달성</p>
<hr />
<h2 id="10-bcnf">10. 완전한 작업 예제: 비정규화에서 BCNF까지<a class="header-link" href="#10-bcnf" title="Permanent link">&para;</a></h2>
<h3 id="101">10.1 시나리오<a class="header-link" href="#101" title="Permanent link">&para;</a></h3>
<p>회사가 프로젝트 배정을 추적:</p>
<div class="highlight"><pre><span></span><code>ProjectAssignment(
    emp_id, emp_name, emp_phone,
    dept_id, dept_name, dept_budget,
    proj_id, proj_name, proj_budget,
    hours_worked, role
)
</code></pre></div>

<p><strong>비즈니스 규칙 (FD):</strong></p>
<div class="highlight"><pre><span></span><code>F = {
    emp_id → emp_name, emp_phone, dept_id,
    dept_id → dept_name, dept_budget,
    proj_id → proj_name, proj_budget,
    {emp_id, proj_id} → hours_worked, role
}
</code></pre></div>

<p><strong>후보 키</strong>: {emp_id, proj_id}</p>
<h3 id="102-1nf">10.2 1NF 확인<a class="header-link" href="#102-1nf" title="Permanent link">&para;</a></h3>
<p>모든 값이 원자적 (단일 값, 배열 없음). ✓ 1NF에 있음.</p>
<h3 id="103-2nf">10.3 2NF 확인<a class="header-link" href="#103-2nf" title="Permanent link">&para;</a></h3>
<p>비주요 속성: emp_name, emp_phone, dept_id, dept_name, dept_budget, proj_name, proj_budget, hours_worked, role.</p>
<p>부분 종속성 (속성이 키 {emp_id, proj_id}의 진부분집합에 의존):
- emp_id → emp_name, emp_phone, dept_id (부분: emp_id 단독에 의존)
- proj_id → proj_name, proj_budget (부분: proj_id 단독에 의존)</p>
<p><strong>2NF에 없음.</strong> 분해:</p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, emp_name, emp_phone, dept_id)
    FD: emp_id → emp_name, emp_phone, dept_id

Project(proj_id, proj_name, proj_budget)
    FD: proj_id → proj_name, proj_budget

Assignment(emp_id, proj_id, hours_worked, role)
    FD: {emp_id, proj_id} → hours_worked, role
</code></pre></div>

<p>이제 2NF에 있음. ✓</p>
<h3 id="104-3nf">10.4 3NF 확인<a class="header-link" href="#104-3nf" title="Permanent link">&para;</a></h3>
<p><strong>Employee(emp_id, emp_name, emp_phone, dept_id)</strong></p>
<p>키: {emp_id}</p>
<p>전이 종속성이 있는가?
- emp_id → dept_id (직접) ✓
- 하지만 dept_name, dept_budget은 어디에? 제거되었음 — 하지만 원래 FD dept_id → dept_name, dept_budget이 있음. dept_name과 dept_budget이 더 이상 이 릴레이션에 없으므로 이 릴레이션 내에 전이 종속성이 존재하지 않음.</p>
<p>실제로 재고해봅시다. 원래 FD dept_id → dept_name, dept_budget은 Employee가 dept_name이나 dept_budget을 포함해서는 안 된다는 것을 의미합니다. 그리고 포함하지 않습니다 — 단계 2의 분해와 함께 갔습니다. 하지만 Department 테이블이 필요합니다:</p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, emp_name, emp_phone, dept_id)
</code></pre></div>

<p>남은 속성들 사이에 전이 종속성이 있는가? emp_id → emp_name, emp_phone, dept_id. 모두 키로부터의 직접 종속성. 이 테이블 내에서 비주요 속성이 다른 비주요 속성을 결정하지 않음 (emp_phone이 dept_id를 결정하지 않음 등).</p>
<p>3NF에 있음 ✓.</p>
<p>하지만 원래 스키마의 FD dept_id → dept_name, dept_budget은 "고아"입니다. Department 테이블이 필요합니다:</p>
<div class="highlight"><pre><span></span><code>Department(dept_id, dept_name, dept_budget)
    키: {dept_id}
</code></pre></div>

<p><strong>이제 모든 릴레이션이 3NF에 있음:</strong></p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, emp_name, emp_phone, dept_id)    — 키: {emp_id}
Department(dept_id, dept_name, dept_budget)         — 키: {dept_id}
Project(proj_id, proj_name, proj_budget)           — 키: {proj_id}
Assignment(emp_id, proj_id, hours_worked, role)     — 키: {emp_id, proj_id}
</code></pre></div>

<h3 id="105-bcnf">10.5 BCNF 확인<a class="header-link" href="#105-bcnf" title="Permanent link">&para;</a></h3>
<p>각 릴레이션에 대해 확인: 모든 결정자가 슈퍼키인가?</p>
<ul>
<li><strong>Employee</strong>: emp_id → (emp_name, emp_phone, dept_id). emp_id가 키. ✓</li>
<li><strong>Department</strong>: dept_id → (dept_name, dept_budget). dept_id가 키. ✓</li>
<li><strong>Project</strong>: proj_id → (proj_name, proj_budget). proj_id가 키. ✓</li>
<li><strong>Assignment</strong>: {emp_id, proj_id} → (hours_worked, role). {emp_id, proj_id}가 키. ✓</li>
</ul>
<p><strong>모두 BCNF에 있음!</strong> ✓</p>
<h3 id="106">10.6 분해 요약<a class="header-link" href="#106" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>원본 (비정규화):
    ProjectAssignment(emp_id, emp_name, emp_phone, dept_id, dept_name,
                      dept_budget, proj_id, proj_name, proj_budget,
                      hours_worked, role)

최종 (BCNF):
    Employee(emp_id, emp_name, emp_phone, dept_id)
    Department(dept_id, dept_name, dept_budget)
    Project(proj_id, proj_name, proj_budget)
    Assignment(emp_id, proj_id, hours_worked, role)
</code></pre></div>

<p>이상 현상 제거:
- <strong>갱신</strong>: 부서 이름 변경시 Department의 한 행만 업데이트
- <strong>삽입</strong>: 직원 없이 부서 추가 가능
- <strong>삭제</strong>: 프로젝트의 모든 배정 제거해도 프로젝트 정보 손실 안됨</p>
<hr />
<h2 id="11-sql">11. SQL에서의 정규화<a class="header-link" href="#11-sql" title="Permanent link">&para;</a></h2>
<h3 id="111">11.1 정규화된 스키마 구현<a class="header-link" href="#111" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">Department</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">dept_id</span><span class="w">     </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">dept_name</span><span class="w">   </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">dept_budget</span><span class="w"> </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span>
<span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">Employee</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">emp_id</span><span class="w">    </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">emp_name</span><span class="w">  </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">emp_phone</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
<span class="w">    </span><span class="n">dept_id</span><span class="w">   </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">dept_id</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">Department</span><span class="p">(</span><span class="n">dept_id</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">Project</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">proj_id</span><span class="w">     </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">proj_name</span><span class="w">   </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">proj_budget</span><span class="w"> </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span>
<span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="k">Assignment</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">emp_id</span><span class="w">       </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">proj_id</span><span class="w">      </span><span class="nb">INT</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="n">hours_worked</span><span class="w"> </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="k">role</span><span class="w">         </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">,</span>
<span class="w">    </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">emp_id</span><span class="p">,</span><span class="w"> </span><span class="n">proj_id</span><span class="p">),</span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">emp_id</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">Employee</span><span class="p">(</span><span class="n">emp_id</span><span class="p">),</span>
<span class="w">    </span><span class="k">FOREIGN</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="p">(</span><span class="n">proj_id</span><span class="p">)</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">Project</span><span class="p">(</span><span class="n">proj_id</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>

<h3 id="112">11.2 쿼리를 통한 정규화 검증<a class="header-link" href="#112" title="Permanent link">&para;</a></h3>
<p>기존 데이터베이스의 잠재적 정규화 문제 확인:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 잠재적 2NF 위반 확인: 부분 종속성</span>
<span class="c1">-- 복합 키의 일부와 상관관계가 있는 비키 컬럼에 중복 값이 있는 경우</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">emp_id</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">emp_name</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">name_count</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">project_assignment_denormalized</span>
<span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">emp_id</span>
<span class="k">HAVING</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">emp_name</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="c1">-- 이것이 행을 반환하면 emp_name이 일관되지 않게 저장됨 (갱신 이상)</span>

<span class="c1">-- 잠재적 3NF 위반 확인: 전이 종속성</span>
<span class="c1">-- 함께 이동하는 컬럼들은 누락된 엔티티를 나타낼 수 있음</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">dept_id</span><span class="p">,</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">dept_name</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">names</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">employee_denormalized</span>
<span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">dept_id</span>
<span class="k">HAVING</span><span class="w"> </span><span class="k">COUNT</span><span class="p">(</span><span class="k">DISTINCT</span><span class="w"> </span><span class="n">dept_name</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="c1">-- 이것이 행을 반환하면 주어진 dept_id에 대해 dept_name이 일관되지 않음</span>
</code></pre></div>

<hr />
<h2 id="12">12. 정규형 요약<a class="header-link" href="#12" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>정규형</th>
<th>조건</th>
<th>제거하는 것</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1NF</strong></td>
<td>원자적 값, 반복 그룹 없음</td>
<td>비관계형 구조</td>
</tr>
<tr>
<td><strong>2NF</strong></td>
<td>1NF + 부분 종속성 없음</td>
<td>부분 키 종속성으로 인한 중복</td>
</tr>
<tr>
<td><strong>3NF</strong></td>
<td>2NF + 전이 종속성 없음</td>
<td>전이 종속성으로 인한 중복</td>
</tr>
<tr>
<td><strong>BCNF</strong></td>
<td>모든 결정자가 슈퍼키</td>
<td>모든 FD 기반 중복</td>
</tr>
</tbody>
</table>
<h3 id="_6">의사결정 흐름도<a class="header-link" href="#_6" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="err">시작</span><span class="o">:</span><span class="w"> </span><span class="n">FD</span><span class="w"> </span><span class="n">F를</span><span class="w"> </span><span class="err">가진</span><span class="w"> </span><span class="err">릴레이션</span><span class="w"> </span><span class="n">R</span>

<span class="n">R이</span><span class="w"> </span><span class="mi">1</span><span class="n">NF에</span><span class="w"> </span><span class="err">있는가</span><span class="o">?</span>
<span class="err">├──</span><span class="w"> </span><span class="err">아니오</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">비원자적</span><span class="w"> </span><span class="err">값과</span><span class="w"> </span><span class="err">반복</span><span class="w"> </span><span class="err">그룹</span><span class="w"> </span><span class="err">제거</span>
<span class="err">└──</span><span class="w"> </span><span class="err">예</span><span class="w"> </span><span class="err">↓</span>

<span class="n">R이</span><span class="w"> </span><span class="mi">2</span><span class="n">NF에</span><span class="w"> </span><span class="err">있는가</span><span class="o">?</span>
<span class="err">├──</span><span class="w"> </span><span class="err">아니오</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">부분</span><span class="w"> </span><span class="err">종속성</span><span class="w"> </span><span class="err">제거</span><span class="w"> </span><span class="o">(</span><span class="err">키의</span><span class="w"> </span><span class="err">일부에</span><span class="w"> </span><span class="err">의존하는</span>
<span class="err">│</span><span class="w">         </span><span class="err">속성</span><span class="w"> </span><span class="err">분리</span><span class="o">)</span>
<span class="err">└──</span><span class="w"> </span><span class="err">예</span><span class="w"> </span><span class="err">↓</span>

<span class="n">R이</span><span class="w"> </span><span class="mi">3</span><span class="n">NF에</span><span class="w"> </span><span class="err">있는가</span><span class="o">?</span>
<span class="err">├──</span><span class="w"> </span><span class="err">아니오</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">전이</span><span class="w"> </span><span class="err">종속성</span><span class="w"> </span><span class="err">제거</span><span class="w"> </span><span class="o">(</span><span class="err">비키</span><span class="w"> </span><span class="err">속성에</span><span class="w"> </span><span class="err">의존하는</span>
<span class="err">│</span><span class="w">         </span><span class="err">속성</span><span class="w"> </span><span class="err">분리</span><span class="o">)</span>
<span class="err">└──</span><span class="w"> </span><span class="err">예</span><span class="w"> </span><span class="err">↓</span>

<span class="n">R이</span><span class="w"> </span><span class="n">BCNF에</span><span class="w"> </span><span class="err">있는가</span><span class="o">?</span>
<span class="err">├──</span><span class="w"> </span><span class="err">아니오</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">확인</span><span class="o">:</span><span class="w"> </span><span class="err">종속성</span><span class="w"> </span><span class="err">보존을</span><span class="w"> </span><span class="err">잃어도</span><span class="w"> </span><span class="err">되는가</span><span class="o">?</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="err">예</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">BCNF</span><span class="w"> </span><span class="err">알고리즘으로</span><span class="w"> </span><span class="err">분해</span>
<span class="err">│</span><span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="err">아니오</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="mi">3</span><span class="n">NF에</span><span class="w"> </span><span class="err">머물기</span>
<span class="err">└──</span><span class="w"> </span><span class="err">예</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">완료</span><span class="o">!</span>
</code></pre></div>

<hr />
<h2 id="13-exercises">13. 연습 문제(Exercises)<a class="header-link" href="#13-exercises" title="Permanent link">&para;</a></h2>
<h3 id="1">연습 문제 1: 정규형 식별<a class="header-link" href="#1" title="Permanent link">&para;</a></h3>
<p>각 릴레이션에 대해 가장 높은 정규형 (1NF, 2NF, 3NF, 또는 BCNF) 식별:</p>
<p><strong>a)</strong> R(A, B, C, D), 키: {A, B}, FD: A → C, AB → D</p>
<p><strong>b)</strong> R(A, B, C), 키: {A}, FD: A → B, B → C</p>
<p><strong>c)</strong> R(A, B, C, D), 키: {A}, FD: A → BCD</p>
<p><strong>d)</strong> R(A, B, C), 키: {A, B}와 {A, C}, FD: AB → C, AC → B, B → C, C → B</p>
<details>
<summary>해답</summary>

**a)** A → C는 부분 종속성 (C가 키 {A,B}의 일부에 의존). **1NF** (2NF 아님).

**b)** A → B (키로부터 직접, OK), B → C (전이: A → B → C). 3NF 아님. 하지만 부분 종속성 없음 (단일 속성 키), 따라서 2NF. **2NF** (3NF 아님).

**c)** 키로부터만 FD. 모든 결정자 (A)가 슈퍼키. **BCNF**.

**d)** B → C: B는 슈퍼키가 아니지만 C는 주요 속성 (키 {A,C}의 일부). 따라서 3NF 성립. B는 슈퍼키가 아니므로 BCNF 실패. **3NF** (BCNF 아님).
</details>

<h3 id="2-3nf">연습 문제 2: 3NF 합성<a class="header-link" href="#2-3nf" title="Permanent link">&para;</a></h3>
<p>다음에 3NF 합성 알고리즘 적용:</p>
<p>R(A, B, C, D, E)에 F = { A → B, BC → D, D → E, E → C }</p>
<details>
<summary>해답</summary>

**단계 1: 최소 커버**

RHS 분해: 이미 단일 속성.

BC → D에서 불필요한 LHS 확인:
- B 제거: {C}⁺ = {C}. D ∉ {C}⁺. B 유지.
- C 제거: {B}⁺ = {B}. D ∉ {B}⁺. C 유지.

중복 FD 확인:
- A → B: A→B 없이 {A}⁺ = {A}. B ∉ {A}⁺. 유지.
- BC → D: BC→D 없이 {B,C}⁺ = {B,C}. D ∉ {B,C}⁺. 유지.
- D → E: D→E 없이 {D}⁺ = {D}. E ∉ {D}⁺. 유지.
- E → C: E→C 없이 {E}⁺ = {E}. C ∉ {E}⁺. 유지.

F_min = { A → B, BC → D, D → E, E → C }

**단계 2: 스키마 생성 (LHS로 그룹화)**

- R₁(A, B) from A → B
- R₂(B, C, D) from BC → D
- R₃(D, E) from D → E
- R₄(E, C) from E → C

**단계 3: 후보 키 확인**

{A}⁺ = {A, B}. 전체 아님.
{A, C}⁺ = {A, B, C, D, E}. 전체! 후보 키: {A, C}.
{A, E}⁺ = {A, B, C, D, E} (E→C, A→B, BC→D, D→E). 전체! 후보 키: {A, E}.
{A, D}⁺ = {A, B, D, E, C}. 전체! 후보 키: {A, D}.

R₁-R₄ 중 어느 것도 {A,C}, {A,E}, 또는 {A,D}를 전체 포함하지 않음.
- R₁ = {A,B}: 아니오
- R₂ = {B,C,D}: A 없음
- R₃ = {D,E}: A 없음
- R₄ = {E,C}: A 없음

R₅ = {A, C} (또는 {A, D} 또는 {A, E}) 추가.

**단계 4: 부분집합 제거**

R₄(E, C) ⊆ R₂(B, C, D)? 아니오 (E가 R₂에 없음). 제거할 부분집합 없음.

**최종 분해:**

<div class="highlight"><pre><span></span><code>R₁(A, B)       — 키: {A}
R₂(B, C, D)    — 키: {B, C}
R₃(D, E)       — 키: {D}
R₄(E, C)       — 키: {E}
R₅(A, C)       — 키: {A, C} (R의 후보 키)
</code></pre></div>



모두 3NF ✓, 무손실 조인 ✓, 종속성 보존 ✓.
</details>

<h3 id="3-bcnf">연습 문제 3: BCNF 분해<a class="header-link" href="#3-bcnf" title="Permanent link">&para;</a></h3>
<p>BCNF로 분해:</p>
<p>R(A, B, C, D)에 F = { AB → C, C → A, C → D }</p>
<details>
<summary>해답</summary>

후보 키: {A,B}와 {B,C} (검증: {A,B}⁺ = {A,B,C,D}, {B,C}⁺ = {A,B,C,D}).

BCNF 확인:
- AB → C: {A,B}는 슈퍼키. ✓
- C → A: {C}⁺ = {A,C,D}. C는 슈퍼키가 아님. **BCNF 위반!**
- C → D: 같은 문제. **BCNF 위반!**

C → A에서 분해 (또는 C → AD):
- {C}⁺ ∩ {A,B,C,D} = {A,C,D}
- R₁ = (A, C, D) with key {C}
- R₂ = {C} ∪ ({A,B,C,D} - {A,C,D}) = (B, C) with key {B,C}

R₁(A, C, D) 확인:
- C → A: C는 R₁의 키. ✓
- C → D: C는 R₁의 키. ✓
- BCNF ✓

R₂(B, C) 확인:
- 슈퍼키가 아닌 결정자를 가진 비자명한 FD 없음.
- BCNF ✓

**BCNF 분해: R₁(A, C, D), R₂(B, C)**

종속성 보존: AB → C는 R₁과 R₂ 조인 필요. **보존 안됨.**
</details>

<h3 id="4-lossless-join">연습 문제 4: 무손실 조인(Lossless-Join) 검증<a class="header-link" href="#4-lossless-join" title="Permanent link">&para;</a></h3>
<p>다음 분해가 무손실 조인(Lossless-Join) 속성을 갖는지 검증하시오:</p>
<p>R(A, B, C, D)에 F = { A → B, B → C }</p>
<p>분해: R₁(A, B), R₂(A, C), R₃(B, D)</p>
<details>
<summary>해답</summary>

추적(chase) 테스트 사용:

초기 행렬:
|    | A  | B   | C   | D   |
|----|----|-----|-----|-----|
| R₁ | a₁ | a₂  | b₁₃ | b₁₄ |
| R₂ | a₁ | b₂₂ | a₃  | b₂₄ |
| R₃ | b₃₁| a₂  | b₃₃ | a₄  |

A → B 적용: R₁과 R₂가 A에서 일치(= a₁).
- R₁.B = a₂, R₂.B = b₂₂. R₁이 구별 기호를 가짐. R₂.B = a₂로 설정.

|    | A  | B  | C   | D   |
|----|----|----|-----|-----|
| R₁ | a₁ | a₂ | b₁₃ | b₁₄ |
| R₂ | a₁ | a₂ | a₃  | b₂₄ |
| R₃ | b₃₁| a₂ | b₃₃ | a₄  |

B → C 적용: R₁, R₂, R₃가 B에서 일치(= a₂).
- C 값: b₁₃, a₃, b₃₃. a₃ 존재. 모두 a₃로 설정.

|    | A  | B  | C  | D   |
|----|----|----|----| ----|
| R₁ | a₁ | a₂ | a₃ | b₁₄ |
| R₂ | a₁ | a₂ | a₃ | b₂₄ |
| R₃ | b₃₁| a₂ | a₃ | a₄  |

더 이상의 반복에서 변경 없음.

행 확인: 모든 구별 기호를 가진 행 없음. R₁은 b₁₄, R₂는 b₂₄, R₃는 b₃₁을 가짐.

**이 분해는 무손실 조인(Lossless-Join)이 아님.** ✗

문제점: R₃(B, D)는 다른 릴레이션과 B만 공유하며, B는 D의 결정 속성을 포함하는 어떤 릴레이션의 키도 아님.

올바른 분해: R₁(A, B), R₂(B, C, D) — B → C가 성립하고 {B}가 {B,C}에 제한된 R₂의 키이므로 무손실.

실제로 B → D는 주어지지 않음. FD는 A → B와 B → C뿐. 따라서 D에는 결정하는 FD가 없음. 재고해보면: {A}⁺ = {A,B,C}. 키는 D를 포함해야 함: 키 = {A, D}.

더 나은 분해: R₁(A, B, C)와 R₂(A, D). 공통 = {A}. A → {B,C}. {A}는 R₁의 키. 무손실 ✓.
</details>

<h3 id="5-full-normalization">연습 문제 5: 완전 정규화(Full Normalization)<a class="header-link" href="#5-full-normalization" title="Permanent link">&para;</a></h3>
<p>합성 알고리즘을 사용하여 다음을 3NF로 정규화하시오:</p>
<div class="highlight"><pre><span></span><code>Library(isbn, title, author_id, author_name, publisher_id,
        publisher_name, publisher_city, branch_id, branch_name, copies)
</code></pre></div>

<p>FD:</p>
<div class="highlight"><pre><span></span><code>isbn → title, author_id, publisher_id
author_id → author_name
publisher_id → publisher_name, publisher_city
{isbn, branch_id} → copies
branch_id → branch_name
</code></pre></div>

<details>
<summary>해답</summary>

**단계 1: 최소 커버(Minimal Cover)**

우변 분해:

<div class="highlight"><pre><span></span><code>isbn → title, isbn → author_id, isbn → publisher_id,
author_id → author_name,
publisher_id → publisher_name, publisher_id → publisher_city,
{isbn, branch_id} → copies,
branch_id → branch_name
</code></pre></div>



이미 최소 (우변에 단일 속성, 불필요한 좌변 없음, 중복 FD 없음).

**단계 2: 좌변으로 그룹화**

- R₁(isbn, title, author_id, publisher_id) — isbn → title, author_id, publisher_id에서
- R₂(author_id, author_name) — author_id → author_name에서
- R₃(publisher_id, publisher_name, publisher_city) — publisher_id → publisher_name, publisher_city에서
- R₄(isbn, branch_id, copies) — {isbn, branch_id} → copies에서
- R₅(branch_id, branch_name) — branch_id → branch_name에서

**단계 3: 후보 키 = {isbn, branch_id}**

R₄가 {isbn, branch_id}를 포함함. ✓

**단계 4: 제거할 부분집합 없음.**

**최종 3NF 분해:**

<div class="highlight"><pre><span></span><code>Book(isbn, title, author_id, publisher_id)         — 키: {isbn}
Author(author_id, author_name)                      — 키: {author_id}
Publisher(publisher_id, publisher_name, publisher_city) — 키: {publisher_id}
BranchStock(isbn, branch_id, copies)                — 키: {isbn, branch_id}
Branch(branch_id, branch_name)                      — 키: {branch_id}
</code></pre></div>



모든 결정자가 단일 속성 키(또는 BranchStock의 복합 키)이므로 BCNF이기도 함.
</details>

<h3 id="6-anomaly">연습 문제 6: 이상(Anomaly) 식별<a class="header-link" href="#6-anomaly" title="Permanent link">&para;</a></h3>
<p>다음 릴레이션과 샘플 데이터를 보고, 구체적인 갱신, 삽입, 삭제 이상을 식별하시오:</p>
<div class="highlight"><pre><span></span><code>CourseSection(course_id, section, semester, instructor, building, room)

FDs: {course_id, section, semester} → instructor, building, room
     building, room → capacity   (capacity도 속성으로 가정)
</code></pre></div>

<div class="highlight"><pre><span></span><code>| course_id | section | semester | instructor | building | room | capacity |
|-----------|---------|----------|------------|----------|------|----------|
| CS101     | 1       | Fall24   | Dr. Smith  | Watson   | 101  | 50       |
| CS101     | 2       | Fall24   | Dr. Jones  | Watson   | 101  | 50       |
| CS201     | 1       | Fall24   | Dr. Smith  | Watson   | 201  | 30       |
| CS201     | 1       | Spr25    | Dr. Smith  | Taylor   | 105  | 40       |
</code></pre></div>

<details>
<summary>해답</summary>

**갱신 이상(Update Anomaly)**: Watson 101의 수용 인원이 변경되면(예: 리모델링으로 좌석 추가), 여러 행(행 1과 2)을 갱신해야 함. 행 1만 갱신하면 행 1과 2가 불일치하게 됨.

**삽입 이상(Insertion Anomaly)**: 해당 강의실에 예정된 수업이 없으면 Taylor 302의 수용 인원이 60임을 기록할 수 없음. 강의실 정보를 독립적으로 저장할 방법이 없음.

**삭제 이상(Deletion Anomaly)**: CS201 Section 1 Spring 2025가 취소되면(행 4 삭제), Taylor 105의 수용 인원이 40임을 알 수 없게 됨(해당 강의실을 사용하는 다른 수업이 없다고 가정).

**근본 원인**: 전이 종속성(Transitive Dependency) {course_id, section, semester} → {building, room} → capacity가 중복을 만듦.

**해결**: 다음과 같이 분해:

<div class="highlight"><pre><span></span><code>CourseSection(course_id, section, semester, instructor, building, room)
Room(building, room, capacity)
</code></pre></div>


</details>

<hr />
<h2 id="14-summary">14. 요약(Summary)<a class="header-link" href="#14-summary" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>개념</th>
<th>핵심 아이디어</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1NF</strong></td>
<td>원자적 값만 — 관계형 모델의 기초</td>
</tr>
<tr>
<td><strong>2NF</strong></td>
<td>부분 종속성 없음 — 모든 비주요 속성이 전체 키에 의존</td>
</tr>
<tr>
<td><strong>3NF</strong></td>
<td>전이 종속성 없음 — 비주요 속성이 키에만 의존</td>
</tr>
<tr>
<td><strong>BCNF</strong></td>
<td>모든 결정자가 슈퍼키 — 가장 엄격한 FD 기반 형태</td>
</tr>
<tr>
<td><strong>무손실 조인</strong></td>
<td>자연 조인이 원래 데이터 복구 — 필수</td>
</tr>
<tr>
<td><strong>종속성 보존</strong></td>
<td>모든 FD를 조인 없이 확인 가능 — 바람직하지만 때때로 BCNF를 위해 희생</td>
</tr>
<tr>
<td><strong>3NF 합성</strong></td>
<td>무손실 조인과 종속성 보존 모두 보장</td>
</tr>
<tr>
<td><strong>BCNF 분해</strong></td>
<td>무손실 조인 보장; 종속성 보존 잃을 수 있음</td>
</tr>
</tbody>
</table>
<p>BCNF까지의 정규화는 함수 종속성으로 인한 모든 중복을 처리합니다. 그러나 다른 유형의 종속성 — 다치 종속성과 조인 종속성 — 이 있어 더 높은 정규형이 필요합니다. 이는 다음 레슨에서 탐구합니다.</p>
<hr />
<p><strong>이전</strong>: <a href="./05_Functional_Dependencies.md">05_Functional_Dependencies.md</a> | <strong>다음</strong>: <a href="./07_Advanced_Normalization.md">07_Advanced_Normalization.md</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/05_Functional_Dependencies.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 05: 함수 종속성(Functional Dependencies)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/07_Advanced_Normalization.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 07: 고급 정규화(Advanced Normalization)</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}