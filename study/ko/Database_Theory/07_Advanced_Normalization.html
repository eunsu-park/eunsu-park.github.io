{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 07: 고급 정규화(Advanced Normalization) - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Database_Theory/">Database Theory</a>
    <span class="separator">/</span>
    <span class="current">Lesson 07: 고급 정규화(Advanced Normalization)</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 07: 고급 정규화(Advanced Normalization)</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/06_Normalization.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 06: 정규화 (1NF ~ BCNF)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/08_Query_Processing.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 08: 쿼리 처리(Query Processing)</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#1-introduction">1. 소개(Introduction)</a><ul>
<li><a href="#11-the-hierarchy-of-normal-forms">1.1 정규형의 계층(The Hierarchy of Normal Forms)</a></li>
</ul>
</li>
<li><a href="#2-multivalued-dependencies-mvds">2. 다치 종속성(Multivalued Dependencies, MVDs)</a><ul>
<li><a href="#21-motivation">2.1 동기(Motivation)</a></li>
<li><a href="#22-definition">2.2 정의(Definition)</a></li>
<li><a href="#23-intuitive-understanding">2.3 직관적 이해(Intuitive Understanding)</a></li>
<li><a href="#24-mvd-properties-of-mvds">2.4 MVD의 속성(Properties of MVDs)</a></li>
<li><a href="#25-mvdtrivial-mvds">2.5 자명한 MVD(Trivial MVDs)</a></li>
</ul>
</li>
<li><a href="#3-4fourth-normal-form-4nf">3. 제4정규형(Fourth Normal Form, 4NF)</a><ul>
<li><a href="#31-definition">3.1 정의(Definition)</a></li>
<li><a href="#32-bcnf-relationship-to-bcnf">3.2 BCNF와의 관계(Relationship to BCNF)</a></li>
<li><a href="#33-4nf-4nf-decomposition-algorithm">3.3 4NF 분해 알고리즘(4NF Decomposition Algorithm)</a></li>
<li><a href="#34-worked-example">3.4 작업 예제(Worked Example)</a></li>
<li><a href="#35-a-more-complex-example">3.5 더 복잡한 예제(A More Complex Example)</a></li>
</ul>
</li>
<li><a href="#4-5fifth-normal-form-5nf-pjnf">4. 제5정규형(Fifth Normal Form, 5NF / PJNF)</a><ul>
<li><a href="#41-join-dependencies">4.1 조인 종속성(Join Dependencies)</a></li>
<li><a href="#42-mvd-jd-mvds-as-special-case-of-jds">4.2 MVD를 JD의 특수 경우로(MVDs as Special Case of JDs)</a></li>
<li><a href="#43-5nf-definition-of-5nf">4.3 5NF의 정의(Definition of 5NF)</a></li>
<li><a href="#44-5nf-example-need-for-5nf">4.4 예제: 5NF의 필요성(Example: Need for 5NF)</a></li>
<li><a href="#45-detecting-join-dependencies">4.5 조인 종속성 감지(Detecting Join Dependencies)</a></li>
</ul>
</li>
<li><a href="#5-domain-key-normal-form-dknf">5. 도메인-키 정규형(Domain-Key Normal Form, DKNF)</a><ul>
<li><a href="#51-definition">5.1 정의(Definition)</a></li>
<li><a href="#52-significance">5.2 중요성(Significance)</a></li>
<li><a href="#53-example">5.3 예제(Example)</a></li>
<li><a href="#54-dknf-when-dknf-fails">5.4 DKNF 실패 경우(When DKNF Fails)</a></li>
<li><a href="#55-practical-relevance">5.5 실용적 관련성(Practical Relevance)</a></li>
</ul>
</li>
<li><a href="#6-summary-of-all-normal-forms">6. 모든 정규형의 요약(Summary of All Normal Forms)</a></li>
<li><a href="#7-denormalization">7. 비정규화(Denormalization)</a><ul>
<li><a href="#71-when-to-denormalize">7.1 언제 비정규화할까(When to Denormalize)</a></li>
<li><a href="#72-denormalization-techniques">7.2 비정규화 기법(Denormalization Techniques)</a><ul>
<li><a href="#1-prejoined-tables">기법 1: 사전 조인된 테이블(Prejoined Tables)</a></li>
<li><a href="#2-derivedcomputed-columns">기법 2: 파생/계산 열(Derived/Computed Columns)</a></li>
<li><a href="#3-redundant-columns">기법 3: 중복 열(Redundant Columns)</a></li>
<li><a href="#4-summaryaggregate-tables">기법 4: 요약/집계 테이블(Summary/Aggregate Tables)</a></li>
<li><a href="#5-materialized-views">기법 5: 구체화된 뷰(Materialized Views)</a></li>
</ul>
</li>
<li><a href="#73-managing-denormalized-data">7.3 비정규화된 데이터 관리(Managing Denormalized Data)</a></li>
<li><a href="#74-the-normalization-denormalization-spectrum">7.4 정규화-비정규화 스펙트럼(The Normalization-Denormalization Spectrum)</a></li>
<li><a href="#75-decision-framework">7.5 의사결정 프레임워크(Decision Framework)</a></li>
</ul>
</li>
<li><a href="#8-star-schema-and-snowflake-schema">8. 스타 스키마와 스노플레이크 스키마(Star Schema and Snowflake Schema)</a><ul>
<li><a href="#81-star-schema">8.1 스타 스키마(Star Schema)</a></li>
<li><a href="#82-snowflake-schema">8.2 스노플레이크 스키마(Snowflake Schema)</a></li>
<li><a href="#83-vs-star-vs-snowflake">8.3 스타 vs 스노플레이크(Star vs Snowflake)</a></li>
<li><a href="#84-fact-table-types">8.4 팩트 테이블 유형(Fact Table Types)</a></li>
<li><a href="#85-slowly-changing-dimensions-scd">8.5 느리게 변하는 차원(Slowly Changing Dimensions, SCD)</a></li>
</ul>
</li>
<li><a href="#9-practical-normalization-guidelines">9. 실용적 정규화 지침(Practical Normalization Guidelines)</a><ul>
<li><a href="#91-rules-of-thumb">9.1 경험 법칙(Rules of Thumb)</a></li>
<li><a href="#92-common-patterns">9.2 일반적인 패턴(Common Patterns)</a></li>
<li><a href="#93-anti-patterns-to-avoid">9.3 피해야 할 안티패턴(Anti-Patterns to Avoid)</a></li>
</ul>
</li>
<li><a href="#10-exercises">10. 연습문제(Exercises)</a><ul>
<li><a href="#1-mvd-identifying-mvds">연습문제 1: MVD 식별(Identifying MVDs)</a></li>
<li><a href="#2-mvd-vs-fd">연습문제 2: MVD vs FD</a></li>
<li><a href="#3-star-schema-design">연습문제 3: 스타 스키마 설계(Star Schema Design)</a></li>
<li><a href="#4-4nf-4nf-decomposition">연습문제 4: 4NF 분해(4NF Decomposition)</a></li>
<li><a href="#5-denormalization-decision">연습문제 5: 비정규화 결정(Denormalization Decision)</a></li>
<li><a href="#6-join-dependency">연습문제 6: 조인 종속성(Join Dependency)</a></li>
</ul>
</li>
<li><a href="#11-summary">11. 요약(Summary)</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-07-advanced-normalization">Lesson 07: 고급 정규화(Advanced Normalization)<a class="header-link" href="#lesson-07-advanced-normalization" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./06_Normalization.md">06_Normalization.md</a> | <strong>다음</strong>: <a href="./08_Query_Processing.md">08_Query_Processing.md</a></p>
<hr />
<blockquote>
<p><strong>주제(Topic)</strong>: Database Theory
<strong>레슨(Lesson)</strong>: 7 of 16
<strong>선행 학습(Prerequisites)</strong>: 함수 종속성(Functional dependencies, Lesson 05), BCNF까지의 정규화(normalization through BCNF, Lesson 06)
<strong>목표(Objective)</strong>: 다치 종속성과 4NF(Multivalued dependencies and 4NF), 조인 종속성과 5NF(Join dependencies and 5NF), DKNF의 이론적 이상(theoretical ideal of DKNF), 그리고 실무 시스템을 위한 실용적 비정규화 전략(practical denormalization strategies)을 이해합니다</p>
</blockquote>
<h2 id="1-introduction">1. 소개(Introduction)<a class="header-link" href="#1-introduction" title="Permanent link">&para;</a></h2>
<p>Lesson 06에서 우리는 함수 종속성이 BCNF까지의 정규화를 어떻게 이끄는지 살펴보았습니다. 그러나 BCNF는 <strong>모든</strong> 형태의 중복성을 제거하지 않습니다. BCNF에 있는 릴레이션이 여전히 다른 종류의 제약조건에 의해 야기된 중복 데이터를 포함하는 상황이 있습니다: <strong>다치 종속성(multivalued dependencies)</strong>과 <strong>조인 종속성(join dependencies)</strong>입니다.</p>
<p>이 레슨은 이러한 문제를 다루는 더 높은 정규형(4NF, 5NF, DKNF)을 다루고, 때로는 <strong>덜 정규화하는 것이 더 나은</strong> 실무적 현실 — 비정규화의 예술(art of denormalization) — 로 전환합니다.</p>
<h3 id="11-the-hierarchy-of-normal-forms">1.1 정규형의 계층(The Hierarchy of Normal Forms)<a class="header-link" href="#11-the-hierarchy-of-normal-forms" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>DKNF  (Domain-Key Normal Form — 이론적 이상)
  ↑
5NF / PJNF  (Project-Join Normal Form)
  ↑
4NF  (Fourth Normal Form)
  ↑
BCNF  (Boyce-Codd Normal Form)
  ↑
3NF  (Third Normal Form)
  ↑
2NF  (Second Normal Form)
  ↑
1NF  (First Normal Form)
</code></pre></div>

<p>각 수준은 추가적인 중복성 클래스를 제거합니다. 실무에서 BCNF는 대부분의 애플리케이션에 충분합니다. 4NF는 가끔 필요합니다. 5NF와 DKNF는 주로 이론적 관심사입니다.</p>
<hr />
<h2 id="2-multivalued-dependencies-mvds">2. 다치 종속성(Multivalued Dependencies, MVDs)<a class="header-link" href="#2-multivalued-dependencies-mvds" title="Permanent link">&para;</a></h2>
<h3 id="21-motivation">2.1 동기(Motivation)<a class="header-link" href="#21-motivation" title="Permanent link">&para;</a></h3>
<p>직원, 그들의 기술, 그리고 할당된 프로젝트를 추적하는 릴레이션을 고려하세요:</p>
<div class="highlight"><pre><span></span><code>EmpSkillProject(emp_id, skill, project)
</code></pre></div>

<p>다음을 가정합니다:
- 직원의 기술은 그들의 프로젝트 할당과 <strong>독립적</strong>입니다
- 직원 E1은 기술 {Java, Python}을 가지고 있고 프로젝트 {Alpha, Beta}에서 일합니다</p>
<p>이를 올바르게 표현하려면 <strong>모든 조합</strong>이 필요합니다:</p>
<div class="highlight"><pre><span></span><code>| emp_id | skill  | project |
|--------|--------|---------|
| E1     | Java   | Alpha   |
| E1     | Java   | Beta    |
| E1     | Python | Alpha   |
| E1     | Python | Beta    |
</code></pre></div>

<p>하나의 행(예: E1/Python/Beta)을 잊어버리면, 데이터는 E1의 Python 기술이 Beta 프로젝트와 연관되지 않았다고 잘못 암시합니다. 이 "모든 조합" 요구사항이 <strong>다치 종속성</strong>의 특징입니다.</p>
<p>참고: 이 릴레이션은 BCNF에 있습니다 (유일한 후보 키는 전체 집합 {emp_id, skill, project}이고, 비자명한 FD가 없습니다). 그러나 명백한 중복성이 있습니다 — 각 기술은 프로젝트당 한 번씩 나열되고, 그 반대도 마찬가지입니다.</p>
<h3 id="22-definition">2.2 정의(Definition)<a class="header-link" href="#22-definition" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: 릴레이션 R에 대해 <strong>다치 종속성(multivalued dependency, MVD)</strong> X →→ Y가 성립한다는 것은, R의 모든 튜플 쌍 t₁과 t₂에 대해 t₁[X] = t₂[X]이면, R에 튜플 t₃와 t₄가 존재하여 다음을 만족함을 의미합니다:</p>
<ul>
<li>t₃[X] = t₄[X] = t₁[X] = t₂[X]</li>
<li>t₃[Y] = t₁[Y] and t₃[Z] = t₂[Z]</li>
<li>t₄[Y] = t₂[Y] and t₄[Z] = t₁[Z]</li>
</ul>
<p>여기서 Z = R - X - Y (나머지 모든 속성).</p>
</blockquote>
<p>더 간단한 말로: X를 고정하면, Y 값의 집합은 다른 속성들과 독립적입니다. 모든 조합이 나타나야 합니다.</p>
<h3 id="23-intuitive-understanding">2.3 직관적 이해(Intuitive Understanding)<a class="header-link" href="#23-intuitive-understanding" title="Permanent link">&para;</a></h3>
<p>X →→ Y의 의미:</p>
<blockquote>
<p>"주어진 X 값에 대해, Y가 취하는 값들의 집합은 나머지 속성들(R - X - Y)이 취하는 값들과 <strong>독립적</strong>입니다."</p>
</blockquote>
<p>우리 예제에서:
- emp_id →→ skill (주어진 직원에 대해, 기술은 프로젝트와 독립적입니다)
- emp_id →→ project (주어진 직원에 대해, 프로젝트는 기술과 독립적입니다)</p>
<h3 id="24-mvd-properties-of-mvds">2.4 MVD의 속성(Properties of MVDs)<a class="header-link" href="#24-mvd-properties-of-mvds" title="Permanent link">&para;</a></h3>
<p><strong>보완 규칙(Complementation rule)</strong>: X →→ Y이면, X →→ Z (여기서 Z = R - X - Y).</p>
<p>이는 정의로부터 직접 따라옵니다. 우리 예제에서, emp_id →→ skill은 emp_id →→ project를 함의합니다.</p>
<p><strong>모든 FD는 MVD입니다</strong>: X → Y이면, X →→ Y. (하지만 역은 성립하지 않습니다.)</p>
<p>증명: X → Y이고 t₁[X] = t₂[X]이면, t₁[Y] = t₂[Y]. "교환(swap)" 튜플 t₃와 t₄는 바로 t₁과 t₂ 자체입니다.</p>
<p><strong>MVD 추론 규칙(MVD inference rules)</strong> (암스트롱 공리와 유사):</p>
<table>
<thead>
<tr>
<th>규칙</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td>보완(Complementation)</td>
<td>X →→ Y ⟹ X →→ (R - X - Y)</td>
</tr>
<tr>
<td>확장(Augmentation)</td>
<td>X →→ Y and W ⊇ Z ⟹ XW →→ YZ</td>
</tr>
<tr>
<td>이행(Transitivity)</td>
<td>X →→ Y and Y →→ Z ⟹ X →→ (Z - Y)</td>
</tr>
<tr>
<td>복제(Replication)</td>
<td>X → Y ⟹ X →→ Y</td>
</tr>
<tr>
<td>결합(Coalescence)</td>
<td>X →→ Y, Z ⊆ Y, W ∩ Y = ∅, W → Z ⟹ X → Z</td>
</tr>
</tbody>
</table>
<h3 id="25-mvdtrivial-mvds">2.5 자명한 MVD(Trivial MVDs)<a class="header-link" href="#25-mvdtrivial-mvds" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: MVD X →→ Y가 <strong>자명(trivial)</strong>하다는 것은:
- Y ⊆ X이거나,
- X ∪ Y = R (릴레이션의 모든 속성)</p>
</blockquote>
<p>자명한 MVD는 항상 성립하며 중복성을 야기하지 않습니다.</p>
<hr />
<h2 id="3-4fourth-normal-form-4nf">3. 제4정규형(Fourth Normal Form, 4NF)<a class="header-link" href="#3-4fourth-normal-form-4nf" title="Permanent link">&para;</a></h2>
<h3 id="31-definition">3.1 정의(Definition)<a class="header-link" href="#31-definition" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: 릴레이션 스키마 R이 <strong>제4정규형(Fourth Normal Form, 4NF)</strong>에 있다는 것은, R에 성립하는 모든 비자명한 다치 종속성 X →→ Y에 대해:</p>
<p>X가 R의 슈퍼키입니다.</p>
</blockquote>
<p>4NF는 BCNF보다 엄격히 더 강합니다. 다치 종속성에 의한 중복성을 제거합니다.</p>
<h3 id="32-bcnf-relationship-to-bcnf">3.2 BCNF와의 관계(Relationship to BCNF)<a class="header-link" href="#32-bcnf-relationship-to-bcnf" title="Permanent link">&para;</a></h3>
<p>모든 FD는 MVD이므로, 모든 비자명한 MVD가 슈퍼키 결정자를 가지면, 모든 비자명한 FD도 슈퍼키 결정자를 가집니다. 따라서:</p>
<div class="highlight"><pre><span></span><code><span class="mf">4</span><span class="n">NF</span><span class="w"> </span><span class="err">⊂</span><span class="w"> </span><span class="n">BCNF</span><span class="w"> </span><span class="err">⊂</span><span class="w"> </span><span class="mf">3</span><span class="n">NF</span><span class="w"> </span><span class="err">⊂</span><span class="w"> </span><span class="mf">2</span><span class="n">NF</span><span class="w"> </span><span class="err">⊂</span><span class="w"> </span><span class="mf">1</span><span class="n">NF</span>
</code></pre></div>

<p>4NF에 있는 릴레이션은 항상 BCNF에 있지만, BCNF에 있는 릴레이션은 4NF에 있지 않을 수 있습니다 (우리의 EmpSkillProject 예제가 보여주듯이).</p>
<h3 id="33-4nf-4nf-decomposition-algorithm">3.3 4NF 분해 알고리즘(4NF Decomposition Algorithm)<a class="header-link" href="#33-4nf-4nf-decomposition-algorithm" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="mi">4</span><span class="n">NF_Decomposition</span><span class="o">(</span><span class="n">R</span><span class="o">,</span><span class="w"> </span><span class="n">D</span><span class="o">)</span>
<span class="n">INPUT</span><span class="o">:</span><span class="w">  </span><span class="n">R</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">릴레이션</span><span class="w"> </span><span class="err">스키마</span>
<span class="w">        </span><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">FD와</span><span class="w"> </span><span class="n">MVD의</span><span class="w"> </span><span class="err">집합</span>
<span class="n">OUTPUT</span><span class="o">:</span><span class="w"> </span><span class="err">무손실</span><span class="w"> </span><span class="err">조인을</span><span class="w"> </span><span class="err">가진</span><span class="w"> </span><span class="mi">4</span><span class="n">NF</span><span class="w"> </span><span class="err">릴레이션들로의</span><span class="w"> </span><span class="err">분해</span>

<span class="n">result</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="o">{</span><span class="n">R</span><span class="o">}</span>

<span class="n">WHILE</span><span class="w"> </span><span class="n">result에</span><span class="w"> </span><span class="mi">4</span><span class="n">NF에</span><span class="w"> </span><span class="err">있지</span><span class="w"> </span><span class="err">않은</span><span class="w"> </span><span class="n">Rᵢ가</span><span class="w"> </span><span class="err">존재</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">Rᵢ에서</span><span class="w"> </span><span class="mi">4</span><span class="n">NF를</span><span class="w"> </span><span class="err">위반하는</span><span class="w"> </span><span class="err">비자명한</span><span class="w"> </span><span class="n">MVD</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">→→</span><span class="w"> </span><span class="n">Y를</span><span class="w"> </span><span class="err">찾습니다</span>
<span class="w">    </span><span class="o">(</span><span class="err">즉</span><span class="o">,</span><span class="w"> </span><span class="n">X가</span><span class="w"> </span><span class="n">Rᵢ의</span><span class="w"> </span><span class="err">슈퍼키가</span><span class="w"> </span><span class="err">아님</span><span class="o">)</span>

<span class="w">    </span><span class="n">Rᵢ를</span><span class="w"> </span><span class="err">다음으로</span><span class="w"> </span><span class="err">교체</span><span class="o">:</span>
<span class="w">        </span><span class="n">R₁</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">∪</span><span class="w"> </span><span class="n">Y</span>
<span class="w">        </span><span class="n">R₂</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rᵢ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Y</span><span class="w">    </span><span class="o">(</span><span class="err">또는</span><span class="o">,</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="err">∪</span><span class="w"> </span><span class="n">Z</span><span class="o">,</span><span class="w"> </span><span class="err">여기서</span><span class="w"> </span><span class="n">Z</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Rᵢ</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">X</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Y</span><span class="o">)</span>
<span class="n">END</span><span class="w"> </span><span class="n">WHILE</span>

<span class="n">RETURN</span><span class="w"> </span><span class="n">result</span>
</code></pre></div>

<p>이는 BCNF 분해 알고리즘과 유사하지만 FD 대신 MVD를 사용합니다.</p>
<h3 id="34-worked-example">3.4 작업 예제(Worked Example)<a class="header-link" href="#34-worked-example" title="Permanent link">&para;</a></h3>
<p><strong>EmpSkillProject(emp_id, skill, project)</strong></p>
<p>MVDs:
- emp_id →→ skill
- emp_id →→ project</p>
<p>Key: {emp_id, skill, project} (FD가 존재하지 않으므로 전체 릴레이션)</p>
<p>4NF 확인: emp_id →→ skill은 비자명하고, {emp_id}는 슈퍼키가 아닙니다. <strong>위반!</strong></p>
<p>emp_id →→ skill에 대해 분해:
- R₁ = {emp_id, skill}
- R₂ = {emp_id, project}</p>
<p>R₁(emp_id, skill) 확인:
- Key: {emp_id, skill}
- 자명한 MVD만 존재. 4NF ✓</p>
<p>R₂(emp_id, project) 확인:
- Key: {emp_id, project}
- 자명한 MVD만 존재. 4NF ✓</p>
<p><strong>최종 4NF 분해:</strong></p>
<div class="highlight"><pre><span></span><code>EmpSkill(emp_id, skill)       — key: {emp_id, skill}
EmpProject(emp_id, project)   — key: {emp_id, project}
</code></pre></div>

<h3 id="35-a-more-complex-example">3.5 더 복잡한 예제(A More Complex Example)<a class="header-link" href="#35-a-more-complex-example" title="Permanent link">&para;</a></h3>
<p>다음을 고려하세요:</p>
<div class="highlight"><pre><span></span><code>CourseBook(course, teacher, book)
</code></pre></div>

<p>다음을 가정합니다:
- 각 과목은 여러 교사가 가르칠 수 있습니다
- 각 과목은 여러 책을 사용합니다
- 과목에 사용되는 책은 누가 가르치는지와 관계없이 동일합니다</p>
<p>MVDs: course →→ teacher, course →→ book</p>
<p>하지만 다음도 있다고 가정합니다: teacher → book (각 교사는 특정 책을 사용하며, 이는 교사마다 다를 수 있습니다). 이는 MVD가 아니라 FD입니다. 이 경우, MVD course →→ book은 성립하지 않을 수 있고, 분석이 달라집니다.</p>
<p>이는 MVD를 식별하려면 실제 세계의 의미론을 주의 깊게 분석해야 함을 보여줍니다.</p>
<hr />
<h2 id="4-5fifth-normal-form-5nf-pjnf">4. 제5정규형(Fifth Normal Form, 5NF / PJNF)<a class="header-link" href="#4-5fifth-normal-form-5nf-pjnf" title="Permanent link">&para;</a></h2>
<h3 id="41-join-dependencies">4.1 조인 종속성(Join Dependencies)<a class="header-link" href="#41-join-dependencies" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: <strong>조인 종속성(join dependency, JD)</strong> ⋈{R₁, R₂, ..., Rₙ}이 릴레이션 R에 성립한다는 것은:</p>
<p>R = π_{R₁}(R) ⋈ π_{R₂}(R) ⋈ ... ⋈ π_{Rₙ}(R)</p>
<p>R의 모든 합법적인 인스턴스에 대해 성립함을 의미합니다.</p>
</blockquote>
<p>조인 종속성은 R이 항상 R₁, R₂, ..., Rₙ으로 무손실 분해될 수 있다고 말합니다.</p>
<h3 id="42-mvd-jd-mvds-as-special-case-of-jds">4.2 MVD를 JD의 특수 경우로(MVDs as Special Case of JDs)<a class="header-link" href="#42-mvd-jd-mvds-as-special-case-of-jds" title="Permanent link">&para;</a></h3>
<p>R에 대한 모든 MVD X →→ Y는 조인 종속성 ⋈{XY, XZ} (여기서 Z = R - X - Y)와 동등합니다.</p>
<p>따라서 MVD는 이진 조인 종속성(정확히 두 개의 구성 요소로의 분해)입니다. 일반 조인 종속성은 세 개 이상의 구성 요소로의 분해를 요구할 수 있습니다.</p>
<h3 id="43-5nf-definition-of-5nf">4.3 5NF의 정의(Definition of 5NF)<a class="header-link" href="#43-5nf-definition-of-5nf" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의</strong>: 릴레이션 스키마 R이 <strong>제5정규형(Fifth Normal Form, 5NF)</strong> 또는 <strong>Project-Join Normal Form (PJNF)</strong>에 있다는 것은, R에 성립하는 모든 비자명한 조인 종속성 ⋈{R₁, R₂, ..., Rₙ}에 대해:</p>
<p>모든 Rᵢ가 R의 슈퍼키입니다.</p>
</blockquote>
<p>5NF는 조인 종속성으로 정의된 가장 강력한 정규형입니다. 투영(projection)과 조인을 통해 감지할 수 있는 모든 중복성을 제거합니다.</p>
<h3 id="44-5nf-example-need-for-5nf">4.4 예제: 5NF의 필요성(Example: Need for 5NF)<a class="header-link" href="#44-5nf-example-need-for-5nf" title="Permanent link">&para;</a></h3>
<p>공급자, 부품, 프로젝트에 관한 릴레이션을 고려하세요:</p>
<div class="highlight"><pre><span></span><code>SPJ(supplier, part, project)
</code></pre></div>

<p>다음 제약조건이 성립한다고 가정합니다: "공급자 S가 부품 P를 공급하고, 부품 P가 프로젝트 J에 사용되며, 공급자 S가 프로젝트 J에 어떤 부품을 공급한다면, 공급자 S는 프로젝트 J에 부품 P를 공급합니다."</p>
<p>이는 <strong>순환 조인 종속성(cyclic join dependency)</strong>입니다:</p>
<p>⋈{(supplier, part), (part, project), (supplier, project)}</p>
<p>이는 SPJ = π_{supplier,part}(SPJ) ⋈ π_{part,project}(SPJ) ⋈ π_{supplier,project}(SPJ)를 의미합니다</p>
<p>이 JD는 어떤 MVD에 의해서도 함의되지 않습니다 (세 방향 분해가 필요합니다). 이 JD가 성립하고 전체 속성 집합이 유일한 키라면:
- 릴레이션은 4NF에 있을 수 있습니다 (비자명한 MVD가 없음)
- 하지만 5NF에는 <strong>없습니다</strong> (구성 요소가 슈퍼키가 아닌 비자명한 JD)</p>
<p><strong>분해:</strong></p>
<div class="highlight"><pre><span></span><code>SP(supplier, part)         — 어떤 공급자가 어떤 부품을 공급하는지
PJ(part, project)          — 어떤 부품이 어떤 프로젝트에 사용되는지
SJ(supplier, project)      — 어떤 공급자가 어떤 프로젝트에 공급하는지
</code></pre></div>

<h3 id="45-detecting-join-dependencies">4.5 조인 종속성 감지(Detecting Join Dependencies)<a class="header-link" href="#45-detecting-join-dependencies" title="Permanent link">&para;</a></h3>
<p>조인 종속성은 실무에서 감지하기 매우 어렵습니다:</p>
<ol>
<li>미묘합니다 — SPJ 예제의 순환 제약조건은 명백하지 않습니다</li>
<li>속성 폐포 계산과 유사한 간단한 테스트가 없습니다</li>
<li>데이터 검사가 아니라 도메인 지식으로부터 식별되어야 합니다</li>
</ol>
<p>이것이 5NF가 주로 이론적 관심사인 이유입니다.</p>
<hr />
<h2 id="5-domain-key-normal-form-dknf">5. 도메인-키 정규형(Domain-Key Normal Form, DKNF)<a class="header-link" href="#5-domain-key-normal-form-dknf" title="Permanent link">&para;</a></h2>
<h3 id="51-definition">5.1 정의(Definition)<a class="header-link" href="#51-definition" title="Permanent link">&para;</a></h3>
<blockquote>
<p><strong>정의 (Fagin, 1981)</strong>: 릴레이션 스키마 R이 <strong>도메인-키 정규형(Domain-Key Normal Form, DKNF)</strong>에 있다는 것은, R의 모든 제약조건이 R의 도메인 제약조건과 키 제약조건의 논리적 귀결임을 의미합니다.</p>
<ul>
<li><strong>도메인 제약조건(Domain constraint)</strong>: 속성의 허용 값에 대한 제한 (예: age &gt; 0, status ∈ {'active', 'inactive'})</li>
<li><strong>키 제약조건(Key constraint)</strong>: 속성 집합에 대한 유일성 제약조건</li>
</ul>
</blockquote>
<h3 id="52-significance">5.2 중요성(Significance)<a class="header-link" href="#52-significance" title="Permanent link">&para;</a></h3>
<p>DKNF는 "궁극의" 정규형입니다. 릴레이션이 DKNF에 있으면, 알려진 모든 유형의 종속성(FD, MVD, JD 또는 기타)으로 특성화될 수 있는 중복성이 <strong>없습니다</strong>.</p>
<p>그러나 DKNF는 중요한 제한이 있습니다:</p>
<blockquote>
<p><strong>릴레이션을 DKNF로 변환하는 일반 알고리즘은 존재하지 않습니다.</strong></p>
</blockquote>
<p>이는 DKNF를 이론적 이상으로 만듭니다 — 완벽한 정규화가 어떻게 보이는지 알려주지만, 모든 경우에 거기에 도달하는 방법을 알려주지 않습니다.</p>
<h3 id="53-example">5.3 예제(Example)<a class="header-link" href="#53-example" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Employee(emp_id, emp_name, dept, salary)
</code></pre></div>

<p>도메인 제약조건:
- emp_id: 양의 정수
- salary: 양의 십진수
- dept ∈ {'Engineering', 'Marketing', 'Sales', 'HR'}</p>
<p>키 제약조건: emp_id가 기본 키.</p>
<p>유일한 제약조건이 emp_id가 다른 모든 속성을 유일하게 결정한다는 것이고, 도메인 제약조건이 위와 같다면, 이 릴레이션은 DKNF에 있습니다 — 모든 제약조건이 키와 도메인 제약조건만으로부터 따라옵니다.</p>
<h3 id="54-dknf-when-dknf-fails">5.4 DKNF 실패 경우(When DKNF Fails)<a class="header-link" href="#54-dknf-when-dknf-fails" title="Permanent link">&para;</a></h3>
<p>릴레이션이 DKNF에 <strong>없는</strong> 경우는 도메인 또는 키 제약조건으로 표현할 수 없는 제약조건이 있을 때입니다. 예를 들어:</p>
<div class="highlight"><pre><span></span><code>Employee(emp_id, emp_name, dept, dept_budget)
</code></pre></div>

<p>제약조건: dept → dept_budget (같은 부서의 모든 직원은 동일한 예산을 봅니다).</p>
<p>이는 키 제약조건이 <strong>아닌</strong> FD입니다 (dept는 키가 아닙니다). 따라서 이 릴레이션은 DKNF에 없습니다. 해결책: Employee(emp_id, emp_name, dept)와 Department(dept, dept_budget)로 분해하며, dept는 Department 테이블에서 키입니다.</p>
<h3 id="55-practical-relevance">5.5 실용적 관련성(Practical Relevance)<a class="header-link" href="#55-practical-relevance" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>정규형</th>
<th>실무 사용</th>
</tr>
</thead>
<tbody>
<tr>
<td>1NF - BCNF</td>
<td>매우 일반적. 모든 데이터베이스 설계자가 알아야 합니다.</td>
</tr>
<tr>
<td>4NF</td>
<td>가끔 필요. 독립적인 다대다 관계.</td>
</tr>
<tr>
<td>5NF</td>
<td>드뭅니다. 특정 도메인의 순환 제약조건.</td>
</tr>
<tr>
<td>DKNF</td>
<td>이론적. 실용적 알고리즘이 존재하지 않습니다.</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6-summary-of-all-normal-forms">6. 모든 정규형의 요약(Summary of All Normal Forms)<a class="header-link" href="#6-summary-of-all-normal-forms" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>NF</th>
<th>조건</th>
<th>제거하는 것</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1NF</strong></td>
<td>원자적 값</td>
<td>비관계형 구조</td>
</tr>
<tr>
<td><strong>2NF</strong></td>
<td>부분 FD 없음</td>
<td>부분 키 종속성</td>
</tr>
<tr>
<td><strong>3NF</strong></td>
<td>이행 FD 없음 (주 속성 예외 있음)</td>
<td>이행 종속성</td>
</tr>
<tr>
<td><strong>BCNF</strong></td>
<td>모든 FD 결정자가 슈퍼키</td>
<td>모든 FD 기반 중복성</td>
</tr>
<tr>
<td><strong>4NF</strong></td>
<td>모든 비자명한 MVD 결정자가 슈퍼키</td>
<td>MVD 기반 중복성</td>
</tr>
<tr>
<td><strong>5NF</strong></td>
<td>모든 비자명한 JD 구성 요소가 슈퍼키</td>
<td>JD 기반 중복성</td>
</tr>
<tr>
<td><strong>DKNF</strong></td>
<td>모든 제약조건이 도메인 + 키로부터 따라옴</td>
<td>모든 가능한 중복성</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="7-denormalization">7. 비정규화(Denormalization)<a class="header-link" href="#7-denormalization" title="Permanent link">&para;</a></h2>
<h3 id="71-when-to-denormalize">7.1 언제 비정규화할까(When to Denormalize)<a class="header-link" href="#71-when-to-denormalize" title="Permanent link">&para;</a></h3>
<p>정규화는 <strong>데이터 무결성</strong>과 <strong>저장 효율성</strong>을 최적화합니다. 하지만 실제 시스템은 <strong>읽기 성능</strong>도 필요합니다. 비정규화는 쿼리 성능을 향상시키기 위해 의도적으로 중복성을 도입하는 것입니다.</p>
<p>비정규화하는 일반적인 이유:</p>
<ol>
<li><strong>비용이 많이 드는 조인</strong>: 많은 테이블을 조인하는 자주 실행되는 쿼리</li>
<li><strong>집계 성능</strong>: 사전 계산된 count, sum, average</li>
<li><strong>읽기 중심 워크로드</strong>: 읽기가 쓰기보다 훨씬 많은 시스템 (예: 100:1 비율)</li>
<li><strong>보고 및 분석</strong>: 과거 데이터에 대한 복잡한 분석 쿼리</li>
<li><strong>지연 시간 요구사항</strong>: 밀리초 이하의 응답 시간</li>
</ol>
<h3 id="72-denormalization-techniques">7.2 비정규화 기법(Denormalization Techniques)<a class="header-link" href="#72-denormalization-techniques" title="Permanent link">&para;</a></h3>
<h4 id="1-prejoined-tables">기법 1: 사전 조인된 테이블(Prejoined Tables)<a class="header-link" href="#1-prejoined-tables" title="Permanent link">&para;</a></h4>
<p>여러 정규화된 테이블의 데이터를 단일 테이블에 저장:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 정규화됨: 조인 필요</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">order_id</span><span class="p">,</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">order_date</span><span class="p">,</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">customer_name</span><span class="p">,</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">email</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="n">o</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">customers</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">customer_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>

<span class="c1">-- 비정규화됨: 조인 불필요</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">order_id</span><span class="p">,</span><span class="w"> </span><span class="n">order_date</span><span class="p">,</span><span class="w"> </span><span class="n">customer_name</span><span class="p">,</span><span class="w"> </span><span class="n">customer_email</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">orders_denormalized</span><span class="p">;</span>
</code></pre></div>

<p><strong>트레이드오프</strong>: 더 빠른 읽기, 하지만 customer_name과 customer_email이 모든 주문에 걸쳐 중복됩니다.</p>
<h4 id="2-derivedcomputed-columns">기법 2: 파생/계산 열(Derived/Computed Columns)<a class="header-link" href="#2-derivedcomputed-columns" title="Permanent link">&para;</a></h4>
<p>사전 계산된 값 저장:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 매번 계산하는 대신:</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">order_id</span><span class="p">,</span><span class="w"> </span><span class="k">SUM</span><span class="p">(</span><span class="n">quantity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">price</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">total</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">order_items</span>
<span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">order_id</span><span class="p">;</span>

<span class="c1">-- 총액을 직접 저장:</span>
<span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="n">total_amount</span><span class="w"> </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">);</span>

<span class="c1">-- 각 항목 변경 시 업데이트:</span>
<span class="k">UPDATE</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">total_amount</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="k">SUM</span><span class="p">(</span><span class="n">quantity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">price</span><span class="p">)</span>
<span class="w">    </span><span class="k">FROM</span><span class="w"> </span><span class="n">order_items</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">order_items</span><span class="p">.</span><span class="n">order_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">orders</span><span class="p">.</span><span class="n">order_id</span>
<span class="p">)</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">order_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">;</span>
</code></pre></div>

<h4 id="3-redundant-columns">기법 3: 중복 열(Redundant Columns)<a class="header-link" href="#3-redundant-columns" title="Permanent link">&para;</a></h4>
<p>조인을 피하기 위해 자주 액세스되는 외래 테이블 열 추가:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 정규화됨</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">order_id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">customer_id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">customers</span><span class="p">(</span><span class="n">customer_id</span><span class="p">),</span>
<span class="w">    </span><span class="n">order_date</span><span class="w"> </span><span class="nb">DATE</span>
<span class="p">);</span>

<span class="c1">-- 비정규화됨: 표시 목적으로 customer_name 추가</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">order_id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">customer_id</span><span class="w"> </span><span class="nb">INT</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">customers</span><span class="p">(</span><span class="n">customer_id</span><span class="p">),</span>
<span class="w">    </span><span class="n">customer_name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span><span class="w">  </span><span class="c1">-- 중복이지만 조인을 피함</span>
<span class="w">    </span><span class="n">order_date</span><span class="w"> </span><span class="nb">DATE</span>
<span class="p">);</span>
</code></pre></div>

<h4 id="4-summaryaggregate-tables">기법 4: 요약/집계 테이블(Summary/Aggregate Tables)<a class="header-link" href="#4-summaryaggregate-tables" title="Permanent link">&para;</a></h4>
<p>사전 계산된 집계를 위한 별도의 테이블 생성:</p>
<div class="highlight"><pre><span></span><code><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">daily_sales_summary</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">sale_date</span><span class="w">   </span><span class="nb">DATE</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">total_orders</span><span class="w"> </span><span class="nb">INT</span><span class="p">,</span>
<span class="w">    </span><span class="n">total_revenue</span><span class="w"> </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
<span class="w">    </span><span class="n">avg_order_value</span><span class="w"> </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">);</span>

<span class="c1">-- 야간 배치 작업 또는 트리거로 채워짐</span>
</code></pre></div>

<h4 id="5-materialized-views">기법 5: 구체화된 뷰(Materialized Views)<a class="header-link" href="#5-materialized-views" title="Permanent link">&para;</a></h4>
<p>일부 데이터베이스는 구체화된 뷰를 지원합니다 — 테이블로 저장된 사전 계산 쿼리 결과:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL</span>
<span class="k">CREATE</span><span class="w"> </span><span class="n">MATERIALIZED</span><span class="w"> </span><span class="k">VIEW</span><span class="w"> </span><span class="n">product_sales_summary</span><span class="w"> </span><span class="k">AS</span>
<span class="k">SELECT</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">product_id</span><span class="p">,</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">product_name</span><span class="p">,</span>
<span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">category</span><span class="p">,</span>
<span class="w">    </span><span class="k">COUNT</span><span class="p">(</span><span class="n">oi</span><span class="p">.</span><span class="n">order_id</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">times_ordered</span><span class="p">,</span>
<span class="w">    </span><span class="k">SUM</span><span class="p">(</span><span class="n">oi</span><span class="p">.</span><span class="n">quantity</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">total_quantity</span><span class="p">,</span>
<span class="w">    </span><span class="k">SUM</span><span class="p">(</span><span class="n">oi</span><span class="p">.</span><span class="n">quantity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">oi</span><span class="p">.</span><span class="n">price</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">total_revenue</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">products</span><span class="w"> </span><span class="n">p</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">order_items</span><span class="w"> </span><span class="n">oi</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">product_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oi</span><span class="p">.</span><span class="n">product_id</span>
<span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">product_id</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">product_name</span><span class="p">,</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">category</span><span class="p">;</span>

<span class="c1">-- 주기적으로 새로고침</span>
<span class="n">REFRESH</span><span class="w"> </span><span class="n">MATERIALIZED</span><span class="w"> </span><span class="k">VIEW</span><span class="w"> </span><span class="n">product_sales_summary</span><span class="p">;</span>
</code></pre></div>

<h3 id="73-managing-denormalized-data">7.3 비정규화된 데이터 관리(Managing Denormalized Data)<a class="header-link" href="#73-managing-denormalized-data" title="Permanent link">&para;</a></h3>
<p>비정규화는 정규화가 방지하도록 설계된 바로 그 이상 현상들을 도입합니다. 이를 관리하는 전략:</p>
<p><strong>1. 애플리케이션 수준 강제(Application-level enforcement)</strong></p>
<p>애플리케이션이 쓰기 시 일관성을 보장:</p>
<div class="highlight"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">update_customer_name</span><span class="p">(</span><span class="n">customer_id</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
    <span class="c1"># 정규화된 소스 업데이트</span>
    <span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;UPDATE customers SET name = ? WHERE id = ?&quot;</span><span class="p">,</span>
               <span class="n">new_name</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">)</span>

    <span class="c1"># 모든 비정규화된 복사본 업데이트</span>
    <span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;UPDATE orders SET customer_name = ? WHERE customer_id = ?&quot;</span><span class="p">,</span>
               <span class="n">new_name</span><span class="p">,</span> <span class="n">customer_id</span><span class="p">)</span>
    <span class="n">db</span><span class="o">.</span><span class="n">commit</span><span class="p">()</span>
</code></pre></div>

<p><strong>2. 데이터베이스 트리거(Database triggers)</strong></p>
<p>데이터베이스가 일관성을 자동으로 유지하도록 합니다:</p>
<div class="highlight"><pre><span></span><code><span class="k">CREATE</span><span class="w"> </span><span class="k">OR</span><span class="w"> </span><span class="k">REPLACE</span><span class="w"> </span><span class="k">FUNCTION</span><span class="w"> </span><span class="n">sync_customer_name</span><span class="p">()</span>
<span class="k">RETURNS</span><span class="w"> </span><span class="k">TRIGGER</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="err">$$</span>
<span class="k">BEGIN</span>
<span class="w">    </span><span class="k">IF</span><span class="w"> </span><span class="k">NEW</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">OLD</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">        </span><span class="k">UPDATE</span><span class="w"> </span><span class="n">orders</span>
<span class="w">        </span><span class="k">SET</span><span class="w"> </span><span class="n">customer_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">NEW</span><span class="p">.</span><span class="n">name</span>
<span class="w">        </span><span class="k">WHERE</span><span class="w"> </span><span class="n">customer_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">NEW</span><span class="p">.</span><span class="n">customer_id</span><span class="p">;</span>
<span class="w">    </span><span class="k">END</span><span class="w"> </span><span class="k">IF</span><span class="p">;</span>
<span class="w">    </span><span class="k">RETURN</span><span class="w"> </span><span class="k">NEW</span><span class="p">;</span>
<span class="k">END</span><span class="p">;</span>
<span class="err">$$</span><span class="w"> </span><span class="k">LANGUAGE</span><span class="w"> </span><span class="n">plpgsql</span><span class="p">;</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TRIGGER</span><span class="w"> </span><span class="n">trg_customer_name_sync</span>
<span class="k">AFTER</span><span class="w"> </span><span class="k">UPDATE</span><span class="w"> </span><span class="k">OF</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">customers</span>
<span class="k">FOR</span><span class="w"> </span><span class="k">EACH</span><span class="w"> </span><span class="k">ROW</span><span class="w"> </span><span class="k">EXECUTE</span><span class="w"> </span><span class="k">FUNCTION</span><span class="w"> </span><span class="n">sync_customer_name</span><span class="p">();</span>
</code></pre></div>

<p><strong>3. 최종 일관성(Eventual consistency)</strong></p>
<p>비정규화된 데이터가 일시적으로 오래될 수 있음을 수용:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 신선도 추적을 위한 last_synced 타임스탬프 사용</span>
<span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">orders_denormalized</span><span class="w"> </span><span class="k">ADD</span><span class="w"> </span><span class="k">COLUMN</span><span class="w"> </span><span class="n">last_synced</span><span class="w"> </span><span class="k">TIMESTAMP</span><span class="p">;</span>

<span class="c1">-- 백그라운드 작업이 주기적으로 새로고침</span>
<span class="k">UPDATE</span><span class="w"> </span><span class="n">orders_denormalized</span><span class="w"> </span><span class="n">od</span>
<span class="k">SET</span><span class="w"> </span><span class="n">customer_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">last_synced</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NOW</span><span class="p">()</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">customers</span><span class="w"> </span><span class="k">c</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">od</span><span class="p">.</span><span class="n">customer_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">customer_id</span>
<span class="k">AND</span><span class="w"> </span><span class="n">od</span><span class="p">.</span><span class="n">customer_name</span><span class="w"> </span><span class="o">&lt;&gt;</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
</code></pre></div>

<h3 id="74-the-normalization-denormalization-spectrum">7.4 정규화-비정규화 스펙트럼(The Normalization-Denormalization Spectrum)<a class="header-link" href="#74-the-normalization-denormalization-spectrum" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>완전 정규화 (BCNF/4NF)                완전 비정규화
├──────────────────────────────────────────────────┤
│                                                      │
│  ✓ 중복성 없음          ✗ 최대 중복성                │
│  ✓ 이상 현상 없음       ✗ 모든 이상 현상 가능        │
│  ✗ 많은 조인 필요        ✓ 조인 불필요                │
│  ✗ 복잡한 쿼리           ✓ 간단한 쿼리                │
│  ✓ 쓰기 최적화           ✓ 읽기 최적화                │
│                                                      │
│         OLTP 시스템 ←──────→ OLAP/분석              │
</code></pre></div>

<h3 id="75-decision-framework">7.5 의사결정 프레임워크(Decision Framework)<a class="header-link" href="#75-decision-framework" title="Permanent link">&para;</a></h3>
<p>비정규화하기 전에 다음 질문들을 하세요:</p>
<ol>
<li><strong>조인이 정말 병목인가?</strong> 먼저 프로파일링하세요. 종종 적절한 인덱싱이 비정규화의 필요성을 제거합니다.</li>
<li><strong>읽기:쓰기 비율은 얼마인가?</strong> 비정규화는 읽기가 지배적일 때 (&gt;10:1) 가장 도움이 됩니다.</li>
<li><strong>일관성이 얼마나 중요한가?</strong> 금융 시스템은 완벽한 일관성을 요구합니다; 추천 엔진은 약간의 지연을 허용할 수 있습니다.</li>
<li><strong>구체화된 뷰로 충분한가?</strong> 기본 스키마를 수정하지 않고 비정규화의 이점을 제공합니다.</li>
<li><strong>팀이 유지보수할 준비가 되어 있나?</strong> 비정규화된 스키마는 규율이 필요합니다 — 모든 쓰기 경로가 모든 복사본을 업데이트해야 합니다.</li>
</ol>
<hr />
<h2 id="8-star-schema-and-snowflake-schema">8. 스타 스키마와 스노플레이크 스키마(Star Schema and Snowflake Schema)<a class="header-link" href="#8-star-schema-and-snowflake-schema" title="Permanent link">&para;</a></h2>
<p>데이터 웨어하우징은 분석 쿼리에 최적화된 특정 비정규화 패턴을 사용합니다.</p>
<h3 id="81-star-schema">8.1 스타 스키마(Star Schema)<a class="header-link" href="#81-star-schema" title="Permanent link">&para;</a></h3>
<p>스타 스키마는 가장 간단한 데이터 웨어하우스 패턴입니다. 다음으로 구성됩니다:
- 중심에 하나의 <strong>팩트 테이블(fact table)</strong> (측정/이벤트)
- 바깥으로 방사하는 여러 <strong>차원 테이블(dimension tables)</strong> (설명 속성)</p>
<div class="highlight"><pre><span></span><code><span class="w">                    </span><span class="err">┌──────────────┐</span>
<span class="w">                    </span><span class="err">│</span><span class="w">   </span><span class="n">dim_date</span><span class="w">   </span><span class="err">│</span>
<span class="w">                    </span><span class="err">│──────────────│</span>
<span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">date_key</span><span class="w"> </span><span class="p">(</span><span class="n">PK</span><span class="p">)</span><span class="err">│</span>
<span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">full_date</span><span class="w">    </span><span class="err">│</span>
<span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">year</span><span class="w">         </span><span class="err">│</span>
<span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">quarter</span><span class="w">      </span><span class="err">│</span>
<span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">month</span><span class="w">        </span><span class="err">│</span>
<span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">day_of_week</span><span class="w">  </span><span class="err">│</span>
<span class="w">                    </span><span class="err">└──────┬───────┘</span>
<span class="w">                           </span><span class="err">│</span>
<span class="err">┌──────────────┐</span><span class="w">    </span><span class="err">┌──────┴───────┐</span><span class="w">    </span><span class="err">┌──────────────┐</span>
<span class="err">│</span><span class="w"> </span><span class="n">dim_product</span><span class="w">  </span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w">  </span><span class="n">fact_sales</span><span class="w">  </span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">dim_customer</span><span class="w"> </span><span class="err">│</span>
<span class="err">│──────────────│</span><span class="w">    </span><span class="err">│──────────────│</span><span class="w">    </span><span class="err">│──────────────│</span>
<span class="err">│</span><span class="w"> </span><span class="n">product_key</span><span class="w">  </span><span class="err">│◄───│</span><span class="w"> </span><span class="n">product_key</span><span class="w">  </span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">customer_key</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w"> </span><span class="n">product_name</span><span class="w"> </span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">customer_key</span><span class="w"> </span><span class="err">│───►│</span><span class="w"> </span><span class="n">cust_name</span><span class="w">    </span><span class="err">│</span>
<span class="err">│</span><span class="w"> </span><span class="n">category</span><span class="w">     </span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">date_key</span><span class="w">     </span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">city</span><span class="w">         </span><span class="err">│</span>
<span class="err">│</span><span class="w"> </span><span class="n">subcategory</span><span class="w">  </span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">store_key</span><span class="w">    </span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">state</span><span class="w">        </span><span class="err">│</span>
<span class="err">│</span><span class="w"> </span><span class="n">brand</span><span class="w">        </span><span class="err">│</span><span class="w">    </span><span class="err">│──────────────│</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">segment</span><span class="w">      </span><span class="err">│</span>
<span class="err">└──────────────┘</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">quantity</span><span class="w">     </span><span class="err">│</span><span class="w">    </span><span class="err">└──────────────┘</span>
<span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">unit_price</span><span class="w">   </span><span class="err">│</span>
<span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">total_amount</span><span class="w"> </span><span class="err">│</span><span class="w">    </span><span class="err">┌──────────────┐</span>
<span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="n">discount</span><span class="w">     </span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w">  </span><span class="n">dim_store</span><span class="w">   </span><span class="err">│</span>
<span class="w">                    </span><span class="err">└──────┬───────┘</span><span class="w">    </span><span class="err">│──────────────│</span>
<span class="w">                           </span><span class="err">│</span><span class="w">            </span><span class="err">│</span><span class="w"> </span><span class="n">store_key</span><span class="w">    </span><span class="err">│</span>
<span class="w">                           </span><span class="err">└───────────►│</span><span class="w"> </span><span class="n">store_name</span><span class="w">   </span><span class="err">│</span>
<span class="w">                                        </span><span class="err">│</span><span class="w"> </span><span class="n">city</span><span class="w">         </span><span class="err">│</span>
<span class="w">                                        </span><span class="err">│</span><span class="w"> </span><span class="n">state</span><span class="w">        </span><span class="err">│</span>
<span class="w">                                        </span><span class="err">│</span><span class="w"> </span><span class="n">region</span><span class="w">       </span><span class="err">│</span>
<span class="w">                                        </span><span class="err">└──────────────┘</span>
</code></pre></div>

<p><strong>주요 특징:</strong>
- 팩트 테이블은 모든 차원 테이블에 대한 외래 키를 가집니다
- 차원 테이블은 <strong>비정규화</strong>되어 있습니다 (예: dim_product는 category와 subcategory를 하나의 평면 테이블에 가집니다)
- 쿼리는 일반적으로 차원에 필터링하고 팩트를 집계합니다</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 전형적인 스타 스키마 쿼리: 제품 카테고리 및 분기별 총 판매액</span>
<span class="k">SELECT</span>
<span class="w">    </span><span class="n">d</span><span class="p">.</span><span class="n">category</span><span class="p">,</span>
<span class="w">    </span><span class="n">dd</span><span class="p">.</span><span class="k">year</span><span class="p">,</span>
<span class="w">    </span><span class="n">dd</span><span class="p">.</span><span class="n">quarter</span><span class="p">,</span>
<span class="w">    </span><span class="k">SUM</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">total_amount</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">total_sales</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">fact_sales</span><span class="w"> </span><span class="n">f</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">dim_product</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">product_key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">product_key</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">dim_date</span><span class="w"> </span><span class="n">dd</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">date_key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dd</span><span class="p">.</span><span class="n">date_key</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">dd</span><span class="p">.</span><span class="k">year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2025</span>
<span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">category</span><span class="p">,</span><span class="w"> </span><span class="n">dd</span><span class="p">.</span><span class="k">year</span><span class="p">,</span><span class="w"> </span><span class="n">dd</span><span class="p">.</span><span class="n">quarter</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">dd</span><span class="p">.</span><span class="n">quarter</span><span class="p">,</span><span class="w"> </span><span class="n">total_sales</span><span class="w"> </span><span class="k">DESC</span><span class="p">;</span>
</code></pre></div>

<h3 id="82-snowflake-schema">8.2 스노플레이크 스키마(Snowflake Schema)<a class="header-link" href="#82-snowflake-schema" title="Permanent link">&para;</a></h3>
<p>스노플레이크 스키마는 차원 테이블을 하위 차원으로 정규화합니다:</p>
<div class="highlight"><pre><span></span><code>                         ┌──────────────┐
                         │  dim_brand   │
                         │──────────────│
                         │ brand_key    │
                         │ brand_name   │
                         │ manufacturer │
                         └──────┬───────┘
                                │
┌──────────────┐    ┌───────────┴──┐    ┌──────────────┐
│dim_subcategory│   │ dim_product  │    │  fact_sales  │
│──────────────│    │──────────────│    │──────────────│
│ subcat_key   │◄───│ product_key  │◄───│ product_key  │
│ subcat_name  │    │ product_name │    │ customer_key │
│ category_key │    │ subcat_key   │    │ date_key     │
└──────┬───────┘    │ brand_key    │    │ quantity     │
       │            └──────────────┘    │ total_amount │
┌──────┴───────┐                        └──────────────┘
│dim_category  │
│──────────────│
│ category_key │
│ category_name│
└──────────────┘
</code></pre></div>

<p><strong>주요 특징:</strong>
- 차원 테이블이 <strong>정규화</strong>되어 있습니다 (3NF 또는 BCNF)
- 큰 차원 테이블의 저장 공간 감소
- 쿼리에 더 많은 조인 필요</p>
<h3 id="83-vs-star-vs-snowflake">8.3 스타 vs 스노플레이크(Star vs Snowflake)<a class="header-link" href="#83-vs-star-vs-snowflake" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>측면</th>
<th>스타 스키마</th>
<th>스노플레이크 스키마</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>차원 구조</strong></td>
<td>평면 (비정규화)</td>
<td>정규화 (2NF-BCNF)</td>
</tr>
<tr>
<td><strong>쿼리 복잡성</strong></td>
<td>더 간단 (더 적은 조인)</td>
<td>더 복잡 (더 많은 조인)</td>
</tr>
<tr>
<td><strong>쿼리 성능</strong></td>
<td>더 빠름 (더 적은 조인)</td>
<td>더 느림 (더 많은 조인)</td>
</tr>
<tr>
<td><strong>저장 공간</strong></td>
<td>더 많음 (차원의 중복성)</td>
<td>더 적음 (중복성 없음)</td>
</tr>
<tr>
<td><strong>ETL 복잡성</strong></td>
<td>더 간단</td>
<td>더 복잡</td>
</tr>
<tr>
<td><strong>유지보수</strong></td>
<td>업데이트가 더 많은 행에 영향</td>
<td>업데이트가 격리됨</td>
</tr>
<tr>
<td><strong>업계 선호도</strong></td>
<td>가장 일반적</td>
<td>차원이 매우 클 때 사용</td>
</tr>
</tbody>
</table>
<h3 id="84-fact-table-types">8.4 팩트 테이블 유형(Fact Table Types)<a class="header-link" href="#84-fact-table-types" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>유형</th>
<th>설명</th>
<th>예</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>트랜잭션(Transaction)</strong></td>
<td>이벤트당 하나의 행</td>
<td>각 판매, 클릭, 로그인</td>
</tr>
<tr>
<td><strong>주기적 스냅샷(Periodic snapshot)</strong></td>
<td>정기적 간격</td>
<td>일일 계좌 잔액, 월별 재고</td>
</tr>
<tr>
<td><strong>누적 스냅샷(Accumulating snapshot)</strong></td>
<td>생애주기 추적</td>
<td>주문: 주문됨 → 배송됨 → 배달됨 날짜</td>
</tr>
<tr>
<td><strong>팩트리스 팩트(Factless fact)</strong></td>
<td>측정값이 없는 이벤트</td>
<td>학생 출석 (키만)</td>
</tr>
</tbody>
</table>
<h3 id="85-slowly-changing-dimensions-scd">8.5 느리게 변하는 차원(Slowly Changing Dimensions, SCD)<a class="header-link" href="#85-slowly-changing-dimensions-scd" title="Permanent link">&para;</a></h3>
<p>차원 속성이 시간에 따라 변할 때:</p>
<p><strong>유형 1: 덮어쓰기(Overwrite)</strong> — 단순히 값을 업데이트. 이력을 잃습니다.</p>
<div class="highlight"><pre><span></span><code><span class="k">UPDATE</span><span class="w"> </span><span class="n">dim_customer</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">city</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;New York&#39;</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">customer_key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">;</span>
</code></pre></div>

<p><strong>유형 2: 새 행 추가(Add new row)</strong> — 유효 날짜가 있는 새 차원 행을 생성.</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 전: 고객이 Boston에 살았음</span>
<span class="o">|</span><span class="w"> </span><span class="n">customer_key</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">cust_id</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">city</span><span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">valid_from</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">valid_to</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="k">current</span><span class="w"> </span><span class="o">|</span>
<span class="o">|</span><span class="c1">-------------|---------|---------|------------|------------|---------|</span>
<span class="o">|</span><span class="w"> </span><span class="mi">42</span><span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="n">C100</span><span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Boston</span><span class="w">  </span><span class="o">|</span><span class="w"> </span><span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">01</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">9999</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">31</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Y</span><span class="w">       </span><span class="o">|</span>

<span class="c1">-- 후: 고객이 New York으로 이사</span>
<span class="o">|</span><span class="w"> </span><span class="n">customer_key</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">cust_id</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">city</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">valid_from</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">valid_to</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="k">current</span><span class="w"> </span><span class="o">|</span>
<span class="o">|</span><span class="c1">-------------|---------|----------|------------|------------|---------|</span>
<span class="o">|</span><span class="w"> </span><span class="mi">42</span><span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="n">C100</span><span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="n">Boston</span><span class="w">   </span><span class="o">|</span><span class="w"> </span><span class="mi">2020</span><span class="o">-</span><span class="mi">01</span><span class="o">-</span><span class="mi">01</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">2025</span><span class="o">-</span><span class="mi">06</span><span class="o">-</span><span class="mi">30</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">N</span><span class="w">       </span><span class="o">|</span>
<span class="o">|</span><span class="w"> </span><span class="mi">99</span><span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="n">C100</span><span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="k">New</span><span class="w"> </span><span class="n">York</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">2025</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">01</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="mi">9999</span><span class="o">-</span><span class="mi">12</span><span class="o">-</span><span class="mi">31</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Y</span><span class="w">       </span><span class="o">|</span>
</code></pre></div>

<p><strong>유형 3: 새 열 추가(Add new column)</strong> — 이전 값을 추적.</p>
<div class="highlight"><pre><span></span><code><span class="o">|</span><span class="w"> </span><span class="n">customer_key</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">city</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">prev_city</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">city_change_date</span><span class="w"> </span><span class="o">|</span>
<span class="o">|</span><span class="c1">-------------|----------|-----------|-----------------|</span>
<span class="o">|</span><span class="w"> </span><span class="mi">42</span><span class="w">          </span><span class="o">|</span><span class="w"> </span><span class="k">New</span><span class="w"> </span><span class="n">York</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">Boston</span><span class="w">    </span><span class="o">|</span><span class="w"> </span><span class="mi">2025</span><span class="o">-</span><span class="mi">07</span><span class="o">-</span><span class="mi">01</span><span class="w">      </span><span class="o">|</span>
</code></pre></div>

<hr />
<h2 id="9-practical-normalization-guidelines">9. 실용적 정규화 지침(Practical Normalization Guidelines)<a class="header-link" href="#9-practical-normalization-guidelines" title="Permanent link">&para;</a></h2>
<h3 id="91-rules-of-thumb">9.1 경험 법칙(Rules of Thumb)<a class="header-link" href="#91-rules-of-thumb" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p><strong>정규화로 시작하고, 필요성이 입증되면 비정규화하세요</strong>. 조기 비정규화는 흔한 실수입니다.</p>
</li>
<li>
<p><strong>OLTP 시스템</strong>: 최소 3NF, 가급적 BCNF로 정규화하세요. 쓰기 중심 워크로드는 일관성을 요구합니다.</p>
</li>
<li>
<p><strong>OLAP/분석</strong>: 스타 또는 스노플레이크 스키마를 사용하세요. 읽기 중심 분석 워크로드는 더 적은 조인으로 이득을 봅니다.</p>
</li>
<li>
<p><strong>마이크로서비스</strong>: 각 서비스가 자체 데이터를 소유합니다. 서비스 내에서는 정규화하고; 서비스 간 중복성은 수용합니다.</p>
</li>
<li>
<p><strong>NoSQL 데이터베이스</strong>: 문서 저장소(MongoDB)는 종종 내장/비정규화 구조를 사용합니다. 그래프 데이터베이스는 자체 모델링 패턴을 가집니다. 관계형 정규화 이론은 주로 관계형 데이터베이스에 적용됩니다.</p>
</li>
</ol>
<h3 id="92-common-patterns">9.2 일반적인 패턴(Common Patterns)<a class="header-link" href="#92-common-patterns" title="Permanent link">&para;</a></h3>
<p><strong>패턴 1: 룩업 테이블(Lookup tables)</strong> — 작고 거의 변하지 않는 참조 데이터.</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 항상 정규화: 국가, 통화, 상태 코드</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">country</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">country_code</span><span class="w"> </span><span class="nb">CHAR</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">country_name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span>
<span class="p">);</span>
</code></pre></div>

<p><strong>패턴 2: 감사/이력 테이블(Audit/history tables)</strong> — 의도적으로 비정규화.</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 이벤트 시점의 데이터 스냅샷 저장</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">order_audit</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">audit_id</span><span class="w">       </span><span class="nb">SERIAL</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">order_id</span><span class="w">       </span><span class="nb">INT</span><span class="p">,</span>
<span class="w">    </span><span class="n">customer_name</span><span class="w">  </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span><span class="w">  </span><span class="c1">-- 스냅샷, FK 아님</span>
<span class="w">    </span><span class="n">product_name</span><span class="w">   </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span><span class="w">  </span><span class="c1">-- 스냅샷, FK 아님</span>
<span class="w">    </span><span class="n">total_amount</span><span class="w">   </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">),</span>
<span class="w">    </span><span class="n">recorded_at</span><span class="w">    </span><span class="k">TIMESTAMP</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">NOW</span><span class="p">()</span>
<span class="p">);</span>
</code></pre></div>

<p><strong>패턴 3: 캐시 테이블(Cache tables)</strong> — 성능을 위해 사전 계산.</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 정규화된 소스: orders + order_items로부터 계산</span>
<span class="c1">-- 캐시: 트리거 또는 배치 작업으로 업데이트</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">customer_stats</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">customer_id</span><span class="w">     </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">customers</span><span class="p">(</span><span class="n">customer_id</span><span class="p">),</span>
<span class="w">    </span><span class="n">total_orders</span><span class="w">    </span><span class="nb">INT</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">total_spent</span><span class="w">     </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span>
<span class="w">    </span><span class="n">last_order_date</span><span class="w"> </span><span class="nb">DATE</span><span class="p">,</span>
<span class="w">    </span><span class="n">updated_at</span><span class="w">      </span><span class="k">TIMESTAMP</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="n">NOW</span><span class="p">()</span>
<span class="p">);</span>
</code></pre></div>

<h3 id="93-anti-patterns-to-avoid">9.3 피해야 할 안티패턴(Anti-Patterns to Avoid)<a class="header-link" href="#93-anti-patterns-to-avoid" title="Permanent link">&para;</a></h3>
<p><strong>1. Entity-Attribute-Value (EAV)</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 피할 것: 유사-유연하지만 쿼리와 무결성에 끔찍함</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">attributes</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">entity_id</span><span class="w">   </span><span class="nb">INT</span><span class="p">,</span>
<span class="w">    </span><span class="n">attr_name</span><span class="w">   </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
<span class="w">    </span><span class="n">attr_value</span><span class="w">  </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">500</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>

<p>문제: 타입 안전성 없음, 참조 무결성 없음, 끔찍한 쿼리 성능.</p>
<p><strong>2. 과정규화(Over-normalization)</strong></p>
<p><code>Address(street, city, state, zip)</code>와 같은 테이블을 <code>Address(street, zip_id)</code> + <code>ZipCode(zip_id, city, state)</code>로 분할하는 것은 기술적으로 올바르지만 (zip → city, state) 거의 유익하지 않습니다 — 우편번호 데이터는 극히 드물게 변합니다.</p>
<p><strong>3. One True Lookup Table (OTLT)</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 피할 것: 모든 참조 데이터를 하나의 테이블에 넣기</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">lookup</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">lookup_type</span><span class="w">  </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
<span class="w">    </span><span class="n">lookup_code</span><span class="w">  </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
<span class="w">    </span><span class="n">lookup_value</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">200</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>

<p>문제: 외래 키 무결성 없음, 타입별 검증 없음, 혼란스러운 의미론.</p>
<hr />
<h2 id="10-exercises">10. 연습문제(Exercises)<a class="header-link" href="#10-exercises" title="Permanent link">&para;</a></h2>
<h3 id="1-mvd-identifying-mvds">연습문제 1: MVD 식별(Identifying MVDs)<a class="header-link" href="#1-mvd-identifying-mvds" title="Permanent link">&para;</a></h3>
<p>R(student, course, hobby)가 주어지고, 학생의 과목들이 그들의 취미와 독립적이라면:</p>
<ol>
<li>어떤 MVD가 성립하나요?</li>
<li>가장 높은 정규형은 무엇인가요?</li>
<li>4NF로 분해하세요.</li>
</ol>
<details>
<summary>해답</summary>

1. **MVDs**: student →→ course 그리고 student →→ hobby (보완에 의해)

2. **가장 높은 NF**: 유일한 키는 {student, course, hobby}입니다. 비자명한 FD가 없으므로 BCNF가 성립합니다. 하지만 MVD student →→ course는 결정자 {student}가 슈퍼키가 아닙니다. **BCNF이지만 4NF는 아닙니다.**

3. **4NF 분해**:
   - R₁(student, course) — key: {student, course}
   - R₂(student, hobby) — key: {student, hobby}

   둘 다 4NF에 있습니다 (자명한 MVD만 남음). ✓
</details>

<h3 id="2-mvd-vs-fd">연습문제 2: MVD vs FD<a class="header-link" href="#2-mvd-vs-fd" title="Permanent link">&para;</a></h3>
<p>R(A, B, C)가 주어지고 제약조건: A의 각 값에 대해 B 값의 집합이 C 값과 관계없이 고정됨.</p>
<ol>
<li>이것은 FD인가요 MVD인가요?</li>
<li>A → B가 성립하나요?</li>
<li>A →→ B가 성립하나요?</li>
</ol>
<details>
<summary>해답</summary>

1. 이것은 **MVD**입니다. 제약조건은 B 값과 C 값이 A가 주어졌을 때 독립적이라고 말합니다.

2. **A → B는 반드시 성립하지 않습니다.** FD A → B는 각 A 값이 정확히 하나의 B 값과 연관됨을 의미합니다. 제약조건은 A가 **집합**의 B 값과 연관되며, 이는 하나 이상의 요소를 가질 수 있다고 말합니다.

3. **A →→ B가 성립합니다.** 이것이 정확히 다치 종속성의 정의입니다: 주어진 A에 대해 B 값의 집합이 C 값과 독립적입니다.

예:

<div class="highlight"><pre><span></span><code>| A  | B  | C  |
|----|----|----|
| a1 | b1 | c1 |
| a1 | b1 | c2 |
| a1 | b2 | c1 |
| a1 | b2 | c2 |
</code></pre></div>


A →→ B가 성립합니다 (모든 A-B 조합이 모든 C와 나타남). A → B는 성립하지 않습니다 (a1이 b1과 b2 모두에 매핑됨).
</details>

<h3 id="3-star-schema-design">연습문제 3: 스타 스키마 설계(Star Schema Design)<a class="header-link" href="#3-star-schema-design" title="Permanent link">&para;</a></h3>
<p>도서관 대출 시스템을 위한 스타 스키마를 설계하세요. 팩트는 "책 대출 이벤트"입니다. 다음을 식별하세요:
1. 팩트 테이블과 그 측정값
2. 최소 3개의 차원 테이블
3. 스키마를 사용한 샘플 SQL 쿼리</p>
<details>
<summary>해답</summary>

**팩트 테이블: fact_checkout**

<div class="highlight"><pre><span></span><code><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">fact_checkout</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">checkout_key</span><span class="w">    </span><span class="nb">SERIAL</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">date_key</span><span class="w">        </span><span class="nb">INT</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">dim_date</span><span class="p">(</span><span class="n">date_key</span><span class="p">),</span>
<span class="w">    </span><span class="n">book_key</span><span class="w">        </span><span class="nb">INT</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">dim_book</span><span class="p">(</span><span class="n">book_key</span><span class="p">),</span>
<span class="w">    </span><span class="n">patron_key</span><span class="w">      </span><span class="nb">INT</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">dim_patron</span><span class="p">(</span><span class="n">patron_key</span><span class="p">),</span>
<span class="w">    </span><span class="n">branch_key</span><span class="w">      </span><span class="nb">INT</span><span class="w"> </span><span class="k">REFERENCES</span><span class="w"> </span><span class="n">dim_branch</span><span class="p">(</span><span class="n">branch_key</span><span class="p">),</span>
<span class="w">    </span><span class="c1">-- 측정값</span>
<span class="w">    </span><span class="n">days_borrowed</span><span class="w">   </span><span class="nb">INT</span><span class="p">,</span>
<span class="w">    </span><span class="n">is_returned</span><span class="w">     </span><span class="nb">BOOLEAN</span><span class="p">,</span>
<span class="w">    </span><span class="n">late_fee</span><span class="w">        </span><span class="nb">DECIMAL</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>



**차원 테이블:**

<div class="highlight"><pre><span></span><code><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">dim_date</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">date_key</span><span class="w">    </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">full_date</span><span class="w">   </span><span class="nb">DATE</span><span class="p">,</span>
<span class="w">    </span><span class="k">year</span><span class="w">        </span><span class="nb">INT</span><span class="p">,</span>
<span class="w">    </span><span class="k">month</span><span class="w">       </span><span class="nb">INT</span><span class="p">,</span>
<span class="w">    </span><span class="n">day_of_week</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span>
<span class="w">    </span><span class="n">is_weekend</span><span class="w">  </span><span class="nb">BOOLEAN</span>
<span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">dim_book</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">book_key</span><span class="w">    </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">isbn</span><span class="w">        </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
<span class="w">    </span><span class="n">title</span><span class="w">       </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">200</span><span class="p">),</span>
<span class="w">    </span><span class="n">author</span><span class="w">      </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
<span class="w">    </span><span class="n">genre</span><span class="w">       </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
<span class="w">    </span><span class="n">publisher</span><span class="w">   </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
<span class="w">    </span><span class="n">pub_year</span><span class="w">    </span><span class="nb">INT</span>
<span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">dim_patron</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">patron_key</span><span class="w">  </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">patron_id</span><span class="w">   </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span>
<span class="w">    </span><span class="n">name</span><span class="w">        </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
<span class="w">    </span><span class="n">membership</span><span class="w">  </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w">  </span><span class="c1">-- &#39;adult&#39;, &#39;student&#39;, &#39;senior&#39;</span>
<span class="w">    </span><span class="n">city</span><span class="w">        </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">)</span>
<span class="p">);</span>

<span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">dim_branch</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="n">branch_key</span><span class="w">  </span><span class="nb">INT</span><span class="w"> </span><span class="k">PRIMARY</span><span class="w"> </span><span class="k">KEY</span><span class="p">,</span>
<span class="w">    </span><span class="n">branch_name</span><span class="w"> </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
<span class="w">    </span><span class="n">city</span><span class="w">        </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">50</span><span class="p">),</span>
<span class="w">    </span><span class="k">state</span><span class="w">       </span><span class="nb">VARCHAR</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div>



**샘플 쿼리: 월별 가장 인기 있는 장르:**

<div class="highlight"><pre><span></span><code><span class="k">SELECT</span>
<span class="w">    </span><span class="n">dd</span><span class="p">.</span><span class="k">year</span><span class="p">,</span>
<span class="w">    </span><span class="n">dd</span><span class="p">.</span><span class="k">month</span><span class="p">,</span>
<span class="w">    </span><span class="n">db</span><span class="p">.</span><span class="n">genre</span><span class="p">,</span>
<span class="w">    </span><span class="k">COUNT</span><span class="p">(</span><span class="o">*</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">checkouts</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">fact_checkout</span><span class="w"> </span><span class="n">f</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">dim_date</span><span class="w"> </span><span class="n">dd</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">date_key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">dd</span><span class="p">.</span><span class="n">date_key</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">dim_book</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">f</span><span class="p">.</span><span class="n">book_key</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">db</span><span class="p">.</span><span class="n">book_key</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">dd</span><span class="p">.</span><span class="k">year</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2025</span>
<span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">dd</span><span class="p">.</span><span class="k">year</span><span class="p">,</span><span class="w"> </span><span class="n">dd</span><span class="p">.</span><span class="k">month</span><span class="p">,</span><span class="w"> </span><span class="n">db</span><span class="p">.</span><span class="n">genre</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">dd</span><span class="p">.</span><span class="k">month</span><span class="p">,</span><span class="w"> </span><span class="n">checkouts</span><span class="w"> </span><span class="k">DESC</span><span class="p">;</span>
</code></pre></div>


</details>

<h3 id="4-4nf-4nf-decomposition">연습문제 4: 4NF 분해(4NF Decomposition)<a class="header-link" href="#4-4nf-4nf-decomposition" title="Permanent link">&para;</a></h3>
<p>R(A, B, C, D)가 주어지고:
- A →→ B
- A → C</p>
<p>4NF로 분해하세요.</p>
<details>
<summary>해답</summary>

먼저, 모든 종속성을 식별합니다:
- A →→ B는 A →→ CD를 함의합니다 (보완, R - A - B = {C, D}이므로)
- A → C (FD, A →→ C를 함의)

키: {A, B, D}⁺ 또는 실제 키를 찾으세요. A → C이므로 A로부터 C를 얻습니다. 따라서 B와 D를 결정하기 위해 A와 충분한 것이 필요합니다. A →→ B이면 B는 다치 값이므로 B는 키에 있어야 합니다. 마찬가지로 D가 키에 있을 수 있습니다.

키 후보: {A, B, D} (A가 C만 함수적으로 결정하고, B와 D가 A가 주어졌을 때 서로 독립이므로).

4NF 확인: A →→ B는 비자명하고, {A}는 슈퍼키가 아닙니다. 위반!

**A →→ B에 대해 분해:**
- R₁(A, B) — key: {A, B}
- R₂(A, C, D) — key: {A, D} (A → C이므로)

R₁(A, B) 확인: 자명한 MVD만. 4NF ✓
R₂(A, C, D) 확인: A → C. {A}가 슈퍼키인가? {A}⁺ = {A, C}. 아니요, D가 결정되지 않음. 키는 {A, D}입니다. A → C는 A가 슈퍼키가 아닌 FD입니다 — 이는 BCNF를 위반합니다!

**R₂를 A → C에 대해 분해:**
- R₃(A, C) — key: {A}
- R₄(A, D) — key: {A, D}

**최종 4NF 분해:**

<div class="highlight"><pre><span></span><code>R₁(A, B)    — key: {A, B}
R₃(A, C)    — key: {A}
R₄(A, D)    — key: {A, D}
</code></pre></div>



모두 4NF에 있습니다 ✓.
</details>

<h3 id="5-denormalization-decision">연습문제 5: 비정규화 결정(Denormalization Decision)<a class="header-link" href="#5-denormalization-decision" title="Permanent link">&para;</a></h3>
<p>각 시나리오에 대해 정규화할 것인지 비정규화할 것인지 결정하세요. 이유를 설명하세요.</p>
<ol>
<li>1000만 개의 제품이 있는 전자상거래 제품 카탈로그, 읽기:쓰기 비율 1000:1</li>
<li>전신송금을 처리하는 은행 거래 시스템</li>
<li>저자 이름과 프로필 사진이 있는 게시물을 보여주는 소셜 미디어 뉴스 피드</li>
<li>매초 센서 판독값을 기록하는 과학 데이터 수집 시스템</li>
</ol>
<details>
<summary>해답</summary>

1. **제품 카탈로그 (1000만 개 제품, 1000:1 읽기:쓰기)**: **비정규화.** 압도적인 읽기 우세가 중복성을 정당화합니다. 카테고리 이름, 브랜드 이름 등이 직접 내장된 비정규화된 제품 테이블을 사용하세요. 검색/필터 페이지를 위한 구체화된 뷰를 고려하세요. 업데이트는 드물고 배치 처리될 수 있습니다.

2. **은행 전신송금**: **정규화 (BCNF).** 금융 데이터는 완벽한 일관성을 요구합니다. 모든 센트는 정확히 한 번 계상되어야 합니다. 조인의 성능 비용은 수용 가능합니다 — 정확성이 최우선입니다. 적절한 외래 키와 제약조건이 있는 정규화된 테이블을 사용하세요.

3. **소셜 미디어 뉴스 피드**: **비정규화.** 뉴스 피드는 읽기 중심이고 지연 시간에 민감합니다. 저자 이름과 프로필 사진 URL을 피드 항목에 직접 저장하세요 (또는 Redis 같은 캐시 계층 사용). 최종 일관성을 수용하세요 — 사용자가 프로필 사진을 변경하면 이전 게시물이 일시적으로 이전 사진을 보여주는 것이 수용 가능합니다.

4. **센서 데이터 수집**: **하이브리드.** 센서 메타데이터 (sensor_id, location, type)는 정규화되어야 합니다 (거의 변하지 않음). 시계열 판독값은 특수 패턴을 사용할 수 있습니다 — 시계열 데이터베이스 (InfluxDB, TimescaleDB) 또는 시간별로 파티션된 비정규화 와이드 테이블. 핵심 제약은 조인 복잡성이 아니라 쓰기 처리량입니다.
</details>

<h3 id="6-join-dependency">연습문제 6: 조인 종속성(Join Dependency)<a class="header-link" href="#6-join-dependency" title="Permanent link">&para;</a></h3>
<p>R(A, B, C)가 조인 종속성 ⋈{(A,B), (B,C), (A,C)}를 가질 때:</p>
<ol>
<li>이 릴레이션이 반드시 4NF에 있나요?</li>
<li>5NF에 있나요?</li>
<li>5NF로 분해하세요.</li>
</ol>
<details>
<summary>해답</summary>

1. **4NF?** 아마도 예. JD ⋈{(A,B), (B,C), (A,C)}는 삼원 조인 종속성이며, 어떤 MVD에 의해서도 함의되지 않습니다. 비자명한 MVD가 없으면 릴레이션은 4NF에 있습니다.

2. **5NF?** 아니요. JD ⋈{(A,B), (B,C), (A,C)}는 비자명합니다 (후보 키에 의해 함의되지 않음). 유일한 키가 {A, B, C} (모든 속성)라면, {A,B}, {B,C}, {A,C}는 슈퍼키가 아닙니다. **5NF에 없습니다.**

3. **5NF 분해:**
   ```
   R₁(A, B)   — key: {A, B}
   R₂(B, C)   — key: {B, C}
   R₃(A, C)   — key: {A, C}
   ```

   JD는 이 분해가 무손실임을 보장합니다: R = R₁ ⋈ R₂ ⋈ R₃. 각 구성 요소는 자명한 JD만 가집니다. 모두 5NF에 있습니다 ✓.
</details>

<hr />
<h2 id="11-summary">11. 요약(Summary)<a class="header-link" href="#11-summary" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>개념</th>
<th>핵심 포인트</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MVD (X →→ Y)</strong></td>
<td>주어진 X에 대해, Y 값은 다른 속성들과 독립적</td>
</tr>
<tr>
<td><strong>4NF</strong></td>
<td>모든 비자명한 MVD 결정자가 슈퍼키</td>
</tr>
<tr>
<td><strong>조인 종속성(Join Dependency)</strong></td>
<td>R이 여러 투영으로 무손실 분해 가능</td>
</tr>
<tr>
<td><strong>5NF (PJNF)</strong></td>
<td>모든 비자명한 JD 구성 요소가 슈퍼키</td>
</tr>
<tr>
<td><strong>DKNF</strong></td>
<td>모든 제약조건이 도메인과 키로부터 따라옴 (이론적 이상)</td>
</tr>
<tr>
<td><strong>비정규화(Denormalization)</strong></td>
<td>읽기 성능을 위한 의도적 중복성</td>
</tr>
<tr>
<td><strong>스타 스키마(Star Schema)</strong></td>
<td>팩트 테이블 + 평면 차원 테이블 (데이터 웨어하우징)</td>
</tr>
<tr>
<td><strong>스노플레이크 스키마(Snowflake Schema)</strong></td>
<td>팩트 테이블 + 정규화된 차원 테이블</td>
</tr>
</tbody>
</table>
<p>핵심 실무 요점: <strong>기본적으로 정규화하고(BCNF), 성능이 요구할 때 의도적이고 규율 있게 비정규화하세요</strong>. 모든 비정규화 결정과 그 유지보수 전략을 문서화하세요.</p>
<p>다음 레슨은 쿼리 처리(query processing)를 다룹니다 — 데이터베이스 엔진이 이러한 스키마에 대한 쿼리를 실제로 어떻게 실행하는지, 그리고 옵티마이저가 효율적인 실행 계획을 어떻게 선택하는지 다룹니다.</p>
<hr />
<p><strong>이전</strong>: <a href="./06_Normalization.md">06_Normalization.md</a> | <strong>다음</strong>: <a href="./08_Query_Processing.md">08_Query_Processing.md</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/06_Normalization.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 06: 정규화 (1NF ~ BCNF)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/08_Query_Processing.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">Lesson 08: 쿼리 처리(Query Processing)</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}