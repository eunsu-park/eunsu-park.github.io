{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lesson 08: 쿼리 처리(Query Processing) - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Database_Theory/">Database Theory</a>
    <span class="separator">/</span>
    <span class="current">Lesson 08: 쿼리 처리(Query Processing)</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>Lesson 08: 쿼리 처리(Query Processing)</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/07_Advanced_Normalization.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 07: 고급 정규화(Advanced Normalization)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/09_Indexing.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">09. 인덱싱</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#1-introduction">1. 소개(Introduction)</a><ul>
<li><a href="#11-the-query-processing-pipeline">1.1 쿼리 처리 파이프라인(The Query Processing Pipeline)</a></li>
<li><a href="#12-example-a-simple-querys-journey">1.2 예제: 간단한 쿼리의 여정(Example: A Simple Query's Journey)</a></li>
</ul>
</li>
<li><a href="#2-parsing-and-translation">2. 파싱과 변환(Parsing and Translation)</a><ul>
<li><a href="#21-parsing">2.1 파싱(Parsing)</a></li>
<li><a href="#22-translation-to-relational-algebra">2.2 관계 대수로 변환(Translation to Relational Algebra)</a></li>
</ul>
</li>
<li><a href="#3-query-evaluation-plans-and-the-iterator-model">3. 쿼리 평가 계획과 반복자 모델(Query Evaluation Plans and the Iterator Model)</a><ul>
<li><a href="#31-query-evaluation-plan">3.1 쿼리 평가 계획(Query Evaluation Plan)</a></li>
<li><a href="#32-volcanopipeline-the-iterator-volcanopipeline-model">3.2 반복자(Volcano/Pipeline) 모델(The Iterator (Volcano/Pipeline) Model)</a></li>
<li><a href="#33-vs-materialization-vs-pipelining">3.3 구체화 vs 파이프라이닝(Materialization vs Pipelining)</a></li>
<li><a href="#34-vs-pull-vs-push-model">3.4 풀 vs 푸시 모델(Pull vs Push Model)</a></li>
</ul>
</li>
<li><a href="#4-cost-estimation">4. 비용 추정(Cost Estimation)</a><ul>
<li><a href="#41-cost-metrics">4.1 비용 지표(Cost Metrics)</a></li>
<li><a href="#42-notation">4.2 표기법(Notation)</a></li>
<li><a href="#43-example-catalog-statistics">4.3 예제 카탈로그 통계(Example Catalog Statistics)</a></li>
</ul>
</li>
<li><a href="#5-selection-implementation">5. 선택 구현(Selection Implementation)</a><ul>
<li><a href="#51-a1-linear-scan-full-table-scan">5.1 알고리즘 A1: 선형 스캔(전체 테이블 스캔) (Linear Scan (Full Table Scan))</a></li>
<li><a href="#52-a2-binary-search">5.2 알고리즘 A2: 이진 검색(Binary Search)</a></li>
<li><a href="#53-a3-primary-index-equality-on-key">5.3 알고리즘 A3: 기본 인덱스, 키에 대한 동등 조건(Primary Index, Equality on Key)</a></li>
<li><a href="#54-a4-primary-index-equality-on-non-key">5.4 알고리즘 A4: 기본 인덱스, 비키에 대한 동등 조건(Primary Index, Equality on Non-Key)</a></li>
<li><a href="#55-a5-secondary-index-equality">5.5 알고리즘 A5: 보조 인덱스, 동등 조건(Secondary Index, Equality)</a></li>
<li><a href="#56-selection-with-range-predicates">5.6 범위 술어를 사용한 선택(Selection with Range Predicates)</a></li>
<li><a href="#57-selection-with-complex-predicates">5.7 복잡한 술어를 사용한 선택(Selection with Complex Predicates)</a></li>
<li><a href="#58-comparison-summary">5.8 비교 요약(Comparison Summary)</a></li>
</ul>
</li>
<li><a href="#6-join-algorithms">6. 조인 알고리즘(Join Algorithms)</a><ul>
<li><a href="#61-notation">6.1 표기법(Notation)</a></li>
<li><a href="#62-j1-nested-loop-join-nlj">6.2 알고리즘 J1: 중첩 루프 조인(Nested Loop Join, NLJ)</a></li>
<li><a href="#63-j2-block-nested-loop-join-bnlj">6.3 알고리즘 J2: 블록 중첩 루프 조인(Block Nested Loop Join, BNLJ)</a></li>
<li><a href="#64-j3-indexed-nested-loop-join">6.4 알고리즘 J3: 인덱스 중첩 루프 조인(Indexed Nested Loop Join)</a></li>
<li><a href="#65-j4-sort-merge-join">6.5 알고리즘 J4: 정렬-병합 조인(Sort-Merge Join)</a></li>
<li><a href="#66-j5-hash-join">6.6 알고리즘 J5: 해시 조인(Hash Join)</a></li>
<li><a href="#67-cost-comparison">6.7 비용 비교(Cost Comparison)</a></li>
</ul>
</li>
<li><a href="#7-query-optimization">7. 쿼리 최적화(Query Optimization)</a><ul>
<li><a href="#71-overview">7.1 개요(Overview)</a></li>
<li><a href="#72-equivalence-rules-for-relational-algebra">7.2 관계 대수의 동등 규칙(Equivalence Rules for Relational Algebra)</a><ul>
<li><a href="#1-cascade-of-selections">규칙 1: 선택의 연쇄(Cascade of Selections)</a></li>
<li><a href="#2-commutativity-of-selection">규칙 2: 선택의 교환성(Commutativity of Selection)</a></li>
<li><a href="#3-cascade-of-projections">규칙 3: 투영의 연쇄(Cascade of Projections)</a></li>
<li><a href="#4-commutativity-of-join">규칙 4: 조인의 교환성(Commutativity of Join)</a></li>
<li><a href="#5-associativity-of-join">규칙 5: 조인의 결합성(Associativity of Join)</a></li>
<li><a href="#6-push-selection-through-join">규칙 6: 조인을 통한 선택 푸시(Push Selection Through Join)</a></li>
<li><a href="#7-push-selection-through-set-operations">규칙 7: 집합 연산을 통한 선택 푸시(Push Selection Through Set Operations)</a></li>
<li><a href="#8-push-projection-through-join">규칙 8: 조인을 통한 투영 푸시(Push Projection Through Join)</a></li>
</ul>
</li>
<li><a href="#73-heuristic-optimization">7.3 휴리스틱 최적화(Heuristic Optimization)</a><ul>
<li><a href="#_1">예제: 휴리스틱 최적화</a></li>
</ul>
</li>
<li><a href="#74-cost-based-optimization">7.4 비용 기반 최적화(Cost-Based Optimization)</a><ul>
<li><a href="#selectivity-estimation">선택도 추정(Selectivity Estimation)</a></li>
<li><a href="#join-size-estimation">조인 크기 추정(Join Size Estimation)</a></li>
<li><a href="#histograms">히스토그램(Histograms)</a></li>
</ul>
</li>
<li><a href="#75-join-ordering-optimization">7.5 조인 순서 최적화(Join Ordering Optimization)</a></li>
<li><a href="#76-vs-left-deep-vs-bushy-join-trees">7.6 왼쪽-깊은 vs 덤불 조인 트리(Left-Deep vs Bushy Join Trees)</a></li>
</ul>
</li>
<li><a href="#8-statistics-and-catalog-information">8. 통계 및 카탈로그 정보(Statistics and Catalog Information)</a><ul>
<li><a href="#81-what-the-catalog-stores">8.1 카탈로그에 저장되는 것(What the Catalog Stores)</a></li>
<li><a href="#82-updating-statistics">8.2 통계 업데이트(Updating Statistics)</a></li>
<li><a href="#83-impact-of-stale-statistics">8.3 오래된 통계의 영향(Impact of Stale Statistics)</a></li>
</ul>
</li>
<li><a href="#9-query-execution-engine-architecture">9. 쿼리 실행 엔진 아키텍처(Query Execution Engine Architecture)</a><ul>
<li><a href="#91-components">9.1 구성 요소(Components)</a></li>
<li><a href="#92-plan-caching">9.2 계획 캐싱(Plan Caching)</a></li>
<li><a href="#93-reading-execution-plans">9.3 실행 계획 읽기(Reading Execution Plans)</a></li>
<li><a href="#94-adaptive-query-execution">9.4 적응형 쿼리 실행(Adaptive Query Execution)</a></li>
</ul>
</li>
<li><a href="#10-advanced-topics">10. 고급 주제(Advanced Topics)</a><ul>
<li><a href="#101-parallel-query-execution">10.1 병렬 쿼리 실행(Parallel Query Execution)</a></li>
<li><a href="#102-columnar-execution">10.2 열 기반 실행(Columnar Execution)</a></li>
<li><a href="#103-just-in-time-jit-just-in-time-jit-compilation">10.3 Just-In-Time (JIT) 컴파일(Just-In-Time (JIT) Compilation)</a></li>
</ul>
</li>
<li><a href="#11-exercises">11. 연습문제(Exercises)</a><ul>
<li><a href="#1-cost-calculation">연습문제 1: 비용 계산(Cost Calculation)</a></li>
<li><a href="#2-selectivity-estimation">연습문제 2: 선택도 추정(Selectivity Estimation)</a></li>
<li><a href="#3-heuristic-optimization">연습문제 3: 휴리스틱 최적화(Heuristic Optimization)</a></li>
<li><a href="#4-join-algorithm-selection">연습문제 4: 조인 알고리즘 선택(Join Algorithm Selection)</a></li>
<li><a href="#5-reading-execution-plans">연습문제 5: 실행 계획 읽기(Reading Execution Plans)</a></li>
<li><a href="#6-equivalence-rules">연습문제 6: 동등 규칙(Equivalence Rules)</a></li>
<li><a href="#7-cost-based-optimization">연습문제 7: 비용 기반 최적화(Cost-Based Optimization)</a></li>
</ul>
</li>
<li><a href="#12-summary">12. 요약(Summary)</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="lesson-08-query-processing">Lesson 08: 쿼리 처리(Query Processing)<a class="header-link" href="#lesson-08-query-processing" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./07_Advanced_Normalization.md">07_Advanced_Normalization.md</a> | <strong>다음</strong>: <a href="./09_Indexing.md">09_Indexing.md</a></p>
<hr />
<blockquote>
<p><strong>주제(Topic)</strong>: Database Theory
<strong>레슨(Lesson)</strong>: 8 of 16
<strong>선행 학습(Prerequisites)</strong>: 관계 대수(Relational algebra, Lesson 03), SQL 기초, 디스크 I/O 이해
<strong>목표(Objective)</strong>: DBMS가 SQL 쿼리를 효율적인 실행 계획으로 변환하는 방법을 이해하고, 선택(selection)과 조인(join) 알고리즘의 비용 모델을 숙달하며, 쿼리 최적화 기법을 파악합니다</p>
</blockquote>
<h2 id="1-introduction">1. 소개(Introduction)<a class="header-link" href="#1-introduction" title="Permanent link">&para;</a></h2>
<p>SQL 쿼리를 작성할 때, 데이터베이스는 작성된 그대로 실행하지 않습니다. SQL 문과 실제 디스크 액세스 사이에는 <strong>파싱(parsing)</strong>, <strong>최적화(optimization)</strong>, <strong>실행(execution)</strong>의 정교한 파이프라인이 있습니다. 이 파이프라인을 이해하는 것은 효율적인 쿼리를 작성하고 성능 문제를 진단하는 데 중요합니다.</p>
<h3 id="11-the-query-processing-pipeline">1.1 쿼리 처리 파이프라인(The Query Processing Pipeline)<a class="header-link" href="#11-the-query-processing-pipeline" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>SQL Query
    │
    ▼
┌─────────────────┐
│    Parser        │ → 구문 검사, 파스 트리
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Translator      │ → 관계 대수 표현식
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Optimizer       │ → 최선의 실행 계획 선택
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│  Execution       │ → 계획 실행, 결과 반환
│  Engine          │
└─────────────────┘
</code></pre></div>

<h3 id="12-example-a-simple-querys-journey">1.2 예제: 간단한 쿼리의 여정(Example: A Simple Query's Journey)<a class="header-link" href="#12-example-a-simple-querys-journey" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">dept_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="n">e</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">departments</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">dept_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">dept_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">salary</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">80000</span><span class="p">;</span>
</code></pre></div>

<ol>
<li><strong>파서(Parser)</strong>: 구문 검사, 테이블/열 이름 해석, 파스 트리 생성</li>
<li><strong>변환기(Translator)</strong>: 관계 대수로 변환: π_{name, dept_name}(σ_{salary &gt; 80000}(employees ⋈_{dept_id} departments))</li>
<li><strong>최적화기(Optimizer)</strong>: 많은 동등한 계획을 고려:</li>
<li>먼저 필터링 후 조인? 아니면 먼저 조인 후 필터링?</li>
<li>salary에 인덱스 사용? dept_id에?</li>
<li>중첩 루프 조인? 해시 조인? 정렬-병합 조인?</li>
<li><strong>실행 엔진(Execution engine)</strong>: 반복자 모델을 사용하여 선택된 계획 실행</li>
</ol>
<hr />
<h2 id="2-parsing-and-translation">2. 파싱과 변환(Parsing and Translation)<a class="header-link" href="#2-parsing-and-translation" title="Permanent link">&para;</a></h2>
<h3 id="21-parsing">2.1 파싱(Parsing)<a class="header-link" href="#21-parsing" title="Permanent link">&para;</a></h3>
<p>파서는 다음을 수행합니다:</p>
<ol>
<li><strong>어휘 분석(Lexical analysis)</strong>: 쿼리를 토큰으로 분해 (키워드, 식별자, 연산자, 리터럴)</li>
<li><strong>구문 분석(Syntax analysis)</strong>: 쿼리가 SQL 문법 규칙을 따르는지 확인, 파스 트리 생성</li>
<li><strong>의미 분석(Semantic analysis)</strong>: 테이블과 열이 존재하는지, 타입이 호환되는지, 사용자가 권한을 가지는지 확인</li>
</ol>
<p><strong>파스 트리</strong> (우리 예제):</p>
<div class="highlight"><pre><span></span><code>         SELECT
        /      \
   ProjectList  FROM
   /      \      |
 e.name  d.dept_name  JoinClause
                        /    \
                  employees  departments
                       |
                  ON e.dept_id = d.dept_id
                       |
                  WHERE e.salary &gt; 80000
</code></pre></div>

<h3 id="22-translation-to-relational-algebra">2.2 관계 대수로 변환(Translation to Relational Algebra)<a class="header-link" href="#22-translation-to-relational-algebra" title="Permanent link">&para;</a></h3>
<p>파서 출력은 초기 관계 대수 표현식 (또는 <strong>쿼리 트리(query tree)</strong>라고 하는 동등한 내부 표현)으로 변환됩니다:</p>
<div class="highlight"><pre><span></span><code>π_{name, dept_name}
    │
    σ_{salary &gt; 80000}
    │
    ⋈_{dept_id}
   / \
  e   d
</code></pre></div>

<p>이 초기 표현식은 <strong>논리적으로 정확</strong>하지만 반드시 <strong>효율적이지는 않습니다</strong>. 최적화기의 역할은 동등하지만 더 빠른 계획을 찾는 것입니다.</p>
<hr />
<h2 id="3-query-evaluation-plans-and-the-iterator-model">3. 쿼리 평가 계획과 반복자 모델(Query Evaluation Plans and the Iterator Model)<a class="header-link" href="#3-query-evaluation-plans-and-the-iterator-model" title="Permanent link">&para;</a></h2>
<h3 id="31-query-evaluation-plan">3.1 쿼리 평가 계획(Query Evaluation Plan)<a class="header-link" href="#31-query-evaluation-plan" title="Permanent link">&para;</a></h3>
<p><strong>쿼리 평가 계획(query evaluation plan)</strong> (또는 실행 계획)은 다음을 명시합니다:
- 수행할 관계 대수 연산
- 각 연산에 사용할 <strong>알고리즘</strong>
- 연산이 실행되는 <strong>순서</strong>
- 연산 간 데이터 흐름 방식</p>
<h3 id="32-volcanopipeline-the-iterator-volcanopipeline-model">3.2 반복자(Volcano/Pipeline) 모델(The Iterator (Volcano/Pipeline) Model)<a class="header-link" href="#32-volcanopipeline-the-iterator-volcanopipeline-model" title="Permanent link">&para;</a></h3>
<p>대부분의 현대 데이터베이스는 <strong>반복자 모델(iterator model)</strong> (Goetz Graefe의 Volcano 쿼리 처리 시스템에서 따와 Volcano 모델이라고도 함)을 사용합니다:</p>
<p>모든 연산자는 세 가지 메서드를 구현합니다:</p>
<div class="highlight"><pre><span></span><code><span class="nv">open</span><span class="ss">()</span><span class="w">   </span>→<span class="w"> </span>연산자<span class="w"> </span>초기화.<span class="w"> </span>자식<span class="w"> </span>반복자<span class="w"> </span>열기,<span class="w"> </span>버퍼<span class="w"> </span>할당.
<span class="k">next</span><span class="ss">()</span><span class="w">   </span>→<span class="w"> </span>결과의<span class="w"> </span>다음<span class="w"> </span>튜플<span class="w"> </span>반환.<span class="w"> </span>필요에<span class="w"> </span>따라<span class="w"> </span>자식의<span class="w"> </span><span class="k">next</span><span class="ss">()</span><span class="w"> </span>호출.
<span class="nv">close</span><span class="ss">()</span><span class="w">  </span>→<span class="w"> </span>정리.<span class="w"> </span>버퍼<span class="w"> </span>해제,<span class="w"> </span>자식<span class="w"> </span>반복자<span class="w"> </span>닫기.
</code></pre></div>

<p><strong>핵심 통찰</strong>: 연산자들이 트리로 구성됩니다. 루트가 <code>next()</code>를 호출하면, 이것이 리프(테이블 스캔)까지 계단식으로 내려갑니다. 튜플들은 한 번에 하나씩 <strong>위로</strong> 흐릅니다.</p>
<div class="highlight"><pre><span></span><code>         π_{name, dept_name}     ← 루트가 next() 호출
              │
         σ_{salary &gt; 80000}     ← 필터링, 일치하는 튜플을 위로 전달
              │
         ⋈_{dept_id}            ← 조인된 튜플 생성
            / \
      Scan(e)  Scan(d)          ← 디스크에서 튜플 읽기
</code></pre></div>

<h3 id="33-vs-materialization-vs-pipelining">3.3 구체화 vs 파이프라이닝(Materialization vs Pipelining)<a class="header-link" href="#33-vs-materialization-vs-pipelining" title="Permanent link">&para;</a></h3>
<p><strong>구체화(Materialization)</strong>: 각 연산자가 <strong>전체</strong> 결과를 생성하여 임시 릴레이션에 저장한 다음 부모에 전달합니다. 간단하지만 많은 임시 저장 공간이 필요합니다.</p>
<p><strong>파이프라이닝(Pipelining)</strong>: 튜플들이 완전히 구체화되지 않고 연산자들을 통해 흐릅니다. 한 튜플이 생성되자마자 다음 연산자로 전달됩니다. 훨씬 더 메모리 효율적입니다.</p>
<div class="highlight"><pre><span></span><code><span class="err">구체화</span><span class="o">:</span>
<span class="w">  </span><span class="n">Scan</span><span class="o">(</span><span class="n">e</span><span class="o">)</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="o">[</span><span class="err">전체</span><span class="w"> </span><span class="err">임시</span><span class="w"> </span><span class="err">테이블</span><span class="o">]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">σ</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="o">[</span><span class="err">전체</span><span class="w"> </span><span class="err">임시</span><span class="w"> </span><span class="err">테이블</span><span class="o">]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">⋈</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="o">[</span><span class="err">전체</span><span class="w"> </span><span class="err">임시</span><span class="w"> </span><span class="err">테이블</span><span class="o">]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">π</span>

<span class="err">파이프라이닝</span><span class="o">:</span>
<span class="w">  </span><span class="n">Scan</span><span class="o">(</span><span class="n">e</span><span class="o">)</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">σ</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">⋈</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">π</span>
<span class="w">  </span><span class="o">(</span><span class="err">튜플별로</span><span class="o">,</span><span class="w"> </span><span class="err">전체</span><span class="w"> </span><span class="err">임시</span><span class="w"> </span><span class="err">테이블</span><span class="w"> </span><span class="err">없음</span><span class="o">)</span>
</code></pre></div>

<p>파이프라이닝이 선호되지만 항상 가능하지는 않습니다. 일부 연산은 <strong>블로킹(blocking)</strong>입니다 — 출력을 생성하기 전에 모든 입력을 소비해야 합니다:
- <strong>정렬(Sorting)</strong> (정렬하려면 모든 튜플을 봐야 함)
- <strong>해시 조인 빌드 단계(Hash join build phase)</strong> (전체 해시 테이블을 빌드해야 함)
- <strong>집계(Aggregation)</strong> (모든 그룹을 처리해야 함)</p>
<h3 id="34-vs-pull-vs-push-model">3.4 풀 vs 푸시 모델(Pull vs Push Model)<a class="header-link" href="#34-vs-pull-vs-push-model" title="Permanent link">&para;</a></h3>
<p>위에서 설명한 반복자 모델은 <strong>풀(pull)</strong> 모델 (또는 수요 주도)입니다: 부모가 <code>next()</code>를 호출하여 자식으로부터 튜플을 가져옵니다.</p>
<p>현대 시스템은 점점 더 <strong>푸시(push)</strong> 모델 (또는 데이터 주도)을 사용합니다: 자식이 부모에게 튜플을 푸시합니다. 이는 더 캐시 친화적이고 컴파일에 적합할 수 있습니다.</p>
<div class="highlight"><pre><span></span><code>풀<span class="w"> </span><span class="ss">(</span><span class="nv">Volcano</span><span class="ss">)</span>:<span class="w">                    </span>푸시:
<span class="w">  </span>부모가<span class="w"> </span><span class="nv">child</span>.<span class="k">next</span><span class="ss">()</span><span class="w"> </span>호출<span class="w">          </span>자식이<span class="w"> </span><span class="nv">parent</span>.<span class="nv">consume</span><span class="ss">(</span><span class="nv">tuple</span><span class="ss">)</span><span class="w"> </span>호출
<span class="w">  </span>자식이<span class="w"> </span>하나의<span class="w"> </span>튜플<span class="w"> </span>반환<span class="w">            </span>부모가<span class="w"> </span>즉시<span class="w"> </span>처리
<span class="w">  </span>부모가<span class="w"> </span>처리<span class="w">                       </span>더<span class="w"> </span>캐시<span class="w"> </span>친화적
</code></pre></div>

<p>일부 시스템 (예: HyPer, Umbra)은 쿼리를 데이터를 연산자들을 통해 푸시하는 타이트한 루프로 컴파일하여 거의 손으로 코딩한 것과 같은 성능을 달성합니다.</p>
<hr />
<h2 id="4-cost-estimation">4. 비용 추정(Cost Estimation)<a class="header-link" href="#4-cost-estimation" title="Permanent link">&para;</a></h2>
<h3 id="41-cost-metrics">4.1 비용 지표(Cost Metrics)<a class="header-link" href="#41-cost-metrics" title="Permanent link">&para;</a></h3>
<p>쿼리 처리의 주요 비용:</p>
<table>
<thead>
<tr>
<th>비용 구성 요소</th>
<th>기호</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>디스크 I/O</strong></td>
<td>tT, tS</td>
<td>전송 시간(순차 읽기)과 탐색 시간</td>
</tr>
<tr>
<td><strong>CPU</strong></td>
<td>—</td>
<td>비교, 해싱, 계산</td>
</tr>
<tr>
<td><strong>메모리</strong></td>
<td>M</td>
<td>사용 가능한 버퍼 페이지</td>
</tr>
<tr>
<td><strong>네트워크</strong></td>
<td>—</td>
<td>분산 쿼리용</td>
</tr>
</tbody>
</table>
<p>전통적 시스템에서는 <strong>디스크 I/O가 지배적</strong>입니다. 다음과 같은 디스크의 경우:
- 탐색 시간(Seek time, tS) ≈ 4 ms
- 블록당 전송 시간(Transfer time per block, tT) ≈ 0.1 ms</p>
<p>단일 랜덤 I/O는 ~4.1 ms가 소요되는 반면, 순차 읽기는 블록당 ~0.1 ms가 소요됩니다. 이 40:1 비율은 순차 액세스 패턴이 왜 그렇게 중요한지 설명합니다.</p>
<h3 id="42-notation">4.2 표기법(Notation)<a class="header-link" href="#42-notation" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>기호</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>n_r</td>
<td>릴레이션 r의 튜플 수</td>
</tr>
<tr>
<td>b_r</td>
<td>r의 튜플을 포함하는 디스크 블록 수</td>
</tr>
<tr>
<td>l_r</td>
<td>r의 튜플 크기(바이트)</td>
</tr>
<tr>
<td>f_r</td>
<td>블로킹 팩터: 블록당 튜플 = ⌊B / l_r⌋</td>
</tr>
<tr>
<td>B</td>
<td>블록(페이지) 크기(바이트)</td>
</tr>
<tr>
<td>V(A, r)</td>
<td>r의 속성 A의 고유 값 수</td>
</tr>
<tr>
<td>M</td>
<td>메모리의 사용 가능한 버퍼 페이지 수</td>
</tr>
</tbody>
</table>
<p>관계: b_r = ⌈n_r / f_r⌉</p>
<h3 id="43-example-catalog-statistics">4.3 예제 카탈로그 통계(Example Catalog Statistics)<a class="header-link" href="#43-example-catalog-statistics" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>employees (e):
    n_e = 10,000 튜플
    l_e = 200 바이트
    B   = 4,096 바이트 (4 KB 페이지)
    f_e = ⌊4096 / 200⌋ = 20 튜플/블록
    b_e = ⌈10000 / 20⌉ = 500 블록
    V(dept_id, e) = 50 고유 부서
    V(salary, e) = 2,000 고유 급여 값

departments (d):
    n_d = 50 튜플
    l_d = 100 바이트
    f_d = ⌊4096 / 100⌋ = 40 튜플/블록
    b_d = ⌈50 / 40⌉ = 2 블록
</code></pre></div>

<hr />
<h2 id="5-selection-implementation">5. 선택 구현(Selection Implementation)<a class="header-link" href="#5-selection-implementation" title="Permanent link">&para;</a></h2>
<p>선택(Selection, σ)은 술어를 만족하는 튜플을 필터링합니다. 구현 전략은 사용 가능한 인덱스에 크게 의존합니다.</p>
<h3 id="51-a1-linear-scan-full-table-scan">5.1 알고리즘 A1: 선형 스캔(전체 테이블 스캔) (Linear Scan (Full Table Scan))<a class="header-link" href="#51-a1-linear-scan-full-table-scan" title="Permanent link">&para;</a></h3>
<p>릴레이션의 모든 블록을 스캔하여 각 튜플을 술어에 대해 테스트합니다.</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">LinearScan</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">predicate</span><span class="o">)</span>
<span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">IF</span><span class="w"> </span><span class="n">t</span><span class="w"> </span><span class="n">satisfies</span><span class="w"> </span><span class="n">predicate</span><span class="w"> </span><span class="n">THEN</span>
<span class="w">            </span><span class="n">output</span><span class="w"> </span><span class="n">t</span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">IF</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
</code></pre></div>

<p><strong>비용</strong>: b_r 블록 전송 + 1 탐색</p>
<p>우리 예제: 500 전송 + 1 탐색 = 500 × 0.1ms + 4ms = <strong>54 ms</strong></p>
<p><strong>사용 시기</strong>: 항상 적용 가능. 인덱스가 없거나 선택도가 매우 낮을 때 (대부분의 튜플이 자격) 사용됩니다.</p>
<h3 id="52-a2-binary-search">5.2 알고리즘 A2: 이진 검색(Binary Search)<a class="header-link" href="#52-a2-binary-search" title="Permanent link">&para;</a></h3>
<p>파일이 선택 속성으로 정렬되어 있고 술어가 동등 조건이면:</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">BinarySearch</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="o">)</span>
<span class="err">이진</span><span class="w"> </span><span class="err">검색을</span><span class="w"> </span><span class="err">사용하여</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v를</span><span class="w"> </span><span class="err">포함하는</span><span class="w"> </span><span class="err">첫</span><span class="w"> </span><span class="err">번째</span><span class="w"> </span><span class="err">블록</span><span class="w"> </span><span class="err">찾기</span>
<span class="err">앞으로</span><span class="w"> </span><span class="err">스캔하여</span><span class="w"> </span><span class="err">모든</span><span class="w"> </span><span class="err">일치하는</span><span class="w"> </span><span class="err">튜플</span><span class="w"> </span><span class="err">찾기</span>
</code></pre></div>

<p><strong>비용</strong>: 검색을 위한 ⌈log₂(b_r)⌉ 탐색 및 전송 + 중복 값을 위한 추가 블록</p>
<p>키에 대한 동등 조건: ⌈log₂(500)⌉ = 9 블록 액세스 = 9 × (4ms + 0.1ms) = <strong>37 ms</strong></p>
<h3 id="53-a3-primary-index-equality-on-key">5.3 알고리즘 A3: 기본 인덱스, 키에 대한 동등 조건(Primary Index, Equality on Key)<a class="header-link" href="#53-a3-primary-index-equality-on-key" title="Permanent link">&para;</a></h3>
<p>선택 속성 (키인)에 기본 B⁺-트리 인덱스가 존재하면:</p>
<div class="highlight"><pre><span></span><code>비용 = (h_i + 1) × (tS + tT)
</code></pre></div>

<p>여기서 h_i는 B⁺-트리의 높이 (일반적으로 2-4).</p>
<p>h_i = 3인 경우: 4 × 4.1ms = <strong>16.4 ms</strong> (3 인덱스 레벨 + 1 데이터 블록)</p>
<h3 id="54-a4-primary-index-equality-on-non-key">5.4 알고리즘 A4: 기본 인덱스, 비키에 대한 동등 조건(Primary Index, Equality on Non-Key)<a class="header-link" href="#54-a4-primary-index-equality-on-non-key" title="Permanent link">&para;</a></h3>
<p>여러 튜플이 일치할 수 있습니다. 이들은 연속적입니다 (파일이 이 속성으로 정렬되어 있으므로):</p>
<div class="highlight"><pre><span></span><code>비용 = h_i × (tS + tT) + tS + tT × b
</code></pre></div>

<p>여기서 b는 일치하는 튜플을 포함하는 블록 수입니다.</p>
<h3 id="55-a5-secondary-index-equality">5.5 알고리즘 A5: 보조 인덱스, 동등 조건(Secondary Index, Equality)<a class="header-link" href="#55-a5-secondary-index-equality" title="Permanent link">&para;</a></h3>
<p><strong>후보 키에 대해</strong> (최대 하나의 일치):</p>
<div class="highlight"><pre><span></span><code>비용 = (h_i + 1) × (tS + tT)
</code></pre></div>

<p>키 속성에 대한 기본 인덱스와 동일합니다.</p>
<p><strong>비키 속성에 대해</strong> (여러 일치):</p>
<div class="highlight"><pre><span></span><code>비용 = (h_i + n) × (tS + tT)
</code></pre></div>

<p>여기서 n은 일치하는 튜플 수입니다. 각 일치하는 튜플은 <strong>다른 블록</strong>에 있을 수 있으므로 (기본 인덱스처럼 연속적이지 않음), 각각 별도의 탐색이 필요합니다.</p>
<p>이는 낮은 선택도 술어에 대해 <strong>매우 비쌀</strong> 수 있습니다. n = 500이면, 비용은 (3 + 500) × 4.1ms = <strong>2,062 ms</strong> — 전체 테이블 스캔 (54 ms)보다 훨씬 나쁩니다!</p>
<h3 id="56-selection-with-range-predicates">5.6 범위 술어를 사용한 선택(Selection with Range Predicates)<a class="header-link" href="#56-selection-with-range-predicates" title="Permanent link">&para;</a></h3>
<p><code>salary &gt; 80000</code>와 같은 술어의 경우:</p>
<table>
<thead>
<tr>
<th>방법</th>
<th>비용</th>
</tr>
</thead>
<tbody>
<tr>
<td>선형 스캔</td>
<td>b_r (항상 작동)</td>
</tr>
<tr>
<td>기본 인덱스 (B⁺-트리)</td>
<td>h_i + b/2 (평균적으로 리프 레벨의 절반 스캔)</td>
</tr>
<tr>
<td>보조 인덱스 (B⁺-트리)</td>
<td>h_i + 범위의 리프 페이지 + 일치하는 레코드 포인터</td>
</tr>
</tbody>
</table>
<h3 id="57-selection-with-complex-predicates">5.7 복잡한 술어를 사용한 선택(Selection with Complex Predicates)<a class="header-link" href="#57-selection-with-complex-predicates" title="Permanent link">&para;</a></h3>
<p><strong>연언 선택(Conjunctive selection)</strong> (σ_{θ₁ ∧ θ₂ ∧ ... ∧ θₙ}):</p>
<ol>
<li>한 조건에 인덱스가 있으면, 그것을 사용하고 나머지 조건을 필터로 적용</li>
<li>여러 조건에 인덱스가 있으면, <strong>인덱스 교집합(index intersection)</strong> 사용: 각 인덱스에서 레코드 포인터를 가져와 교집합을 구한 다음 일치하는 레코드 검색</li>
<li>여러 속성에 대한 복합 인덱스 (사용 가능하면 이상적)</li>
</ol>
<p><strong>선언 선택(Disjunctive selection)</strong> (σ_{θ₁ ∨ θ₂ ∨ ... ∨ θₙ}):</p>
<ol>
<li><strong>모든</strong> 조건에 인덱스가 있으면, <strong>인덱스 합집합(index union)</strong> 사용: 각 인덱스에서 포인터를 가져와 합집합을 구함</li>
<li>어떤 조건에 인덱스가 없으면, 선형 스캔을 사용해야 함 (하나의 누락된 인덱스가 전체 접근 방식을 무효화)</li>
</ol>
<h3 id="58-comparison-summary">5.8 비교 요약(Comparison Summary)<a class="header-link" href="#58-comparison-summary" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>알고리즘</th>
<th>조건</th>
<th>비용 (블록)</th>
</tr>
</thead>
<tbody>
<tr>
<td>선형 스캔</td>
<td>항상</td>
<td>b_r</td>
</tr>
<tr>
<td>이진 검색</td>
<td>정렬된 파일, 동등 조건</td>
<td>⌈log₂(b_r)⌉</td>
</tr>
<tr>
<td>기본 B⁺-트리, 키</td>
<td>키에 대한 인덱스</td>
<td>h_i + 1</td>
</tr>
<tr>
<td>기본 B⁺-트리, 비키</td>
<td>비키에 대한 인덱스</td>
<td>h_i + 일치하는 블록</td>
</tr>
<tr>
<td>보조 B⁺-트리, 키</td>
<td>키에 대한 인덱스</td>
<td>h_i + 1</td>
</tr>
<tr>
<td>보조 B⁺-트리, 비키</td>
<td>비키에 대한 인덱스</td>
<td>h_i + n (각 일치 = 1 탐색!)</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6-join-algorithms">6. 조인 알고리즘(Join Algorithms)<a class="header-link" href="#6-join-algorithms" title="Permanent link">&para;</a></h2>
<p>조인은 일반적으로 쿼리 처리에서 가장 비용이 많이 드는 연산입니다. 조인 알고리즘의 선택이 성능에 극적인 영향을 미칩니다.</p>
<h3 id="61-notation">6.1 표기법(Notation)<a class="header-link" href="#61-notation" title="Permanent link">&para;</a></h3>
<p>릴레이션 r (외부)과 s (내부)를 조인합니다:
- b_r, b_s = 블록 수
- n_r, n_s = 튜플 수
- M = 사용 가능한 메모리 페이지</p>
<h3 id="62-j1-nested-loop-join-nlj">6.2 알고리즘 J1: 중첩 루프 조인(Nested Loop Join, NLJ)<a class="header-link" href="#62-j1-nested-loop-join-nlj" title="Permanent link">&para;</a></h3>
<p>가장 간단한 조인 알고리즘. r의 각 튜플에 대해 s의 모든 것을 스캔하여 일치를 찾습니다.</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">NestedLoopJoin</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">s</span><span class="o">,</span><span class="w"> </span><span class="err">θ</span><span class="o">)</span>
<span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_r</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_s</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">IF</span><span class="w"> </span><span class="o">(</span><span class="n">t_r</span><span class="o">,</span><span class="w"> </span><span class="n">t_s</span><span class="o">)</span><span class="w"> </span><span class="n">satisfies</span><span class="w"> </span><span class="err">θ</span><span class="w"> </span><span class="n">THEN</span>
<span class="w">            </span><span class="n">output</span><span class="w"> </span><span class="o">(</span><span class="n">t_r</span><span class="w"> </span><span class="err">⋈</span><span class="w"> </span><span class="n">t_s</span><span class="o">)</span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">IF</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
</code></pre></div>

<p><strong>비용 (최악의 경우 — 각 릴레이션에 단일 버퍼 페이지)</strong>:</p>
<div class="highlight"><pre><span></span><code>비용 = n_r × b_s + b_r   블록 전송
     = n_r + b_r          탐색
</code></pre></div>

<p>r의 n_r 튜플 각각에 대해 s의 모든 b_s 블록을 스캔합니다. 추가로 r 자체의 b_r 블록 읽기.</p>
<p><strong>예제</strong>: employees (외부)를 departments (내부)와 조인:
- n_r = 10,000, b_s = 2, b_r = 500
- 전송: 10,000 × 2 + 500 = 20,500
- 탐색: 10,000 + 500 = 10,500
- 시간: 20,500 × 0.1ms + 10,500 × 4ms = <strong>44,050 ms ≈ 44초</strong></p>
<p><strong>최적화</strong>: 항상 <strong>더 작은</strong> 릴레이션을 내부(s)로 배치하세요. 교환하면:
- n_r = 50, b_s = 500, b_r = 2
- 전송: 50 × 500 + 2 = 25,002
- 이는 전송에서는 더 나쁘지만 탐색에서는 더 좋습니다.</p>
<p>실제로 튜플 수준 중첩 루프는 거의 사용되지 않습니다. 블록 수준이 훨씬 더 좋습니다.</p>
<h3 id="63-j2-block-nested-loop-join-bnlj">6.3 알고리즘 J2: 블록 중첩 루프 조인(Block Nested Loop Join, BNLJ)<a class="header-link" href="#63-j2-block-nested-loop-join-bnlj" title="Permanent link">&para;</a></h3>
<p>튜플별 반복 대신 블록별로 반복합니다.</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">BlockNestedLoopJoin</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">s</span><span class="o">,</span><span class="w"> </span><span class="err">θ</span><span class="o">)</span>
<span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">B_r</span><span class="w"> </span><span class="n">OF</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">block</span><span class="w"> </span><span class="n">B_s</span><span class="w"> </span><span class="n">OF</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_r</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">B_r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">            </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_s</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">B_s</span><span class="w"> </span><span class="n">DO</span>
<span class="w">                </span><span class="n">IF</span><span class="w"> </span><span class="o">(</span><span class="n">t_r</span><span class="o">,</span><span class="w"> </span><span class="n">t_s</span><span class="o">)</span><span class="w"> </span><span class="n">satisfies</span><span class="w"> </span><span class="err">θ</span><span class="w"> </span><span class="n">THEN</span>
<span class="w">                    </span><span class="n">output</span><span class="w"> </span><span class="o">(</span><span class="n">t_r</span><span class="w"> </span><span class="err">⋈</span><span class="w"> </span><span class="n">t_s</span><span class="o">)</span>
<span class="w">                </span><span class="n">END</span><span class="w"> </span><span class="n">IF</span>
<span class="w">            </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="w">        </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
</code></pre></div>

<p><strong>비용</strong>:</p>
<div class="highlight"><pre><span></span><code>블록 전송 = b_r × b_s + b_r
탐색     = 2 × b_r
</code></pre></div>

<p>r의 각 블록은 한 번 읽힙니다. r의 각 블록에 대해 s의 전부가 스캔됩니다 (b_s 블록). s는 b_r번 읽힙니다.</p>
<p><strong>예제</strong>: 동일한 테이블:
- 전송: 500 × 2 + 500 = 1,500
- 탐색: 2 × 500 = 1,000
- 시간: 1,500 × 0.1ms + 1,000 × 4ms = <strong>4,150 ms ≈ 4.2초</strong></p>
<p>튜플 수준 NLJ보다 10배 개선!</p>
<p><strong>M 버퍼 페이지를 사용한 추가 최적화</strong>:</p>
<p>외부 릴레이션에 (M - 2) 페이지, 내부에 1 페이지, 출력에 1 페이지 사용:</p>
<div class="highlight"><pre><span></span><code>블록 전송 = ⌈b_r / (M-2)⌉ × b_s + b_r
탐색     = 2 × ⌈b_r / (M-2)⌉
</code></pre></div>

<p>M = 52인 경우 (외부에 50 페이지, 내부에 1, 출력에 1):
- 외부 청크: ⌈500 / 50⌉ = 10
- 전송: 10 × 2 + 500 = 520
- 탐색: 2 × 10 = 20
- 시간: 520 × 0.1ms + 20 × 4ms = <strong>132 ms</strong></p>
<p>전체 외부가 메모리에 맞으면 (b_r ≤ M - 2), 비용은 <strong>b_r + b_s</strong> 전송과 <strong>2</strong> 탐색뿐입니다 — 단일 패스!</p>
<h3 id="64-j3-indexed-nested-loop-join">6.4 알고리즘 J3: 인덱스 중첩 루프 조인(Indexed Nested Loop Join)<a class="header-link" href="#64-j3-indexed-nested-loop-join" title="Permanent link">&para;</a></h3>
<p>내부 릴레이션의 조인 속성에 인덱스가 있으면, 스캔 대신 사용합니다.</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">IndexedNestedLoopJoin</span><span class="o">(</span><span class="n">r</span><span class="o">,</span><span class="w"> </span><span class="n">s</span><span class="o">,</span><span class="w"> </span><span class="err">θ</span><span class="o">)</span>
<span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_r</span><span class="w"> </span><span class="n">IN</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">s의</span><span class="w"> </span><span class="err">인덱스를</span><span class="w"> </span><span class="err">사용하여</span><span class="w"> </span><span class="n">t_r과</span><span class="w"> </span><span class="err">일치하는</span><span class="w"> </span><span class="err">튜플</span><span class="w"> </span><span class="err">찾기</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="n">EACH</span><span class="w"> </span><span class="n">matching</span><span class="w"> </span><span class="n">t_s</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">output</span><span class="w"> </span><span class="o">(</span><span class="n">t_r</span><span class="w"> </span><span class="err">⋈</span><span class="w"> </span><span class="n">t_s</span><span class="o">)</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
</code></pre></div>

<p><strong>비용</strong>:</p>
<div class="highlight"><pre><span></span><code>비용 = b_r + n_r × c
</code></pre></div>

<p>여기서 c는 s에 대한 단일 인덱스 조회 비용입니다 (일반적으로 B⁺-트리의 키에 대한 동등 조건의 경우 h_i + 1).</p>
<p><strong>예제</strong>: departments.dept_id에 인덱스 (h_i = 2):
- c = 2 + 1 = 3 (인덱스 순회 + 1 데이터 블록)
- 비용: 500 + 10,000 × 3 = 30,500 블록 액세스
- 하지만 탐색을 고려하면: 인덱스가 메모리에 있으면 BNLJ보다 훨씬 더 좋음</p>
<p>인덱스가 버퍼 캐시에 있으면 (작은 인덱스의 경우 일반적):
- c ≈ 1 (데이터 블록만)
- 비용: 500 + 10,000 × 1 = 10,500 전송</p>
<h3 id="65-j4-sort-merge-join">6.5 알고리즘 J4: 정렬-병합 조인(Sort-Merge Join)<a class="header-link" href="#65-j4-sort-merge-join" title="Permanent link">&para;</a></h3>
<p>조인 속성으로 두 릴레이션을 정렬한 다음 병합합니다.</p>
<div class="highlight"><pre><span></span><code><span class="nl">ALGORITHM</span><span class="p">:</span><span class="w"> </span><span class="n">SortMergeJoin</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">join_attr</span><span class="p">)</span>
<span class="n">Phase</span><span class="w"> </span><span class="mi">1</span><span class="err">:</span><span class="w"> </span><span class="n">r을</span><span class="w"> </span><span class="n">join_attr로</span><span class="w"> </span><span class="n">정렬</span><span class="w"> </span><span class="p">(</span><span class="n">외부</span><span class="w"> </span><span class="n">병합</span><span class="w"> </span><span class="n">정렬</span><span class="p">)</span>
<span class="n">Phase</span><span class="w"> </span><span class="mi">2</span><span class="err">:</span><span class="w"> </span><span class="n">s를</span><span class="w"> </span><span class="n">join_attr로</span><span class="w"> </span><span class="n">정렬</span><span class="w"> </span><span class="p">(</span><span class="n">외부</span><span class="w"> </span><span class="n">병합</span><span class="w"> </span><span class="n">정렬</span><span class="p">)</span>
<span class="n">Phase</span><span class="w"> </span><span class="mi">3</span><span class="err">:</span><span class="w"> </span><span class="n">병합</span>
<span class="w">    </span><span class="n">p_r</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">정렬된</span><span class="w"> </span><span class="n">r의</span><span class="w"> </span><span class="n">첫</span><span class="w"> </span><span class="n">번째</span><span class="w"> </span><span class="n">튜플</span>
<span class="w">    </span><span class="n">p_s</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">정렬된</span><span class="w"> </span><span class="n">s의</span><span class="w"> </span><span class="n">첫</span><span class="w"> </span><span class="n">번째</span><span class="w"> </span><span class="n">튜플</span>
<span class="w">    </span><span class="k">WHILE</span><span class="w"> </span><span class="n">릴레이션이</span><span class="w"> </span><span class="n">소진되지</span><span class="w"> </span><span class="n">않음</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="k">IF</span><span class="w"> </span><span class="n">p_r</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">p_s</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">            </span><span class="n">모든</span><span class="w"> </span><span class="n">일치하는</span><span class="w"> </span><span class="n">조합</span><span class="w"> </span><span class="n">출력</span>
<span class="w">            </span><span class="n">동등</span><span class="w"> </span><span class="n">그룹을</span><span class="w"> </span><span class="n">지나</span><span class="w"> </span><span class="n">두</span><span class="w"> </span><span class="n">포인터</span><span class="w"> </span><span class="n">모두</span><span class="w"> </span><span class="n">전진</span>
<span class="w">        </span><span class="k">ELSE</span><span class="w"> </span><span class="k">IF</span><span class="w"> </span><span class="n">p_r</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">p_s</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">            </span><span class="n">p_r</span><span class="w"> </span><span class="n">전진</span>
<span class="w">        </span><span class="k">ELSE</span>
<span class="w">            </span><span class="n">p_s</span><span class="w"> </span><span class="n">전진</span>
<span class="w">        </span><span class="k">END</span><span class="w"> </span><span class="k">IF</span>
<span class="w">    </span><span class="k">END</span><span class="w"> </span><span class="k">WHILE</span>
</code></pre></div>

<p><strong>비용</strong>:</p>
<div class="highlight"><pre><span></span><code>정렬 비용 = O(b × log_M(b)) 각 릴레이션에 대해 (외부 병합 정렬)
병합 비용 = b_r + b_s (정렬된 두 릴레이션을 통한 단일 패스)

총 = sort(r) + sort(s) + b_r + b_s
</code></pre></div>

<p>b 블록과 M 메모리 페이지를 가진 릴레이션의 외부 병합 정렬 비용:
- 초기 정렬 후 런 수: ⌈b / M⌉
- 병합 패스 수: ⌈log_{M-1}(⌈b/M⌉)⌉
- 각 패스는 모든 블록을 읽고 씁니다: 패스당 2 × b
- 총 정렬 비용: 2 × b × (1 + ⌈log_{M-1}(⌈b/M⌉)⌉) 블록 전송</p>
<p><strong>예제</strong> (M = 52):
- employees 정렬: ⌈500/52⌉ = 10 런, ⌈log₅₁(10)⌉ = 1 병합 패스
  - 비용: 2 × 500 × (1 + 1) = 2,000 전송
- departments 정렬: 이미 메모리에 맞음 (2 블록 &lt; 52)
  - 비용: 2 × 2 = 4 전송
- 병합: 500 + 2 = 502 전송
- <strong>총: 2,506 전송</strong></p>
<p><strong>정렬-병합이 뛰어난 경우</strong>:
- 두 릴레이션이 이미 정렬되어 있음 (정렬 단계 건너뛰기!)
- 해시 조인이 메모리를 다 쓰는 큰 릴레이션
- 비동등 조인 (정렬-병합은 θ-조인을 처리할 수 있지만 해시 조인은 불가능)</p>
<h3 id="66-j5-hash-join">6.6 알고리즘 J5: 해시 조인(Hash Join)<a class="header-link" href="#66-j5-hash-join" title="Permanent link">&para;</a></h3>
<p>더 작은 릴레이션에 해시 테이블을 빌드한 다음 더 큰 것으로 프로브합니다.</p>
<div class="highlight"><pre><span></span><code><span class="nl">ALGORITHM</span><span class="p">:</span><span class="w"> </span><span class="n">HashJoin</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">join_attr</span><span class="p">)</span>
<span class="n">Phase</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">빌드</span><span class="p">)</span><span class="err">:</span><span class="w"> </span><span class="n">더</span><span class="w"> </span><span class="n">작은</span><span class="w"> </span><span class="n">릴레이션</span><span class="p">(</span><span class="n">s라고</span><span class="w"> </span><span class="n">하자</span><span class="p">)</span><span class="n">을</span><span class="w"> </span><span class="n">메모리에</span><span class="w"> </span><span class="n">해시</span>
<span class="w">    </span><span class="n">hash_table</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="err">{}</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="k">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_s</span><span class="w"> </span><span class="ow">IN</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">bucket</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">t_s</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="p">)</span>
<span class="w">        </span><span class="n">t_s를</span><span class="w"> </span><span class="n">hash_table</span><span class="o">[</span><span class="n">bucket</span><span class="o">]</span><span class="n">에</span><span class="w"> </span><span class="n">삽입</span>
<span class="w">    </span><span class="k">END</span><span class="w"> </span><span class="k">FOR</span>

<span class="n">Phase</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="n">프로브</span><span class="p">)</span><span class="err">:</span><span class="w"> </span><span class="n">더</span><span class="w"> </span><span class="n">큰</span><span class="w"> </span><span class="n">릴레이션</span><span class="w"> </span><span class="n">스캔</span><span class="p">,</span><span class="w"> </span><span class="n">해시</span><span class="w"> </span><span class="n">테이블</span><span class="w"> </span><span class="n">프로브</span>
<span class="w">    </span><span class="k">FOR</span><span class="w"> </span><span class="k">EACH</span><span class="w"> </span><span class="n">tuple</span><span class="w"> </span><span class="n">t_r</span><span class="w"> </span><span class="ow">IN</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">bucket</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="n">t_r</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="p">)</span>
<span class="w">        </span><span class="k">FOR</span><span class="w"> </span><span class="k">EACH</span><span class="w"> </span><span class="n">t_s</span><span class="w"> </span><span class="ow">IN</span><span class="w"> </span><span class="n">hash_table</span><span class="o">[</span><span class="n">bucket</span><span class="o">]</span><span class="w"> </span><span class="n">DO</span>
<span class="w">            </span><span class="k">IF</span><span class="w"> </span><span class="n">t_r</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_s</span><span class="o">[</span><span class="n">join_attr</span><span class="o">]</span><span class="w"> </span><span class="k">THEN</span>
<span class="w">                </span><span class="k">output</span><span class="w"> </span><span class="p">(</span><span class="n">t_r</span><span class="w"> </span><span class="err">⋈</span><span class="w"> </span><span class="n">t_s</span><span class="p">)</span>
<span class="w">            </span><span class="k">END</span><span class="w"> </span><span class="k">IF</span>
<span class="w">        </span><span class="k">END</span><span class="w"> </span><span class="k">FOR</span>
<span class="w">    </span><span class="k">END</span><span class="w"> </span><span class="k">FOR</span>
</code></pre></div>

<p><strong>비용 (빌드 릴레이션이 메모리에 맞는 경우)</strong>:</p>
<div class="highlight"><pre><span></span><code>비용 = b_s + b_r  블록 전송 (두 릴레이션을 한 번씩 읽기)
     = 2          탐색
</code></pre></div>

<p>이것은 최적입니다! 각 릴레이션을 정확히 한 번씩 읽습니다.</p>
<p><strong>예제</strong>: departments (2 블록)가 메모리에 맞음:
- 비용: 2 + 500 = 502 전송, 2 탐색
- 시간: 502 × 0.1ms + 2 × 4ms = <strong>58.2 ms</strong></p>
<p><strong>Grace 해시 조인 (빌드가 메모리에 맞지 않을 때)</strong>:</p>
<p>더 작은 릴레이션이 메모리에 맞지 않으면, 파티셔닝 사용:</p>
<div class="highlight"><pre><span></span><code>Phase 1 (파티션): r과 s를 모두 M-1 파티션으로 해시
    각 파티션은 디스크에 기록됨

Phase 2 (빌드 &amp; 프로브): 각 파티션 i에 대해:
    s의 파티션 i를 해시 테이블에 로드
    r의 파티션 i를 스캔, 해시 테이블 프로브
</code></pre></div>

<p><strong>비용</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="err">파티셔닝</span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="o">(</span><span class="n">b_r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b_s</span><span class="o">)</span><span class="w">    </span><span class="err">전송</span><span class="w"> </span><span class="o">(</span><span class="err">읽기</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="err">쓰기</span><span class="w"> </span><span class="err">모두</span><span class="o">)</span>
<span class="err">빌드</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="err">프로브</span><span class="o">:</span><span class="w"> </span><span class="n">b_r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b_s</span><span class="w">     </span><span class="err">전송</span><span class="w"> </span><span class="o">(</span><span class="err">두</span><span class="w"> </span><span class="err">파티션</span><span class="w"> </span><span class="err">읽기</span><span class="o">)</span>
<span class="err">총</span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="o">(</span><span class="n">b_r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b_s</span><span class="o">)</span><span class="w">          </span><span class="err">전송</span>
</code></pre></div>

<p><strong>요구사항</strong>: 더 작은 릴레이션의 각 파티션이 메모리에 맞아야 함:</p>
<div class="highlight"><pre><span></span><code>b_s / (M - 1) ≤ M - 2
⟹ b_s ≤ (M - 1)(M - 2) ≈ M²
</code></pre></div>

<p>따라서 해시 조인은 더 작은 릴레이션이 최대 약 M² 블록을 가지면 작동합니다.</p>
<h3 id="67-cost-comparison">6.7 비용 비교(Cost Comparison)<a class="header-link" href="#67-cost-comparison" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>알고리즘</th>
<th style="text-align: center;">블록 전송</th>
<th style="text-align: center;">탐색</th>
<th>최선의 경우</th>
</tr>
</thead>
<tbody>
<tr>
<td>중첩 루프</td>
<td style="text-align: center;">n_r × b_s + b_r</td>
<td style="text-align: center;">n_r + b_r</td>
<td>절대 (최악의 경우)</td>
</tr>
<tr>
<td>블록 중첩 루프</td>
<td style="text-align: center;">⌈b_r/(M-2)⌉ × b_s + b_r</td>
<td style="text-align: center;">2⌈b_r/(M-2)⌉</td>
<td>인덱스 없음, 작은 M</td>
</tr>
<tr>
<td>인덱스 NL</td>
<td style="text-align: center;">b_r + n_r × c</td>
<td style="text-align: center;">b_r + n_r</td>
<td>내부 조인 속성에 인덱스</td>
</tr>
<tr>
<td>정렬-병합</td>
<td style="text-align: center;">정렬 비용 + b_r + b_s</td>
<td style="text-align: center;">많은 탐색</td>
<td>이미 정렬됨, 또는 θ-조인</td>
</tr>
<tr>
<td>해시 조인 (인메모리)</td>
<td style="text-align: center;">b_r + b_s</td>
<td style="text-align: center;">2</td>
<td>더 작은 릴레이션이 메모리에 맞음</td>
</tr>
<tr>
<td>Grace 해시 조인</td>
<td style="text-align: center;">3(b_r + b_s)</td>
<td style="text-align: center;">중간</td>
<td>큰 릴레이션, M² 충분</td>
</tr>
</tbody>
</table>
<p><strong>우리 예제에 대한 실제 비교</strong> (employees ⋈ departments, M = 52):</p>
<table>
<thead>
<tr>
<th>알고리즘</th>
<th>전송</th>
<th>시간 (대략)</th>
</tr>
</thead>
<tbody>
<tr>
<td>튜플 NLJ</td>
<td>20,500</td>
<td>44초</td>
</tr>
<tr>
<td>블록 NLJ (M=52)</td>
<td>520</td>
<td>132 ms</td>
</tr>
<tr>
<td>정렬-병합</td>
<td>2,506</td>
<td>~260 ms</td>
</tr>
<tr>
<td>해시 조인 (인메모리)</td>
<td>502</td>
<td>58 ms</td>
</tr>
</tbody>
</table>
<p>더 작은 릴레이션이 메모리에 맞을 때 해시 조인이 결정적으로 승리합니다.</p>
<hr />
<h2 id="7-query-optimization">7. 쿼리 최적화(Query Optimization)<a class="header-link" href="#7-query-optimization" title="Permanent link">&para;</a></h2>
<h3 id="71-overview">7.1 개요(Overview)<a class="header-link" href="#71-overview" title="Permanent link">&para;</a></h3>
<p>최적화기는 초기 쿼리 계획을 동등하지만 더 효율적인 것으로 변환합니다. 두 가지 주요 접근 방식:</p>
<ol>
<li><strong>휴리스틱(규칙 기반) 최적화(Heuristic (rule-based) optimization)</strong>: "거의 항상" 유익한 변환 규칙 적용</li>
<li><strong>비용 기반 최적화(Cost-based optimization)</strong>: 대안 계획 나열, 각 비용 추정, 가장 저렴한 것 선택</li>
</ol>
<p>대부분의 실제 시스템은 두 가지의 조합을 사용합니다.</p>
<h3 id="72-equivalence-rules-for-relational-algebra">7.2 관계 대수의 동등 규칙(Equivalence Rules for Relational Algebra)<a class="header-link" href="#72-equivalence-rules-for-relational-algebra" title="Permanent link">&para;</a></h3>
<p>이러한 규칙은 최적화기가 한 표현식을 동등한 것으로 변환할 수 있게 합니다:</p>
<h4 id="1-cascade-of-selections">규칙 1: 선택의 연쇄(Cascade of Selections)<a class="header-link" href="#1-cascade-of-selections" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>σ_{θ₁ ∧ θ₂}(r) = σ_{θ₁}(σ_{θ₂}(r))
</code></pre></div>

<p>연언은 순차적 선택으로 분할될 수 있습니다.</p>
<h4 id="2-commutativity-of-selection">규칙 2: 선택의 교환성(Commutativity of Selection)<a class="header-link" href="#2-commutativity-of-selection" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>σ_{θ₁}(σ_{θ₂}(r)) = σ_{θ₂}(σ_{θ₁}(r))
</code></pre></div>

<p>선택의 순서는 중요하지 않습니다.</p>
<h4 id="3-cascade-of-projections">규칙 3: 투영의 연쇄(Cascade of Projections)<a class="header-link" href="#3-cascade-of-projections" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>π_{L₁}(π_{L₂}(...(π_{Lₙ}(r)))) = π_{L₁}(r)
</code></pre></div>

<p>가장 바깥쪽 투영만 중요합니다 (L₁ ⊆ L₂ ⊆ ... ⊆ Lₙ인 한).</p>
<h4 id="4-commutativity-of-join">규칙 4: 조인의 교환성(Commutativity of Join)<a class="header-link" href="#4-commutativity-of-join" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>r ⋈ s = s ⋈ r
</code></pre></div>

<h4 id="5-associativity-of-join">규칙 5: 조인의 결합성(Associativity of Join)<a class="header-link" href="#5-associativity-of-join" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>(r ⋈ s) ⋈ t = r ⋈ (s ⋈ t)
</code></pre></div>

<p>이는 다방향 조인에 중요합니다. n개 테이블의 경우, (2(n-1))! / (n-1)! 다른 조인 순서가 있습니다 (카탈란 수). 5개 테이블의 경우, 14개 순서. 10개 테이블: 4,862개.</p>
<h4 id="6-push-selection-through-join">규칙 6: 조인을 통한 선택 푸시(Push Selection Through Join)<a class="header-link" href="#6-push-selection-through-join" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>σ_{θ}(r ⋈ s) = σ_{θ}(r) ⋈ s     (θ가 r의 속성만 포함하는 경우)
</code></pre></div>

<p>이것이 가장 중요한 단일 최적화입니다: <strong>일찍 필터링하여 중간 결과 크기 감소</strong>.</p>
<h4 id="7-push-selection-through-set-operations">규칙 7: 집합 연산을 통한 선택 푸시(Push Selection Through Set Operations)<a class="header-link" href="#7-push-selection-through-set-operations" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>σ_{θ}(r ∪ s) = σ_{θ}(r) ∪ σ_{θ}(s)
σ_{θ}(r ∩ s) = σ_{θ}(r) ∩ s     (또는 r ∩ σ_{θ}(s))
σ_{θ}(r - s) = σ_{θ}(r) - s
</code></pre></div>

<h4 id="8-push-projection-through-join">규칙 8: 조인을 통한 투영 푸시(Push Projection Through Join)<a class="header-link" href="#8-push-projection-through-join" title="Permanent link">&para;</a></h4>
<div class="highlight"><pre><span></span><code>π_{L}(r ⋈_{θ} s) = π_{L}(π_{L₁}(r) ⋈_{θ} π_{L₂}(s))
</code></pre></div>

<p>여기서 L₁ = L 또는 θ에 필요한 r의 속성, L₂ = L 또는 θ에 필요한 s의 속성.</p>
<h3 id="73-heuristic-optimization">7.3 휴리스틱 최적화(Heuristic Optimization)<a class="header-link" href="#73-heuristic-optimization" title="Permanent link">&para;</a></h3>
<p>일반 전략:</p>
<ol>
<li>연언 선택 <strong>분해</strong> (규칙 1)</li>
<li>선택을 가능한 한 아래로 <strong>푸시</strong> (규칙 6, 7)</li>
<li>투영을 가능한 한 아래로 <strong>푸시</strong> (규칙 8)</li>
<li><strong>조인 순서 선택</strong>: 가장 선택적인 조인을 먼저 배치</li>
<li>파이프라인으로 실행될 수 있는 <strong>하위 트리 식별</strong></li>
</ol>
<h4 id="_1">예제: 휴리스틱 최적화<a class="header-link" href="#_1" title="Permanent link">&para;</a></h4>
<p>원본:</p>
<div class="highlight"><pre><span></span><code>π_{e.name, d.dept_name}(σ_{e.salary &gt; 80000 ∧ d.building = &#39;Watson&#39;}(employees ⋈ departments))
</code></pre></div>

<p><strong>1단계</strong>: 선택 분해</p>
<div class="highlight"><pre><span></span><code>π_{e.name, d.dept_name}(σ_{e.salary &gt; 80000}(σ_{d.building = &#39;Watson&#39;}(employees ⋈ departments)))
</code></pre></div>

<p><strong>2단계</strong>: 선택 푸시 다운</p>
<div class="highlight"><pre><span></span><code>π_{e.name, d.dept_name}(σ_{e.salary &gt; 80000}(employees) ⋈ σ_{d.building = &#39;Watson&#39;}(departments))
</code></pre></div>

<p><strong>3단계</strong>: 투영 푸시 다운</p>
<div class="highlight"><pre><span></span><code>π_{e.name, d.dept_name}(
    π_{e.name, e.dept_id}(σ_{e.salary &gt; 80000}(employees))
    ⋈
    π_{d.dept_id, d.dept_name}(σ_{d.building = &#39;Watson&#39;}(departments))
)
</code></pre></div>

<p><strong>전후 비교:</strong></p>
<div class="highlight"><pre><span></span><code><span class="err">전</span><span class="o">:</span><span class="w"> </span><span class="err">모든</span><span class="w"> </span><span class="err">직원을</span><span class="w"> </span><span class="err">모든</span><span class="w"> </span><span class="err">부서와</span><span class="w"> </span><span class="err">조인</span><span class="o">,</span><span class="w"> </span><span class="err">그</span><span class="w"> </span><span class="err">다음</span><span class="w"> </span><span class="err">필터링</span><span class="o">.</span>
<span class="w">  </span><span class="err">비용</span><span class="o">:</span><span class="w"> </span><span class="mi">10</span><span class="o">,</span><span class="mi">000</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="o">,</span><span class="mi">000</span><span class="w"> </span><span class="err">중간</span><span class="w"> </span><span class="err">튜플</span>

<span class="err">후</span><span class="o">:</span><span class="w"> </span><span class="err">직원</span><span class="w"> </span><span class="err">필터링</span><span class="w"> </span><span class="o">(</span><span class="mi">1</span><span class="o">,</span><span class="mi">000</span><span class="err">개</span><span class="w"> </span><span class="err">남음</span><span class="o">)</span><span class="w"> </span><span class="err">및</span><span class="w"> </span><span class="err">부서</span><span class="w"> </span><span class="o">(</span><span class="mi">5</span><span class="err">개</span><span class="w"> </span><span class="err">남음</span><span class="o">),</span><span class="w"> </span><span class="err">그</span><span class="w"> </span><span class="err">다음</span><span class="w"> </span><span class="err">조인</span><span class="o">.</span>
<span class="w">  </span><span class="err">비용</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">000</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="mi">000</span><span class="w"> </span><span class="err">중간</span><span class="w"> </span><span class="err">튜플</span><span class="w"> </span><span class="err">—</span><span class="w"> </span><span class="mi">100</span><span class="err">배</span><span class="w"> </span><span class="err">감소</span><span class="o">!</span>
</code></pre></div>

<h3 id="74-cost-based-optimization">7.4 비용 기반 최적화(Cost-Based Optimization)<a class="header-link" href="#74-cost-based-optimization" title="Permanent link">&para;</a></h3>
<p>휴리스틱 최적화는 좋지만 충분하지 않습니다. 최적화기는 각 계획의 <strong>실제 비용</strong>을 추정하여 최선의 것을 선택해야 합니다.</p>
<h4 id="selectivity-estimation">선택도 추정(Selectivity Estimation)<a class="header-link" href="#selectivity-estimation" title="Permanent link">&para;</a></h4>
<p>술어의 <strong>선택도(selectivity)</strong>는 그것을 만족하는 튜플의 분율을 추정합니다:</p>
<table>
<thead>
<tr>
<th>술어</th>
<th>추정 선택도</th>
</tr>
</thead>
<tbody>
<tr>
<td>A = v (동등 조건)</td>
<td>1 / V(A, r)</td>
</tr>
<tr>
<td>A &gt; v (범위, 균등 분포)</td>
<td>(max(A) - v) / (max(A) - min(A))</td>
</tr>
<tr>
<td>A ≥ v₁ AND A ≤ v₂</td>
<td>(v₂ - v₁) / (max(A) - min(A))</td>
</tr>
<tr>
<td>θ₁ ∧ θ₂ (연언, 독립)</td>
<td>sel(θ₁) × sel(θ₂)</td>
</tr>
<tr>
<td>θ₁ ∨ θ₂ (선언, 독립)</td>
<td>sel(θ₁) + sel(θ₂) - sel(θ₁) × sel(θ₂)</td>
</tr>
<tr>
<td>NOT θ</td>
<td>1 - sel(θ)</td>
</tr>
</tbody>
</table>
<p><strong>예제</strong>: σ_{salary &gt; 80000}(employees)의 크기 추정</p>
<p>급여가 30,000부터 150,000까지의 범위 (균등 분포):</p>
<div class="highlight"><pre><span></span><code>sel = (150,000 - 80,000) / (150,000 - 30,000) = 70,000 / 120,000 ≈ 0.583
추정 튜플 = 10,000 × 0.583 ≈ 5,833
</code></pre></div>

<h4 id="join-size-estimation">조인 크기 추정(Join Size Estimation)<a class="header-link" href="#join-size-estimation" title="Permanent link">&para;</a></h4>
<p>속성 A에 대한 자연 조인 r ⋈ s의 경우:</p>
<div class="highlight"><pre><span></span><code>추정 크기 = (n_r × n_s) / max(V(A, r), V(A, s))
</code></pre></div>

<p><strong>예제</strong>: dept_id에 대한 employees ⋈ departments:</p>
<div class="highlight"><pre><span></span><code>크기 = (10,000 × 50) / max(50, 50) = 500,000 / 50 = 10,000
</code></pre></div>

<p>이것은 의미가 있습니다: 각 직원은 하나의 부서에 있으므로, 조인은 직원당 하나의 튜플을 생성합니다.</p>
<h4 id="histograms">히스토그램(Histograms)<a class="header-link" href="#histograms" title="Permanent link">&para;</a></h4>
<p>균등 분포 가정은 종종 부정확합니다. 실제 데이터베이스는 <strong>히스토그램</strong> — 값의 분포에 대한 통계를 유지합니다:</p>
<p><strong>등폭 히스토그램(Equi-width histogram)</strong>: 값 범위를 동일 폭 버킷으로 나누고, 버킷당 튜플을 세헤아립니다.</p>
<div class="highlight"><pre><span></span><code>급여 히스토그램 (5 버킷):
  [30K-54K):  2,500명 직원
  [54K-78K):  3,000명 직원
  [78K-102K): 2,500명 직원
  [102K-126K): 1,500명 직원
  [126K-150K]: 500명 직원
</code></pre></div>

<p>이 히스토그램으로 σ_{salary &gt; 80000}을 추정하면:</p>
<div class="highlight"><pre><span></span><code>(102K-80K)/(102K-78K) × 2,500 + 1,500 + 500 = (22/24) × 2,500 + 2,000 ≈ 4,292
</code></pre></div>

<p>균등 추정 5,833보다 훨씬 더 정확합니다!</p>
<p><strong>등깊이(등높이) 히스토그램(Equi-depth (equi-height) histogram)</strong>: 각 버킷이 대략 동일한 수의 튜플을 가집니다. 치우친 분포에 더 좋습니다.</p>
<h3 id="75-join-ordering-optimization">7.5 조인 순서 최적화(Join Ordering Optimization)<a class="header-link" href="#75-join-ordering-optimization" title="Permanent link">&para;</a></h3>
<p>다방향 조인의 경우, 순서가 엄청나게 중요합니다. 다음을 고려하세요:</p>
<div class="highlight"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">r1</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">r2</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">r3</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="p">...</span><span class="w"> </span><span class="k">JOIN</span><span class="w"> </span><span class="n">r4</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="p">...</span>
</code></pre></div>

<p>가능한 순서 (4개 테이블):
1. ((r1 ⋈ r2) ⋈ r3) ⋈ r4
2. (r1 ⋈ (r2 ⋈ r3)) ⋈ r4
3. (r1 ⋈ r2) ⋈ (r3 ⋈ r4)
4. ... (훨씬 더 많음)</p>
<p>최적화기는 <strong>동적 프로그래밍</strong>을 사용하여 최선의 순서를 찾습니다:</p>
<div class="highlight"><pre><span></span><code><span class="n">ALGORITHM</span><span class="o">:</span><span class="w"> </span><span class="n">FindBestJoinOrder</span><span class="o">({</span><span class="n">R₁</span><span class="o">,</span><span class="w"> </span><span class="n">R₂</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">Rₙ</span><span class="o">})</span>

<span class="n">FOR</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">single</span><span class="w"> </span><span class="n">relation</span><span class="w"> </span><span class="n">Rᵢ</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">bestPlan</span><span class="o">({</span><span class="n">Rᵢ</span><span class="o">})</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">Rᵢ에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="err">액세스</span><span class="w"> </span><span class="err">경로</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>

<span class="n">FOR</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">TO</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="n">DO</span>
<span class="w">    </span><span class="n">FOR</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="n">subset</span><span class="w"> </span><span class="n">S</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">size</span><span class="w"> </span><span class="s1">&#39;size&#39;</span><span class="w"> </span><span class="n">DO</span>
<span class="w">        </span><span class="n">bestPlan</span><span class="o">(</span><span class="n">S</span><span class="o">)</span><span class="w"> </span><span class="err">←</span><span class="w"> </span><span class="n">S를</span><span class="w"> </span><span class="err">비어</span><span class="w"> </span><span class="err">있지</span><span class="w"> </span><span class="err">않은</span><span class="w"> </span><span class="n">S₁</span><span class="w"> </span><span class="err">∪</span><span class="w"> </span><span class="n">S₂로</span><span class="w"> </span><span class="err">분할하는</span>
<span class="w">                       </span><span class="err">모든</span><span class="w"> </span><span class="err">방법에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">MIN</span><span class="o">:</span>
<span class="w">                       </span><span class="n">cost</span><span class="o">(</span><span class="n">bestPlan</span><span class="o">(</span><span class="n">S₁</span><span class="o">)</span><span class="w"> </span><span class="err">⋈</span><span class="w"> </span><span class="n">bestPlan</span><span class="o">(</span><span class="n">S₂</span><span class="o">))</span>
<span class="w">    </span><span class="n">END</span><span class="w"> </span><span class="n">FOR</span>
<span class="n">END</span><span class="w"> </span><span class="n">FOR</span>

<span class="n">RETURN</span><span class="w"> </span><span class="n">bestPlan</span><span class="o">({</span><span class="n">R₁</span><span class="o">,</span><span class="w"> </span><span class="n">R₂</span><span class="o">,</span><span class="w"> </span><span class="o">...,</span><span class="w"> </span><span class="n">Rₙ</span><span class="o">})</span>
</code></pre></div>

<p>이것은 모든 가능한 조인 트리(왼쪽-깊은 트리뿐만 아니라 덤불 트리도 포함)를 고려합니다. 복잡도: O(3ⁿ) — 지수적이지만 최대 ~15-20개 테이블까지의 쿼리에 실용적입니다.</p>
<p>더 큰 쿼리의 경우, 휴리스틱 또는 탐욕 알고리즘이 대신 사용됩니다.</p>
<h3 id="76-vs-left-deep-vs-bushy-join-trees">7.6 왼쪽-깊은 vs 덤불 조인 트리(Left-Deep vs Bushy Join Trees)<a class="header-link" href="#76-vs-left-deep-vs-bushy-join-trees" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>왼쪽-깊은 트리:              덤불 트리:

        ⋈                        ⋈
       / \                      / \
      ⋈   R₄                  ⋈   ⋈
     / \                      / \ / \
    ⋈   R₃                  R₁ R₂ R₃ R₄
   / \
  R₁  R₂
</code></pre></div>

<p><strong>왼쪽-깊은 트리</strong>는 많은 최적화기가 선호합니다:
1. 각 조인 단계의 내부 릴레이션이 파이프라이닝을 사용할 수 있습니다 (구체화 없음)
2. 인덱스 중첩 루프 조인이 자연스럽게 작동합니다 (내부 = 인덱스된 테이블)
3. 검색 공간이 더 작습니다: n! 순서 vs 덤불 트리의 경우 지수적으로 더 많음</p>
<hr />
<h2 id="8-statistics-and-catalog-information">8. 통계 및 카탈로그 정보(Statistics and Catalog Information)<a class="header-link" href="#8-statistics-and-catalog-information" title="Permanent link">&para;</a></h2>
<h3 id="81-what-the-catalog-stores">8.1 카탈로그에 저장되는 것(What the Catalog Stores)<a class="header-link" href="#81-what-the-catalog-stores" title="Permanent link">&para;</a></h3>
<p>시스템 카탈로그(메타데이터)는 비용 추정을 위한 통계를 유지합니다:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL 카탈로그 테이블:</span>
<span class="n">pg_class</span><span class="w">     </span><span class="c1">-- 테이블/인덱스 통계 (n_r, b_r 등)</span>
<span class="n">pg_statistic</span><span class="w"> </span><span class="c1">-- 열 수준 통계 (히스토그램, 고유 값, 상관관계)</span>
<span class="n">pg_stats</span><span class="w">     </span><span class="c1">-- 통계의 사람이 읽을 수 있는 뷰</span>
</code></pre></div>

<p>주요 통계:
- <strong>n_r</strong> (reltuples): 테이블의 행 수
- <strong>b_r</strong> (relpages): 디스크 페이지 수
- <strong>V(A, r)</strong> (n_distinct): 열당 고유 값 수
- <strong>히스토그램(Histograms)</strong>: 열당 값 분포
- <strong>상관관계(Correlation)</strong>: 물리적 순서가 논리적 순서와 얼마나 잘 일치하는지 (범위 스캔에 중요)
- <strong>가장 일반적인 값(Most common values, MCV)</strong>: 가장 빈번한 값의 목록과 그 빈도
- <strong>NULL 분율(NULL fraction)</strong>: 열당 NULL 값의 분율</p>
<h3 id="82-updating-statistics">8.2 통계 업데이트(Updating Statistics)<a class="header-link" href="#82-updating-statistics" title="Permanent link">&para;</a></h3>
<p>데이터가 변경됨에 따라 통계가 오래됩니다. 데이터베이스는 통계를 새로 고칠 명령을 제공합니다:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL</span>
<span class="k">ANALYZE</span><span class="w"> </span><span class="n">employees</span><span class="p">;</span><span class="w">              </span><span class="c1">-- 하나의 테이블에 대한 통계 업데이트</span>
<span class="k">ANALYZE</span><span class="p">;</span><span class="w">                         </span><span class="c1">-- 모든 테이블에 대한 통계 업데이트</span>
<span class="k">ALTER</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="p">(</span><span class="n">autovacuum_analyze_threshold</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">50</span><span class="p">);</span>

<span class="c1">-- MySQL</span>
<span class="k">ANALYZE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">employees</span><span class="p">;</span>

<span class="c1">-- SQL Server</span>
<span class="k">UPDATE</span><span class="w"> </span><span class="k">STATISTICS</span><span class="w"> </span><span class="n">employees</span><span class="p">;</span>
</code></pre></div>

<p>PostgreSQL의 <strong>autovacuum</strong> 프로세스는 충분한 행이 변경되면 자동으로 통계를 업데이트합니다 (기본값: 테이블의 10%).</p>
<h3 id="83-impact-of-stale-statistics">8.3 오래된 통계의 영향(Impact of Stale Statistics)<a class="header-link" href="#83-impact-of-stale-statistics" title="Permanent link">&para;</a></h3>
<p>오래된 통계는 <strong>나쁜 계획</strong>으로 이어집니다:</p>
<div class="highlight"><pre><span></span><code><span class="err">시나리오</span><span class="o">:</span><span class="w"> </span><span class="err">통계가</span><span class="w"> </span><span class="err">수집되었을</span><span class="w"> </span><span class="err">때</span><span class="w"> </span><span class="err">테이블이</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">000</span><span class="err">개</span><span class="w"> </span><span class="err">행을</span><span class="w"> </span><span class="err">가졌습니다</span><span class="o">.</span>
<span class="w">          </span><span class="err">이제</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">000</span><span class="o">,</span><span class="mi">000</span><span class="err">개</span><span class="w"> </span><span class="err">행을</span><span class="w"> </span><span class="err">가집니다</span><span class="o">.</span>

<span class="err">최적화기</span><span class="w"> </span><span class="err">생각</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;작은 테이블, 중첩 루프 조인이 괜찮습니다.&quot;</span>
<span class="err">현실</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;거대한 테이블, 해시 조인이 1000배 더 빠를 것입니다.&quot;</span>
</code></pre></div>

<p>이것은 프로덕션 시스템에서 갑작스러운 쿼리 성능 저하의 가장 일반적인 원인 중 하나입니다.</p>
<hr />
<h2 id="9-query-execution-engine-architecture">9. 쿼리 실행 엔진 아키텍처(Query Execution Engine Architecture)<a class="header-link" href="#9-query-execution-engine-architecture" title="Permanent link">&para;</a></h2>
<h3 id="91-components">9.1 구성 요소(Components)<a class="header-link" href="#91-components" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="err">┌──────────────────────────────────────────────────────────┐</span>
<span class="err">│</span><span class="w">                    </span><span class="n">Query</span><span class="w"> </span><span class="n">Executor</span><span class="w">                         </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">┌────────────┐</span><span class="w">  </span><span class="err">┌────────────┐</span><span class="w">  </span><span class="err">┌────────────────────┐</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Plan</span><span class="w"> </span><span class="n">Cache</span><span class="w">  </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Iterator</span><span class="w">   </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Expression</span><span class="w">         </span><span class="err">│</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="p">(</span><span class="n">prepared</span><span class="w">   </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Operators</span><span class="w">  </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Evaluator</span><span class="w">          </span><span class="err">│</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">  </span><span class="n">statements</span><span class="p">)</span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">            </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="p">(</span><span class="n">predicates</span><span class="p">,</span><span class="w">       </span><span class="err">│</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">             </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">SeqScan</span><span class="w">  </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">  </span><span class="n">projections</span><span class="p">,</span><span class="w">      </span><span class="err">│</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">             </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">IdxScan</span><span class="w">  </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">  </span><span class="n">aggregations</span><span class="p">)</span><span class="w">     </span><span class="err">│</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">             </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">NestLoop</span><span class="w"> </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">             </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">HashJoin</span><span class="w"> </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">             </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">SortMrg</span><span class="w">  </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">             </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">HashAgg</span><span class="w">  </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">             </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">Sort</span><span class="w">     </span><span class="err">│</span><span class="w">  </span><span class="err">│</span><span class="w">                    </span><span class="err">│</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="err">└────────────┘</span><span class="w">  </span><span class="err">└────────────┘</span><span class="w">  </span><span class="err">└────────────────────┘</span><span class="w"> </span><span class="err">│</span>
<span class="err">│</span><span class="w">                         </span><span class="err">│</span><span class="w">                                 </span><span class="err">│</span>
<span class="err">│</span><span class="w">              </span><span class="err">┌──────────┴──────────┐</span><span class="w">                     </span><span class="err">│</span>
<span class="err">│</span><span class="w">              </span><span class="err">│</span><span class="w">  </span><span class="n">Buffer</span><span class="w"> </span><span class="n">Manager</span><span class="w">     </span><span class="err">│</span><span class="w">                     </span><span class="err">│</span>
<span class="err">│</span><span class="w">              </span><span class="err">│</span><span class="w">  </span><span class="p">(</span><span class="n">page</span><span class="w"> </span><span class="n">cache</span><span class="p">)</span><span class="w">       </span><span class="err">│</span><span class="w">                     </span><span class="err">│</span>
<span class="err">│</span><span class="w">              </span><span class="err">└──────────┬──────────┘</span><span class="w">                     </span><span class="err">│</span>
<span class="err">│</span><span class="w">                         </span><span class="err">│</span><span class="w">                                 </span><span class="err">│</span>
<span class="err">│</span><span class="w">              </span><span class="err">┌──────────┴──────────┐</span><span class="w">                     </span><span class="err">│</span>
<span class="err">│</span><span class="w">              </span><span class="err">│</span><span class="w">  </span><span class="n">Storage</span><span class="w"> </span><span class="n">Engine</span><span class="w">     </span><span class="err">│</span><span class="w">                     </span><span class="err">│</span>
<span class="err">│</span><span class="w">              </span><span class="err">│</span><span class="w">  </span><span class="p">(</span><span class="n">disk</span><span class="w"> </span><span class="n">I</span><span class="o">/</span><span class="n">O</span><span class="p">)</span><span class="w">         </span><span class="err">│</span><span class="w">                     </span><span class="err">│</span>
<span class="err">│</span><span class="w">              </span><span class="err">└─────────────────────┘</span><span class="w">                     </span><span class="err">│</span>
<span class="err">└──────────────────────────────────────────────────────────┘</span>
</code></pre></div>

<h3 id="92-plan-caching">9.2 계획 캐싱(Plan Caching)<a class="header-link" href="#92-plan-caching" title="Permanent link">&para;</a></h3>
<p>파싱과 최적화는 비용이 많이 듭니다. 데이터베이스는 이 작업을 반복하지 않도록 실행 계획을 캐시합니다:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL: 준비된 문은 계획을 캐시합니다</span>
<span class="k">PREPARE</span><span class="w"> </span><span class="n">find_emp</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">emp_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">$</span><span class="mi">1</span><span class="p">;</span>

<span class="k">EXECUTE</span><span class="w"> </span><span class="n">find_emp</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span><span class="w">   </span><span class="c1">-- 첫 실행: 파싱 + 최적화 + 실행</span>
<span class="k">EXECUTE</span><span class="w"> </span><span class="n">find_emp</span><span class="p">(</span><span class="mi">99</span><span class="p">);</span><span class="w">   </span><span class="c1">-- 후속: 캐시된 계획 재사용</span>
</code></pre></div>

<p><strong>계획 무효화</strong>: 캐시된 계획은 다음의 경우 무효가 됩니다:
- 테이블 구조 변경 (ALTER TABLE)
- 통계 업데이트 (ANALYZE)
- 인덱스 생성 또는 삭제</p>
<h3 id="93-reading-execution-plans">9.3 실행 계획 읽기(Reading Execution Plans)<a class="header-link" href="#93-reading-execution-plans" title="Permanent link">&para;</a></h3>
<p>대부분의 데이터베이스는 실행 계획을 보는 명령을 제공합니다:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL</span>
<span class="k">EXPLAIN</span><span class="w"> </span><span class="k">ANALYZE</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">dept_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="n">e</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">departments</span><span class="w"> </span><span class="n">d</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">dept_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">dept_id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">salary</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">80000</span><span class="p">;</span>
</code></pre></div>

<p>출력 (예):</p>
<div class="highlight"><pre><span></span><code><span class="nf">Hash</span><span class="w"> </span><span class="nf">Join</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">1.12</span><span class="p">.</span><span class="mf">.25.47</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">167</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">actual</span><span class="w"> </span><span class="n">time</span><span class="o">=</span><span class="mf">0.05</span><span class="p">.</span><span class="mf">.0.31</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">150</span><span class="w"> </span><span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="nf">Hash</span><span class="w"> </span><span class="n">Cond</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">dept_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">.</span><span class="n">dept_id</span><span class="p">)</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="kr">Scan</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="n">e</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.00</span><span class="p">.</span><span class="mf">.22.50</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">167</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">actual</span><span class="w"> </span><span class="n">time</span><span class="o">=</span><span class="mf">0.01</span><span class="p">.</span><span class="mf">.0.15</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">150</span><span class="w"> </span><span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">Filter</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">salary</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">80000</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rows</span><span class="w"> </span><span class="n">Removed</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">Filter</span><span class="o">:</span><span class="w"> </span><span class="mi">850</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="nf">Hash</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">1.05</span><span class="p">.</span><span class="mf">.1.05</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">50</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">28</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">actual</span><span class="w"> </span><span class="n">time</span><span class="o">=</span><span class="mf">0.02</span><span class="p">.</span><span class="mf">.0.02</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">50</span><span class="w"> </span><span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="w">        </span><span class="n">Buckets</span><span class="o">:</span><span class="w"> </span><span class="mi">1024</span><span class="w">  </span><span class="n">Batches</span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="n">Memory</span><span class="w"> </span><span class="n">Usage</span><span class="o">:</span><span class="w"> </span><span class="mi">12</span><span class="n">kB</span>
<span class="w">        </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="kr">Scan</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">departments</span><span class="w"> </span><span class="n">d</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.00</span><span class="p">.</span><span class="mf">.1.05</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">50</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">28</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="n">actual</span><span class="w"> </span><span class="n">time</span><span class="o">=</span><span class="mf">0.00</span><span class="p">.</span><span class="mf">.0.01</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">50</span><span class="w"> </span><span class="n">loops</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">Planning</span><span class="w"> </span><span class="n">Time</span><span class="o">:</span><span class="w"> </span><span class="mf">0.15</span><span class="w"> </span><span class="n">ms</span>
<span class="n">Execution</span><span class="w"> </span><span class="n">Time</span><span class="o">:</span><span class="w"> </span><span class="mf">0.38</span><span class="w"> </span><span class="n">ms</span>
</code></pre></div>

<p><strong>이 계획 읽기 (아래에서 위로)</strong>:
1. departments의 순차 스캔 (50개 행) → 해시 테이블 빌드 (12 KB)
2. salary &gt; 80000 필터를 사용한 employees의 순차 스캔 (1000개 중 150개 행 통과)
3. dept_id를 사용한 해시 조인
4. 총: 0.38 ms 실행 시간</p>
<h3 id="94-adaptive-query-execution">9.4 적응형 쿼리 실행(Adaptive Query Execution)<a class="header-link" href="#94-adaptive-query-execution" title="Permanent link">&para;</a></h3>
<p>현대 데이터베이스는 런타임 중에 실행 계획을 조정할 수 있습니다:</p>
<ul>
<li><strong>PostgreSQL</strong>: 준비된 문에 대해 일반 vs 맞춤 계획을 사용합니다. 5번 실행 후, 비교하고 전환할 수 있습니다.</li>
<li><strong>Oracle</strong>: 적응형 커서 공유 — 캐시된 계획이 특정 매개변수 값에 대해 성능이 나쁠 때 감지</li>
<li><strong>Spark SQL</strong>: 적응형 쿼리 실행(Adaptive Query Execution, AQE) — 실제 파티션 크기에 기반하여 쿼리 중간에 재최적화</li>
</ul>
<hr />
<h2 id="10-advanced-topics">10. 고급 주제(Advanced Topics)<a class="header-link" href="#10-advanced-topics" title="Permanent link">&para;</a></h2>
<h3 id="101-parallel-query-execution">10.1 병렬 쿼리 실행(Parallel Query Execution)<a class="header-link" href="#101-parallel-query-execution" title="Permanent link">&para;</a></h3>
<p>현대 데이터베이스는 여러 CPU 코어에 걸쳐 쿼리 실행을 병렬화합니다:</p>
<div class="highlight"><pre><span></span><code>              Gather
             /  |  \
     Worker1  Worker2  Worker3
        |        |        |
     Scan(p1) Scan(p2) Scan(p3)  ← 병렬 순차 스캔
</code></pre></div>

<p>병렬화 가능한 연산:
- 스캔 (테이블을 범위로 나눔)
- 필터 (각 워커가 자신의 파티션을 필터링)
- 해시 조인 (병렬 빌드 + 병렬 프로브)
- 집계 (워커당 부분 집계, 그 다음 병합)
- 정렬 (병렬 정렬, 그 다음 병합)</p>
<h3 id="102-columnar-execution">10.2 열 기반 실행(Columnar Execution)<a class="header-link" href="#102-columnar-execution" title="Permanent link">&para;</a></h3>
<p>전통적인 행 저장소: 전체 행을 읽으며, 일부 열만 필요해도.</p>
<p>열 저장소: 각 열을 별도로 저장, 필요한 열만 읽음.</p>
<div class="highlight"><pre><span></span><code>행 저장소:                     열 저장소:
[id=1, name=Alice, sal=80K]   id:   [1, 2, 3, ...]
[id=2, name=Bob,   sal=90K]   name: [Alice, Bob, ...]
[id=3, name=Carol, sal=75K]   sal:  [80K, 90K, 75K, ...]
</code></pre></div>

<p>분석을 위한 열 저장소의 장점:
- 필요한 열만 읽기 (더 적은 I/O)
- 더 나은 압축 (유사한 값이 함께)
- CPU 친화적 (열 배열에 대한 SIMD 연산)
- 사용처: DuckDB, ClickHouse, Redshift, BigQuery</p>
<h3 id="103-just-in-time-jit-just-in-time-jit-compilation">10.3 Just-In-Time (JIT) 컴파일(Just-In-Time (JIT) Compilation)<a class="header-link" href="#103-just-in-time-jit-just-in-time-jit-compilation" title="Permanent link">&para;</a></h3>
<p>쿼리 계획을 해석하는 대신 (각 튜플에 대해 가상 함수 호출), 네이티브 머신 코드로 컴파일:</p>
<div class="highlight"><pre><span></span><code>전통적 (해석):
  각 튜플에 대해:
    가상 함수 호출: 술어 평가
    가상 함수 호출: 열 투영
    가상 함수 호출: 조인을 위한 해시

JIT 컴파일:
  각 튜플에 대해:
    if tuple.salary &gt; 80000:    // 인라인, 가상 디스패치 없음
      hash = tuple.dept_id % N   // 인라인
      emit(tuple.name, ...)      // 인라인
</code></pre></div>

<p>JIT 컴파일은 해석 오버헤드를 제거하며, 복잡한 표현식과 큰 데이터셋에 특히 유익합니다.</p>
<p>PostgreSQL은 표현식 평가 및 튜플 변형을 위한 JIT 컴파일을 (LLVM 사용) 지원합니다.</p>
<hr />
<h2 id="11-exercises">11. 연습문제(Exercises)<a class="header-link" href="#11-exercises" title="Permanent link">&para;</a></h2>
<h3 id="1-cost-calculation">연습문제 1: 비용 계산(Cost Calculation)<a class="header-link" href="#1-cost-calculation" title="Permanent link">&para;</a></h3>
<p>주어진:
- employees: n = 10,000, b = 500, emp_id에 인덱스 (B⁺-트리, 높이 3)
- departments: n = 200, b = 10
- 메모리: M = 12 페이지</p>
<p>dept_id로 employees와 departments를 조인하는 비용 (블록 전송)을 계산하세요:</p>
<ol>
<li>블록 중첩 루프 조인 (employees가 외부)</li>
<li>블록 중첩 루프 조인 (departments가 외부)</li>
<li>해시 조인 (departments가 빌드)</li>
</ol>
<details>
<summary>해답</summary>

1. **BNLJ (employees 외부)**:
   - 외부 청크: ⌈500 / (12-2)⌉ = ⌈500/10⌉ = 50
   - 비용: 50 × 10 + 500 = 1,000 전송

2. **BNLJ (departments 외부)**:
   - 외부 청크: ⌈10 / (12-2)⌉ = ⌈10/10⌉ = 1
   - 비용: 1 × 500 + 10 = 510 전송

3. **해시 조인 (departments가 빌드)**:
   - departments (10 블록)가 12 페이지 메모리에 맞음
   - 비용: 10 + 500 = 510 전송

해시 조인과 departments-외부 BNLJ는 비슷합니다. 해시 조인은 더 적은 탐색 (2 vs. 2)을 가집니다. 실제로 해시 조인은 더 나은 캐시 동작으로 인해 선호됩니다.
</details>

<h3 id="2-selectivity-estimation">연습문제 2: 선택도 추정(Selectivity Estimation)<a class="header-link" href="#2-selectivity-estimation" title="Permanent link">&para;</a></h3>
<p>주어진: 10,000개 행의 employees 테이블.
- salary: min=30,000, max=150,000, V(salary) = 2,000
- dept_id: V(dept_id) = 50
- city: V(city) = 100</p>
<p>다음이 반환하는 튜플 수를 추정하세요:</p>
<ol>
<li>σ_{salary = 75000}(employees)</li>
<li>σ_{salary &gt; 100000}(employees)</li>
<li>σ_{dept_id = 5 ∧ city = 'Boston'}(employees)</li>
</ol>
<details>
<summary>해답</summary>

1. **salary = 75000**: sel = 1/V(salary) = 1/2000. 결과: 10,000/2,000 = **5 튜플**

2. **salary > 100000**: sel = (150,000 - 100,000)/(150,000 - 30,000) = 50,000/120,000 ≈ 0.417. 결과: 10,000 × 0.417 ≈ **4,167 튜플**

3. **dept_id = 5 AND city = 'Boston'** (독립성 가정):
   - sel(dept_id = 5) = 1/50
   - sel(city = 'Boston') = 1/100
   - 결합: (1/50) × (1/100) = 1/5,000
   - 결과: 10,000 / 5,000 = **2 튜플**
</details>

<h3 id="3-heuristic-optimization">연습문제 3: 휴리스틱 최적화(Heuristic Optimization)<a class="header-link" href="#3-heuristic-optimization" title="Permanent link">&para;</a></h3>
<p>다음 쿼리 트리를 휴리스틱 규칙을 사용하여 최적화하세요:</p>
<div class="highlight"><pre><span></span><code><span class="k">SELECT</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">product_name</span><span class="p">,</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">category_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">products</span><span class="w"> </span><span class="n">p</span><span class="p">,</span><span class="w"> </span><span class="n">categories</span><span class="w"> </span><span class="k">c</span><span class="p">,</span><span class="w"> </span><span class="n">order_items</span><span class="w"> </span><span class="n">oi</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">category_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">category_id</span>
<span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="n">p</span><span class="p">.</span><span class="n">product_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">oi</span><span class="p">.</span><span class="n">product_id</span>
<span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="n">oi</span><span class="p">.</span><span class="n">quantity</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">10</span>
<span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">category_name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Electronics&#39;</span><span class="p">;</span>
</code></pre></div>

<p>초기 및 최적화된 쿼리 트리를 그리세요.</p>
<details>
<summary>해답</summary>

**초기 (최적화되지 않은) 트리:**


<div class="highlight"><pre><span></span><code>π_{product_name, category_name}
    │
σ_{p.cat_id=c.cat_id ∧ p.prod_id=oi.prod_id ∧ oi.qty&gt;10 ∧ c.cat_name=&#39;Electronics&#39;}
    │
    ×  (카티전 곱)
   / \
  ×   oi
 / \
p   c
</code></pre></div>



**최적화된 트리 (선택 푸시 다운, 카티전 곱 대신 조인 사용):**


<div class="highlight"><pre><span></span><code>π_{product_name, category_name}
    │
    ⋈_{p.cat_id = c.cat_id}
   / \
  ⋈_{p.prod_id = oi.prod_id}    σ_{cat_name=&#39;Electronics&#39;}(c)
 / \
p   σ_{qty &gt; 10}(oi)
</code></pre></div>



**적용된 최적화:**
1. 연언 선택 분해
2. σ_{qty > 10}을 order_items로 푸시 (조인 전)
3. σ_{cat_name = 'Electronics'}을 categories로 푸시 (조인 전)
4. 카티전 곱을 목표 조인으로 교체
5. 일찍 투영 (명확성을 위해 표시하지 않았지만, 필요한 열만 통과)

핵심 이득: categories가 ~1개 행 ('Electronics')으로 필터링되고, order_items가 하위 집합 (qty > 10)으로 필터링된 후, 조인이 발생합니다.
</details>

<h3 id="4-join-algorithm-selection">연습문제 4: 조인 알고리즘 선택(Join Algorithm Selection)<a class="header-link" href="#4-join-algorithm-selection" title="Permanent link">&para;</a></h3>
<p>각 시나리오에 대해 최적화기가 어떤 조인 알고리즘을 선택할 것 같은지 결정하세요.</p>
<ol>
<li>100개 행 룩업 테이블을 1000만 개 행 팩트 테이블과 조인. 팩트 테이블의 조인 열에 인덱스 존재.</li>
<li>두 100만 개 행 테이블을 조인, 둘 다 정렬되지 않음, 충분한 메모리 (1GB 버퍼 풀).</li>
<li>두 100만 개 행 테이블을 범위 조건으로 조인 (r.date BETWEEN s.start_date AND s.end_date).</li>
<li>두 테이블을 조인하는데 둘 다 이미 조인 열로 정렬되어 있음.</li>
</ol>
<details>
<summary>해답</summary>

1. **인덱스 중첩 루프 조인.** 룩업 테이블 (100개 행)이 외부; 각 행에 대해 팩트 테이블의 인덱스를 사용하여 일치를 찾습니다. 비용: 100개 인덱스 조회, 각 O(log n). 1000만 개 행을 스캔하는 것보다 훨씬 빠릅니다.

2. **해시 조인.** 충분한 메모리로, 한 테이블의 해시 테이블이 메모리에 완전히 맞습니다. 비용: 두 테이블을 한 번씩 읽기 (최적). 인덱스 불필요, 정렬 불필요.

3. **정렬-병합 조인** 또는 **블록 중첩 루프 조인.** 해시 조인은 범위 조건에 작동하지 않습니다 (범위를 해시할 수 없음). 날짜 열에 대한 정렬-병합은 효율적인 범위 매칭을 허용합니다. 블록 NLJ는 정렬이 너무 비싸면 대안입니다.

4. **정렬-병합 조인 (정렬 단계 건너뛰기).** 두 테이블이 이미 정렬되어 있으므로, 병합 단계 비용은 b_r + b_s입니다 — 각 테이블을 통한 단일 패스. 이것은 최적입니다.
</details>

<h3 id="5-reading-execution-plans">연습문제 5: 실행 계획 읽기(Reading Execution Plans)<a class="header-link" href="#5-reading-execution-plans" title="Permanent link">&para;</a></h3>
<p>이 PostgreSQL EXPLAIN 출력이 주어졌을 때, 아래 질문에 답하세요:</p>
<div class="highlight"><pre><span></span><code><span class="n">Nested</span><span class="w"> </span><span class="nf">Loop</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.29</span><span class="p">.</span><span class="mf">.8.33</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">64</span><span class="p">)</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="nf">Index</span><span class="w"> </span><span class="kr">Scan</span><span class="w"> </span><span class="n">using</span><span class="w"> </span><span class="n">idx_emp_id</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">employees</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.29</span><span class="p">.</span><span class="mf">.4.30</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">40</span><span class="p">)</span>
<span class="w">        </span><span class="nf">Index</span><span class="w"> </span><span class="n">Cond</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">emp_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">42</span><span class="p">)</span>
<span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="n">Seq</span><span class="w"> </span><span class="kr">Scan</span><span class="w"> </span><span class="n">on</span><span class="w"> </span><span class="n">departments</span><span class="w">  </span><span class="p">(</span><span class="n">cost</span><span class="o">=</span><span class="mf">0.00</span><span class="p">.</span><span class="mf">.1.62</span><span class="w"> </span><span class="n">rows</span><span class="o">=</span><span class="mi">1</span><span class="w"> </span><span class="n">width</span><span class="o">=</span><span class="mi">24</span><span class="p">)</span>
<span class="w">        </span><span class="n">Filter</span><span class="o">:</span><span class="w"> </span><span class="p">(</span><span class="n">dept_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">employees</span><span class="p">.</span><span class="n">dept_id</span><span class="p">)</span>
<span class="w">        </span><span class="n">Rows</span><span class="w"> </span><span class="n">Removed</span><span class="w"> </span><span class="n">by</span><span class="w"> </span><span class="n">Filter</span><span class="o">:</span><span class="w"> </span><span class="mi">49</span>
</code></pre></div>

<ol>
<li>어떤 조인 알고리즘이 사용되나요?</li>
<li>어떤 테이블이 외부 (드라이빙) 테이블인가요?</li>
<li>최적화기가 왜 employees에 인덱스 스캔을 사용하나요?</li>
<li>왜 departments에 순차 스캔이 사용되나요?</li>
<li>추정 총 비용은 얼마인가요?</li>
</ol>
<details>
<summary>해답</summary>

1. **중첩 루프 조인.**

2. **employees가 외부 테이블입니다** (중첩 루프 아래에 먼저 나열됨). 루프를 구동합니다.

3. **emp_id = 42가 매우 선택적인 동등 술어이기 때문입니다.** emp_id의 인덱스는 정확히 1개 행 (rows=1)을 찾습니다. 전체 employees 테이블을 읽는 것은 낭비입니다.

4. **departments가 작기 때문입니다 (50개 행, ~2 페이지).** 각 외부 행 (이 경우 1개만)에 대해, 전체 departments 테이블이 스캔됩니다. 외부 행이 1개만 있으므로, 순차 스캔은 한 번만 실행됩니다. 아주 작은 테이블에 대한 단일 프로브의 경우 인덱스 조회가 더 빠르지 않을 수 있습니다.

5. **총 추정 비용: 8.33** (PostgreSQL의 비용 단위로, 1.0 ≈ 순차 페이지 읽기). 이는 매우 저렴합니다 — 본질적으로 1개 인덱스 조회 + 1개 작은 테이블 스캔.
</details>

<h3 id="6-equivalence-rules">연습문제 6: 동등 규칙(Equivalence Rules)<a class="header-link" href="#6-equivalence-rules" title="Permanent link">&para;</a></h3>
<p>동등 규칙을 사용하여 이 두 표현식이 동일한 결과를 생성함을 보이세요:</p>
<p><strong>표현식 A:</strong></p>
<div class="highlight"><pre><span></span><code>σ_{dept=&#39;CS&#39;}(employees ⋈ departments)
</code></pre></div>

<p><strong>표현식 B:</strong></p>
<div class="highlight"><pre><span></span><code>employees ⋈ σ_{dept=&#39;CS&#39;}(departments)
</code></pre></div>

<p>어느 것이 더 효율적이고 왜 그런가요?</p>
<details>
<summary>해답</summary>

**동등성 증명:**

규칙 6 (조인을 통한 선택 푸시)에 의해, 술어 dept='CS'가 departments의 속성만 포함하면:


<div class="highlight"><pre><span></span><code>σ_{dept=&#39;CS&#39;}(employees ⋈ departments) = employees ⋈ σ_{dept=&#39;CS&#39;}(departments)
</code></pre></div>



이것이 유효한 이유:
1. 조인은 모든 일치하는 (employee, department) 쌍을 생성합니다
2. 선택은 그 다음 dept='CS'로 필터링합니다
3. 동등하게, 먼저 departments를 필터링하여 CS 부서만 얻은 다음 조인할 수 있습니다

**표현식 B가 더 효율적**입니다:
- 표현식 A: 모든 직원을 모든 부서와 조인 (10,000 × 50 조합 평가), 그 다음 필터링. 조인은 10,000개 행을 생성한 다음, 필터가 ~200개만 유지 (50개 중 1/50이 CS에 있다면).
- 표현식 B: 먼저 departments를 필터링 (50 → 1개 행), 그 다음 조인. 조인은 1개 부서 행과만 직원을 일치시키면 됩니다. 훨씬 더 적은 작업.

중간 결과의 크기:
- A: 10,000 중간 행 → 필터 → 200 최종 행
- B: 1 중간 행 × employees → 200 최종 행 직접
</details>

<h3 id="7-cost-based-optimization">연습문제 7: 비용 기반 최적화(Cost-Based Optimization)<a class="header-link" href="#7-cost-based-optimization" title="Permanent link">&para;</a></h3>
<p>세 테이블과 그 통계가 주어졌습니다:</p>
<div class="highlight"><pre><span></span><code>orders (o):     n = 100,000,  b = 5,000
customers (c):  n = 10,000,   b = 500
products (p):   n = 1,000,    b = 50
</code></pre></div>

<p>조인 술어: o.cust_id = c.cust_id AND o.prod_id = p.prod_id</p>
<p>해시 조인과 M = 100 페이지를 가정합니다. 이 두 조인 순서를 비교하세요:</p>
<p><strong>계획 A</strong>: (orders ⋈ customers) ⋈ products
<strong>계획 B</strong>: (orders ⋈ products) ⋈ customers</p>
<details>
<summary>해답</summary>

**계획 A: (orders ⋈ customers) ⋈ products**

1단계: orders ⋈ customers (해시 조인, customers가 빌드)
- 빌드: 500 블록 (customers가 100 페이지에 맞나? 아니요, 500 > 100. Grace 해시 조인 필요.)
- Grace 해시 조인 비용: 3 × (5,000 + 500) = 16,500 전송
- 결과 크기: 100,000개 행 (각 주문이 하나의 고객을 가짐)
- 결과 블록: ~5,000 (orders와 유사)

2단계: result ⋈ products (해시 조인, products가 빌드)
- 빌드: 50 블록 (products가 100 페이지에 맞음. 인메모리 해시 조인.)
- 비용: 5,000 + 50 = 5,050 전송
- 계획 A 총: 16,500 + 5,050 = **21,550 전송**

**계획 B: (orders ⋈ products) ⋈ customers**

1단계: orders ⋈ products (해시 조인, products가 빌드)
- 빌드: 50 블록 (products가 메모리에 맞음!)
- 인메모리 해시 조인 비용: 5,000 + 50 = 5,050 전송
- 결과 크기: 100,000개 행 (각 주문이 하나의 제품을 가짐)
- 결과 블록: ~5,000

2단계: result ⋈ customers (해시 조인, customers가 빌드)
- 빌드: 500 블록 (100 페이지에 맞지 않음. Grace 해시 조인.)
- 비용: 3 × (5,000 + 500) = 16,500 전송
- 계획 B 총: 5,050 + 16,500 = **21,550 전송**

흥미롭게도, 총 전송 수는 동일합니다! 하지만 계획 B가 약간 더 나은 이유:
1. 1단계가 인메모리 해시 조인 사용 (더 적은 탐색, 더 나은 캐시)
2. 1단계의 중간 결과가 2단계로 파이프라인될 수 있습니다

더 똑똑한 접근법: 두 작은 테이블 (products: 50, customers: 500)에 해시 테이블을 빌드한 다음, orders를 한 번 스캔:

**계획 C**: orders를 한 번 스캔, 두 해시 테이블 모두 프로브
- 비용: 5,000 + 500 + 50 = 5,550 전송 (두 해시 테이블이 메모리에 맞으면 — 550 페이지가 필요하며, M=100을 초과)

M=600이면, 계획 C가 최적일 것입니다.
</details>

<hr />
<h2 id="12-summary">12. 요약(Summary)<a class="header-link" href="#12-summary" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>개념</th>
<th>핵심 포인트</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>쿼리 처리 파이프라인(Query Processing Pipeline)</strong></td>
<td>파싱 → 최적화 → 실행</td>
</tr>
<tr>
<td><strong>반복자 모델(Iterator Model)</strong></td>
<td>open/next/close 인터페이스; 튜플이 연산자 트리를 통해 위로 흐름</td>
</tr>
<tr>
<td><strong>파이프라이닝(Pipelining)</strong></td>
<td>중간 결과 구체화 회피</td>
</tr>
<tr>
<td><strong>선택 알고리즘(Selection algorithms)</strong></td>
<td>선형 스캔, 이진 검색, 인덱스 스캔; 선택은 선택도에 의존</td>
</tr>
<tr>
<td><strong>조인 알고리즘(Join algorithms)</strong></td>
<td>NLJ, 블록 NLJ, 인덱스 NLJ, 정렬-병합, 해시 조인</td>
</tr>
<tr>
<td><strong>해시 조인(Hash join)</strong></td>
<td>빌드 릴레이션이 메모리에 맞을 때 최적: 비용 = b_r + b_s</td>
</tr>
<tr>
<td><strong>정렬-병합 조인(Sort-merge join)</strong></td>
<td>사전 정렬된 데이터와 범위 조인에 최선</td>
</tr>
<tr>
<td><strong>휴리스틱 최적화(Heuristic optimization)</strong></td>
<td>선택 푸시 다운, 투영 푸시 다운, 조인 재정렬</td>
</tr>
<tr>
<td><strong>비용 기반 최적화(Cost-based optimization)</strong></td>
<td>통계를 사용하여 비용 추정; 조인 순서를 위한 동적 프로그래밍</td>
</tr>
<tr>
<td><strong>통계(Statistics)</strong></td>
<td>히스토그램, 고유 값, 상관관계 — 좋은 계획에 필수적</td>
</tr>
<tr>
<td><strong>계획 캐싱(Plan caching)</strong></td>
<td>준비된 문에 대한 반복 파싱/최적화 회피</td>
</tr>
</tbody>
</table>
<p>쿼리 처리는 데이터베이스 이론이 시스템 엔지니어링과 만나는 곳입니다. 이러한 개념을 이해하면 더 나은 쿼리를 작성하고, 적절한 인덱스를 생성하고 (다음 레슨에서 다룸), 실행 계획을 읽어 성능 문제를 진단하는 데 도움이 됩니다.</p>
<hr />
<p><strong>이전</strong>: <a href="./07_Advanced_Normalization.md">07_Advanced_Normalization.md</a> | <strong>다음</strong>: <a href="./09_Indexing.md">09_Indexing.md</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/07_Advanced_Normalization.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 07: 고급 정규화(Advanced Normalization)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/09_Indexing.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">09. 인덱싱</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}