{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>09. 인덱싱 - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Database_Theory/">Database Theory</a>
    <span class="separator">/</span>
    <span class="current">09. 인덱싱</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>09. 인덱싱</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/08_Query_Processing.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 08: 쿼리 처리(Query Processing)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/10_Transaction_Theory.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">10. 트랜잭션 이론</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#_1">학습 목표</a></li>
<li><a href="#1">1. 인덱싱이 중요한 이유</a><ul>
<li><a href="#_2">기본 문제</a></li>
<li><a href="#vs">순차 vs. 인덱스 접근</a></li>
<li><a href="#_3">인덱스를 사용하지 않아야 할 때</a></li>
<li><a href="#_4">비용 모델 기초</a></li>
</ul>
</li>
<li><a href="#2">2. 정렬된 인덱스</a><ul>
<li><a href="#_5">인덱스 구조 기본</a></li>
<li><a href="#21">2.1 주 인덱스</a></li>
<li><a href="#22">2.2 클러스터링 인덱스</a></li>
<li><a href="#23">2.3 보조 인덱스</a></li>
<li><a href="#vs_1">밀집 vs. 희소 인덱스</a></li>
<li><a href="#_6">다단계 인덱스</a></li>
</ul>
</li>
<li><a href="#3-b-tree">3. B-Tree</a><ul>
<li><a href="#31">3.1 구조</a></li>
<li><a href="#32">3.2 검색</a></li>
<li><a href="#33">3.3 삽입</a></li>
<li><a href="#34">3.4 삭제</a></li>
<li><a href="#35">3.5 복잡도 분석</a></li>
</ul>
</li>
<li><a href="#4-btree">4. B+Tree</a><ul>
<li><a href="#41">4.1 구조와 특성</a></li>
<li><a href="#_7">노드 형식</a></li>
<li><a href="#42-btree-vs-b-tree">4.2 B+Tree vs. B-Tree 비교</a></li>
<li><a href="#43-btree">4.3 B+Tree에서 검색</a></li>
<li><a href="#44-btree">4.4 B+Tree에 삽입</a></li>
<li><a href="#45-btree">4.5 B+Tree에서 삭제</a></li>
<li><a href="#46">4.6 대량 로딩</a></li>
<li><a href="#47">4.7 높이와 성능 분석</a></li>
</ul>
</li>
<li><a href="#5">5. 해시 기반 인덱싱</a><ul>
<li><a href="#51">5.1 정적 해싱</a></li>
<li><a href="#52">5.2 확장 가능 해싱</a></li>
<li><a href="#53">5.3 선형 해싱</a></li>
<li><a href="#vs-btree">해시 vs. B+Tree 비교</a></li>
</ul>
</li>
<li><a href="#6">6. 비트맵 인덱스</a><ul>
<li><a href="#61">6.1 개념</a></li>
<li><a href="#62">6.2 비트맵 연산</a></li>
<li><a href="#63">6.3 비트맵 인덱스를 사용해야 할 때</a></li>
<li><a href="#64">6.4 비트맵 압축</a></li>
<li><a href="#65">6.5 공간 분석</a></li>
</ul>
</li>
<li><a href="#7">7. 다차원 인덱싱</a><ul>
<li><a href="#71">7.1 문제</a></li>
<li><a href="#72-r-tree">7.2 R-Tree</a></li>
<li><a href="#73-kd-tree">7.3 kd-Tree</a></li>
</ul>
</li>
<li><a href="#8">8. 인덱스 선택과 설계 지침</a><ul>
<li><a href="#81">8.1 인덱스 선택 문제</a></li>
<li><a href="#82">8.2 커버링 인덱스</a></li>
<li><a href="#83">8.3 복합 (다중 컬럼) 인덱스</a></li>
<li><a href="#84">8.4 부분 인덱스</a></li>
<li><a href="#85">8.5 표현식 인덱스</a></li>
<li><a href="#86">8.6 실용적 지침</a></li>
</ul>
</li>
<li><a href="#9">9. 주요 데이터베이스의 인덱스 구조</a><ul>
<li><a href="#postgresql">PostgreSQL</a></li>
<li><a href="#mysql-innodb">MySQL InnoDB</a></li>
<li><a href="#_8">요약 표</a></li>
</ul>
</li>
<li><a href="#10">10. 연습문제</a><ul>
<li><a href="#_9">개념적 질문</a></li>
<li><a href="#_10">실용적 질문</a></li>
<li><a href="#_11">분석 질문</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="09">09. 인덱싱<a class="header-link" href="#09" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./08_Query_Processing.md">질의 처리와 최적화</a> | <strong>다음</strong>: <a href="./10_Transaction_Theory.md">트랜잭션 이론</a></p>
<hr />
<h2 id="_1">학습 목표<a class="header-link" href="#_1" title="Permanent link">&para;</a></h2>
<ul>
<li>인덱싱이 데이터베이스 성능에 중요한 이유 이해</li>
<li>정렬된 인덱스(Ordered Indices) 구분: 주 인덱스(Primary), 클러스터링(Clustering), 보조 인덱스(Secondary)</li>
<li>B-Tree와 B+Tree 구조, 연산 및 복잡도 마스터</li>
<li>해시 기반 인덱싱 기법: 정적(Static), 확장가능(Extendible), 선형 해싱(Linear Hashing)</li>
<li>비트맵 인덱스(Bitmap Indices)와 다차원 인덱스 구조 이해</li>
<li>실무에서 인덱스 설계 지침 적용</li>
</ul>
<hr />
<h2 id="1">1. 인덱싱이 중요한 이유<a class="header-link" href="#1" title="Permanent link">&para;</a></h2>
<h3 id="_2">기본 문제<a class="header-link" href="#_2" title="Permanent link">&para;</a></h3>
<p>100만 개의 행을 가진 <code>employees</code> 테이블이 디스크에 저장되어 있다고 가정하자. 각 디스크 블록은 10개의 행을 담으므로, 테이블은 10만 개의 블록을 차지한다. ID로 직원 한 명을 찾으려면:</p>
<div class="highlight"><pre><span></span><code>인덱스 없이:  모든 10만 개 블록 스캔  →  O(n) 디스크 I/O
인덱스 사용:  인덱스 포인터 따라가기  →  O(log n) 디스크 I/O
</code></pre></div>

<p>10만 블록의 경우:
- <strong>순차 스캔</strong>: 최대 10만 번의 블록 읽기
- <strong>B+Tree 인덱스</strong> (분기 계수 200): 대략 log_200(1,000,000) ≈ 3 블록 읽기</p>
<p>이는 <strong>33,000배의 I/O 비용 개선</strong>이다.</p>
<h3 id="vs">순차 vs. 인덱스 접근<a class="header-link" href="#vs" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>순차 접근 (테이블 스캔):
┌──────┬──────┬──────┬──────┬──────┬──────┬──────┐
│ Blk1 │ Blk2 │ Blk3 │ Blk4 │ Blk5 │ ...  │ BlkN │
└──────┴──────┴──────┴──────┴──────┴──────┴──────┘
  ↑ 모든 블록을 순차적으로 읽음

인덱스 접근:
┌─────────────────┐
│   인덱스 루트    │  ← 1 I/O
│  [50│100│150]    │
└──┬──────┬──────┬─┘
   ↓      ↓      ↓
 ┌────┐ ┌────┐ ┌────┐
 │리프│ │리프│ │리프│  ← 1 I/O (포인터 따라가기)
 └──┬─┘ └────┘ └────┘
    ↓
 ┌──────┐
 │ 데이터│  ← 1 I/O (실제 레코드 가져오기)
 │ 블록 │
 └──────┘
</code></pre></div>

<h3 id="_3">인덱스를 사용하지 않아야 할 때<a class="header-link" href="#_3" title="Permanent link">&para;</a></h3>
<p>인덱스가 항상 유익한 것은 아니다:</p>
<ul>
<li><strong>작은 테이블</strong>: 몇 개의 블록을 순차 스캔하는 것이 인덱스 탐색 오버헤드보다 빠름</li>
<li><strong>높은 선택도 쿼리(High Selectivity Queries)</strong>: 쿼리가 대부분의 행(예: 테이블의 15-20% 이상)을 반환하면, 전체 스캔이 더 저렴함</li>
<li><strong>빈번한 쓰기</strong>: 모든 INSERT, UPDATE, DELETE는 인덱스도 업데이트해야 함</li>
<li><strong>낮은 카디널리티 컬럼</strong>: B+Tree로 불린 컬럼을 인덱싱하는 것은 낭비임 (비트맵 인덱스가 적절할 수 있음)</li>
</ul>
<h3 id="_4">비용 모델 기초<a class="header-link" href="#_4" title="Permanent link">&para;</a></h3>
<p>디스크 접근 비용이 쿼리 성능을 지배한다. <strong>블록 전송(Block Transfers)</strong> (디스크 블록 읽기/쓰기)과 <strong>탐색(Seeks)</strong> (디스크 헤드 이동) 단위로 측정한다.</p>
<p>다음과 같이 정의하자:
- <code>b</code> = 파일의 블록 수
- <code>n</code> = 레코드 수
- <code>f</code> = 블로킹 팩터(Blocking Factor) (블록당 레코드 수), 따라서 <code>b = ⌈n/f⌉</code></p>
<table>
<thead>
<tr>
<th>접근 방법</th>
<th>평균 비용 (동등 검색)</th>
</tr>
</thead>
<tbody>
<tr>
<td>선형 스캔 (미정렬)</td>
<td>b/2 블록 전송</td>
</tr>
<tr>
<td>선형 스캔 (정렬)</td>
<td>⌈log₂(b)⌉ (이진 검색)</td>
</tr>
<tr>
<td>주 인덱스 (정렬)</td>
<td>⌈log₂(b_i)⌉ + 1, 여기서 b_i = 인덱스 블록</td>
</tr>
<tr>
<td>B+Tree</td>
<td>⌈log_p(b)⌉ + 1, 여기서 p = 분기 계수</td>
</tr>
<tr>
<td>해시 인덱스</td>
<td>1 (이상적) ~ 2 (오버플로우 포함)</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="2">2. 정렬된 인덱스<a class="header-link" href="#2" title="Permanent link">&para;</a></h2>
<h3 id="_5">인덱스 구조 기본<a class="header-link" href="#_5" title="Permanent link">&para;</a></h3>
<p><strong>인덱스(Index)</strong>는 <strong>검색 키 값(Search Key Values)</strong>을 <strong>포인터(Pointers)</strong> (레코드 식별자 또는 블록 주소)에 매핑하는 데이터 구조다. 검색 키는 반드시 기본 키일 필요는 없다 -- 어떤 속성이나 속성 집합이든 검색 키로 사용될 수 있다.</p>
<div class="highlight"><pre><span></span><code>인덱스 엔트리 형식:
┌─────────────┬─────────────┐
│ 검색 키 값   │ 레코드      │
│             │ 포인터      │
└─────────────┴─────────────┘
</code></pre></div>

<h3 id="21">2.1 주 인덱스<a class="header-link" href="#21" title="Permanent link">&para;</a></h3>
<p><strong>주 인덱스(Primary Index)</strong>는 순차적으로 정렬된 파일의 <strong>정렬 키(Ordering Key)</strong>에 구축된다. 파일은 인덱싱된 속성으로 물리적으로 정렬된다.</p>
<div class="highlight"><pre><span></span><code>직원 ID에 대한 주 인덱스 (파일이 ID로 정렬됨):

인덱스:                         데이터 파일:
┌─────┬──────┐                 ┌───────────────────┐
│ 100 │  ──────────────────→  │ 100 │ Alice │ ... │ 블록 1
├─────┼──────┤                 │ 105 │ Bob   │ ... │
│ 200 │  ──────┐               ├───────────────────┤
├─────┼──────┤  └───────────→  │ 200 │ Carol │ ... │ 블록 2
│ 300 │  ──────┐               │ 210 │ Dave  │ ... │
└─────┴──────┘  │              ├───────────────────┤
                 └───────────→ │ 300 │ Eve   │ ... │ 블록 3
                               │ 350 │ Frank │ ... │
                               └───────────────────┘
</code></pre></div>

<p><strong>특성:</strong>
- <strong>블록당</strong> 하나의 인덱스 엔트리 (레코드당이 아님) -- 이것은 희소 인덱스(Sparse Index)
- 검색 키는 파일이 정렬된 것과 동일한 속성
- 동등 검색과 범위 쿼리에 매우 효율적
- 테이블당 <strong>하나</strong>의 주 인덱스만 존재 (파일은 한 가지 방법으로만 정렬 가능)</p>
<h3 id="22">2.2 클러스터링 인덱스<a class="header-link" href="#22" title="Permanent link">&para;</a></h3>
<p><strong>클러스터링 인덱스(Clustering Index)</strong>는 파일이 물리적으로 정렬된 비-키 속성에 구축된다. 여러 레코드가 동일한 검색 키 값을 공유할 수 있다.</p>
<div class="highlight"><pre><span></span><code>부서에 대한 클러스터링 인덱스:

인덱스:                         데이터 파일 (부서로 정렬):
┌──────────┬──────┐            ┌───────────────────────────┐
│ Acctg    │  ──────────────→ │ Acctg  │ Alice │ 60000   │
├──────────┼──────┤            │ Acctg  │ Bob   │ 55000   │
│ Eng      │  ──────┐          ├───────────────────────────┤
├──────────┼──────┤  └──────→ │ Eng    │ Carol │ 80000   │
│ Sales    │  ──────┐          │ Eng    │ Dave  │ 75000   │
└──────────┴──────┘  │         │ Eng    │ Eve   │ 72000   │
                      │        ├───────────────────────────┤
                      └─────→  │ Sales  │ Frank │ 50000   │
                               │ Sales  │ Grace │ 52000   │
                               └───────────────────────────┘
</code></pre></div>

<p><strong>특성:</strong>
- 검색 키의 <strong>고유 값당</strong> 하나의 인덱스 엔트리
- 각 포인터는 해당 값을 포함하는 첫 번째 블록으로 이어짐
- 그룹화 및 집계 쿼리에 효율적</p>
<h3 id="23">2.3 보조 인덱스<a class="header-link" href="#23" title="Permanent link">&para;</a></h3>
<p><strong>보조 인덱스(Secondary Index)</strong>는 비-정렬 속성에 대한 대체 접근 경로를 제공한다. 파일은 이 속성으로 정렬되어 있지 <strong>않다</strong>.</p>
<div class="highlight"><pre><span></span><code>급여에 대한 보조 인덱스:

인덱스 (급여로 정렬):      데이터 파일 (ID로 정렬, 급여로는 정렬 안 됨):
┌───────┬──────┐               ┌───────────────────────────┐
│ 50000 │  ──────────────────→ │ 100 │ Alice │ 60000     │ 블록 1
├───────┼──────┤               │ 105 │ Bob   │ 50000     │
│ 55000 │  ──────┐              ├───────────────────────────┤
├───────┼──────┤  │            │ 200 │ Carol │ 80000     │ 블록 2
│ 60000 │  ──────┐│            │ 210 │ Dave  │ 55000     │
├───────┼──────┤  ││           ├───────────────────────────┤
│ 72000 │  ──┐    ││           │ 300 │ Eve   │ 72000     │ 블록 3
│ ...   │    │    ││           │ 350 │ Frank │ 75000     │
└───────┴────┘    ││           └───────────────────────────┘
                  │││  (포인터가 블록 경계를 넘음)
</code></pre></div>

<p><strong>특성:</strong>
- <strong>밀집 인덱스(Dense Index)</strong>여야 함 (레코드당 하나의 엔트리, 블록당이 아님) - 데이터가 검색 키로 정렬되어 있지 않기 때문
- 동일한 테이블에 여러 보조 인덱스가 존재할 수 있음
- 범위 쿼리에 덜 효율적 (비순차 데이터로 인한 랜덤 I/O 패턴)
- 중복 키 값에 대해 추가 간접 수준(포인터 버킷)이 사용되기도 함</p>
<h3 id="vs_1">밀집 vs. 희소 인덱스<a class="header-link" href="#vs_1" title="Permanent link">&para;</a></h3>
<p><strong>밀집 인덱스(Dense Index)</strong>: 데이터 파일의 <strong>모든 레코드</strong>에 대해 하나의 인덱스 엔트리.</p>
<div class="highlight"><pre><span></span><code>밀집 인덱스:
┌─────┬───┐     ┌──────────────┐
│ 100 │ ──┼───→ │ 100 │ Alice  │
├─────┼───┤     │ 105 │ Bob    │ ←── 105에 대한 엔트리 존재
│ 105 │ ──┼───→ │              │
├─────┼───┤     ├──────────────┤
│ 200 │ ──┼───→ │ 200 │ Carol  │
├─────┼───┤     │ 210 │ Dave   │
│ 210 │ ──┼───→ │              │
└─────┴───┘     └──────────────┘
</code></pre></div>

<p><strong>희소 인덱스(Sparse Index)</strong>: <strong>일부 레코드</strong>에 대한 하나의 인덱스 엔트리 (일반적으로 블록당 하나).</p>
<div class="highlight"><pre><span></span><code>희소 인덱스:
┌─────┬───┐     ┌──────────────┐
│ 100 │ ──┼───→ │ 100 │ Alice  │  블록 1
│     │   │     │ 105 │ Bob    │  (105에 대한 엔트리 없음)
├─────┼───┤     ├──────────────┤
│ 200 │ ──┼───→ │ 200 │ Carol  │  블록 2
│     │   │     │ 210 │ Dave   │  (210에 대한 엔트리 없음)
└─────┴───┘     └──────────────┘
</code></pre></div>

<p><strong>비교:</strong></p>
<table>
<thead>
<tr>
<th>측면</th>
<th>밀집 인덱스</th>
<th>희소 인덱스</th>
</tr>
</thead>
<tbody>
<tr>
<td>공간</td>
<td>더 큼 (레코드당 엔트리)</td>
<td>더 작음 (블록당 엔트리)</td>
</tr>
<tr>
<td>검색</td>
<td>직접 조회 가능</td>
<td>블록 내 스캔 필요할 수 있음</td>
</tr>
<tr>
<td>요구사항</td>
<td>미정렬 파일에서 작동</td>
<td>정렬된 데이터 파일 필요</td>
</tr>
<tr>
<td>유지보수</td>
<td>삽입/삭제 시 더 많은 업데이트</td>
<td>더 적은 업데이트</td>
</tr>
<tr>
<td>사용 사례</td>
<td>보조 인덱스</td>
<td>주 인덱스</td>
</tr>
</tbody>
</table>
<h3 id="_6">다단계 인덱스<a class="header-link" href="#_6" title="Permanent link">&para;</a></h3>
<p>인덱스 자체가 메모리에 맞지 않을 정도로 크면, <strong>인덱스에 대한 인덱스</strong>를 구축할 수 있다:</p>
<div class="highlight"><pre><span></span><code>레벨 2 (외부 인덱스):
┌──────┬───┐
│  1   │ ──┼───→ ┌──────┬───┐
│ 500  │ ──┼─┐   │  1   │ ──┼───→ 데이터 블록 1
└──────┴───┘ │   │ 100  │ ──┼───→ 데이터 블록 2
              │   │ 200  │ ──┼───→ 데이터 블록 3
              │   │ ...  │   │
              │   └──────┴───┘
              │   레벨 1 (내부 인덱스, 파트 1)
              │
              └→ ┌──────┬───┐
                 │ 500  │ ──┼───→ 데이터 블록 K
                 │ 600  │ ──┼───→ 데이터 블록 K+1
                 │ ...  │   │
                 └──────┴───┘
                 레벨 1 (내부 인덱스, 파트 2)
</code></pre></div>

<p>이는 자연스럽게 트리 구조 인덱스, 특히 B-Tree와 B+Tree로 이어진다.</p>
<hr />
<h2 id="3-b-tree">3. B-Tree<a class="header-link" href="#3-b-tree" title="Permanent link">&para;</a></h2>
<h3 id="31">3.1 구조<a class="header-link" href="#31" title="Permanent link">&para;</a></h3>
<p>차수 <code>m</code>의 <strong>B-Tree</strong> (또는 degree <code>m</code>의 B-Tree)는 다음을 만족한다:</p>
<ol>
<li>모든 노드는 최대 <code>m</code>개의 자식을 가짐</li>
<li>모든 내부 노드(루트 제외)는 최소 <code>⌈m/2⌉</code>개의 자식을 가짐</li>
<li>루트는 최소 2개의 자식을 가짐 (리프가 아닌 경우)</li>
<li>모든 리프는 동일한 레벨에 나타남</li>
<li><code>k</code>개의 자식을 가진 비-리프 노드는 <code>k-1</code>개의 키를 포함</li>
</ol>
<div class="highlight"><pre><span></span><code>차수 4의 B-Tree (각 노드는 최대 3개의 키 보유):

                    ┌─────────┐
                    │   30     │
                    └──┬───┬──┘
                  ┌────┘   └────┐
           ┌──────┴──┐    ┌────┴──────┐
           │ 10 │ 20 │    │ 40 │ 50   │
           └┬───┬───┬┘    └┬───┬────┬─┘
            ↓   ↓   ↓      ↓   ↓    ↓
          ┌──┐┌──┐┌──┐  ┌──┐┌──┐ ┌───┐
          │5 ││15││25│  │35││45│ │55  │
          │8 ││  ││  │  │  ││  │ │60  │
          └──┘└──┘└──┘  └──┘└──┘ └───┘

참고: B-Tree에서는 (B+Tree와 달리) 데이터 포인터가
모든 노드에 존재하며, 리프만이 아님.
</code></pre></div>

<p><strong>노드 구조</strong> (<code>n</code>개의 키를 가진 내부 노드):</p>
<div class="highlight"><pre><span></span><code>┌────┬─────┬────┬─────┬────┬─────┬────┐
│ P₁ │ K₁  │ P₂ │ K₂  │ P₃ │ ... │ Pₙ₊₁│
│    │ D₁  │    │ D₂  │    │     │    │
└────┴─────┴────┴─────┴────┴─────┴────┘
  ↓          ↓          ↓            ↓
부트리    부트리    부트리      부트리
&lt; K₁     [K₁,K₂)   [K₂,K₃)      ≥ Kₙ

여기서:
  Pᵢ = 자식 노드에 대한 포인터 (또는 리프의 경우 데이터 블록)
  Kᵢ = 검색 키 값
  Dᵢ = 키 Kᵢ를 가진 데이터 레코드에 대한 포인터
</code></pre></div>

<h3 id="32">3.2 검색<a class="header-link" href="#32" title="Permanent link">&para;</a></h3>
<p>키 <code>K</code>에 대한 B-Tree 검색:</p>
<div class="highlight"><pre><span></span><code><span class="n">BTREE</span><span class="o">-</span><span class="k">SEARCH</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="k">key</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="err">:</span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="err">≤</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">n</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="k">key</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="err">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">)</span><span class="w">           </span><span class="o">//</span><span class="w"> </span><span class="n">이</span><span class="w"> </span><span class="n">노드에서</span><span class="w"> </span><span class="n">발견</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nl">leaf</span><span class="p">:</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">NOT_FOUND</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">디스크에서</span><span class="w"> </span><span class="n">자식</span><span class="w"> </span><span class="n">읽기</span>
<span class="w">    </span><span class="k">DISK</span><span class="o">-</span><span class="k">READ</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">child</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">BTREE</span><span class="o">-</span><span class="k">SEARCH</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">child</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span>
</code></pre></div>

<p><strong>복잡도</strong>: O(log_m n) 디스크 I/O, 여기서 n은 키의 수이고 m은 차수.</p>
<h3 id="33">3.3 삽입<a class="header-link" href="#33" title="Permanent link">&para;</a></h3>
<p>차수 <code>m</code>의 B-Tree에 키 <code>K</code> 삽입:</p>
<ol>
<li><strong>찾기</strong>: 검색을 사용하여 적절한 리프 노드 찾기</li>
<li><strong>삽입</strong>: 리프 내에 정렬된 순서로 키 삽입</li>
<li>노드가 오버플로우하면 (<code>m</code>개의 키를 가짐):</li>
<li>중간 키에서 노드를 두 노드로 <strong>분할</strong></li>
<li>중간 키를 부모로 <strong>승격</strong></li>
<li>필요시 부모 오버플로우를 재귀적으로 처리</li>
</ol>
<p><strong>예: 차수 3의 B-Tree에 25 삽입 (노드당 최대 2개의 키):</strong></p>
<div class="highlight"><pre><span></span><code>이전:
        ┌────┐
        │ 20 │
        └─┬──┘
     ┌────┴─────┐
  ┌─────┐   ┌──────┐
  │10│15│   │22│30 │  ← 노드가 꽉 참
  └─────┘   └──────┘

단계 1: 키 25는 오른쪽 리프 [22, 30]에 속함.
단계 2: 삽입 → [22, 25, 30] — 오버플로우! (3개의 키 &gt; 최대 2)
단계 3: 중간값(25)에서 분할. 25를 부모로 승격.

이후:
        ┌──────┐
        │20│25 │
        └┬──┬──┘
    ┌────┘  │  └────┐
 ┌─────┐ ┌──┐  ┌──┐
 │10│15│ │22│  │30│
 └─────┘ └──┘  └──┘
</code></pre></div>

<h3 id="34">3.4 삭제<a class="header-link" href="#34" title="Permanent link">&para;</a></h3>
<p>차수 <code>m</code>의 B-Tree에서 키 <code>K</code> 삭제:</p>
<ol>
<li><code>K</code>를 포함하는 노드 <strong>찾기</strong></li>
<li><code>K</code>가 <strong>리프</strong>에 있으면: 직접 제거</li>
<li><code>K</code>가 <strong>내부 노드</strong>에 있으면: 리프에서 선행자(또는 후속자)로 교체한 다음 리프에서 삭제</li>
<li>노드가 <strong>언더플로우</strong>하면 (<code>⌈m/2⌉ - 1</code>개 미만의 키):</li>
<li>가능하면 형제에서 <strong>재분배</strong> (빌리기)</li>
<li>그렇지 않으면 형제와 <strong>병합</strong>하고 부모에서 키를 내림</li>
<li>부모 언더플로우를 재귀적으로 처리</li>
</ol>
<p><strong>예: 위 트리에서 20 삭제 (차수 3, 비-루트 노드당 최소 1개의 키):</strong></p>
<div class="highlight"><pre><span></span><code>이전:
        ┌──────┐
        │20│25 │
        └┬──┬──┘
    ┌────┘  │  └────┐
 ┌─────┐ ┌──┐  ┌──┐
 │10│15│ │22│  │30│
 └─────┘ └──┘  └──┘

단계 1: 키 20은 내부 노드에 있음.
단계 2: 중위 선행자(15)로 교체.
단계 3: 리프에서 15 삭제.

교체 후:
        ┌──────┐
        │15│25 │
        └┬──┬──┘
    ┌────┘  │  └────┐
 ┌──┐   ┌──┐   ┌──┐
 │10│   │22│   │30│
 └──┘   └──┘   └──┘
</code></pre></div>

<h3 id="35">3.5 복잡도 분석<a class="header-link" href="#35" title="Permanent link">&para;</a></h3>
<p><code>n</code>개의 키를 가진 차수 <code>m</code>의 B-Tree:</p>
<table>
<thead>
<tr>
<th>연산</th>
<th>디스크 I/O</th>
<th>CPU 시간</th>
</tr>
</thead>
<tbody>
<tr>
<td>검색</td>
<td>O(log_m n)</td>
<td>O(m · log_m n)</td>
</tr>
<tr>
<td>삽입</td>
<td>O(log_m n)</td>
<td>O(m · log_m n)</td>
</tr>
<tr>
<td>삭제</td>
<td>O(log_m n)</td>
<td>O(m · log_m n)</td>
</tr>
</tbody>
</table>
<p><strong>높이 한계</strong>: <code>n ≥ 1</code>개의 키와 최소 차수 <code>t = ⌈m/2⌉</code>에 대해:</p>
<div class="highlight"><pre><span></span><code>h ≤ log_t((n+1)/2)
</code></pre></div>

<p>일반적인 분기 계수 100-200으로, 높이 3-4의 트리는 <strong>수십억</strong>개의 레코드를 인덱싱할 수 있다.</p>
<hr />
<h2 id="4-btree">4. B+Tree<a class="header-link" href="#4-btree" title="Permanent link">&para;</a></h2>
<h3 id="41">4.1 구조와 특성<a class="header-link" href="#41" title="Permanent link">&para;</a></h3>
<p><strong>B+Tree</strong>는 관계형 데이터베이스에서 가장 널리 사용되는 인덱스 구조다 (PostgreSQL, MySQL InnoDB, Oracle, SQL Server 모두 B+Tree 사용). B-Tree와 중요한 차이점:</p>
<ol>
<li><strong>모든 데이터 포인터는 리프 노드에 있음</strong> -- 내부 노드는 키와 자식 포인터만 저장</li>
<li><strong>리프 노드가 연결됨</strong> -- 효율적인 범위 스캔을 위한 이중 연결 리스트</li>
<li><strong>내부 노드의 키가 리프에 중복됨</strong> (내부 키는 가이드 역할만)</li>
</ol>
<div class="highlight"><pre><span></span><code>B+Tree 구조:

내부 노드 (가이드 키만):
                    ┌────────────┐
                    │  30  │  60  │
                    └──┬───┬──┬──┘
              ┌────────┘   │  └────────┐
              ↓            ↓           ↓
        ┌─────────┐  ┌─────────┐  ┌─────────┐
        │ 10 │ 20 │  │ 40 │ 50 │  │ 70 │ 80 │
        └─┬──┬──┬─┘  └─┬──┬──┬─┘  └─┬──┬──┬─┘
          ↓  ↓  ↓      ↓  ↓  ↓      ↓  ↓  ↓

리프 노드 (실제 데이터, 연결됨):
┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐  ┌─────┐
│ 5,8 │↔│10,15│↔│20,25│↔│30,35│↔│40,45│↔│50,55│↔│60,65│↔│70,75│↔│80,85│
│     │  │     │  │     │  │     │  │     │  │     │  │     │  │     │  │     │
│ D*  │  │ D*  │  │ D*  │  │ D*  │  │ D*  │  │ D*  │  │ D*  │  │ D*  │  │ D*  │
└─────┘  └─────┘  └─────┘  └─────┘  └─────┘  └─────┘  └─────┘  └─────┘  └─────┘
  ↑                                                                          ↑
Head                                              리프 체인 (이중 연결)     Tail

D* = 실제 데이터 레코드에 대한 포인터
</code></pre></div>

<h3 id="_7">노드 형식<a class="header-link" href="#_7" title="Permanent link">&para;</a></h3>
<p><strong>내부 노드</strong> (차수 <code>m</code>, 최대 <code>m</code>개의 포인터, <code>m-1</code>개의 키):</p>
<div class="highlight"><pre><span></span><code>┌────┬─────┬────┬─────┬────┬─────┬────┐
│ P₁ │ K₁  │ P₂ │ K₂  │ P₃ │ ... │ Pₘ│
└────┴─────┴────┴─────┴────┴─────┴────┘
subtree(P₁)의 모든 키 &lt; K₁
K₁ ≤ subtree(P₂)의 모든 키 &lt; K₂
...
Kₘ₋₁ ≤ subtree(Pₘ)의 모든 키
</code></pre></div>

<p><strong>리프 노드</strong> (최대 <code>m-1</code>개의 키-포인터 쌍, 형제 포인터 포함):</p>
<div class="highlight"><pre><span></span><code>┌──────┬──────┬──────┬──────┬─────────┐
│K₁,D₁│K₂,D₂│K₃,D₃│ ...  │ Pₙₑₓₜ  │
└──────┴──────┴──────┴──────┴─────────┘
Dᵢ = 키 Kᵢ를 가진 레코드에 대한 포인터
Pₙₑₓₜ = 다음 리프 노드에 대한 포인터
</code></pre></div>

<h3 id="42-btree-vs-b-tree">4.2 B+Tree vs. B-Tree 비교<a class="header-link" href="#42-btree-vs-b-tree" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>특징</th>
<th>B-Tree</th>
<th>B+Tree</th>
</tr>
</thead>
<tbody>
<tr>
<td>데이터 포인터</td>
<td>모든 노드에</td>
<td>리프 노드에만</td>
</tr>
<tr>
<td>키 중복</td>
<td>중복 없음</td>
<td>내부 키가 리프에 중복됨</td>
</tr>
<tr>
<td>리프 연결</td>
<td>연결 안 됨</td>
<td>이중 연결 리스트</td>
</tr>
<tr>
<td>범위 쿼리</td>
<td>트리를 여러 번 탐색해야 함</td>
<td>리프 체인을 따라감</td>
</tr>
<tr>
<td>분기 계수(Fan-out)</td>
<td>낮음 (데이터 포인터가 공간 차지)</td>
<td>높음 (내부 노드가 더 날씬함)</td>
</tr>
<tr>
<td>동등 검색</td>
<td>내부 노드에서 조기 종료 가능</td>
<td>항상 리프까지 감</td>
</tr>
<tr>
<td>공간 사용</td>
<td>전체적으로 약간 적음</td>
<td>약간 많음 (키 중복)</td>
</tr>
<tr>
<td>실제 사용</td>
<td>데이터베이스에서 거의 사용 안 됨</td>
<td>모든 주요 RDBMS에서 표준</td>
</tr>
</tbody>
</table>
<h3 id="43-btree">4.3 B+Tree에서 검색<a class="header-link" href="#43-btree" title="Permanent link">&para;</a></h3>
<p>키 <code>K</code>에 대한 <strong>동등 검색</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">BPLUS</span><span class="o">-</span><span class="k">SEARCH</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">root</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="n">node</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nl">leaf</span><span class="p">:</span>
<span class="w">        </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">smallest</span><span class="w"> </span><span class="k">index</span><span class="w"> </span><span class="n">such</span><span class="w"> </span><span class="n">that</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="k">key</span><span class="o">[</span><span class="n">i</span><span class="o">]</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">no</span><span class="w"> </span><span class="n">such</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="ow">exists</span><span class="err">:</span>
<span class="w">            </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">child</span><span class="o">[</span><span class="n">last</span><span class="o">]</span><span class="w">   </span><span class="o">//</span><span class="w"> </span><span class="n">가장</span><span class="w"> </span><span class="n">오른쪽</span><span class="w"> </span><span class="n">자식</span>
<span class="w">        </span><span class="k">else</span><span class="err">:</span>
<span class="w">            </span><span class="n">node</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">node</span><span class="p">.</span><span class="n">child</span><span class="o">[</span><span class="n">i</span><span class="o">]</span><span class="w">      </span><span class="o">//</span><span class="w"> </span><span class="n">자식</span><span class="w"> </span><span class="n">i로</span><span class="w"> </span><span class="n">이동</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="n">이제</span><span class="w"> </span><span class="n">리프에</span><span class="w"> </span><span class="nl">도달</span><span class="p">:</span><span class="w"> </span><span class="n">K</span><span class="w"> </span><span class="n">스캔</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="k">each</span><span class="w"> </span><span class="p">(</span><span class="k">key</span><span class="p">,</span><span class="w"> </span><span class="n">pointer</span><span class="p">)</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="nl">node</span><span class="p">:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nl">K</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="n">pointer</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">NOT_FOUND</span>
</code></pre></div>

<p><strong>범위 검색</strong> <code>[lo, hi]</code>의 키:</p>
<div class="highlight"><pre><span></span><code><span class="nv">BPLUS</span><span class="o">-</span><span class="nv">RANGE</span><span class="o">-</span><span class="nv">SEARCH</span><span class="ss">(</span><span class="nv">root</span>,<span class="w"> </span><span class="nv">lo</span>,<span class="w"> </span><span class="nv">hi</span><span class="ss">)</span>:
<span class="w">    </span><span class="o">//</span><span class="w"> </span>단계<span class="w"> </span><span class="mi">1</span>:<span class="w"> </span><span class="nv">lo</span>를<span class="w"> </span>포함하는<span class="w"> </span>리프<span class="w"> </span>찾기
<span class="w">    </span><span class="nv">leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">find</span><span class="w"> </span><span class="nv">leaf</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">lo</span><span class="w"> </span><span class="ss">(</span>동등<span class="w"> </span>검색<span class="w"> </span>로직<span class="w"> </span>사용<span class="ss">)</span>

<span class="w">    </span><span class="o">//</span><span class="w"> </span>단계<span class="w"> </span><span class="mi">2</span>:<span class="w"> </span>연결<span class="w"> </span>리스트를<span class="w"> </span>통해<span class="w"> </span>리프<span class="w"> </span>스캔
<span class="w">    </span><span class="nv">results</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[]
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="nv">leaf</span><span class="w"> </span><span class="nv">is</span><span class="w"> </span><span class="nv">not</span><span class="w"> </span><span class="nv">null</span>:
<span class="w">        </span><span class="k">for</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="ss">(</span><span class="nv">key</span>,<span class="w"> </span><span class="nv">pointer</span><span class="ss">)</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">leaf</span>:
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="nv">hi</span>:
<span class="w">                </span><span class="k">return</span><span class="w"> </span><span class="nv">results</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="nv">key</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="nv">lo</span>:
<span class="w">                </span><span class="nv">results</span>.<span class="nv">append</span><span class="ss">(</span><span class="nv">pointer</span><span class="ss">)</span>
<span class="w">        </span><span class="nv">leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">leaf</span>.<span class="k">next</span><span class="w">    </span><span class="o">//</span><span class="w"> </span>리프<span class="w"> </span>체인을<span class="w"> </span>따라감<span class="o">!</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="nv">results</span>
</code></pre></div>

<p>이것이 B+Tree가 범위 쿼리에 뛰어난 이유다 -- 시작 리프를 찾으면, 연결 리스트를 따라가기만 하면 된다.</p>
<h3 id="44-btree">4.4 B+Tree에 삽입<a class="header-link" href="#44-btree" title="Permanent link">&para;</a></h3>
<p>데이터 포인터 <code>D</code>와 함께 키 <code>K</code> 삽입:</p>
<div class="highlight"><pre><span></span><code><span class="n">BPLUS</span><span class="o">-</span><span class="k">INSERT</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="w"> </span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="n">leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find</span><span class="w"> </span><span class="n">appropriate</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="n">node</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="nl">room</span><span class="p">:</span>
<span class="w">        </span><span class="k">insert</span><span class="w"> </span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="w"> </span><span class="n">D</span><span class="p">)</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">sorted</span><span class="w"> </span><span class="k">order</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">leaf</span>
<span class="w">    </span><span class="k">else</span><span class="err">:</span>
<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="n">리프</span><span class="w"> </span><span class="nl">오버플로우</span><span class="p">:</span><span class="w"> </span><span class="n">분할</span>
<span class="w">        </span><span class="k">Create</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">leaf</span><span class="w"> </span><span class="n">L</span><span class="s1">&#39;</span>
<span class="s1">        Distribute entries evenly: first ⌈m/2⌉ stay, rest go to L&#39;</span>

<span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="nl">복사</span><span class="p">:</span><span class="w"> </span><span class="n">L</span><span class="s1">&#39;의 첫 번째 키가 부모로 감</span>
<span class="s1">        parent-key = L&#39;</span><span class="p">.</span><span class="k">key</span><span class="o">[</span><span class="n">1</span><span class="o">]</span>
<span class="w">        </span><span class="k">INSERT</span><span class="o">-</span><span class="ow">IN</span><span class="o">-</span><span class="n">PARENT</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span><span class="w"> </span><span class="n">parent</span><span class="o">-</span><span class="k">key</span><span class="p">,</span><span class="w"> </span><span class="n">L</span><span class="s1">&#39;)</span>

<span class="s1">    Update leaf linked list pointers</span>

<span class="s1">INSERT-IN-PARENT(left, key, right):</span>
<span class="s1">    if parent has room:</span>
<span class="s1">        insert (key, right pointer) in parent</span>
<span class="s1">    else:</span>
<span class="s1">        // 내부 노드 오버플로우: 분할</span>
<span class="s1">        Create new internal node N&#39;</span>
<span class="w">        </span><span class="nl">Distribute</span><span class="p">:</span><span class="w"> </span><span class="k">first</span><span class="w"> </span><span class="err">⌈</span><span class="n">m</span><span class="o">/</span><span class="mi">2</span><span class="err">⌉</span><span class="w"> </span><span class="n">pointers</span><span class="w"> </span><span class="n">stay</span><span class="p">,</span><span class="w"> </span><span class="n">rest</span><span class="w"> </span><span class="k">go</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">N</span><span class="s1">&#39;</span>

<span class="s1">        // 푸시: 중간 키가 부모로 감 (복사되지 않음)</span>
<span class="s1">        middle-key = the key that separates the two halves</span>
<span class="s1">        INSERT-IN-PARENT(parent, middle-key, N&#39;</span><span class="p">)</span>
</code></pre></div>

<p><strong>중요한 구별:</strong>
- 리프 분할: <strong>복사</strong> (분리 키가 리프와 부모 모두에 존재)
- 내부 분할: <strong>푸시</strong> (분리 키가 부모로 이동하고 분할되는 노드에서 제거됨)</p>
<p><strong>예: 차수 3의 B+Tree에 7 삽입 (리프당 최대 2개의 키):</strong></p>
<div class="highlight"><pre><span></span><code>이전:
           ┌────┐
           │ 5  │
           └┬───┘
       ┌────┘  └────┐
    ┌─────┐     ┌──────┐
    │ 3,4 │ ──→ │ 5,6  │
    └─────┘     └──────┘

단계 1: 키 7은 리프 [5, 6]에 속함. 리프가 꽉 참.
단계 2: 리프 분할: [5]와 [6, 7]. 키 6을 부모로 복사.

이후:
           ┌──────┐
           │ 5 │ 6│
           └┬──┬──┘
       ┌───┘  │  └───┐
    ┌─────┐ ┌───┐ ┌─────┐
    │ 3,4 │→│ 5 │→│ 6,7 │
    └─────┘ └───┘ └─────┘
</code></pre></div>

<h3 id="45-btree">4.5 B+Tree에서 삭제<a class="header-link" href="#45-btree" title="Permanent link">&para;</a></h3>
<p>키 <code>K</code> 삭제:</p>
<div class="highlight"><pre><span></span><code><span class="nv">BPLUS</span><span class="o">-</span><span class="nv">DELETE</span><span class="ss">(</span><span class="nv">root</span>,<span class="w"> </span><span class="nv">K</span><span class="ss">)</span>:
<span class="w">    </span><span class="nv">leaf</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">find</span><span class="w"> </span><span class="nv">leaf</span><span class="w"> </span><span class="nv">containing</span><span class="w"> </span><span class="nv">K</span>
<span class="w">    </span><span class="nv">Remove</span><span class="w"> </span><span class="nv">K</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">leaf</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nv">leaf</span><span class="w"> </span><span class="nv">has</span><span class="w"> </span><span class="nv">enough</span><span class="w"> </span><span class="nv">keys</span><span class="w"> </span><span class="ss">(</span>≥<span class="w"> </span>⌈<span class="ss">(</span><span class="nv">m</span><span class="o">-</span><span class="mi">1</span><span class="ss">)</span><span class="o">/</span><span class="mi">2</span>⌉<span class="ss">)</span>:
<span class="w">        </span><span class="nv">done</span><span class="w"> </span><span class="ss">(</span>첫<span class="w"> </span>번째<span class="w"> </span>키가<span class="w"> </span>변경되면<span class="w"> </span>부모<span class="w"> </span>키<span class="w"> </span>업데이트<span class="w"> </span>필요할<span class="w"> </span>수<span class="w"> </span>있음<span class="ss">)</span>
<span class="w">    </span><span class="k">else</span>:
<span class="w">        </span><span class="o">//</span><span class="w"> </span>언더플로우
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nv">sibling</span><span class="w"> </span><span class="nv">has</span><span class="w"> </span><span class="nv">extra</span><span class="w"> </span><span class="nv">keys</span>:
<span class="w">            </span><span class="nv">redistribute</span><span class="w"> </span><span class="ss">(</span>형제에서<span class="w"> </span>빌림<span class="ss">)</span>
<span class="w">            </span><span class="nv">update</span><span class="w"> </span><span class="nv">parent</span><span class="w"> </span><span class="nv">key</span>
<span class="w">        </span><span class="k">else</span>:
<span class="w">            </span><span class="nv">merge</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">sibling</span>
<span class="w">            </span><span class="nv">delete</span><span class="w"> </span><span class="nv">entry</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">parent</span>
<span class="w">            </span><span class="nv">recursively</span><span class="w"> </span><span class="nv">handle</span><span class="w"> </span><span class="nv">parent</span><span class="w"> </span><span class="nv">underflow</span>
</code></pre></div>

<p><strong>리프 병합</strong>은 부모에서 키를 제거한다. <strong>내부 노드 병합</strong>은 부모에서 키를 내린다. 루트가 단일 자식만 남으면, 자식이 새 루트가 된다 (트리 높이 감소).</p>
<h3 id="46">4.6 대량 로딩<a class="header-link" href="#46" title="Permanent link">&para;</a></h3>
<p>빈 트리에서 하나씩 삽입하여 B+Tree를 구축하는 것은 비효율적이다. <strong>대량 로딩(Bulk Loading)</strong>은 기존 데이터에 인덱스를 생성할 때 사용된다:</p>
<div class="highlight"><pre><span></span><code>BULK-LOAD(sorted_data, m):
    // 단계 1: 검색 키로 데이터 정렬 (필요시 외부 정렬)

    // 단계 2: 리프 노드를 순차적으로 채움
    for each key in sorted_data:
        add to current leaf
        if leaf full:
            start new leaf
            add separator to parent level

    // 단계 3: 상향식으로 내부 레벨 구축
    repeat for each level until root is created
</code></pre></div>

<p><strong>대량 로딩의 장점:</strong>
- 랜덤 I/O 대신 순차 I/O
- 채움 비율(Fill Factor) 제어 가능 (예: 향후 삽입을 위해 90% 채움)
- O(n log_m n) 전체, 하지만 상수가 훨씬 더 좋음</p>
<p><strong>PostgreSQL:</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">-- CREATE INDEX는 테이블에 데이터가 있을 때 내부적으로 대량 로딩 사용</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_emp_salary</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">employees</span><span class="p">(</span><span class="n">salary</span><span class="p">);</span>

<span class="c1">-- REINDEX는 인덱스를 재구축 (대량 업데이트 후 유용)</span>
<span class="k">REINDEX</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_emp_salary</span><span class="p">;</span>
</code></pre></div>

<h3 id="47">4.7 높이와 성능 분석<a class="header-link" href="#47" title="Permanent link">&para;</a></h3>
<p><code>n</code>개의 검색 키 값을 가진 차수 <code>m</code>의 B+Tree:</p>
<p><strong>최대 높이:</strong></p>
<div class="highlight"><pre><span></span><code>h ≤ ⌈log_{⌈m/2⌉}(n)⌉
</code></pre></div>

<p><strong>실제 예:</strong></p>
<p>주어진:
- 블록 크기: 4 KB
- 키 크기: 8바이트, 포인터 크기: 8바이트
- 내부 노드 분기 계수: m = 4096 / (8 + 8) = 256
- 리프 엔트리: (m-1) = 리프당 255</p>
<p>n = 100,000,000 (1억) 레코드의 경우:</p>
<div class="highlight"><pre><span></span><code>높이 = ⌈log₁₂₈(100,000,000)⌉ = ⌈log₁₂₈(10⁸)⌉ ≈ ⌈8/2.1⌉ ≈ 4
</code></pre></div>

<p>따라서 1억 개 중 어떤 레코드든 <strong>4번의 디스크 읽기</strong>로 찾을 수 있다. 실제로 루트와 상위 레벨은 메모리에 캐시되어, 이를 <strong>1-2번의 디스크 읽기</strong>로 줄일 수 있다.</p>
<hr />
<h2 id="5">5. 해시 기반 인덱싱<a class="header-link" href="#5" title="Permanent link">&para;</a></h2>
<h3 id="51">5.1 정적 해싱<a class="header-link" href="#51" title="Permanent link">&para;</a></h3>
<p><strong>해시 인덱스</strong>는 해시 함수 <code>h(K)</code>를 사용하여 검색 키 값을 버킷 주소에 직접 매핑한다.</p>
<div class="highlight"><pre><span></span><code><span class="n">해시</span><span class="w"> </span><span class="n">함수</span><span class="w"> </span><span class="n">h가</span><span class="w"> </span><span class="n">키</span><span class="w"> </span><span class="n">K를</span><span class="w"> </span><span class="n">버킷</span><span class="w"> </span><span class="n">번호에</span><span class="w"> </span><span class="nl">매핑</span><span class="p">:</span>

<span class="k">Key</span><span class="err">:</span><span class="w"> </span><span class="ss">&quot;Alice&quot;</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">h</span><span class="p">(</span><span class="ss">&quot;Alice&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>
<span class="k">Key</span><span class="err">:</span><span class="w"> </span><span class="ss">&quot;Bob&quot;</span><span class="w">   </span><span class="err">→</span><span class="w"> </span><span class="n">h</span><span class="p">(</span><span class="ss">&quot;Bob&quot;</span><span class="p">)</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="k">Key</span><span class="err">:</span><span class="w"> </span><span class="ss">&quot;Carol&quot;</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">h</span><span class="p">(</span><span class="ss">&quot;Carol&quot;</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="p">(</span><span class="n">충돌</span><span class="err">!</span><span class="p">)</span>

<span class="n">버킷</span><span class="w"> </span><span class="nl">배열</span><span class="p">:</span>
<span class="err">┌─────────┐</span>
<span class="err">│</span><span class="w"> </span><span class="n">버킷</span><span class="w"> </span><span class="mi">0</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="o">[</span><span class="n">Bob, ...</span><span class="o">]</span>
<span class="err">├─────────┤</span>
<span class="err">│</span><span class="w"> </span><span class="n">버킷</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="o">[</span><span class="n">empty</span><span class="o">]</span>
<span class="err">├─────────┤</span>
<span class="err">│</span><span class="w"> </span><span class="n">버킷</span><span class="w"> </span><span class="mi">2</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="o">[</span><span class="n">Alice, ...</span><span class="o">]</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="o">[</span><span class="n">Carol, ...</span><span class="o">]</span><span class="w">  </span><span class="p">(</span><span class="n">오버플로우</span><span class="w"> </span><span class="n">체인</span><span class="p">)</span>
<span class="err">├─────────┤</span>
<span class="err">│</span><span class="w"> </span><span class="n">버킷</span><span class="w"> </span><span class="mi">3</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="o">[</span><span class="n">Dave, ...</span><span class="o">]</span>
<span class="err">└─────────┘</span>
</code></pre></div>

<p><strong>특성:</strong>
- <strong>이상적인 경우</strong>: O(1) 조회 -- 한 번의 디스크 읽기
- <strong>오버플로우 처리</strong>: 체이닝 (오버플로우 버킷의 연결 리스트)
- <strong>약점</strong>: 고정된 버킷 수. 파일이 증가하면 성능 저하</p>
<p><strong>해시 함수 요구사항:</strong>
1. <strong>균일 분포</strong>: 키가 버킷 전체에 균등하게 분산되어야 함
2. <strong>결정적</strong>: 동일한 키는 항상 동일한 버킷에 매핑
3. <strong>빠른 계산</strong>: O(1) 시간</p>
<h3 id="52">5.2 확장 가능 해싱<a class="header-link" href="#52" title="Permanent link">&para;</a></h3>
<p><strong>확장 가능 해싱(Extendible Hashing)</strong>은 전체 파일을 재구성하지 않고 필요에 따라 크기가 2배가 되는 <strong>디렉토리</strong>를 사용하여 데이터 증가에 적응한다.</p>
<p><strong>주요 개념:</strong>
- <strong>전역 깊이(Global Depth)</strong> (<code>d</code>): 디렉토리가 사용하는 해시 값의 비트 수
- <strong>로컬 깊이(Local Depth)</strong> (<code>dᵢ</code>): 버킷 <code>i</code>가 사용하는 비트 수
- 디렉토리 크기 = <code>2^d</code> 엔트리</p>
<div class="highlight"><pre><span></span><code>전역 깊이 d = 2인 예:

해시 값 (2진수):        디렉토리 (d=2):
h(K₁) = 01001...            ┌────┬───────────┐
h(K₂) = 10110...            │ 00 │ ──→ 버킷 A (로컬 깊이 2)
h(K₃) = 00101...            │ 01 │ ──→ 버킷 B (로컬 깊이 2)
h(K₄) = 11010...            │ 10 │ ──→ 버킷 C (로컬 깊이 1)
h(K₅) = 10011...            │ 11 │ ──→ 버킷 C (로컬 깊이 1)
                             └────┴───────────┘

참고: 엔트리 10과 11 모두 버킷 C를 가리킴
C의 로컬 깊이 (1) &lt; 전역 깊이 (2)이기 때문.
버킷 C에는 첫 번째 비트만 중요함.
</code></pre></div>

<p><strong>버킷 오버플로우 시 버킷 분할:</strong></p>
<div class="highlight"><pre><span></span><code>버킷 B (로컬 깊이 2)가 오버플로우하면:

케이스 1: 로컬 깊이 &lt; 전역 깊이
  → 버킷 분할, 로컬 깊이 증가
  → 엔트리 재분배
  → 디렉토리 포인터 업데이트

케이스 2: 로컬 깊이 == 전역 깊이
  → 디렉토리를 2배로 (전역 깊이 1 증가)
  → 버킷 분할, 로컬 깊이 증가
  → 엔트리 재분배
  → 디렉토리 포인터 업데이트
</code></pre></div>

<p><strong>장점:</strong>
- 오버플로우 체인 없음 (분할이 증가 처리)
- 조회당 최대 2번의 디스크 접근 (디렉토리 1번, 버킷 1번)
- 우아하게 증가</p>
<p><strong>단점:</strong>
- 데이터가 치우치면 디렉토리가 커질 수 있음
- 디렉토리 2배 확장은 비싸지만 드물게 발생</p>
<h3 id="53">5.3 선형 해싱<a class="header-link" href="#53" title="Permanent link">&para;</a></h3>
<p><strong>선형 해싱(Linear Hashing)</strong>은 디렉토리를 완전히 피한다. 버킷은 분할 포인터로 제어되는 <strong>라운드 로빈</strong> 방식으로 한 번에 하나씩 분할된다.</p>
<p><strong>핵심 아이디어:</strong>
- 다음 분할할 버킷을 추적하는 <strong>분할 포인터</strong> <code>s</code> 유지
- 두 개의 해시 함수 사용: <code>h₀(K) = K mod N</code>과 <code>h₁(K) = K mod 2N</code>
- 버킷이 오버플로우하면, 분할 포인터의 버킷을 분할 (오버플로우된 버킷이 아님)</p>
<div class="highlight"><pre><span></span><code><span class="nv">N</span><span class="o">=</span><span class="mi">4</span><span class="w"> </span>버킷,<span class="w"> </span>분할<span class="w"> </span>포인터<span class="w"> </span><span class="nv">s</span><span class="o">=</span><span class="mi">1</span>인<span class="w"> </span>상태:

버킷:
┌──────────┐
│<span class="w"> </span>버킷<span class="w"> </span><span class="mi">0</span><span class="w">   </span>│<span class="w"> </span>→<span class="w"> </span>[<span class="nv">h</span>₁<span class="ss">(</span><span class="nv">K</span><span class="ss">)</span><span class="o">=</span><span class="mi">0</span>인<span class="w"> </span>레코드]<span class="w">    </span><span class="ss">(</span>이미<span class="w"> </span>분할됨,<span class="w"> </span><span class="nv">h</span>₁<span class="w"> </span>사용<span class="ss">)</span>
├──────────┤
│<span class="w"> </span>버킷<span class="w"> </span><span class="mi">1</span><span class="w">   </span>│<span class="w"> </span>→<span class="w"> </span>[<span class="nv">h</span>₀<span class="ss">(</span><span class="nv">K</span><span class="ss">)</span><span class="o">=</span><span class="mi">1</span>인<span class="w"> </span>레코드]<span class="w">    </span>←<span class="w"> </span>분할<span class="w"> </span>포인터<span class="w"> </span><span class="nv">s</span>
├──────────┤
│<span class="w"> </span>버킷<span class="w"> </span><span class="mi">2</span><span class="w">   </span>│<span class="w"> </span>→<span class="w"> </span>[<span class="nv">h</span>₀<span class="ss">(</span><span class="nv">K</span><span class="ss">)</span><span class="o">=</span><span class="mi">2</span>인<span class="w"> </span>레코드]<span class="w">    </span><span class="ss">(</span>아직<span class="w"> </span>분할<span class="w"> </span>안<span class="w"> </span>됨,<span class="w"> </span><span class="nv">h</span>₀<span class="w"> </span>사용<span class="ss">)</span>
├──────────┤
│<span class="w"> </span>버킷<span class="w"> </span><span class="mi">3</span><span class="w">   </span>│<span class="w"> </span>→<span class="w"> </span>[<span class="nv">h</span>₀<span class="ss">(</span><span class="nv">K</span><span class="ss">)</span><span class="o">=</span><span class="mi">3</span>인<span class="w"> </span>레코드]<span class="w">    </span><span class="ss">(</span>아직<span class="w"> </span>분할<span class="w"> </span>안<span class="w"> </span>됨,<span class="w"> </span><span class="nv">h</span>₀<span class="w"> </span>사용<span class="ss">)</span>
├──────────┤
│<span class="w"> </span>버킷<span class="w"> </span><span class="mi">4</span><span class="w">   </span>│<span class="w"> </span>→<span class="w"> </span>[<span class="nv">h</span>₁<span class="ss">(</span><span class="nv">K</span><span class="ss">)</span><span class="o">=</span><span class="mi">4</span>인<span class="w"> </span>레코드]<span class="w">    </span><span class="ss">(</span>버킷<span class="w"> </span><span class="mi">0</span><span class="w"> </span>분할로<span class="w"> </span>생성됨<span class="ss">)</span>
└──────────┘

조회<span class="w"> </span>알고리즘:
<span class="w">  </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">h</span>₀<span class="ss">(</span><span class="nv">K</span><span class="ss">)</span><span class="w">          </span><span class="o">//</span><span class="w"> </span>예:<span class="w"> </span><span class="nv">K</span><span class="w"> </span><span class="nv">mod</span><span class="w"> </span><span class="mi">4</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="nv">b</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="nv">s</span>:<span class="w">           </span><span class="o">//</span><span class="w"> </span>버킷이<span class="w"> </span>이미<span class="w"> </span>분할됨
<span class="w">      </span><span class="nv">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">h</span>₁<span class="ss">(</span><span class="nv">K</span><span class="ss">)</span><span class="w">      </span><span class="o">//</span><span class="w"> </span>대신<span class="w"> </span><span class="nv">K</span><span class="w"> </span><span class="nv">mod</span><span class="w"> </span><span class="mi">8</span><span class="w"> </span>사용
<span class="w">  </span><span class="nv">search</span><span class="w"> </span><span class="nv">bucket</span><span class="w"> </span><span class="nv">b</span>
</code></pre></div>

<p><strong>언제 분할할까:</strong>
- 어떤 버킷이 오버플로우하면 분할이 트리거됨
- 분할 포인터의 버킷이 분할됨 (오버플로우된 버킷이 아님!)
- 오버플로우된 버킷은 임시로 오버플로우 체인 사용
- 분할 포인터 전진: <code>s = s + 1</code>
- <code>s = N</code>이면, 라운드 완료: <code>N = 2N</code>, <code>s = 0</code>, 해시 함수 전진</p>
<p><strong>장점:</strong>
- 디렉토리 불필요
- 부드러운 증가 (한 번에 하나의 버킷)
- 보장된 O(1) 평균 접근</p>
<p><strong>단점:</strong>
- 임시 오버플로우 체인
- 분할이 실제 오버플로우된 버킷을 즉시 완화하지 못할 수 있음</p>
<h3 id="vs-btree">해시 vs. B+Tree 비교<a class="header-link" href="#vs-btree" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>기준</th>
<th>해시 인덱스</th>
<th>B+Tree 인덱스</th>
</tr>
</thead>
<tbody>
<tr>
<td>동등 쿼리</td>
<td>O(1) -- 우수</td>
<td>O(log n) -- 좋음</td>
</tr>
<tr>
<td>범위 쿼리</td>
<td>지원 안 함</td>
<td>우수 (리프 체인)</td>
</tr>
<tr>
<td>정렬된 순회</td>
<td>지원 안 함</td>
<td>자연스러움 (리프 스캔)</td>
</tr>
<tr>
<td>동적 증가</td>
<td>확장 가능/선형</td>
<td>분할과 병합</td>
</tr>
<tr>
<td>공간 사용</td>
<td>공간 낭비 가능 (빈 버킷)</td>
<td>좋은 활용 (~67%)</td>
</tr>
<tr>
<td>구현</td>
<td>더 단순</td>
<td>더 복잡</td>
</tr>
<tr>
<td>RDBMS에서 일반적</td>
<td>PostgreSQL (해시), Redis</td>
<td>모든 주요 RDBMS</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="6">6. 비트맵 인덱스<a class="header-link" href="#6" title="Permanent link">&para;</a></h2>
<h3 id="61">6.1 개념<a class="header-link" href="#61" title="Permanent link">&para;</a></h3>
<p><strong>비트맵 인덱스(Bitmap Index)</strong>는 인덱싱된 속성의 각 고유 값에 대해 비트 벡터를 생성한다. 각 비트는 테이블의 행에 해당한다.</p>
<div class="highlight"><pre><span></span><code><span class="err">테이블</span><span class="o">:</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="o">(</span><span class="mi">8</span><span class="err">개</span><span class="w"> </span><span class="err">행</span><span class="o">)</span>
<span class="err">┌─────┬───────┬────────┬────────┐</span>
<span class="err">│</span><span class="w"> </span><span class="n">RID</span><span class="w"> </span><span class="err">│</span><span class="w"> </span><span class="n">Name</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Dept</span><span class="w">   </span><span class="err">│</span><span class="w"> </span><span class="n">Gender</span><span class="w"> </span><span class="err">│</span>
<span class="err">├─────┼───────┼────────┼────────┤</span>
<span class="err">│</span><span class="w">  </span><span class="mi">0</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Alice</span><span class="w"> </span><span class="err">│</span><span class="w"> </span><span class="n">Eng</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">F</span><span class="w">      </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="mi">1</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Bob</span><span class="w">   </span><span class="err">│</span><span class="w"> </span><span class="n">Sales</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">M</span><span class="w">      </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="mi">2</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Carol</span><span class="w"> </span><span class="err">│</span><span class="w"> </span><span class="n">Eng</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">F</span><span class="w">      </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="mi">3</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Dave</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">HR</span><span class="w">     </span><span class="err">│</span><span class="w"> </span><span class="n">M</span><span class="w">      </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="mi">4</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Eve</span><span class="w">   </span><span class="err">│</span><span class="w"> </span><span class="n">Eng</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">F</span><span class="w">      </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="mi">5</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Frank</span><span class="w"> </span><span class="err">│</span><span class="w"> </span><span class="n">Sales</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">M</span><span class="w">      </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="mi">6</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Grace</span><span class="w"> </span><span class="err">│</span><span class="w"> </span><span class="n">HR</span><span class="w">     </span><span class="err">│</span><span class="w"> </span><span class="n">F</span><span class="w">      </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="mi">7</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Hank</span><span class="w">  </span><span class="err">│</span><span class="w"> </span><span class="n">Eng</span><span class="w">    </span><span class="err">│</span><span class="w"> </span><span class="n">M</span><span class="w">      </span><span class="err">│</span>
<span class="err">└─────┴───────┴────────┴────────┘</span>

<span class="n">Dept에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="err">비트맵</span><span class="w"> </span><span class="err">인덱스</span><span class="o">:</span>
<span class="w">  </span><span class="n">Eng</span><span class="o">:</span><span class="w">   </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="w">  </span><span class="o">(</span><span class="err">행</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">7</span><span class="o">)</span>
<span class="w">  </span><span class="n">Sales</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">]</span><span class="w">  </span><span class="o">(</span><span class="err">행</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">5</span><span class="o">)</span>
<span class="w">  </span><span class="n">HR</span><span class="o">:</span><span class="w">    </span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">]</span><span class="w">  </span><span class="o">(</span><span class="err">행</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="mi">6</span><span class="o">)</span>

<span class="n">Gender에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="err">비트맵</span><span class="w"> </span><span class="err">인덱스</span><span class="o">:</span>
<span class="w">  </span><span class="n">F</span><span class="o">:</span><span class="w">     </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">]</span><span class="w">  </span><span class="o">(</span><span class="err">행</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="mi">2</span><span class="o">,</span><span class="mi">4</span><span class="o">,</span><span class="mi">6</span><span class="o">)</span>
<span class="w">  </span><span class="n">M</span><span class="o">:</span><span class="w">     </span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span><span class="w">  </span><span class="o">(</span><span class="err">행</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="mi">3</span><span class="o">,</span><span class="mi">5</span><span class="o">,</span><span class="mi">7</span><span class="o">)</span>
</code></pre></div>

<h3 id="62">6.2 비트맵 연산<a class="header-link" href="#62" title="Permanent link">&para;</a></h3>
<p><strong>비트 연산</strong>을 사용하여 비트맵을 결합하여 쿼리에 답할 수 있다:</p>
<div class="highlight"><pre><span></span><code><span class="err">쿼리</span><span class="o">:</span><span class="w"> </span><span class="err">모든</span><span class="w"> </span><span class="err">여성</span><span class="w"> </span><span class="err">엔지니어</span><span class="w"> </span><span class="err">찾기</span>

<span class="w">  </span><span class="n">Dept</span><span class="o">=</span><span class="n">Eng</span><span class="o">:</span><span class="w">  </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span>
<span class="w">  </span><span class="n">AND</span>
<span class="w">  </span><span class="n">Gender</span><span class="o">=</span><span class="n">F</span><span class="o">:</span><span class="w">  </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">]</span>
<span class="w">  </span><span class="err">─────────────────────────────────────</span>
<span class="w">  </span><span class="err">결과</span><span class="o">:</span><span class="w">      </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">]</span><span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="err">행</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="mi">4</span>
<span class="w">                                         </span><span class="o">(</span><span class="n">Alice</span><span class="o">,</span><span class="w"> </span><span class="n">Carol</span><span class="o">,</span><span class="w"> </span><span class="n">Eve</span><span class="o">)</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">쿼리</span><span class="o">:</span><span class="w"> </span><span class="n">Sales</span><span class="w"> </span><span class="err">또는</span><span class="w"> </span><span class="n">HR의</span><span class="w"> </span><span class="err">모든</span><span class="w"> </span><span class="err">직원</span><span class="w"> </span><span class="err">찾기</span>

<span class="w">  </span><span class="n">Dept</span><span class="o">=</span><span class="n">Sales</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">]</span>
<span class="w">  </span><span class="n">OR</span>
<span class="w">  </span><span class="n">Dept</span><span class="o">=</span><span class="n">HR</span><span class="o">:</span><span class="w">    </span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">]</span>
<span class="w">  </span><span class="err">─────────────────────────────────────</span>
<span class="w">  </span><span class="err">결과</span><span class="o">:</span><span class="w">       </span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">]</span><span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="err">행</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">쿼리</span><span class="o">:</span><span class="w"> </span><span class="err">모든</span><span class="w"> </span><span class="err">비</span><span class="o">-</span><span class="err">엔지니어</span><span class="w"> </span><span class="err">찾기</span>

<span class="w">  </span><span class="n">NOT</span><span class="w"> </span><span class="n">Dept</span><span class="o">=</span><span class="n">Eng</span><span class="o">:</span><span class="w"> </span><span class="n">NOT</span><span class="w"> </span><span class="o">[</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">]</span>
<span class="w">  </span><span class="err">─────────────────────────────────────────────</span>
<span class="w">  </span><span class="err">결과</span><span class="o">:</span><span class="w">             </span><span class="o">[</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">0</span><span class="o">]</span><span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="err">행</span><span class="w"> </span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="mi">3</span><span class="o">,</span><span class="w"> </span><span class="mi">5</span><span class="o">,</span><span class="w"> </span><span class="mi">6</span>
</code></pre></div>

<h3 id="63">6.3 비트맵 인덱스를 사용해야 할 때<a class="header-link" href="#63" title="Permanent link">&para;</a></h3>
<p><strong>이상적인 경우:</strong>
- <strong>낮은 카디널리티</strong> 속성 (Gender: 2개 값, Status: 3-5개 값)
- <strong>데이터 웨어하우징</strong> - 대부분 읽기 전용 접근
- <strong>복잡한 다중 속성 쿼리</strong> (AND/OR 조합)
- <strong>카운트 쿼리</strong> (WHERE가 있는 COUNT) -- 설정된 비트만 세기
- <strong>스타 스키마(Star Schema)</strong> 팩트 테이블의 많은 차원 외래 키</p>
<p><strong>이상적이지 않은 경우:</strong>
- <strong>높은 카디널리티</strong> 속성 (예: 고유 ID -- 값당 하나의 비트맵!)
- <strong>OLTP</strong> - 빈번한 업데이트 (모든 삽입마다 비트맵 업데이트는 비쌈)
- <strong>높은 동시성</strong> 환경 (비트맵 잠금이 많은 행에 영향)</p>
<h3 id="64">6.4 비트맵 압축<a class="header-link" href="#64" title="Permanent link">&para;</a></h3>
<p>대형 테이블의 경우 비트맵이 매우 커질 수 있다. 압축 기법이 도움이 된다:</p>
<p><strong>런 길이 인코딩(Run-Length Encoding, RLE):</strong></p>
<div class="highlight"><pre><span></span><code>원본:  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]
RLE:   (0, 11), (1, 1), (0, 4)    → &quot;11개의 0, 1개의 1, 4개의 0&quot;
</code></pre></div>

<p><strong>워드 정렬 하이브리드(Word-Aligned Hybrid, WAH):</strong>
Oracle 및 다른 시스템에서 사용. 동일한 워드(32 또는 64비트)의 시퀀스를 압축하면서 압축된 형태로 효율적인 비트 연산을 허용한다.</p>
<p><strong>로어링 비트맵(Roaring Bitmaps):</strong>
비트맵을 청크로 분할하고 각 청크에 대해 최적의 표현(배열, 비트맵, 또는 런)을 사용하는 현대적인 압축 기법. Apache Lucene, Apache Spark 및 다른 시스템에서 널리 사용된다.</p>
<h3 id="65">6.5 공간 분석<a class="header-link" href="#65" title="Permanent link">&para;</a></h3>
<p><code>n</code>개 행과 <code>c</code>개 고유 값을 가진 속성을 가진 테이블:</p>
<div class="highlight"><pre><span></span><code>비압축 비트맵 크기 = n × c 비트 = nc/8 바이트

B+Tree와 비교:
B+Tree 인덱스 크기 ≈ n × (key_size + pointer_size) 바이트
</code></pre></div>

<p><strong>예</strong>: 100만 행, 5개 값을 가진 속성:
- 비트맵: 1,000,000 x 5 / 8 = 625,000 바이트 ≈ 610 KB
- B+Tree: 1,000,000 x (8 + 8) = 16,000,000 바이트 ≈ 15.3 MB</p>
<p>낮은 카디널리티 속성의 경우 비트맵은 <strong>25배 더 작다</strong>.</p>
<hr />
<h2 id="7">7. 다차원 인덱싱<a class="header-link" href="#7" title="Permanent link">&para;</a></h2>
<h3 id="71">7.1 문제<a class="header-link" href="#71" title="Permanent link">&para;</a></h3>
<p>표준 B+Tree와 해시 인덱스는 <strong>1차원</strong> 검색 키에 잘 작동한다. 하지만 많은 쿼리는 <strong>여러 차원</strong>을 포함한다:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 공간 쿼리</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">restaurants</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">latitude</span><span class="w"> </span><span class="k">BETWEEN</span><span class="w"> </span><span class="mi">37</span><span class="p">.</span><span class="mi">7</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="mi">37</span><span class="p">.</span><span class="mi">8</span>
<span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="n">longitude</span><span class="w"> </span><span class="k">BETWEEN</span><span class="w"> </span><span class="o">-</span><span class="mi">122</span><span class="p">.</span><span class="mi">5</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="o">-</span><span class="mi">122</span><span class="p">.</span><span class="mi">4</span><span class="p">;</span>

<span class="c1">-- 다중 속성 범위 쿼리</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">products</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">price</span><span class="w"> </span><span class="k">BETWEEN</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="mi">50</span>
<span class="w">  </span><span class="k">AND</span><span class="w"> </span><span class="n">weight</span><span class="w"> </span><span class="k">BETWEEN</span><span class="w"> </span><span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
</code></pre></div>

<p><code>(latitude, longitude)</code>에 대한 B+Tree는 <code>latitude</code>에서 효율적으로 필터링할 수 있지만 <code>longitude</code>에 대해서는 일치하는 모든 엔트리를 스캔해야 한다. 진정한 다차원 인덱스는 두 차원을 동시에 처리한다.</p>
<h3 id="72-r-tree">7.2 R-Tree<a class="header-link" href="#72-r-tree" title="Permanent link">&para;</a></h3>
<p><strong>R-Tree</strong> (Rectangle Tree)는 가장 널리 사용되는 공간 인덱스다. <strong>최소 경계 사각형(Minimum Bounding Rectangles, MBR)</strong>을 사용하여 데이터를 구성한다.</p>
<div class="highlight"><pre><span></span><code>R-Tree 구조:

루트: [MBR₁, MBR₂]
       ┌──────────────────────────────────────┐
       │   ┌───────────┐    ┌──────────────┐  │
       │   │   MBR₁    │    │    MBR₂      │  │
       │   │ ┌──┐ ┌──┐ │    │ ┌───┐  ┌──┐  │  │
       │   │ │P1│ │P2│ │    │ │P3 │  │P4│  │  │
       │   │ └──┘ └──┘ │    │ └───┘  └──┘  │  │
       │   │      ┌──┐ │    │     ┌──┐     │  │
       │   │      │P5│ │    │     │P6│     │  │
       │   │      └──┘ │    │     └──┘     │  │
       │   └───────────┘    └──────────────┘  │
       └──────────────────────────────────────┘

각 내부 노드: [MBR₁, ptr₁, MBR₂, ptr₂, ...]
각 리프 노드: [MBR₁, oid₁, MBR₂, oid₂, ...]
</code></pre></div>

<p><strong>특성:</strong>
- 균형 트리 (모든 리프가 동일한 레벨에)
- 각 노드는 <code>⌈m/2⌉</code>와 <code>m</code> 사이의 엔트리를 포함
- 주어진 레벨의 MBR이 겹칠 수 있음
- 검색은 여러 경로를 따라가야 할 수 있음 (B+Tree와 달리)</p>
<p><strong>연산:</strong>
- <strong>검색</strong>: 루트에서 시작, MBR이 쿼리 사각형과 겹치는 모든 자식으로 내려감
- <strong>삽입</strong>: MBR이 가장 적게 확대되어야 하는 부트리를 선택; 필요시 분할
- <strong>사용처</strong>: PostgreSQL (GiST 인덱스), Oracle Spatial, PostGIS</p>
<h3 id="73-kd-tree">7.3 kd-Tree<a class="header-link" href="#73-kd-tree" title="Permanent link">&para;</a></h3>
<p><strong>kd-tree</strong> (k-차원 트리)는 각 레벨에서 분할 차원을 교대로 하여 공간을 분할한다.</p>
<div class="highlight"><pre><span></span><code><span class="mf">2</span><span class="n">D</span><span class="w"> </span><span class="n">kd</span><span class="o">-</span><span class="n">tree</span><span class="w"> </span><span class="n">예</span><span class="w"> </span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="w"> </span><span class="n">그</span><span class="w"> </span><span class="n">다음</span><span class="w"> </span><span class="n">y</span><span class="p">,</span><span class="w"> </span><span class="n">그</span><span class="w"> </span><span class="n">다음</span><span class="w"> </span><span class="n">x로</span><span class="w"> </span><span class="n">분할</span><span class="p">,</span><span class="w"> </span><span class="mf">...</span><span class="p">):</span>

<span class="n">데이터</span><span class="w"> </span><span class="n">포인트</span><span class="p">:</span><span class="w"> </span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mf">5</span><span class="p">,</span><span class="mf">4</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mf">9</span><span class="p">,</span><span class="mf">6</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mf">4</span><span class="p">,</span><span class="mf">7</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mf">8</span><span class="p">,</span><span class="mf">1</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="mf">7</span><span class="p">,</span><span class="mf">2</span><span class="p">)</span>

<span class="w">                    </span><span class="p">(</span><span class="mf">7</span><span class="p">,</span><span class="mf">2</span><span class="p">)</span><span class="w">          </span><span class="n">x</span><span class="o">=</span><span class="mf">7</span><span class="n">에서</span><span class="w"> </span><span class="n">분할</span>
<span class="w">                   </span><span class="o">/</span><span class="w">     </span><span class="err">\</span>
<span class="w">              </span><span class="p">(</span><span class="mf">5</span><span class="p">,</span><span class="mf">4</span><span class="p">)</span><span class="w">       </span><span class="p">(</span><span class="mf">9</span><span class="p">,</span><span class="mf">6</span><span class="p">)</span><span class="w">    </span><span class="n">y</span><span class="o">=</span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="n">y</span><span class="o">=</span><span class="mf">6</span><span class="n">에서</span><span class="w"> </span><span class="n">분할</span>
<span class="w">             </span><span class="o">/</span><span class="w">    </span><span class="err">\</span><span class="w">          </span><span class="err">\</span>
<span class="w">          </span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">)</span><span class="w">  </span><span class="p">(</span><span class="mf">4</span><span class="p">,</span><span class="mf">7</span><span class="p">)</span><span class="w">      </span><span class="p">(</span><span class="mf">8</span><span class="p">,</span><span class="mf">1</span><span class="p">)</span><span class="w">  </span><span class="n">x</span><span class="o">=</span><span class="mf">2</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">=</span><span class="mf">4</span><span class="p">,</span><span class="w"> </span><span class="n">x</span><span class="o">=</span><span class="mf">8</span><span class="n">에서</span><span class="w"> </span><span class="n">분할</span>

<span class="n">공간</span><span class="w"> </span><span class="n">분할</span><span class="p">:</span>
<span class="err">┌───────────────────────┐</span>
<span class="err">│</span><span class="w">           </span><span class="err">│</span><span class="w">            </span><span class="err">│</span>
<span class="err">│</span><span class="w">  </span><span class="p">(</span><span class="mf">2</span><span class="p">,</span><span class="mf">3</span><span class="p">)</span><span class="w">    </span><span class="err">│</span><span class="w">   </span><span class="p">(</span><span class="mf">9</span><span class="p">,</span><span class="mf">6</span><span class="p">)</span><span class="w">   </span><span class="err">│</span>
<span class="err">│</span><span class="w">    </span><span class="err">·</span><span class="w">      </span><span class="err">│</span><span class="w">     </span><span class="err">·</span><span class="w">     </span><span class="err">│</span>
<span class="err">│───────</span><span class="p">(</span><span class="mf">5</span><span class="p">,</span><span class="mf">4</span><span class="p">)</span><span class="err">──────</span><span class="w">     </span><span class="err">│</span>
<span class="err">│</span><span class="w">    </span><span class="err">·</span><span class="w">  </span><span class="err">│</span><span class="w">   </span><span class="err">│</span><span class="w">           </span><span class="err">│</span>
<span class="err">│</span><span class="w"> </span><span class="p">(</span><span class="mf">4</span><span class="p">,</span><span class="mf">7</span><span class="p">)</span><span class="w"> </span><span class="err">│</span><span class="w">   </span><span class="err">│</span><span class="w">  </span><span class="p">(</span><span class="mf">8</span><span class="p">,</span><span class="mf">1</span><span class="p">)</span><span class="w">    </span><span class="err">│</span>
<span class="err">│</span><span class="w">       </span><span class="err">│</span><span class="w">   </span><span class="err">│</span><span class="w">    </span><span class="err">·</span><span class="w">      </span><span class="err">│</span>
<span class="err">└───────┴───┴───────────┘</span>
<span class="w">        </span><span class="n">x</span><span class="o">=</span><span class="mf">7</span><span class="w">    </span><span class="p">(</span><span class="n">분할선</span><span class="p">)</span>
</code></pre></div>

<p><strong>특성:</strong>
- 이진 트리 (각 노드가 공간을 반으로 분할)
- 낮은 차원 데이터에 효율적 (d ≤ 20)
- 검색: O(n^(1-1/d) + k) 여기서 k는 결과 수
- 동적 데이터에 대해 균형이 맞지 않음 (k-d-B 트리와 같은 변형 사용)</p>
<p><strong>공간 인덱스 비교:</strong></p>
<table>
<thead>
<tr>
<th>특징</th>
<th>R-Tree</th>
<th>kd-Tree</th>
</tr>
</thead>
<tbody>
<tr>
<td>차원</td>
<td>어떤 d에도 작동</td>
<td>낮은 d에 최적</td>
</tr>
<tr>
<td>동적 업데이트</td>
<td>좋음 (이를 위해 설계됨)</td>
<td>나쁨 (불균형 가능)</td>
</tr>
<tr>
<td>디스크 기반</td>
<td>예 (이를 위해 설계됨)</td>
<td>원래 인-메모리</td>
</tr>
<tr>
<td>겹침</td>
<td>겹침 허용</td>
<td>겹침 없음</td>
</tr>
<tr>
<td>사용 사례</td>
<td>GIS, 공간 데이터베이스</td>
<td>k-NN 검색, 인-메모리</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="8">8. 인덱스 선택과 설계 지침<a class="header-link" href="#8" title="Permanent link">&para;</a></h2>
<h3 id="81">8.1 인덱스 선택 문제<a class="header-link" href="#81" title="Permanent link">&para;</a></h3>
<p>올바른 인덱스를 선택하는 것은 성능에 중요하다. <strong>인덱스 선택 문제</strong>는 다음을 묻는다: 워크로드(쿼리 집합)가 주어졌을 때, 어떤 인덱스를 생성해야 하는가?</p>
<p><strong>고려할 요인:</strong>
1. <strong>쿼리 패턴</strong>: WHERE, JOIN, ORDER BY, GROUP BY에 어떤 컬럼이 나타나는가?
2. <strong>업데이트 빈도</strong>: INSERT, UPDATE, DELETE가 얼마나 자주 실행되는가?
3. <strong>데이터 분포</strong>: 각 컬럼의 카디널리티와 선택도
4. <strong>저장 예산</strong>: 각 인덱스는 디스크 공간과 유지보수 오버헤드가 듬
5. <strong>상관관계</strong>: 자주 함께 쿼리되는 컬럼</p>
<h3 id="82">8.2 커버링 인덱스<a class="header-link" href="#82" title="Permanent link">&para;</a></h3>
<p><strong>커버링 인덱스(Covering Index)</strong>는 쿼리에 필요한 모든 컬럼을 포함하므로, 데이터베이스가 테이블에 접근하지 않고 인덱스만으로 쿼리에 답할 수 있다 (<strong>인덱스 전용 스캔</strong>).</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 쿼리:</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">salary</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">department</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span><span class="p">;</span>

<span class="c1">-- 비-커버링 인덱스 (테이블 접근 필요):</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_dept</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">employees</span><span class="p">(</span><span class="n">department</span><span class="p">);</span>
<span class="c1">-- 인덱스를 통해 일치하는 행을 찾은 다음, 테이블에서 name, salary를 가져옴</span>

<span class="c1">-- 커버링 인덱스 (테이블 접근 불필요):</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_dept_covering</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">employees</span><span class="p">(</span><span class="n">department</span><span class="p">,</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">salary</span><span class="p">);</span>
<span class="c1">-- 필요한 모든 컬럼이 인덱스에 있음</span>
</code></pre></div>

<p><strong>PostgreSQL INCLUDE 구문:</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">-- INCLUDE 컬럼은 리프 레벨에 저장되지만 검색 키에는 없음</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_dept_incl</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">employees</span><span class="p">(</span><span class="n">department</span><span class="p">)</span><span class="w"> </span><span class="n">INCLUDE</span><span class="w"> </span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">salary</span><span class="p">);</span>
<span class="c1">-- department는 검색 키; name과 salary는 페이로드만</span>
</code></pre></div>

<p><strong>이점:</strong>
- 테이블 접근 제거 (막대한 I/O 절감)
- 자주 실행되는 쿼리에 특히 효과적</p>
<p><strong>트레이드오프:</strong>
- 더 큰 인덱스 크기
- 업데이트 시 더 많은 컬럼 유지보수</p>
<h3 id="83">8.3 복합 (다중 컬럼) 인덱스<a class="header-link" href="#83" title="Permanent link">&para;</a></h3>
<p><strong>복합 인덱스(Composite Index)</strong>는 여러 컬럼에 구축된다. 컬럼 순서가 매우 중요하다.</p>
<div class="highlight"><pre><span></span><code><span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_dept_salary</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">employees</span><span class="p">(</span><span class="n">department</span><span class="p">,</span><span class="w"> </span><span class="n">salary</span><span class="p">);</span>
</code></pre></div>

<p>이 인덱스는 다음에 유용하다:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 전체 인덱스 사용 (두 컬럼 모두):</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">department</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">salary</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">80000</span><span class="p">;</span>

<span class="c1">-- 인덱스 접두사 사용 (department만):</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">department</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span><span class="p">;</span>

<span class="c1">-- 이 인덱스를 효율적으로 사용하지 않음:</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">salary</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">80000</span><span class="p">;</span><span class="w">  </span><span class="c1">-- salary는 접두사가 아님</span>
</code></pre></div>

<p><strong>최좌 접두사 규칙</strong>: <code>(A, B, C)</code>에 대한 복합 인덱스는 다음 쿼리에 사용될 수 있다:
- <code>A</code>
- <code>A, B</code>
- <code>A, B, C</code></p>
<p>하지만 다음에는 효율적이지 않다:
- <code>B</code> 단독
- <code>C</code> 단독
- <code>B, C</code></p>
<h3 id="84">8.4 부분 인덱스<a class="header-link" href="#84" title="Permanent link">&para;</a></h3>
<p><strong>부분 인덱스(Partial Index)</strong>는 조건자로 정의된 행의 부분집합만 인덱싱한다.</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 활성 직원만 인덱싱 (90%가 비활성이면 인덱스가 훨씬 작음)</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_active_emp</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">employees</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">status</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;active&#39;</span><span class="p">;</span>

<span class="c1">-- 최근 주문만 인덱싱</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_recent_orders</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">orders</span><span class="p">(</span><span class="n">customer_id</span><span class="p">)</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">order_date</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="s1">&#39;2025-01-01&#39;</span><span class="p">;</span>

<span class="c1">-- 비-NULL 값만 인덱싱</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_email</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">users</span><span class="p">(</span><span class="n">email</span><span class="p">)</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">email</span><span class="w"> </span><span class="k">IS</span><span class="w"> </span><span class="k">NOT</span><span class="w"> </span><span class="k">NULL</span><span class="p">;</span>
</code></pre></div>

<p><strong>이점:</strong>
- 더 작은 인덱스 크기 (더 적은 엔트리)
- 더 빠른 유지보수 (더 적은 업데이트)
- 더 나은 캐시 활용</p>
<h3 id="85">8.5 표현식 인덱스<a class="header-link" href="#85" title="Permanent link">&para;</a></h3>
<p>일부 데이터베이스는 계산된 표현식 인덱싱을 지원한다:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL: 표현식 인덱스</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_lower_email</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">users</span><span class="p">(</span><span class="k">lower</span><span class="p">(</span><span class="n">email</span><span class="p">));</span>

<span class="c1">-- 대소문자 구분 없는 검색에 유용:</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="k">lower</span><span class="p">(</span><span class="n">email</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;alice@example.com&#39;</span><span class="p">;</span>

<span class="c1">-- 타임스탬프에서 연도 추출한 인덱스:</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_order_year</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">orders</span><span class="p">(</span><span class="k">EXTRACT</span><span class="p">(</span><span class="k">YEAR</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">order_date</span><span class="p">));</span>
</code></pre></div>

<h3 id="86">8.6 실용적 지침<a class="header-link" href="#86" title="Permanent link">&para;</a></h3>
<p><strong>규칙 1: WHERE, JOIN, ORDER BY의 컬럼 인덱싱</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 이 쿼리는 customer_id, order_date, status의 인덱스로 이익</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">orders</span><span class="w"> </span><span class="n">o</span>
<span class="k">JOIN</span><span class="w"> </span><span class="n">customers</span><span class="w"> </span><span class="k">c</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">customer_id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">c</span><span class="p">.</span><span class="n">id</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">order_date</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="s1">&#39;2025-01-01&#39;</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">o</span><span class="p">.</span><span class="n">status</span><span class="p">;</span>
</code></pre></div>

<p><strong>규칙 2: 선택도 고려</strong>
- 높은 선택도 (일치하는 행이 적음) = 좋은 인덱스 후보
- 낮은 선택도 (대부분의 행이 일치) = 나쁜 인덱스 후보
- 경험 법칙: 인덱스는 행의 15-20% 미만을 선택할 때 유용</p>
<p><strong>규칙 3: 과도한 인덱싱 피하기</strong></p>
<div class="highlight"><pre><span></span><code>각 인덱스 비용:
- 디스크 공간 (인덱스 구조 크기)
- 삽입 오버헤드: ~인덱스당 1번의 B+Tree 삽입
- 업데이트 오버헤드: 인덱스당 구 삭제 + 신 삽입
- 진공/유지보수 오버헤드

일반적인 지침: 테이블당 3-5개 인덱스, 거의 10개를 넘지 않음
</code></pre></div>

<p><strong>규칙 4: EXPLAIN을 사용하여 인덱스 사용 확인</strong></p>
<div class="highlight"><pre><span></span><code><span class="k">EXPLAIN</span><span class="w"> </span><span class="k">ANALYZE</span><span class="w"> </span><span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">department</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span><span class="p">;</span>

<span class="c1">-- 찾을 것:</span>
<span class="c1">-- &quot;Index Scan&quot; 또는 &quot;Index Only Scan&quot; → 인덱스가 사용됨</span>
<span class="c1">-- &quot;Seq Scan&quot; → 인덱스가 사용되지 않음 (또는 존재하지 않음)</span>
<span class="c1">-- &quot;Bitmap Index Scan&quot; → 다중 조건 쿼리에 비트맵 인덱스 사용됨</span>
</code></pre></div>

<p><strong>규칙 5: 인덱스 모니터링 및 유지보수</strong></p>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL: 인덱스 사용 통계 확인</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">schemaname</span><span class="p">,</span><span class="w"> </span><span class="n">tablename</span><span class="p">,</span><span class="w"> </span><span class="n">indexname</span><span class="p">,</span><span class="w"> </span><span class="n">idx_scan</span><span class="p">,</span><span class="w"> </span><span class="n">idx_tup_read</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">pg_stat_user_indexes</span>
<span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">idx_scan</span><span class="w"> </span><span class="k">ASC</span><span class="p">;</span>
<span class="c1">-- idx_scan = 0인 인덱스는 사용되지 않으며 삭제 가능</span>

<span class="c1">-- 인덱스 크기 확인</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">pg_size_pretty</span><span class="p">(</span><span class="n">pg_relation_size</span><span class="p">(</span><span class="s1">&#39;idx_emp_salary&#39;</span><span class="p">));</span>

<span class="c1">-- 단편화된 인덱스 재구축</span>
<span class="k">REINDEX</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_emp_salary</span><span class="p">;</span>
</code></pre></div>

<hr />
<h2 id="9">9. 주요 데이터베이스의 인덱스 구조<a class="header-link" href="#9" title="Permanent link">&para;</a></h2>
<h3 id="postgresql">PostgreSQL<a class="header-link" href="#postgresql" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">-- B+Tree (기본값)</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_btree</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">table</span><span class="p">(</span><span class="k">column</span><span class="p">);</span>

<span class="c1">-- 해시 (동등 검색만, v10부터 WAL 로깅됨)</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_hash</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="n">hash</span><span class="p">(</span><span class="k">column</span><span class="p">);</span>

<span class="c1">-- GiST (일반화된 검색 트리(Generalized Search Tree) -- R-Tree, 전문 검색 등)</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_gist</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="n">gist</span><span class="p">(</span><span class="n">geom_column</span><span class="p">);</span>

<span class="c1">-- GIN (일반화된 역 인덱스(Generalized Inverted Index) -- 배열, JSONB, 전문 검색)</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_gin</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="n">gin</span><span class="p">(</span><span class="n">jsonb_column</span><span class="p">);</span>

<span class="c1">-- BRIN (블록 범위 인덱스(Block Range Index) -- 대형 정렬 테이블)</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_brin</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="n">brin</span><span class="p">(</span><span class="n">timestamp_column</span><span class="p">);</span>

<span class="c1">-- SP-GiST (공간 분할 GiST(Space-Partitioned GiST) -- kd-트리, 기수 트리)</span>
<span class="k">CREATE</span><span class="w"> </span><span class="k">INDEX</span><span class="w"> </span><span class="n">idx_spgist</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="k">USING</span><span class="w"> </span><span class="n">spgist</span><span class="p">(</span><span class="n">point_column</span><span class="p">);</span>
</code></pre></div>

<h3 id="mysql-innodb">MySQL InnoDB<a class="header-link" href="#mysql-innodb" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>- 기본 키 = 클러스터드 B+Tree 인덱스 (데이터가 리프 노드에 저장됨)
- 보조 인덱스는 기본 키 값을 저장 (행 포인터가 아님)
- 이는 보조 인덱스 조회가 두 번의 B+Tree 탐색을 필요로 함을 의미:
  1. 보조 인덱스 → 기본 키 값
  2. 기본 인덱스 → 실제 행 데이터
</code></pre></div>

<h3 id="_8">요약 표<a class="header-link" href="#_8" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>인덱스 타입</th>
<th>최적 용도</th>
<th>한계</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+Tree</td>
<td>범용, 범위, ORDER BY</td>
<td>다차원에는 별로</td>
</tr>
<tr>
<td>해시</td>
<td>정확한 동등 조회</td>
<td>범위 지원 없음</td>
</tr>
<tr>
<td>비트맵</td>
<td>낮은 카디널리티, 분석</td>
<td>OLTP, 높은 카디널리티에 나쁨</td>
</tr>
<tr>
<td>GiST/R-Tree</td>
<td>공간, 기하 데이터</td>
<td>겹침이 검색을 느리게 할 수 있음</td>
</tr>
<tr>
<td>GIN</td>
<td>전문 검색, 배열, JSONB</td>
<td>큰 인덱스, 느린 업데이트</td>
</tr>
<tr>
<td>BRIN</td>
<td>매우 큰, 자연 정렬 테이블</td>
<td>낮은 정밀도</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="10">10. 연습문제<a class="header-link" href="#10" title="Permanent link">&para;</a></h2>
<h3 id="_9">개념적 질문<a class="header-link" href="#_9" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 1</strong>: 보조 인덱스는 밀집해야 하는 반면 주 인덱스는 희소할 수 있는 이유를 설명하라 (레코드당 하나의 엔트리 vs. 블록당 하나의 엔트리).</p>
<p><strong>연습문제 2</strong>: 테이블에 500,000개의 레코드가 각각 4 KB 블록에 저장되어 있다. 각 레코드는 200바이트다. 기본 키에 대한 B+Tree 인덱스는 8바이트 키와 8바이트 포인터를 사용한다. 각 인덱스 노드는 하나의 블록(4 KB)이다.</p>
<p>(a) 하나의 데이터 블록에 몇 개의 레코드가 맞는가?
(b) 테이블은 몇 개의 데이터 블록을 차지하는가?
(c) B+Tree의 최대 분기 계수(차수)는?
(d) B+Tree의 최대 높이는?
(e) 인덱스를 사용한 동등 검색 vs. 전체 테이블 스캔에 몇 번의 디스크 I/O가 필요한가?</p>
<p><strong>연습문제 3</strong>: B-Tree와 B+Tree를 비교하라. 거의 모든 데이터베이스 시스템이 B-Tree 대신 B+Tree를 사용하는 이유는?</p>
<p><strong>연습문제 4</strong>: 1천만 행을 가진 테이블에서 8개의 고유 값을 가진 <code>color</code> 컬럼에 비트맵 인덱스가 생성되었다.</p>
<p>(a) 비트맵 인덱스의 총 비압축 크기는?
(b) 행의 0.1%만 color = 'purple'이면, 런 길이 인코딩을 사용하여 purple 비트맵을 얼마나 압축할 수 있는가?
(c) 이를 동일한 컬럼의 B+Tree 인덱스와 비교하라.</p>
<h3 id="_10">실용적 질문<a class="header-link" href="#_10" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 5</strong>: 다음 쿼리 워크로드에 대한 인덱싱 전략을 설계하라:</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- Q1 (트래픽의 90%): 정확한 조회</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">email</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="p">;</span>

<span class="c1">-- Q2 (트래픽의 5%): 정렬을 포함한 범위 스캔</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">created_at</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">created_at</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">ORDER</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="n">created_at</span><span class="w"> </span><span class="k">DESC</span><span class="w"> </span><span class="k">LIMIT</span><span class="w"> </span><span class="mi">20</span><span class="p">;</span>

<span class="c1">-- Q3 (트래픽의 3%): 다중 컬럼 필터</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">country</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="n">age</span><span class="w"> </span><span class="k">BETWEEN</span><span class="w"> </span><span class="o">?</span><span class="w"> </span><span class="k">AND</span><span class="w"> </span><span class="o">?</span><span class="p">;</span>

<span class="c1">-- Q4 (트래픽의 2%): 텍스트 검색</span>
<span class="k">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">users</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">ILIKE</span><span class="w"> </span><span class="s1">&#39;%smith%&#39;</span><span class="p">;</span>
</code></pre></div>

<p>각 쿼리에 대해 명시하라:
(a) 어떤 인덱스(또는 인덱스들)를 생성할 것인가?
(b) 어떤 타입의 인덱스(B+Tree, 해시, GIN 등)?
(c) 복합, 커버링, 또는 부분 인덱스를 사용할 것인가?</p>
<p><strong>연습문제 6</strong>: 전역 깊이 2, 버킷 용량 2인 다음 확장 가능 해시 디렉토리가 주어졌다:</p>
<div class="highlight"><pre><span></span><code><span class="err">디렉토리</span><span class="o">:</span><span class="w">          </span><span class="err">버킷</span><span class="o">:</span>
<span class="mi">00</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">버킷</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">[</span><span class="n">h</span><span class="o">=</span><span class="mi">00110</span><span class="o">,</span><span class="w"> </span><span class="n">h</span><span class="o">=</span><span class="mi">00010</span><span class="o">]</span><span class="w">  </span><span class="o">(</span><span class="err">로컬</span><span class="w"> </span><span class="err">깊이</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>
<span class="mi">01</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">버킷</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">[</span><span class="n">h</span><span class="o">=</span><span class="mi">01100</span><span class="o">]</span><span class="w">            </span><span class="o">(</span><span class="err">로컬</span><span class="w"> </span><span class="err">깊이</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>
<span class="mi">10</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">버킷</span><span class="w"> </span><span class="n">C</span><span class="w"> </span><span class="o">[</span><span class="n">h</span><span class="o">=</span><span class="mi">10001</span><span class="o">,</span><span class="w"> </span><span class="n">h</span><span class="o">=</span><span class="mi">10110</span><span class="o">]</span><span class="w">  </span><span class="o">(</span><span class="err">로컬</span><span class="w"> </span><span class="err">깊이</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>
<span class="mi">11</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">버킷</span><span class="w"> </span><span class="n">D</span><span class="w"> </span><span class="o">[</span><span class="n">h</span><span class="o">=</span><span class="mi">11000</span><span class="o">]</span><span class="w">            </span><span class="o">(</span><span class="err">로컬</span><span class="w"> </span><span class="err">깊이</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>
</code></pre></div>

<p>해시 값 <code>h = 00001</code>을 가진 레코드를 삽입한 후 디렉토리와 버킷의 상태를 보여라.</p>
<p><strong>연습문제 7</strong>: 4개의 초기 버킷(N=4), 분할 포인터 s=0, 버킷 용량 2인 선형 해싱 방식을 고려하라. 해시 함수는 h₀(K) = K mod 4와 h₁(K) = K mod 8이다. 다음으로 시작:</p>
<div class="highlight"><pre><span></span><code>버킷 0: [8, 16]   (꽉 참)
버킷 1: [5]
버킷 2: [10]
버킷 3: [7, 15]   (꽉 참)
</code></pre></div>

<p>키 12, 9, 3을 (하나씩) 삽입한 후 상태를 보여라.</p>
<h3 id="_11">분석 질문<a class="header-link" href="#_11" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 8</strong>: 차수 <code>m</code>과 <code>n</code>개의 키를 가진 B+Tree의 높이가 최대 <code>⌈log_{⌈m/2⌉}(n)⌉</code>임을 증명하라.</p>
<p><strong>연습문제 9</strong>: 데이터베이스 관리자가 5천만 행을 가진 테이블에서 <code>SELECT COUNT(*) FROM orders WHERE status = 'pending'</code> 쿼리가 2초 걸린다는 것을 발견했다. <code>status</code> 컬럼은 5개의 고유 값을 가진다. 인덱싱 전략을 권장하고 개선을 추정하라.</p>
<p><strong>연습문제 10</strong>: <code>sensor_data</code> 테이블에 10억 개의 행, 컬럼 <code>(sensor_id, timestamp, value, location_x, location_y)</code>가 있고, 다음 쿼리 패턴이 있다:</p>
<ul>
<li>시간 범위 쿼리: <code>WHERE timestamp BETWEEN ? AND ?</code></li>
<li>센서별 쿼리: <code>WHERE sensor_id = ? AND timestamp BETWEEN ? AND ?</code></li>
<li>공간 쿼리: <code>WHERE location_x BETWEEN ? AND ? AND location_y BETWEEN ? AND ?</code></li>
<li>집계: <code>SELECT sensor_id, AVG(value) FROM ... GROUP BY sensor_id</code></li>
</ul>
<p>포괄적인 인덱싱 전략을 설계하라. B+Tree, BRIN, GiST, 복합 인덱스를 고려하라. 선택을 정당화하라.</p>
<hr />
<p><strong>이전</strong>: <a href="./08_Query_Processing.md">질의 처리와 최적화</a> | <strong>다음</strong>: <a href="./10_Transaction_Theory.md">트랜잭션 이론</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/08_Query_Processing.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">Lesson 08: 쿼리 처리(Query Processing)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/10_Transaction_Theory.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">10. 트랜잭션 이론</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}