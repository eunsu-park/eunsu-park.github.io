{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>10. 트랜잭션 이론 - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Database_Theory/">Database Theory</a>
    <span class="separator">/</span>
    <span class="current">10. 트랜잭션 이론</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>10. 트랜잭션 이론</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/09_Indexing.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">09. 인덱싱</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/11_Concurrency_Control.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">11. 동시성 제어</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#_1">학습 목표</a></li>
<li><a href="#1">1. 트랜잭션 개념</a><ul>
<li><a href="#_2">트랜잭션이란?</a></li>
<li><a href="#_3">트랜잭션이 중요한 이유</a></li>
</ul>
</li>
<li><a href="#2-acid">2. ACID 속성</a><ul>
<li><a href="#21-all-or-nothing">2.1 원자성 (All or Nothing)</a></li>
<li><a href="#22">2.2 일관성</a></li>
<li><a href="#23">2.3 격리</a></li>
<li><a href="#24">2.4 지속성</a></li>
<li><a href="#acid">ACID 요약</a></li>
</ul>
</li>
<li><a href="#3">3. 트랜잭션 상태</a><ul>
<li><a href="#_4">상태 설명</a></li>
<li><a href="#_5">중단 후: 재시작 또는 종료?</a></li>
</ul>
</li>
<li><a href="#4">4. 스케줄</a><ul>
<li><a href="#41">4.1 스케줄이란?</a></li>
<li><a href="#42">4.2 직렬 스케줄</a></li>
<li><a href="#43">4.3 직렬화 가능 스케줄</a></li>
</ul>
</li>
<li><a href="#5">5. 충돌 직렬화 가능성</a><ul>
<li><a href="#51">5.1 충돌하는 연산</a></li>
<li><a href="#52">5.2 충돌 동등</a></li>
<li><a href="#53">5.3 충돌 직렬화 가능</a></li>
<li><a href="#54">5.4 선행 그래프 (직렬화 그래프)</a></li>
<li><a href="#55">5.5 직렬 순서를 위한 위상 정렬</a></li>
</ul>
</li>
<li><a href="#6">6. 뷰 직렬화 가능성</a><ul>
<li><a href="#61">6.1 정의</a></li>
<li><a href="#62-vs">6.2 충돌 vs. 뷰 직렬화 가능성</a></li>
<li><a href="#63">6.3 블라인드 쓰기</a></li>
</ul>
</li>
<li><a href="#7">7. 복구 가능성</a><ul>
<li><a href="#71">7.1 복구 가능 스케줄</a></li>
<li><a href="#72">7.2 연쇄 없는 스케줄 (연쇄 롤백 피하기)</a></li>
<li><a href="#73">7.3 엄격한 스케줄</a></li>
<li><a href="#74">7.4 스케줄 속성 계층</a></li>
</ul>
</li>
<li><a href="#8">8. 격리 수준</a><ul>
<li><a href="#81">8.1 동기</a></li>
<li><a href="#82">8.2 이상 현상</a></li>
<li><a href="#83-sql">8.3 SQL 격리 수준</a></li>
<li><a href="#84-read-uncommitted">8.4 Read Uncommitted</a></li>
<li><a href="#85-read-committed">8.5 Read Committed</a></li>
<li><a href="#86-repeatable-read">8.6 Repeatable Read</a></li>
<li><a href="#87-serializable">8.7 Serializable</a></li>
</ul>
</li>
<li><a href="#9">9. 팬텀 문제</a><ul>
<li><a href="#91">9.1 팬텀이 특별한 이유</a></li>
<li><a href="#92">9.2 팬텀 문제 해결책</a></li>
</ul>
</li>
<li><a href="#10_1">10. 스냅샷 격리</a><ul>
<li><a href="#101">10.1 개념</a></li>
<li><a href="#102-first-committer-wins">10.2 First-Committer-Wins 규칙</a></li>
<li><a href="#103-vs">10.3 스냅샷 격리 vs. 직렬화 가능성</a></li>
<li><a href="#104-ssi">10.4 직렬화 가능 스냅샷 격리 (SSI)</a></li>
<li><a href="#105-si">10.5 실제 SI</a></li>
</ul>
</li>
<li><a href="#11">11. 직렬화 가능성 테스트: 완전 알고리즘</a><ul>
<li><a href="#_6">단계별 알고리즘</a></li>
<li><a href="#_7">상세 예</a></li>
</ul>
</li>
<li><a href="#12">12. 연습문제</a><ul>
<li><a href="#_8">개념적 질문</a></li>
<li><a href="#_9">직렬화 가능성 분석</a></li>
<li><a href="#_10">격리 수준</a></li>
<li><a href="#_11">고급 질문</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="10">10. 트랜잭션 이론<a class="header-link" href="#10" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./09_Indexing.md">인덱싱</a> | <strong>다음</strong>: <a href="./11_Concurrency_Control.md">동시성 제어</a></p>
<hr />
<h2 id="_1">학습 목표<a class="header-link" href="#_1" title="Permanent link">&para;</a></h2>
<ul>
<li>트랜잭션 개념과 ACID 속성을 깊이 이해</li>
<li>트랜잭션 상태 전이 추적</li>
<li>선행 그래프(Precedence Graph)를 사용한 충돌 직렬화 가능성(Conflict Serializability) 분석</li>
<li>복구 가능(Recoverable), 연쇄 없는(Cascadeless), 엄격한(Strict) 스케줄 구분</li>
<li>SQL 격리 수준과 허용하는 이상 현상 이해</li>
<li>스냅샷 격리(Snapshot Isolation)와 그 트레이드오프에 대해 추론</li>
</ul>
<hr />
<h2 id="1">1. 트랜잭션 개념<a class="header-link" href="#1" title="Permanent link">&para;</a></h2>
<h3 id="_2">트랜잭션이란?<a class="header-link" href="#_2" title="Permanent link">&para;</a></h3>
<p><strong>트랜잭션(Transaction)</strong>은 데이터베이스의 내용을 접근하고 수정할 수 있는 논리적 작업 단위다. <strong>분할 불가능한</strong> 단위로 취급되어야 하는 일련의 연산(읽기와 쓰기)으로 구성된다.</p>
<p><strong>실세계 비유</strong>: 계좌 A에서 계좌 B로 은행 이체:</p>
<div class="highlight"><pre><span></span><code>트랜잭션 T: A에서 B로 $100 이체

    read(A)           // A = 1000
    A = A - 100       // A = 900
    write(A)
    read(B)           // B = 500
    B = B + 100       // B = 600
    write(B)
    commit
</code></pre></div>

<p><code>write(A)</code>와 <code>write(B)</code> 사이에 시스템이 충돌하면, 돈이 사라질 것이다 -- A에서 $100이 차감되지만 B로 입금되지 않음. 트랜잭션이 이를 방지한다.</p>
<h3 id="_3">트랜잭션이 중요한 이유<a class="header-link" href="#_3" title="Permanent link">&para;</a></h3>
<p>트랜잭션은 두 가지 중요한 보장을 제공한다:</p>
<ol>
<li><strong>실패 원자성(Failure Atomicity)</strong>: 실행 중 실패가 발생하면, 모든 부분 효과가 취소됨</li>
<li><strong>격리(Isolation)</strong>: 동시 트랜잭션이 서로 간섭하지 않음</li>
</ol>
<p>트랜잭션이 없으면, 데이터베이스는 실패와 동시 접근이 있는 상황에서 <strong>데이터 일관성(Data Consistency)</strong>을 보장할 수 없다.</p>
<hr />
<h2 id="2-acid">2. ACID 속성<a class="header-link" href="#2-acid" title="Permanent link">&para;</a></h2>
<p>ACID 속성은 트랜잭션 처리 시스템이 제공해야 하는 네 가지 기본 보장이다.</p>
<h3 id="21-all-or-nothing">2.1 원자성 (All or Nothing)<a class="header-link" href="#21-all-or-nothing" title="Permanent link">&para;</a></h3>
<p>트랜잭션은 <strong>원자적(Atomic)</strong> 단위다: 모든 연산이 데이터베이스에 반영되거나, 아무것도 반영되지 않는다.</p>
<div class="highlight"><pre><span></span><code>트랜잭션 T: $100 이체
┌─────────────────────┐
│ read(A)             │
│ A = A - 100         │
│ write(A)            │
│ ────── crash ────── │ ← 여기서 충돌하면, write(A)를 취소
│ read(B)             │
│ B = B + 100         │
│ write(B)            │
│ commit              │
└─────────────────────┘

두 쓰기 모두 지속되거나, 둘 다 지속되지 않는다.
</code></pre></div>

<p><strong>구현</strong>: 복구 서브시스템은 <strong>로그(Logs)</strong>를 사용하여 불완전한 트랜잭션을 취소하고 커밋된 것을 재실행한다 (레슨 12에서 다룸).</p>
<h3 id="22">2.2 일관성<a class="header-link" href="#22" title="Permanent link">&para;</a></h3>
<p>트랜잭션은 데이터베이스를 하나의 <strong>일관된 상태(Consistent State)</strong>에서 다른 일관된 상태로 변환해야 한다. 일관성은 다음으로 정의된다:</p>
<ul>
<li><strong>무결성 제약(Integrity Constraints)</strong>: 기본 키, 외래 키, CHECK 제약, NOT NULL</li>
<li><strong>응용 수준 불변식(Application-Level Invariants)</strong>: 예: 은행의 총 금액은 일정해야 함</li>
</ul>
<div class="highlight"><pre><span></span><code>일관된 상태:
  계좌 A = 1000, 계좌 B = 500
  불변식: A + B = 1500

트랜잭션 중:
  write(A) 후: A = 900, B = 500  → A + B = 1400 ← 불일치
  write(B) 후: A = 900, B = 600  → A + B = 1500 ← 다시 일관됨

중간 불일치는 허용됨 (다른 트랜잭션에 보이지 않기 때문에,
격리(Isolation)에 의해 보장됨).
</code></pre></div>

<p><strong>책임</strong>: 일관성은 공유 책임이다:
- <strong>DBMS</strong>는 선언된 무결성 제약을 강제함
- <strong>응용 프로그램</strong> (프로그래머)은 트랜잭션 로직이 응용 수준 불변식을 보존하도록 보장해야 함</p>
<h3 id="23">2.3 격리<a class="header-link" href="#23" title="Permanent link">&para;</a></h3>
<p>각 트랜잭션은 시스템에서 <strong>유일한</strong> 트랜잭션인 것처럼 실행되어야 한다. 동시 트랜잭션은 서로의 중간 상태를 보지 않아야 한다.</p>
<div class="highlight"><pre><span></span><code>격리 없이:

T1: read(A)=1000, A=900, write(A)
                                    T2: read(A)=900 ← 부분 결과를 봄!
T1: read(B)=500, B=600, write(B)
T1: commit
                                    T2: read(B)=600
                                    T2: A + B = 900 + 600 = 1500 ← 우연히 정확

하지만 T2가 T1이 B를 쓰기 전에 B를 읽었다면:
                                    T2: read(B)=500
                                    T2: A + B = 900 + 500 = 1400 ← 잘못됨!
</code></pre></div>

<p><strong>구현</strong>: 동시성 제어 서브시스템은 잠금, 타임스탬프, 또는 MVCC를 사용한다 (레슨 11에서 다룸).</p>
<h3 id="24">2.4 지속성<a class="header-link" href="#24" title="Permanent link">&para;</a></h3>
<p>트랜잭션이 <strong>커밋</strong>되면, 시스템이 즉시 충돌하더라도 그 효과는 지속되어야 한다.</p>
<div class="highlight"><pre><span></span><code><span class="n">T</span><span class="o">:</span><span class="w"> </span><span class="n">write</span><span class="o">(</span><span class="n">A</span><span class="o">),</span><span class="w"> </span><span class="n">write</span><span class="o">(</span><span class="n">B</span><span class="o">),</span><span class="w"> </span><span class="n">commit</span>
<span class="w">                                    </span><span class="err">←</span><span class="w"> </span><span class="err">여기서</span><span class="w"> </span><span class="err">시스템</span><span class="w"> </span><span class="err">충돌</span>

<span class="err">복구</span><span class="w"> </span><span class="err">후</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">900</span><span class="o">,</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">600</span><span class="w">   </span><span class="err">←</span><span class="w"> </span><span class="err">커밋된</span><span class="w"> </span><span class="err">변경사항이</span><span class="w"> </span><span class="err">생존</span>
</code></pre></div>

<p><strong>구현</strong>: 복구 서브시스템은 <strong>선행 기록 로깅(Write-Ahead Logging, WAL)</strong>과 <strong>체크포인트(Checkpoints)</strong>를 사용하여 커밋된 데이터가 충돌에서 생존하도록 보장한다 (레슨 12에서 다룸).</p>
<h3 id="acid">ACID 요약<a class="header-link" href="#acid" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>속성</th>
<th>보장</th>
<th>구현처</th>
</tr>
</thead>
<tbody>
<tr>
<td>원자성</td>
<td>전부 또는 전무</td>
<td>복구 시스템 (취소)</td>
</tr>
<tr>
<td>일관성</td>
<td>유효한 상태에서 유효한 상태로</td>
<td>DBMS 제약 + 앱 로직</td>
</tr>
<tr>
<td>격리</td>
<td>동시 트랜잭션 간 간섭 없음</td>
<td>동시성 제어</td>
</tr>
<tr>
<td>지속성</td>
<td>커밋된 데이터가 충돌에서 생존</td>
<td>복구 시스템 (재실행) + WAL</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="3">3. 트랜잭션 상태<a class="header-link" href="#3" title="Permanent link">&para;</a></h2>
<p>트랜잭션은 생애주기 동안 명확하게 정의된 상태 집합을 거친다:</p>
<div class="highlight"><pre><span></span><code>                    ┌──────────┐
     begin          │          │
    ─────────────→  │  활성    │
                    │  (Active)│
                    └────┬─────┘
                         │
                    마지막 문장
                    실행됨
                         │
                         ▼
                ┌────────────────┐
                │   부분 커밋     │
                │   (Partially   │
                │    Committed)  │
                └───────┬────────┘
                   ┌────┴────┐
                   │         │
              출력이 디스크로  실패
              기록됨          감지
                   │         │
                   ▼         ▼
            ┌───────────┐  ┌────────┐
            │ 커밋됨    │  │ 실패   │
            │(Committed)│  │(Failed)│
            └───────────┘  └───┬────┘
                               │
                          롤백
                          완료
                               │
                               ▼
                          ┌─────────┐
                          │ 중단됨  │
                          │(Aborted)│
                          └─────────┘
</code></pre></div>

<h3 id="_4">상태 설명<a class="header-link" href="#_4" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>상태</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>활성(Active)</strong></td>
<td>초기 상태. 트랜잭션이 읽기/쓰기 연산을 실행하는 동안 이 상태에 머뭄.</td>
</tr>
<tr>
<td><strong>부분 커밋(Partially Committed)</strong></td>
<td>마지막 문장이 실행된 후. 트랜잭션의 효과는 여전히 휘발성 메모리(버퍼)에 있을 수 있음.</td>
</tr>
<tr>
<td><strong>커밋됨(Committed)</strong></td>
<td>모든 변경사항이 안정적 저장소에 성공적으로 기록된 후. 트랜잭션이 완료되고 그 효과는 영구적.</td>
</tr>
<tr>
<td><strong>실패(Failed)</strong></td>
<td>정상 실행을 계속할 수 없음을 발견한 후 (예: 제약 위반, 데드락, 시스템 오류).</td>
</tr>
<tr>
<td><strong>중단됨(Aborted)</strong></td>
<td>트랜잭션이 롤백되고 데이터베이스가 트랜잭션 시작 전 상태로 복원된 후.</td>
</tr>
</tbody>
</table>
<h3 id="_5">중단 후: 재시작 또는 종료?<a class="header-link" href="#_5" title="Permanent link">&para;</a></h3>
<p>트랜잭션이 중단되면, 시스템에는 두 가지 옵션이 있다:</p>
<ol>
<li><strong>재시작</strong>: 트랜잭션을 재실행 (데드락과 같은 일시적 실패에 적절)</li>
<li><strong>종료</strong>: 트랜잭션을 완전히 종료 (논리 오류, 제약 위반에 적절)</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="c1">-- 데드락 후 재시작될 수 있는 트랜잭션:</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">UPDATE</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="k">UPDATE</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="c1">-- 데드락 감지되면 → 중단 → 자동 재시작</span>

<span class="c1">-- 종료되어야 하는 트랜잭션:</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">users</span><span class="p">(</span><span class="n">email</span><span class="p">)</span><span class="w"> </span><span class="k">VALUES</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;duplicate@email.com&#39;</span><span class="p">);</span>
<span class="c1">-- 고유 제약 위반이면 → 중단 → 재시작하지 않음</span>
</code></pre></div>

<hr />
<h2 id="4">4. 스케줄<a class="header-link" href="#4" title="Permanent link">&para;</a></h2>
<h3 id="41">4.1 스케줄이란?<a class="header-link" href="#41" title="Permanent link">&para;</a></h3>
<p><strong>스케줄(Schedule)</strong> (또는 <strong>히스토리(History)</strong>)은 동시 트랜잭션의 명령어가 실행되는 시간순 순서를 나타낸다. 스케줄은 각 트랜잭션의 <strong>내부 순서</strong>를 보존해야 한다.</p>
<p><strong>표기법</strong>: 읽기와 쓰기 연산에 집중한다:
- <code>r_i(X)</code> = 트랜잭션 <code>T_i</code>가 데이터 항목 <code>X</code>를 읽음
- <code>w_i(X)</code> = 트랜잭션 <code>T_i</code>가 데이터 항목 <code>X</code>를 씀
- <code>c_i</code> = 트랜잭션 <code>T_i</code>가 커밋함
- <code>a_i</code> = 트랜잭션 <code>T_i</code>가 중단함</p>
<h3 id="42">4.2 직렬 스케줄<a class="header-link" href="#42" title="Permanent link">&para;</a></h3>
<p><strong>직렬 스케줄(Serial Schedule)</strong>은 트랜잭션을 인터리빙 없이 하나씩 실행한다:</p>
<div class="highlight"><pre><span></span><code>직렬 스케줄 S1 (T1 그 다음 T2):
┌─────────────────────────────────────┐
│ T1: r₁(A) w₁(A) r₁(B) w₁(B) c₁   │
│                                     │
│         T2: r₂(A) w₂(A) r₂(B) w₂(B) c₂ │
└─────────────────────────────────────┘

직렬 스케줄 S2 (T2 그 다음 T1):
┌─────────────────────────────────────┐
│ T2: r₂(A) w₂(A) r₂(B) w₂(B) c₂   │
│                                     │
│         T1: r₁(A) w₁(A) r₁(B) w₁(B) c₁ │
└─────────────────────────────────────┘
</code></pre></div>

<p><strong>특성:</strong>
- 항상 정확 (각 트랜잭션이 일관된 데이터베이스를 봄)
- 동시성 없음 -- 낮은 성능
- <code>n</code>개 트랜잭션에 대해 <code>n!</code>개의 가능한 직렬 스케줄</p>
<h3 id="43">4.3 직렬화 가능 스케줄<a class="header-link" href="#43" title="Permanent link">&para;</a></h3>
<p><strong>직렬화 가능 스케줄(Serializable Schedule)</strong>은 <strong>어떤</strong> 직렬 스케줄과 동일한 결과를 생성하는 동시 스케줄이다. 이는 정확성의 황금 표준이다.</p>
<div class="highlight"><pre><span></span><code>직렬화 가능 스케줄 S3 (인터리빙되지만, S1과 동등):
┌──────────────────────────────────────────────┐
│ T1: r₁(A) w₁(A)                             │
│                    T2: r₂(A) w₂(A)           │
│ T1:                           r₁(B) w₁(B) c₁│
│                    T2:                r₂(B) w₂(B) c₂│
└──────────────────────────────────────────────┘

이것이 직렬화 가능한지는 알 수 없음 — 이를 결정하기 위해 공식 테스트 필요.
</code></pre></div>

<hr />
<h2 id="5">5. 충돌 직렬화 가능성<a class="header-link" href="#5" title="Permanent link">&para;</a></h2>
<h3 id="51">5.1 충돌하는 연산<a class="header-link" href="#51" title="Permanent link">&para;</a></h3>
<p>두 연산이 <strong>충돌(Conflict)</strong>하는 경우:
1. <strong>다른</strong> 트랜잭션에 속함
2. <strong>동일한</strong> 데이터 항목에 접근
3. 적어도 하나는 <strong>쓰기</strong></p>
<div class="highlight"><pre><span></span><code>충돌 유형:

r₁(A) ... r₂(A)    → 충돌 없음 (둘 다 읽기)
r₁(A) ... w₂(A)    → 읽기-쓰기 충돌(Read-Write, RW)
w₁(A) ... r₂(A)    → 쓰기-읽기 충돌(Write-Read, WR)
w₁(A) ... w₂(A)    → 쓰기-쓰기 충돌(Write-Write, WW)
</code></pre></div>

<p><strong>충돌하지 않는</strong> 연산은 결과를 변경하지 않고 스케줄에서 <strong>교환</strong> 가능하다.</p>
<h3 id="52">5.2 충돌 동등<a class="header-link" href="#52" title="Permanent link">&para;</a></h3>
<p>두 스케줄이 <strong>충돌 동등(Conflict Equivalent)</strong>한 경우, <strong>인접한 충돌하지 않는</strong> 연산의 교환 시리즈에 의해 하나를 다른 것으로 변환할 수 있다.</p>
<h3 id="53">5.3 충돌 직렬화 가능<a class="header-link" href="#53" title="Permanent link">&para;</a></h3>
<p>스케줄이 어떤 직렬 스케줄과 충돌 동등하면 <strong>충돌 직렬화 가능(Conflict Serializable)</strong>하다.</p>
<p><strong>예: 이 스케줄이 충돌 직렬화 가능한가?</strong></p>
<div class="highlight"><pre><span></span><code>스케줄 S: r₁(A) r₂(A) w₁(A) w₂(A) r₁(B) r₂(B) w₁(B) w₂(B)

단계별 분석:
1. r₁(A)와 r₂(A): 충돌 없음 → 교환 가능
2. r₂(A)와 w₁(A): A에 대한 RW 충돌 → T₂가 T₁이 쓰기 전에 읽음 (T₂ → T₁? 아니요, A에 대해 T₁이 T₂ 뒤에 와야 함)
3. w₁(A)와 w₂(A): A에 대한 WW 충돌 → T₁이 T₂보다 먼저 씀 → T₁ before T₂
4. r₁(B)와 r₂(B): 충돌 없음
5. r₂(B)와 w₁(B): B에 대한 RW 충돌 → T₂가 T₁이 쓰기 전에 읽음 → T₂ before T₁
6. w₁(B)와 w₂(B): B에 대한 WW 충돌 → T₁ before T₂

A에 대해: 충돌 (2)에서, r₂(A) before w₁(A)는 T₂ → T₁을 의미
           충돌 (3)에서, w₁(A) before w₂(A)는 T₁ → T₂를 의미
B에 대해: 충돌 (5)에서, r₂(B) before w₁(B)는 T₂ → T₁을 의미
           충돌 (6)에서, w₁(B) before w₂(B)는 T₁ → T₂를 의미

T₁ → T₂와 T₂ → T₁ 둘 다 있음. 이것은 사이클이므로, 스케줄은
충돌 직렬화 가능하지 않음.
</code></pre></div>

<h3 id="54">5.4 선행 그래프 (직렬화 그래프)<a class="header-link" href="#54" title="Permanent link">&para;</a></h3>
<p><strong>선행 그래프(Precedence Graph)</strong>는 충돌 직렬화 가능성을 테스트하는 효율적인 알고리즘을 제공한다.</p>
<p><strong>구성:</strong>
1. 각 트랜잭션 <code>T_i</code>에 대한 노드 생성
2. <code>T_i</code>의 연산이 먼저 오는 충돌하는 연산 쌍이 존재하면 방향 간선 <code>T_i → T_j</code> 추가</p>
<p><strong>정리</strong>: 스케줄은 선행 그래프가 <strong>비순환적</strong>(사이클 없음)인 <strong>경우에만</strong> 충돌 직렬화 가능하다.</p>
<p><strong>예 1: 직렬화 가능 스케줄</strong></p>
<div class="highlight"><pre><span></span><code><span class="err">스케줄</span><span class="o">:</span><span class="w"> </span><span class="n">r₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">r₂</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">r₁</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">r₂</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">B</span><span class="o">)</span>

<span class="err">충돌</span><span class="o">:</span>
<span class="o">-</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">r₂</span><span class="o">(</span><span class="n">A</span><span class="o">):</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w">  </span><span class="o">(</span><span class="n">A에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">WR</span><span class="o">)</span>
<span class="o">-</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">A</span><span class="o">):</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w">  </span><span class="o">(</span><span class="n">A에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">WW</span><span class="o">)</span>
<span class="o">-</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">r₂</span><span class="o">(</span><span class="n">B</span><span class="o">):</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w">  </span><span class="o">(</span><span class="n">B에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">WR</span><span class="o">)</span>
<span class="o">-</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">B</span><span class="o">):</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w">  </span><span class="o">(</span><span class="n">B에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">WW</span><span class="o">)</span>

<span class="err">선행</span><span class="w"> </span><span class="err">그래프</span><span class="o">:</span>
<span class="w">    </span><span class="n">T₁</span><span class="w"> </span><span class="err">──→</span><span class="w"> </span><span class="n">T₂</span>

<span class="err">사이클</span><span class="w"> </span><span class="err">없음</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">충돌</span><span class="w"> </span><span class="err">직렬화</span><span class="w"> </span><span class="err">가능</span><span class="w"> </span><span class="o">(</span><span class="err">직렬</span><span class="w"> </span><span class="err">순서와</span><span class="w"> </span><span class="err">동등</span><span class="o">:</span><span class="w"> </span><span class="n">T₁</span><span class="o">,</span><span class="w"> </span><span class="n">T₂</span><span class="o">)</span>
</code></pre></div>

<p><strong>예 2: 비직렬화 가능 스케줄</strong></p>
<div class="highlight"><pre><span></span><code><span class="err">스케줄</span><span class="o">:</span><span class="w"> </span><span class="n">r₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">r₂</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">B</span><span class="o">)</span>

<span class="err">충돌</span><span class="o">:</span>
<span class="o">-</span><span class="w"> </span><span class="n">r₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">A</span><span class="o">):</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w">  </span><span class="o">(</span><span class="n">A에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">RW</span><span class="o">)</span>
<span class="o">-</span><span class="w"> </span><span class="n">r₂</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">B</span><span class="o">):</span><span class="w"> </span><span class="n">T₂</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₁</span><span class="w">  </span><span class="o">(</span><span class="n">B에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">RW</span><span class="o">)</span>

<span class="err">선행</span><span class="w"> </span><span class="err">그래프</span><span class="o">:</span>
<span class="w">    </span><span class="n">T₁</span><span class="w"> </span><span class="err">──→</span><span class="w"> </span><span class="n">T₂</span>
<span class="w">     </span><span class="err">↑</span><span class="w">       </span><span class="err">│</span>
<span class="w">     </span><span class="err">└───────┘</span>

<span class="err">사이클</span><span class="w"> </span><span class="err">감지</span><span class="o">:</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₁</span>
<span class="err">→</span><span class="w"> </span><span class="err">충돌</span><span class="w"> </span><span class="err">직렬화</span><span class="w"> </span><span class="err">가능하지</span><span class="w"> </span><span class="err">않음</span>
</code></pre></div>

<p><strong>예 3: 세 트랜잭션</strong></p>
<div class="highlight"><pre><span></span><code><span class="err">스케줄</span><span class="o">:</span><span class="w"> </span><span class="n">r₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">r₂</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">r₃</span><span class="o">(</span><span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="n">w₃</span><span class="o">(</span><span class="n">A</span><span class="o">)</span>

<span class="err">충돌</span><span class="o">:</span>
<span class="o">-</span><span class="w"> </span><span class="n">r₂</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">B</span><span class="o">):</span><span class="w"> </span><span class="n">T₂</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₁</span><span class="w">  </span><span class="o">(</span><span class="n">B에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">RW</span><span class="o">)</span>
<span class="o">-</span><span class="w"> </span><span class="n">r₃</span><span class="o">(</span><span class="n">C</span><span class="o">)</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">C</span><span class="o">):</span><span class="w"> </span><span class="n">T₃</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w">  </span><span class="o">(</span><span class="n">C에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">RW</span><span class="o">)</span>
<span class="o">-</span><span class="w"> </span><span class="n">r₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">w₃</span><span class="o">(</span><span class="n">A</span><span class="o">):</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₃</span><span class="w">  </span><span class="o">(</span><span class="n">A에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">RW</span><span class="o">)</span>

<span class="err">선행</span><span class="w"> </span><span class="err">그래프</span><span class="o">:</span>
<span class="w">    </span><span class="n">T₁</span><span class="w"> </span><span class="err">──→</span><span class="w"> </span><span class="n">T₃</span>
<span class="w">     </span><span class="err">↑</span><span class="w">       </span><span class="err">│</span>
<span class="w">     </span><span class="err">│</span><span class="w">       </span><span class="err">↓</span>
<span class="w">     </span><span class="err">└──</span><span class="w"> </span><span class="n">T₂</span><span class="w"> </span><span class="err">←┘</span>

<span class="err">사이클</span><span class="o">:</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₃</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₁</span>
<span class="err">→</span><span class="w"> </span><span class="err">충돌</span><span class="w"> </span><span class="err">직렬화</span><span class="w"> </span><span class="err">가능하지</span><span class="w"> </span><span class="err">않음</span>
</code></pre></div>

<h3 id="55">5.5 직렬 순서를 위한 위상 정렬<a class="header-link" href="#55" title="Permanent link">&para;</a></h3>
<p>선행 그래프가 비순환적이면, <strong>위상 정렬(Topological Sort)</strong>이 유효한 직렬 순서를 제공한다:</p>
<div class="highlight"><pre><span></span><code>선행 그래프:
    T₁ ──→ T₃
    T₂ ──→ T₃
    T₂ ──→ T₁

위상 정렬: T₂, T₁, T₃
이것이 동등한 직렬 스케줄.
</code></pre></div>

<p><strong>알고리즘:</strong></p>
<div class="highlight"><pre><span></span><code><span class="nv">TOPOLOGICAL</span><span class="o">-</span><span class="nv">SORT</span><span class="ss">(</span><span class="nv">graph</span><span class="ss">)</span>:
<span class="w">    </span><span class="nb">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[]
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="nv">graph</span><span class="w"> </span><span class="nv">has</span><span class="w"> </span><span class="nv">nodes</span>:
<span class="w">        </span><span class="nv">find</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">node</span><span class="w"> </span><span class="nv">with</span><span class="w"> </span><span class="nv">no</span><span class="w"> </span><span class="nv">incoming</span><span class="w"> </span><span class="nv">edges</span>
<span class="w">        </span><span class="nv">add</span><span class="w"> </span><span class="nv">it</span><span class="w"> </span><span class="nv">to</span><span class="w"> </span><span class="nb">result</span>
<span class="w">        </span><span class="nv">remove</span><span class="w"> </span><span class="nv">it</span><span class="w"> </span><span class="nv">and</span><span class="w"> </span><span class="nv">its</span><span class="w"> </span><span class="nv">outgoing</span><span class="w"> </span><span class="nv">edges</span><span class="w"> </span><span class="nv">from</span><span class="w"> </span><span class="nv">graph</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="nv">all</span><span class="w"> </span><span class="nv">nodes</span><span class="w"> </span><span class="nv">removed</span>:
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nb">result</span><span class="w">  </span><span class="o">//</span><span class="w"> </span>유효한<span class="w"> </span>직렬<span class="w"> </span>순서
<span class="w">    </span><span class="k">else</span>:
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nv">CYCLE</span><span class="w">   </span><span class="o">//</span><span class="w"> </span>직렬화<span class="w"> </span>가능하지<span class="w"> </span>않음
</code></pre></div>

<hr />
<h2 id="6">6. 뷰 직렬화 가능성<a class="header-link" href="#6" title="Permanent link">&para;</a></h2>
<h3 id="61">6.1 정의<a class="header-link" href="#61" title="Permanent link">&para;</a></h3>
<p>두 스케줄 <code>S</code>와 <code>S'</code>이 <strong>뷰 동등(View Equivalent)</strong>한 경우:</p>
<ol>
<li><strong>초기 읽기</strong>: <code>S</code>에서 <code>T_i</code>가 <code>X</code>의 초기 값을 읽으면, <code>S'</code>에서도 <code>T_i</code>가 <code>X</code>의 초기 값을 읽음</li>
<li><strong>업데이트된 읽기</strong>: <code>S</code>에서 <code>T_i</code>가 <code>T_j</code>가 쓴 <code>X</code>의 값을 읽으면, <code>S'</code>에서도 <code>T_i</code>가 <code>T_j</code>가 쓴 <code>X</code>의 값을 읽음</li>
<li><strong>최종 쓰기</strong>: <code>S</code>에서 <code>T_i</code>가 <code>X</code>의 최종 쓰기를 수행하면, <code>S'</code>에서도 <code>T_i</code>가 <code>X</code>의 최종 쓰기를 수행</li>
</ol>
<p>스케줄이 어떤 직렬 스케줄과 뷰 동등하면 <strong>뷰 직렬화 가능(View Serializable)</strong>하다.</p>
<h3 id="62-vs">6.2 충돌 vs. 뷰 직렬화 가능성<a class="header-link" href="#62-vs" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>뷰 직렬화 가능 ⊇ 충돌 직렬화 가능

┌─────────────────────────────────────────┐
│        모든 스케줄                       │
│  ┌───────────────────────────────────┐  │
│  │    뷰 직렬화 가능                 │  │
│  │  ┌─────────────────────────────┐  │  │
│  │  │  충돌 직렬화 가능           │  │  │
│  │  │  ┌───────────────────────┐  │  │  │
│  │  │  │   직렬 스케줄          │  │  │  │
│  │  │  └───────────────────────┘  │  │  │
│  │  └─────────────────────────────┘  │  │
│  └───────────────────────────────────┘  │
└─────────────────────────────────────────┘
</code></pre></div>

<p><strong>주요 사실:</strong>
- 모든 충돌 직렬화 가능 스케줄은 뷰 직렬화 가능
- 그 역은 참이 아님 (일부 뷰 직렬화 가능 스케줄은 충돌 직렬화 가능하지 않음)
- 뷰 직렬화 가능성 테스트는 <strong>NP-완전</strong>
- 충돌 직렬화 가능성 테스트는 <strong>다항식</strong> (선행 그래프에서 사이클 감지)
- 실제로 DBMS는 계산 가능성 때문에 충돌 직렬화 가능성(또는 더 약한 보장)을 사용</p>
<h3 id="63">6.3 블라인드 쓰기<a class="header-link" href="#63" title="Permanent link">&para;</a></h3>
<p>뷰 직렬화 가능하지만 충돌 직렬화 가능하지 <strong>않은</strong> 스케줄은 <strong>블라인드 쓰기(Blind Writes)</strong> -- 동일한 항목의 읽기가 선행하지 않는 쓰기를 포함한다.</p>
<div class="highlight"><pre><span></span><code><span class="err">스케줄</span><span class="o">:</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">B</span><span class="o">)</span>

<span class="err">선행</span><span class="w"> </span><span class="err">그래프</span><span class="o">:</span>
<span class="o">-</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">A</span><span class="o">):</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w">  </span><span class="o">(</span><span class="n">A에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">WW</span><span class="o">)</span>
<span class="o">-</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="n">before</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">B</span><span class="o">):</span><span class="w"> </span><span class="n">T₂</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₁</span><span class="w">  </span><span class="o">(</span><span class="n">B에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">WW</span><span class="o">)</span>
<span class="err">사이클</span><span class="o">!</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">충돌</span><span class="w"> </span><span class="err">직렬화</span><span class="w"> </span><span class="err">가능하지</span><span class="w"> </span><span class="err">않음</span>

<span class="err">하지만</span><span class="w"> </span><span class="err">이것은</span><span class="w"> </span><span class="err">뷰</span><span class="w"> </span><span class="err">직렬화</span><span class="w"> </span><span class="err">가능</span><span class="o">:</span>
<span class="o">-</span><span class="w"> </span><span class="err">직렬</span><span class="w"> </span><span class="err">순서</span><span class="w"> </span><span class="n">T₁</span><span class="o">,</span><span class="w"> </span><span class="n">T₂와</span><span class="w"> </span><span class="err">뷰</span><span class="w"> </span><span class="err">동등</span><span class="o">:</span>
<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="err">걱정할</span><span class="w"> </span><span class="err">읽기</span><span class="w"> </span><span class="err">없음</span><span class="w"> </span><span class="o">(</span><span class="err">초기</span><span class="w"> </span><span class="err">읽기나</span><span class="w"> </span><span class="err">업데이트된</span><span class="w"> </span><span class="err">읽기</span><span class="o">)</span>
<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">A의</span><span class="w"> </span><span class="err">최종</span><span class="w"> </span><span class="err">쓰기</span><span class="o">:</span><span class="w"> </span><span class="err">두</span><span class="w"> </span><span class="err">스케줄에서</span><span class="w"> </span><span class="n">T₂</span><span class="w"> </span><span class="err">✓</span>
<span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">B의</span><span class="w"> </span><span class="err">최종</span><span class="w"> </span><span class="err">쓰기</span><span class="o">:</span><span class="w"> </span><span class="err">두</span><span class="w"> </span><span class="err">스케줄에서</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="err">✓</span>
</code></pre></div>

<hr />
<h2 id="7">7. 복구 가능성<a class="header-link" href="#7" title="Permanent link">&para;</a></h2>
<p>직렬화 가능성만으로는 정확성에 충분하지 않다. 트랜잭션 실패로부터 적절한 <strong>복구(Recovery)</strong>를 허용하는 스케줄도 필요하다.</p>
<h3 id="71">7.1 복구 가능 스케줄<a class="header-link" href="#71" title="Permanent link">&para;</a></h3>
<p>스케줄이 <strong>복구 가능(Recoverable)</strong>한 경우, 모든 트랜잭션 쌍 <code>T_i</code>와 <code>T_j</code>에 대해, <code>T_j</code>가 <code>T_i</code>가 쓴 값을 읽으면, <code>T_i</code>가 <code>T_j</code><strong>보다 먼저</strong> 커밋한다.</p>
<div class="highlight"><pre><span></span><code>복구 가능:
    T₁: w₁(A) ................... c₁
    T₂:        r₂(A) ................. c₂
    (T₁이 T₂가 커밋하기 전에 커밋 ✓)

복구 불가능:
    T₁: w₁(A) ........................ a₁ (중단!)
    T₂:        r₂(A) ..... c₂
    (T₂가 T₁의 데이터에 기반하여 커밋했지만 T₁이 나중에 중단!)
    문제: T₂가 잘못된 데이터를 사용했지만 이미 커밋됨 — T₂를 취소할 수 없음
</code></pre></div>

<p><strong>중요한 이유</strong>: 스케줄이 복구 가능하지 않으면, 연쇄 중단이 이미 커밋된 트랜잭션을 취소해야 할 수 있어, 지속성을 위반한다.</p>
<h3 id="72">7.2 연쇄 없는 스케줄 (연쇄 롤백 피하기)<a class="header-link" href="#72" title="Permanent link">&para;</a></h3>
<p><strong>연쇄 롤백(Cascading Rollback)</strong>은 한 트랜잭션의 중단이 커밋되지 않은 데이터를 읽은 다른 트랜잭션의 중단을 강제할 때 발생한다.</p>
<div class="highlight"><pre><span></span><code>연쇄 롤백:
    T₁: w₁(A) ................... a₁ (중단!)
    T₂:        r₂(A) w₂(B) ........  ← 중단해야 함 (T₁의 데이터 읽음)
    T₃:                    r₃(B) ...  ← 중단해야 함 (T₂의 데이터 읽음)

T₁의 중단이 T₂로, 그 다음 T₃로 연쇄됨.
</code></pre></div>

<p>스케줄이 <strong>연쇄 없는(Cascadeless)</strong> (또는 <strong>연쇄 롤백 피하기(Avoids Cascading Rollbacks, ACR)</strong>)인 경우, 모든 트랜잭션이 <strong>커밋된</strong> 트랜잭션이 쓴 값만 읽는다.</p>
<div class="highlight"><pre><span></span><code>연쇄 없는:
    T₁: w₁(A) ............ c₁
    T₂:                         r₂(A) w₂(B)    ← T₁이 커밋한 후에만 읽음
</code></pre></div>

<p><strong>관계</strong>: 모든 연쇄 없는 스케줄은 복구 가능하지만, 그 역은 아니다.</p>
<h3 id="73">7.3 엄격한 스케줄<a class="header-link" href="#73" title="Permanent link">&para;</a></h3>
<p>스케줄이 <strong>엄격(Strict)</strong>한 경우, 어떤 트랜잭션도 커밋되지 않은 트랜잭션이 쓴 값을 읽거나 덮어쓰지 않는다.</p>
<div class="highlight"><pre><span></span><code><span class="err">엄격</span><span class="o">:</span>
<span class="w">    </span><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="o">............</span><span class="w"> </span><span class="n">c₁</span>
<span class="w">    </span><span class="n">T₂</span><span class="o">:</span><span class="w">                         </span><span class="n">r₂</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="n">OR</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="n">T₁이</span><span class="w"> </span><span class="err">커밋한</span><span class="w"> </span><span class="err">후에만</span>

<span class="err">연쇄</span><span class="w"> </span><span class="err">없는이지만</span><span class="w"> </span><span class="err">엄격하지</span><span class="w"> </span><span class="err">않음</span><span class="o">:</span>
<span class="w">    </span><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="o">............</span><span class="w"> </span><span class="n">c₁</span>
<span class="w">    </span><span class="n">T₂</span><span class="o">:</span><span class="w">        </span><span class="n">w₂</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w">                             </span><span class="err">←</span><span class="w"> </span><span class="n">T₁의</span><span class="w"> </span><span class="err">커밋되지</span><span class="w"> </span><span class="err">않은</span><span class="w"> </span><span class="err">데이터를</span><span class="w"> </span><span class="err">덮어씀</span>
<span class="w">    </span><span class="o">(</span><span class="err">커밋되지</span><span class="w"> </span><span class="err">않은</span><span class="w"> </span><span class="err">데이터의</span><span class="w"> </span><span class="err">읽기</span><span class="w"> </span><span class="err">없으므로</span><span class="w"> </span><span class="err">연쇄</span><span class="w"> </span><span class="err">없음</span><span class="o">)</span>
<span class="w">    </span><span class="o">(</span><span class="err">하지만</span><span class="w"> </span><span class="n">T₂가</span><span class="w"> </span><span class="n">T₁이</span><span class="w"> </span><span class="err">커밋하기</span><span class="w"> </span><span class="err">전에</span><span class="w"> </span><span class="err">덮어쓰므로</span><span class="w"> </span><span class="err">엄격하지</span><span class="w"> </span><span class="err">않음</span><span class="o">)</span>
</code></pre></div>

<p><strong>엄격성이 중요한 이유</strong>: 엄격한 스케줄은 쓰기의 "이전 이미지"를 다른 트랜잭션의 중간 쓰기에 대해 걱정하지 않고 취소에 사용할 수 있어 복구를 단순화한다.</p>
<h3 id="74">7.4 스케줄 속성 계층<a class="header-link" href="#74" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>엄격 ⊂ 연쇄 없는 ⊂ 복구 가능 ⊂ 모든 스케줄

┌──────────────────────────────────────────┐
│           모든 스케줄                     │
│  ┌────────────────────────────────────┐  │
│  │       복구 가능                    │  │
│  │  ┌──────────────────────────────┐  │  │
│  │  │     연쇄 없는 (ACR)          │  │  │
│  │  │  ┌────────────────────────┐  │  │  │
│  │  │  │      엄격               │  │  │  │
│  │  │  │  ┌──────────────────┐  │  │  │  │
│  │  │  │  │    직렬           │  │  │  │  │
│  │  │  │  └──────────────────┘  │  │  │  │
│  │  │  └────────────────────────┘  │  │  │
│  │  └──────────────────────────────┘  │  │
│  └────────────────────────────────────┘  │
└──────────────────────────────────────────┘
</code></pre></div>

<table>
<thead>
<tr>
<th>속성</th>
<th>조건</th>
<th>복구 이점</th>
</tr>
</thead>
<tbody>
<tr>
<td>복구 가능</td>
<td>T_j가 T_i로부터 읽으면 → T_i가 T_j보다 먼저 커밋</td>
<td>항상 커밋되지 않은 트랜잭션 취소 가능</td>
</tr>
<tr>
<td>연쇄 없는</td>
<td>커밋된 데이터만 읽음</td>
<td>연쇄 중단 없음</td>
</tr>
<tr>
<td>엄격</td>
<td>커밋되지 않은 데이터의 읽기/덮어쓰기 없음</td>
<td>단순한 취소 (이전 이미지 복원)</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="8">8. 격리 수준<a class="header-link" href="#8" title="Permanent link">&para;</a></h2>
<h3 id="81">8.1 동기<a class="header-link" href="#81" title="Permanent link">&para;</a></h3>
<p>완전한 직렬화 가능성은 최대 정확성을 제공하지만 상당한 성능 비용이 든다 (더 많은 잠금, 더 적은 동시성). 많은 응용 프로그램은 더 나은 처리량을 위해 더 약한 격리를 허용할 수 있다.</p>
<p><strong>SQL 표준</strong>은 네 가지 격리 수준을 정의하며, 각각 특정 이상 현상을 허용한다:</p>
<h3 id="82">8.2 이상 현상<a class="header-link" href="#82" title="Permanent link">&para;</a></h3>
<p><strong>더티 읽기(Dirty Read)</strong>: 커밋되지 않은 트랜잭션이 쓴 데이터를 읽음.</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">w₁</span><span class="o">(</span><span class="n">A</span><span class="o">=</span><span class="mi">100</span><span class="o">)</span><span class="w"> </span><span class="o">............</span><span class="w"> </span><span class="n">a₁</span><span class="w"> </span><span class="o">(</span><span class="err">중단</span><span class="o">,</span><span class="w"> </span><span class="n">A가</span><span class="w"> </span><span class="mi">50</span><span class="err">으로</span><span class="w"> </span><span class="err">되돌림</span><span class="o">)</span>
<span class="n">T₂</span><span class="o">:</span><span class="w">            </span><span class="n">r₂</span><span class="o">(</span><span class="n">A</span><span class="o">)=</span><span class="mi">100</span><span class="w">       </span><span class="err">←</span><span class="w"> </span><span class="n">T₂가</span><span class="w"> </span><span class="s2">&quot;더티&quot;</span><span class="w"> </span><span class="err">값</span><span class="w"> </span><span class="mi">100</span><span class="err">을</span><span class="w"> </span><span class="err">읽음</span>
</code></pre></div>

<p><strong>반복 불가능 읽기(Non-Repeatable Read, Fuzzy Read)</strong>: 동일한 항목을 두 번 읽으면 다른 값이 나옴.</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w">                   </span><span class="n">r₁</span><span class="o">(</span><span class="n">A</span><span class="o">)=</span><span class="mi">50</span><span class="w"> </span><span class="o">..............</span><span class="w"> </span><span class="n">r₁</span><span class="o">(</span><span class="n">A</span><span class="o">)=</span><span class="mi">100</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="err">다름</span><span class="o">!</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">w₂</span><span class="o">(</span><span class="n">A</span><span class="o">=</span><span class="mi">100</span><span class="o">)</span><span class="w"> </span><span class="n">c₂</span>
</code></pre></div>

<p><strong>팬텀 읽기(Phantom Read)</strong>: 쿼리를 두 번 실행하면 다른 행 집합이 반환됨.</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">emp</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">dept</span><span class="o">=</span><span class="s1">&#39;Eng&#39;</span><span class="w">  </span><span class="err">→</span><span class="w">  </span><span class="o">{</span><span class="n">Alice</span><span class="o">,</span><span class="w"> </span><span class="n">Bob</span><span class="o">}</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">INSERT</span><span class="w"> </span><span class="n">INTO</span><span class="w"> </span><span class="n">emp</span><span class="w"> </span><span class="n">VALUES</span><span class="o">(</span><span class="s1">&#39;Carol&#39;</span><span class="o">,</span><span class="s1">&#39;Eng&#39;</span><span class="o">)</span><span class="w">  </span><span class="n">c₂</span>
<span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">emp</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">dept</span><span class="o">=</span><span class="s1">&#39;Eng&#39;</span><span class="w">  </span><span class="err">→</span><span class="w">  </span><span class="o">{</span><span class="n">Alice</span><span class="o">,</span><span class="w"> </span><span class="n">Bob</span><span class="o">,</span><span class="w"> </span><span class="n">Carol</span><span class="o">}</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="err">팬텀</span><span class="o">!</span>
</code></pre></div>

<h3 id="83-sql">8.3 SQL 격리 수준<a class="header-link" href="#83-sql" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>격리 수준</th>
<th>더티 읽기</th>
<th>반복 불가능 읽기</th>
<th>팬텀 읽기</th>
</tr>
</thead>
<tbody>
<tr>
<td>Read Uncommitted</td>
<td>가능</td>
<td>가능</td>
<td>가능</td>
</tr>
<tr>
<td>Read Committed</td>
<td>불가능</td>
<td>가능</td>
<td>가능</td>
</tr>
<tr>
<td>Repeatable Read</td>
<td>불가능</td>
<td>불가능</td>
<td>가능</td>
</tr>
<tr>
<td>Serializable</td>
<td>불가능</td>
<td>불가능</td>
<td>불가능</td>
</tr>
</tbody>
</table>
<div class="highlight"><pre><span></span><code><span class="c1">-- SQL에서 격리 수준 설정:</span>
<span class="k">SET</span><span class="w"> </span><span class="k">TRANSACTION</span><span class="w"> </span><span class="k">ISOLATION</span><span class="w"> </span><span class="k">LEVEL</span><span class="w"> </span><span class="k">READ</span><span class="w"> </span><span class="k">COMMITTED</span><span class="p">;</span>
<span class="c1">-- 또는</span>
<span class="k">BEGIN</span><span class="w"> </span><span class="k">TRANSACTION</span><span class="w"> </span><span class="k">ISOLATION</span><span class="w"> </span><span class="k">LEVEL</span><span class="w"> </span><span class="k">SERIALIZABLE</span><span class="p">;</span>
</code></pre></div>

<h3 id="84-read-uncommitted">8.4 Read Uncommitted<a class="header-link" href="#84-read-uncommitted" title="Permanent link">&para;</a></h3>
<p>가장 약한 수준. 트랜잭션은 다른 트랜잭션의 커밋되지 않은 ("더티") 데이터를 읽을 수 있다.</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">BEGIN</span><span class="w"> </span><span class="o">(</span><span class="n">READ</span><span class="w"> </span><span class="n">UNCOMMITTED</span><span class="o">)</span>
<span class="w">    </span><span class="n">SELECT</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="mi">1000</span>
<span class="w">    </span><span class="o">--</span><span class="w"> </span><span class="err">그</span><span class="w"> </span><span class="err">사이</span><span class="w"> </span><span class="n">T₂가</span><span class="w"> </span><span class="err">업데이트하지만</span><span class="w"> </span><span class="err">커밋하지</span><span class="w"> </span><span class="err">않음</span><span class="o">:</span>
<span class="w">    </span><span class="o">--</span><span class="w"> </span><span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">UPDATE</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="n">SET</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span>
<span class="w">    </span><span class="n">SELECT</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="mi">500</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="err">더티</span><span class="w"> </span><span class="err">읽기</span><span class="o">!</span>
<span class="w">    </span><span class="o">--</span><span class="w"> </span><span class="n">T₂가</span><span class="w"> </span><span class="err">롤백하면</span><span class="o">,</span><span class="w"> </span><span class="mi">500</span><span class="err">은</span><span class="w"> </span><span class="err">절대</span><span class="w"> </span><span class="err">실제</span><span class="w"> </span><span class="err">값이</span><span class="w"> </span><span class="err">아니었음</span>
</code></pre></div>

<p><strong>사용 사례</strong>: 근사 집계, 정확한 값이 중요하지 않은 모니터링 대시보드.</p>
<p><strong>구현</strong>: 읽기 잠금을 획득하지 않음. 쓰기는 여전히 쓰기 잠금을 획득.</p>
<h3 id="85-read-committed">8.5 Read Committed<a class="header-link" href="#85-read-committed" title="Permanent link">&para;</a></h3>
<p>각 읽기는 <strong>읽기 시점에</strong> 커밋된 데이터만 본다. 더티 읽기는 없지만, 다른 트랜잭션이 읽기 사이에 커밋하면 동일한 쿼리가 다른 결과를 반환할 수 있다.</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">BEGIN</span><span class="w"> </span><span class="o">(</span><span class="n">READ</span><span class="w"> </span><span class="n">COMMITTED</span><span class="o">)</span>
<span class="w">    </span><span class="n">SELECT</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="mi">1000</span>
<span class="w">    </span><span class="o">--</span><span class="w"> </span><span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">UPDATE</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="n">SET</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">500</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w"> </span><span class="n">COMMIT</span><span class="o">;</span>
<span class="w">    </span><span class="n">SELECT</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="o">;</span><span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="mi">500</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="err">반복</span><span class="w"> </span><span class="err">불가능</span><span class="w"> </span><span class="err">읽기</span>
<span class="w">    </span><span class="o">--</span><span class="w"> </span><span class="err">두</span><span class="w"> </span><span class="err">읽기</span><span class="w"> </span><span class="err">모두</span><span class="w"> </span><span class="err">커밋된</span><span class="w"> </span><span class="err">데이터를</span><span class="w"> </span><span class="err">보았지만</span><span class="o">,</span><span class="w"> </span><span class="err">다른</span><span class="w"> </span><span class="err">값</span>
</code></pre></div>

<p><strong>기본값</strong>: PostgreSQL, Oracle, SQL Server</p>
<p><strong>구현</strong>: 읽기 잠금이 획득되고 즉시 해제됨 (커밋까지 유지되지 않음). 쓰기 잠금은 커밋까지 유지됨.</p>
<h3 id="86-repeatable-read">8.6 Repeatable Read<a class="header-link" href="#86-repeatable-read" title="Permanent link">&para;</a></h3>
<p>트랜잭션이 데이터 항목을 읽으면, 트랜잭션 전체에서 해당 항목에 대해 항상 동일한 값을 본다 (더티 읽기, 반복 불가능 읽기 없음). 하지만, <strong>팬텀 행</strong>은 여전히 나타날 수 있다.</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">BEGIN</span><span class="w"> </span><span class="o">(</span><span class="n">REPEATABLE</span><span class="w"> </span><span class="n">READ</span><span class="o">)</span>
<span class="w">    </span><span class="n">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">emp</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">dept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span><span class="o">;</span><span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="o">{</span><span class="n">Alice</span><span class="o">,</span><span class="w"> </span><span class="n">Bob</span><span class="o">}</span>
<span class="w">    </span><span class="o">--</span><span class="w"> </span><span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">INSERT</span><span class="w"> </span><span class="n">INTO</span><span class="w"> </span><span class="n">emp</span><span class="w"> </span><span class="n">VALUES</span><span class="o">(</span><span class="s1">&#39;Carol&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span><span class="o">);</span><span class="w"> </span><span class="n">COMMIT</span><span class="o">;</span>
<span class="w">    </span><span class="n">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">emp</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">dept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span><span class="o">;</span><span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="o">{</span><span class="n">Alice</span><span class="o">,</span><span class="w"> </span><span class="n">Bob</span><span class="o">,</span><span class="w"> </span><span class="n">Carol</span><span class="o">}</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="err">팬텀</span><span class="o">!</span>
<span class="w">    </span><span class="o">--</span><span class="w"> </span><span class="n">Alice와</span><span class="w"> </span><span class="n">Bob의</span><span class="w"> </span><span class="err">행</span><span class="w"> </span><span class="err">재읽기는</span><span class="w"> </span><span class="err">동일한</span><span class="w"> </span><span class="err">데이터</span><span class="w"> </span><span class="err">제공</span><span class="w"> </span><span class="o">(</span><span class="err">퍼지</span><span class="w"> </span><span class="err">읽기</span><span class="w"> </span><span class="err">없음</span><span class="o">)</span>
<span class="w">    </span><span class="o">--</span><span class="w"> </span><span class="err">하지만</span><span class="w"> </span><span class="err">새</span><span class="w"> </span><span class="err">행</span><span class="o">(</span><span class="n">Carol</span><span class="o">)</span><span class="err">이</span><span class="w"> </span><span class="err">나타남</span><span class="w"> </span><span class="err">—</span><span class="w"> </span><span class="err">이것이</span><span class="w"> </span><span class="err">팬텀</span>
</code></pre></div>

<p><strong>구현</strong>: 읽기 잠금이 커밋까지 유지됨. 하지만 술어와 일치하는 새 행은 잠기지 않음 (술어 잠금 없음).</p>
<h3 id="87-serializable">8.7 Serializable<a class="header-link" href="#87-serializable" title="Permanent link">&para;</a></h3>
<p>가장 강한 격리 수준. 트랜잭션이 직렬인 것처럼 실행됨. 어떤 종류의 이상 현상도 없음.</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">BEGIN</span><span class="w"> </span><span class="o">(</span><span class="n">SERIALIZABLE</span><span class="o">)</span>
<span class="w">    </span><span class="n">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">emp</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">dept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span><span class="o">;</span><span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="o">{</span><span class="n">Alice</span><span class="o">,</span><span class="w"> </span><span class="n">Bob</span><span class="o">}</span>
<span class="w">    </span><span class="o">--</span><span class="w"> </span><span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">INSERT</span><span class="w"> </span><span class="n">INTO</span><span class="w"> </span><span class="n">emp</span><span class="w"> </span><span class="n">VALUES</span><span class="o">(</span><span class="s1">&#39;Carol&#39;</span><span class="o">,</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span><span class="o">);</span>
<span class="w">    </span><span class="o">--</span><span class="w"> </span><span class="n">T₂가</span><span class="w"> </span><span class="n">BLOCKED됨</span><span class="w"> </span><span class="o">(</span><span class="err">또는</span><span class="w"> </span><span class="n">SSI에서</span><span class="w"> </span><span class="n">T₁이</span><span class="w"> </span><span class="err">커밋</span><span class="w"> </span><span class="err">시</span><span class="w"> </span><span class="err">실패</span><span class="o">)</span><span class="w"> </span><span class="n">T₁이</span><span class="w"> </span><span class="err">완료될</span><span class="w"> </span><span class="err">때까지</span>
<span class="w">    </span><span class="n">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">emp</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">dept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span><span class="o">;</span><span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="o">{</span><span class="n">Alice</span><span class="o">,</span><span class="w"> </span><span class="n">Bob</span><span class="o">}</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="err">동일한</span><span class="w"> </span><span class="err">결과</span>
<span class="n">COMMIT</span><span class="o">;</span>
</code></pre></div>

<p><strong>구현 옵션:</strong>
- <strong>술어 잠금을 포함한 엄격한 2PL</strong> (또는 인덱스 범위 잠금): 전통적 접근
- <strong>직렬화 가능 스냅샷 격리(Serializable Snapshot Isolation, SSI)</strong>: PostgreSQL의 접근 (낙관적, MVCC 기반)</p>
<hr />
<h2 id="9">9. 팬텀 문제<a class="header-link" href="#9" title="Permanent link">&para;</a></h2>
<h3 id="91">9.1 팬텀이 특별한 이유<a class="header-link" href="#91" title="Permanent link">&para;</a></h3>
<p>팬텀 문제는 더티 읽기나 반복 불가능 읽기와 근본적으로 다르다:</p>
<ul>
<li>더티/반복 불가능 읽기는 <strong>기존 행</strong>이 수정되는 것을 포함</li>
<li>팬텀은 <strong>새 행</strong>이 삽입되는 것 (또는 기존 행이 술어와 일치하도록 수정됨)을 포함</li>
</ul>
<p>표준 행 수준 잠금은 팬텀을 방지할 수 없다 왜냐하면 <strong>아직 존재하지 않는 행을 잠글 수 없기 때문</strong>.</p>
<h3 id="92">9.2 팬텀 문제 해결책<a class="header-link" href="#92" title="Permanent link">&para;</a></h3>
<p><strong>술어 잠금(Predicate Locking):</strong>
개별 행이 아닌 쿼리 술어에 기반하여 잠금.</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">SELECT</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">FROM</span><span class="w"> </span><span class="n">emp</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">dept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span>
<span class="w">    </span><span class="err">→</span><span class="w"> </span><span class="err">잠금</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;다른 트랜잭션이 dept = &#39;Eng&#39;인</span>
<span class="s2">             행을 삽입/업데이트/삭제할 수 없음&quot;</span>
</code></pre></div>

<p>술어 잠금은 일반적으로 비싸다 (술어가 임의로 복잡할 수 있음).</p>
<p><strong>인덱스 범위 잠금(Index-Range Locking, Next-Key Locking):</strong>
실용적 근사. 갭을 포함한 인덱스 엔트리 범위를 잠금.</p>
<div class="highlight"><pre><span></span><code><span class="n">dept에</span><span class="w"> </span><span class="n">대한</span><span class="w"> </span><span class="n">B</span><span class="o">+</span><span class="n">Tree</span><span class="w"> </span><span class="nl">인덱스</span><span class="p">:</span>
<span class="p">...</span><span class="w"> </span><span class="err">──→</span><span class="w"> </span><span class="o">[</span><span class="n">Acctg</span><span class="o">]</span><span class="w"> </span><span class="err">──→</span><span class="w"> </span><span class="o">[</span><span class="n">Eng</span><span class="o">]</span><span class="w"> </span><span class="err">──→</span><span class="w"> </span><span class="o">[</span><span class="n">HR</span><span class="o">]</span><span class="w"> </span><span class="err">──→</span><span class="w"> </span><span class="o">[</span><span class="n">Sales</span><span class="o">]</span><span class="w"> </span><span class="err">──→</span><span class="w"> </span><span class="p">...</span>

<span class="s1">&#39;Eng&#39;</span><span class="n">에서</span><span class="w"> </span><span class="s1">&#39;HR&#39;</span><span class="n">까지</span><span class="w"> </span><span class="n">범위</span><span class="w"> </span><span class="n">잠금</span><span class="w"> </span><span class="p">(</span><span class="n">배타적</span><span class="p">).</span>
<span class="n">이것이</span><span class="w"> </span><span class="n">dept</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;Eng&#39;</span><span class="n">인</span><span class="w"> </span><span class="n">모든</span><span class="w"> </span><span class="n">INSERT를</span><span class="w"> </span><span class="n">방지</span><span class="p">.</span>

<span class="n">MySQL</span><span class="w"> </span><span class="n">InnoDB는</span><span class="w"> </span><span class="n">이를</span><span class="w"> </span><span class="ss">&quot;넥스트 키 잠금&quot;</span><span class="n">이라고</span><span class="w"> </span><span class="n">부름</span><span class="p">.</span>
</code></pre></div>

<p><strong>직렬화 가능 스냅샷 격리(SSI):</strong>
PostgreSQL의 접근. 커밋 시점에 의존성 추적을 사용하여 직렬화 이상 현상을 감지 (술어 잠금 불필요).</p>
<hr />
<h2 id="10_1">10. 스냅샷 격리<a class="header-link" href="#10_1" title="Permanent link">&para;</a></h2>
<h3 id="101">10.1 개념<a class="header-link" href="#101" title="Permanent link">&para;</a></h3>
<p><strong>스냅샷 격리(Snapshot Isolation, SI)</strong>는 각 트랜잭션에 트랜잭션 시작 시점의 데이터베이스의 일관된 <strong>스냅샷</strong>을 제공하는 다중 버전 동시성 제어 방식이다.</p>
<div class="highlight"><pre><span></span><code>시간 100의 데이터베이스 상태: A=50, B=100

T₁이 시간 100에 시작: 스냅샷 {A=50, B=100} 봄
T₂가 시간 100에 시작: 스냅샷 {A=50, B=100} 봄

T₁: write(A=75)
T₂: read(A) → 50  (스냅샷에서 읽음, T₁의 쓰기 아님)
T₁: commit at time 105

T₂: read(A) → 50  (여전히 50! T₂의 스냅샷은 시간 100부터)
T₂: commit at time 110
</code></pre></div>

<h3 id="102-first-committer-wins">10.2 First-Committer-Wins 규칙<a class="header-link" href="#102-first-committer-wins" title="Permanent link">&para;</a></h3>
<p>SI는 <strong>first-committer-wins(FCW)</strong> 규칙을 사용하여 손실된 업데이트를 방지한다:</p>
<div class="highlight"><pre><span></span><code>T₁이 시간 100에 시작, T₂가 시간 100에 시작

T₁: write(A=75) ............ commit → 성공 (A를 먼저 커밋)
T₂: write(A=80) ......................... commit → 중단!
     (T₂가 A를 쓰려 했지만, A가 이미 T₁에 의해 수정되고
      T₂의 스냅샷 이후 커밋됨)
</code></pre></div>

<h3 id="103-vs">10.3 스냅샷 격리 vs. 직렬화 가능성<a class="header-link" href="#103-vs" title="Permanent link">&para;</a></h3>
<p>SI는 더티 읽기, 반복 불가능 읽기, 팬텀 읽기를 방지한다. 하지만 SI는 <strong>직렬화 가능하지 않음</strong>! <strong>쓰기 스큐(Write Skew)</strong> 이상 현상을 허용한다.</p>
<p><strong>쓰기 스큐 예:</strong></p>
<div class="highlight"><pre><span></span><code><span class="err">제약</span><span class="o">:</span><span class="w"> </span><span class="err">최소</span><span class="w"> </span><span class="err">한</span><span class="w"> </span><span class="err">명의</span><span class="w"> </span><span class="err">의사가</span><span class="w"> </span><span class="err">당직이어야</span><span class="w"> </span><span class="err">함</span><span class="o">.</span>
<span class="err">초기</span><span class="o">:</span><span class="w"> </span><span class="n">doctor_A</span><span class="o">.</span><span class="na">on_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span><span class="o">,</span><span class="w"> </span><span class="n">doctor_B</span><span class="o">.</span><span class="na">on_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">true</span>

<span class="n">T₁</span><span class="w"> </span><span class="o">(</span><span class="err">스냅샷</span><span class="o">):</span><span class="w"> </span><span class="n">A</span><span class="o">.</span><span class="na">on_call</span><span class="o">=</span><span class="n">T</span><span class="o">,</span><span class="w"> </span><span class="n">B</span><span class="o">.</span><span class="na">on_call</span><span class="o">=</span><span class="n">T</span><span class="w"> </span><span class="err">봄</span>
<span class="n">T₂</span><span class="w"> </span><span class="o">(</span><span class="err">스냅샷</span><span class="o">):</span><span class="w"> </span><span class="n">A</span><span class="o">.</span><span class="na">on_call</span><span class="o">=</span><span class="n">T</span><span class="o">,</span><span class="w"> </span><span class="n">B</span><span class="o">.</span><span class="na">on_call</span><span class="o">=</span><span class="n">T</span><span class="w"> </span><span class="err">봄</span>

<span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;다른 의사(B)가 당직이므로, 나는 당직에서 벗어날 수 있음&quot;</span>
<span class="w">    </span><span class="n">UPDATE</span><span class="w"> </span><span class="n">doctors</span><span class="w"> </span><span class="n">SET</span><span class="w"> </span><span class="n">on_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;A&#39;</span><span class="o">;</span>

<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="s2">&quot;다른 의사(A)가 당직이므로, 나는 당직에서 벗어날 수 있음&quot;</span>
<span class="w">    </span><span class="n">UPDATE</span><span class="w"> </span><span class="n">doctors</span><span class="w"> </span><span class="n">SET</span><span class="w"> </span><span class="n">on_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="w"> </span><span class="n">WHERE</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;B&#39;</span><span class="o">;</span>

<span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">commit</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="err">성공</span><span class="w"> </span><span class="o">(</span><span class="n">T₂가</span><span class="w"> </span><span class="err">아직</span><span class="w"> </span><span class="err">커밋하지</span><span class="w"> </span><span class="err">않음</span><span class="o">,</span><span class="w"> </span><span class="n">A에</span><span class="w"> </span><span class="err">대한</span><span class="w"> </span><span class="n">WW</span><span class="w"> </span><span class="err">충돌</span><span class="w"> </span><span class="err">없음</span><span class="o">)</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">commit</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="err">성공</span><span class="w"> </span><span class="o">(</span><span class="n">T₁이</span><span class="w"> </span><span class="n">A를</span><span class="w"> </span><span class="err">수정</span><span class="o">,</span><span class="w"> </span><span class="n">T₂가</span><span class="w"> </span><span class="n">B를</span><span class="w"> </span><span class="err">수정</span><span class="o">,</span><span class="w"> </span><span class="n">WW</span><span class="w"> </span><span class="err">충돌</span><span class="w"> </span><span class="err">없음</span><span class="o">!)</span>

<span class="err">결과</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="o">.</span><span class="na">on_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span><span class="o">,</span><span class="w"> </span><span class="n">B</span><span class="o">.</span><span class="na">on_call</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="kc">false</span>
<span class="err">→</span><span class="w"> </span><span class="err">아무도</span><span class="w"> </span><span class="err">당직이</span><span class="w"> </span><span class="err">아님</span><span class="o">!</span><span class="w"> </span><span class="err">제약</span><span class="w"> </span><span class="err">위반</span><span class="o">!</span>
</code></pre></div>

<p>직렬화 가능 실행에서는, 한 트랜잭션이 다른 것의 업데이트를 보고 제약을 유지할 것이다. SI는 T₁과 T₂가 스냅샷에서 읽고 <strong>다른</strong> 항목에 쓰기 때문에 이를 허용한다.</p>
<h3 id="104-ssi">10.4 직렬화 가능 스냅샷 격리 (SSI)<a class="header-link" href="#104-ssi" title="Permanent link">&para;</a></h3>
<p><strong>SSI</strong>는 SI를 확장하여 쓰기 스큐와 같은 이상 현상을 감지하고 방지한다. 동시 트랜잭션 간 <strong>읽기-쓰기 의존성</strong>을 추적하고 위험한 구조를 형성하는 트랜잭션을 중단한다.</p>
<div class="highlight"><pre><span></span><code>SSI가 &quot;위험한 구조&quot; 감지:
  T₁ →(rw)→ T₂ →(rw)→ T₃
  (여기서 T₁이 T₂가 덮어쓰는 것을 읽고,
   T₂가 T₃가 덮어쓰는 것을 읽음)

이 패턴이 감지되면, 트랜잭션 중 하나가 중단됨.
</code></pre></div>

<p><strong>PostgreSQL</strong>: 버전 9.1부터 <code>SERIALIZABLE</code> 격리 수준에 SSI를 사용한다. 낙관적 접근이다 -- 트랜잭션이 차단 없이 진행하고, 충돌은 커밋 시점에 감지된다.</p>
<h3 id="105-si">10.5 실제 SI<a class="header-link" href="#105-si" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>데이터베이스</th>
<th>기본 수준</th>
<th>SI 지원</th>
<th>진정한 직렬화 가능</th>
</tr>
</thead>
<tbody>
<tr>
<td>PostgreSQL</td>
<td>Read Committed</td>
<td>예 (REPEATABLE READ)</td>
<td>예 (SSI)</td>
</tr>
<tr>
<td>Oracle</td>
<td>Read Committed</td>
<td>예 (SERIALIZABLE*)</td>
<td>아니오 (SI만, 진정한 직렬 아님)</td>
</tr>
<tr>
<td>MySQL InnoDB</td>
<td>Repeatable Read</td>
<td>부분 (갭 잠금)</td>
<td>예 (잠금 기반)</td>
</tr>
<tr>
<td>SQL Server</td>
<td>Read Committed</td>
<td>예 (SNAPSHOT)</td>
<td>예 (잠금 기반)</td>
</tr>
<tr>
<td>CockroachDB</td>
<td>Serializable</td>
<td>예</td>
<td>예 (SSI)</td>
</tr>
</tbody>
</table>
<p>*참고: Oracle의 "SERIALIZABLE" 수준은 실제로 스냅샷 격리를 제공하며, 진정한 직렬화 가능성이 아니다.</p>
<hr />
<h2 id="11">11. 직렬화 가능성 테스트: 완전 알고리즘<a class="header-link" href="#11" title="Permanent link">&para;</a></h2>
<h3 id="_6">단계별 알고리즘<a class="header-link" href="#_6" title="Permanent link">&para;</a></h3>
<p>트랜잭션 <code>T₁, T₂, ..., Tₙ</code>을 가진 스케줄 <code>S</code>가 주어졌을 때:</p>
<div class="highlight"><pre><span></span><code>SERIALIZABILITY-TEST(S):

1. 노드 T₁, ..., Tₙ으로 선행 그래프 G 초기화

2. 두 개 이상의 트랜잭션이 접근하는 각 데이터 항목 X에 대해:
   a. X에 대한 각 연산 쌍을 시간 순서로:
      <span class="k">-</span> r_i(X)가 w_j(X)를 선행하고 i ≠ j이면:
          간선 T_i → T_j 추가  (RW 충돌)
      <span class="k">-</span> w_i(X)가 r_j(X)를 선행하고 i ≠ j이면:
          간선 T_i → T_j 추가  (WR 충돌)
      <span class="k">-</span> w_i(X)가 w_j(X)를 선행하고 i ≠ j이면:
          간선 T_i → T_j 추가  (WW 충돌)

3. G에 사이클이 있는지 확인:
   <span class="k">-</span> DFS 또는 위상 정렬 사용
   <span class="k">-</span> 사이클 없으면: S는 충돌 직렬화 가능
     위상 정렬이 동등한 직렬 순서를 제공
   <span class="k">-</span> 사이클 존재하면: S는 충돌 직렬화 가능하지 않음
</code></pre></div>

<h3 id="_7">상세 예<a class="header-link" href="#_7" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>스케줄 S:
  r₁(A) r₂(A) w₁(A) r₃(A) w₃(A) w₂(B) r₃(B) w₁(B) c₁ c₂ c₃

단계 1: 노드: T₁, T₂, T₃

단계 2: 데이터 항목별 충돌 분석:

  데이터 항목 A:
    r₁(A) &lt; w₁(A): 동일 트랜잭션, 건너뜀
    r₂(A) &lt; w₁(A): RW 충돌 → T₂ → T₁
    r₂(A) &lt; w₃(A): RW 충돌 → T₂ → T₃
    w₁(A) &lt; r₃(A): WR 충돌 → T₁ → T₃
    w₁(A) &lt; w₃(A): WW 충돌 → T₁ → T₃

  데이터 항목 B:
    w₂(B) &lt; r₃(B): WR 충돌 → T₂ → T₃
    w₂(B) &lt; w₁(B): WW 충돌 → T₂ → T₁
    r₃(B) &lt; w₁(B): RW 충돌 → T₃ → T₁

단계 3: 선행 그래프:

    T₂ → T₁ (A에서: RW 및 B에서: WW)
    T₂ → T₃ (A에서: RW 및 B에서: WR)
    T₁ → T₃ (A에서: WR, WW)
    T₃ → T₁ (B에서: RW)

         T₂
        ↙  ↘
      T₁ ⇄ T₃

    사이클: T₁ → T₃ → T₁

    결과: 충돌 직렬화 가능하지 않음
</code></pre></div>

<hr />
<h2 id="12">12. 연습문제<a class="header-link" href="#12" title="Permanent link">&para;</a></h2>
<h3 id="_8">개념적 질문<a class="header-link" href="#_8" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 1</strong>: 각 ACID 속성에 대해, 그 속성이 위반되면 어떤 일이 일어날 수 있는지 구체적인 예를 들어라. 계좌와 이체가 있는 은행 시나리오를 사용하라.</p>
<p><strong>연습문제 2</strong>: 트랜잭션 상태 다이어그램을 그리고 다음 시나리오에 대한 상태를 추적하라:
- 트랜잭션 T가 시작하고 데이터 항목 A를 읽음
- T가 새 값을 계산하고 A를 씀
- 시스템이 제약 위반을 감지함
- T가 롤백됨</p>
<p><strong>연습문제 3</strong>: 모든 연쇄 없는 스케줄이 복구 가능한 이유를 설명하되, 모든 복구 가능 스케줄이 연쇄 없는 것은 아닌 이유를 설명하라. 각 경우에 대한 예 스케줄을 제공하라.</p>
<h3 id="_9">직렬화 가능성 분석<a class="header-link" href="#_9" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 4</strong>: 다음 각 스케줄이 충돌 직렬화 가능한지 결정하라. 그렇다면, 동등한 직렬 순서를 제시하라. 아니라면, 선행 그래프의 사이클을 식별하라.</p>
<p>(a) <code>r₁(A) r₂(B) w₁(B) w₂(A) c₁ c₂</code></p>
<p>(b) <code>r₁(A) w₂(A) w₁(A) r₂(A) c₁ c₂</code></p>
<p>(c) <code>r₃(B) r₁(A) w₃(A) r₂(B) w₂(A) w₁(B) c₁ c₂ c₃</code></p>
<p>(d) <code>r₁(A) r₂(B) r₃(C) w₁(B) w₂(C) w₃(A) c₁ c₂ c₃</code></p>
<p><strong>연습문제 5</strong>: 다음 스케줄이 주어졌을 때:</p>
<div class="highlight"><pre><span></span><code>r₁(X) r₂(X) w₂(X) r₁(Y) w₁(Y) w₂(Y) c₁ c₂
</code></pre></div>

<p>(a) 선행 그래프를 그려라.
(b) 충돌 직렬화 가능한가?
(c) 복구 가능한가?
(d) 연쇄 없는가?
(e) 엄격한가?</p>
<p><strong>연습문제 6</strong>: 다음과 같은 스케줄을 구성하라:
(a) 뷰 직렬화 가능하지만 충돌 직렬화 가능하지 않음
(b) 복구 가능하지만 연쇄 없지 않음
(c) 연쇄 없지만 엄격하지 않음</p>
<h3 id="_10">격리 수준<a class="header-link" href="#_10" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 7</strong>: 각 시나리오에 대해, 이상 현상을 방지하는 데 필요한 최소 격리 수준을 식별하라:</p>
<p>(a) 커밋되지 않은 수량을 읽는 것이 과다 판매로 이어질 수 있는 재고 시스템.</p>
<p>(b) 계좌 잔액을 합산하는 보고서, 합계가 일관되어야 함 (부분 적용 이체 없음).</p>
<p>(c) 부서당 직원을 세는 쿼리, 카운트가 동일한 트랜잭션 내에서 변경되지 않아야 함.</p>
<p><strong>연습문제 8</strong>: 스냅샷 격리 하에서 <strong>쓰기 스큐</strong> 이상 현상을 보여주는 구체적인 SQL 시나리오를 작성하라. 진정한 직렬화 가능 격리 하에서 이것이 발생할 수 없는 이유를 설명하라.</p>
<p><strong>연습문제 9</strong>: 세 트랜잭션이 있는 스케줄을 고려하라:</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">A를</span><span class="w"> </span><span class="err">읽고</span><span class="w"> </span><span class="err">씀</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">A를</span><span class="w"> </span><span class="err">읽고</span><span class="w"> </span><span class="n">B를</span><span class="w"> </span><span class="err">씀</span>
<span class="n">T₃</span><span class="o">:</span><span class="w"> </span><span class="n">B를</span><span class="w"> </span><span class="err">읽고</span><span class="w"> </span><span class="n">C를</span><span class="w"> </span><span class="err">씀</span>
</code></pre></div>

<p>(a) Read Committed에서 실행하면, 어떤 이상 현상이 발생할 수 있는가?
(b) Repeatable Read에서는?
(c) Serializable에서는?</p>
<h3 id="_11">고급 질문<a class="header-link" href="#_11" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 10</strong>: <code>n</code>개 트랜잭션에 대한 가능한 직렬 스케줄의 수가 <code>n!</code>임을 증명하라. 그런 다음 직렬화 가능성을 검증하기 위해 모든 <code>n!</code> 직렬 스케줄을 테스트하는 것이 비실용적인 이유를 설명하고, 선행 그래프가 어떻게 다항식 시간 대안을 제공하는지 설명하라.</p>
<p><strong>연습문제 11</strong>: Oracle의 <code>SERIALIZABLE</code> 격리 수준은 실제로 스냅샷 격리를 제공하며, 진정한 직렬화 가능성이 아니다. 이 차이를 드러낼 테스트 케이스(특정 테이블 스키마와 두 개의 동시 트랜잭션)를 설계하라. Oracle이 제공할 결과 vs. 진정으로 직렬화 가능한 시스템이 제공할 결과는?</p>
<p><strong>연습문제 12</strong>: 시스템이 Repeatable Read 격리를 사용한다. 트랜잭션 T₁이 동일한 트랜잭션 내에서 <code>SELECT COUNT(*) FROM orders WHERE status = 'pending'</code>을 두 번 실행한다. 두 select 사이에, 트랜잭션 T₂가 status = 'pending'인 새 주문을 삽입하고 커밋한다.</p>
<p>(a) T₁이 두 COUNT 쿼리에 대해 어떤 값을 보는가?
(b) 이것이 팬텀 읽기인가?
(c) Serializable 격리가 이를 어떻게 다르게 처리하는가?
(d) 갭 잠금이 있는 MySQL InnoDB의 "Repeatable Read"가 SQL 표준 정의와 비교하여 이를 어떻게 처리하는가?</p>
<hr />
<p><strong>이전</strong>: <a href="./09_Indexing.md">인덱싱</a> | <strong>다음</strong>: <a href="./11_Concurrency_Control.md">동시성 제어</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/09_Indexing.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">09. 인덱싱</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/11_Concurrency_Control.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">11. 동시성 제어</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}