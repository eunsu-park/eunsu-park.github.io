{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>11. 동시성 제어 - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Database_Theory/">Database Theory</a>
    <span class="separator">/</span>
    <span class="current">11. 동시성 제어</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>11. 동시성 제어</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/10_Transaction_Theory.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">10. 트랜잭션 이론</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/12_Recovery_Systems.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">12. 복구 시스템</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#_1">학습 목표</a></li>
<li><a href="#1">1. 동시성 제어의 필요성</a><ul>
<li><a href="#_2">동시성을 허용하는 이유?</a></li>
<li><a href="#_3">제어 없이 무엇이 잘못될 수 있는가?</a></li>
<li><a href="#_4">동시성 제어의 역할</a></li>
</ul>
</li>
<li><a href="#2">2. 잠금 기반 프로토콜</a><ul>
<li><a href="#21">2.1 잠금 유형</a></li>
<li><a href="#22">2.2 잠금 프로토콜 예</a></li>
<li><a href="#23">2.3 기본 잠금의 문제</a></li>
</ul>
</li>
<li><a href="#3-2-2pl">3. 2단계 잠금 (2PL)</a><ul>
<li><a href="#31-2">3.1 기본 2단계 잠금</a></li>
<li><a href="#32-2pl">3.2 예: 2PL 실행</a></li>
<li><a href="#33-2pl">3.3 문제: 기본 2PL 하의 연쇄 롤백</a></li>
<li><a href="#34-2-strict-2pl">3.4 엄격한 2단계 잠금 (Strict 2PL)</a></li>
<li><a href="#35-2-rigorous-2pl">3.5 엄밀한 2단계 잠금 (Rigorous 2PL)</a></li>
<li><a href="#36-2pl">3.6 2PL 변형 비교</a></li>
</ul>
</li>
<li><a href="#4">4. 데드락</a><ul>
<li><a href="#41">4.1 데드락이란?</a></li>
<li><a href="#42">4.2 데드락 감지</a></li>
<li><a href="#43">4.3 데드락 방지</a></li>
<li><a href="#44">4.4 타임아웃 기반 접근</a></li>
<li><a href="#45">4.5 실제 데드락</a></li>
</ul>
</li>
<li><a href="#5">5. 잠금 세분도</a><ul>
<li><a href="#51">5.1 세분도 스펙트럼</a></li>
<li><a href="#52">5.2 의도 잠금</a></li>
<li><a href="#53">5.3 의도 잠금을 포함한 호환성 행렬</a></li>
<li><a href="#54">5.4 다중 세분도 잠금 프로토콜</a></li>
<li><a href="#55-six">5.5 SIX 잠금</a></li>
<li><a href="#56">5.6 잠금 확대</a></li>
</ul>
</li>
<li><a href="#6">6. 타임스탬프 기반 프로토콜</a><ul>
<li><a href="#61">6.1 기본 타임스탬프 순서</a></li>
<li><a href="#62">6.2 예: 타임스탬프 순서</a></li>
<li><a href="#63-thomas">6.3 Thomas의 쓰기 규칙</a></li>
</ul>
</li>
<li><a href="#7-mvcc">7. 다중 버전 동시성 제어 (MVCC)</a><ul>
<li><a href="#71">7.1 개념</a></li>
<li><a href="#72-mvcc">7.2 MVCC 읽기와 쓰기 규칙</a></li>
<li><a href="#73-mvcc">7.3 MVCC 이점과 비용</a></li>
<li><a href="#74-postgresql-mvcc">7.4 PostgreSQL의 MVCC</a></li>
<li><a href="#75-mysql-innodb-mvcc">7.5 MySQL InnoDB의 MVCC</a></li>
</ul>
</li>
<li><a href="#8-occ">8. 낙관적 동시성 제어 (OCC)</a><ul>
<li><a href="#81">8.1 개념</a></li>
<li><a href="#82">8.2 세 단계</a></li>
<li><a href="#83">8.3 검증 규칙</a></li>
<li><a href="#84-occ">8.4 예: OCC 검증</a></li>
<li><a href="#85-occ">8.5 OCC를 사용해야 할 때</a></li>
</ul>
</li>
<li><a href="#9">9. 동시성 제어 방법 비교</a><ul>
<li><a href="#91">9.1 요약 표</a></li>
<li><a href="#92">9.2 결정 가이드</a></li>
<li><a href="#93">9.3 실제 시스템이 사용하는 것</a></li>
</ul>
</li>
<li><a href="#10">10. 연습문제</a><ul>
<li><a href="#_5">개념적 질문</a></li>
<li><a href="#_6">잠금 기반 프로토콜 문제</a></li>
<li><a href="#mvcc">타임스탬프와 MVCC 문제</a></li>
<li><a href="#occ">OCC 문제</a></li>
<li><a href="#_7">분석과 설계</a></li>
</ul>
</li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="11">11. 동시성 제어<a class="header-link" href="#11" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./10_Transaction_Theory.md">트랜잭션 이론</a> | <strong>다음</strong>: <a href="./12_Recovery_Systems.md">복구 시스템</a></p>
<hr />
<h2 id="_1">학습 목표<a class="header-link" href="#_1" title="Permanent link">&para;</a></h2>
<ul>
<li>동시성 제어가 데이터베이스 정확성에 필수적인 이유 이해</li>
<li>잠금 기반 프로토콜 마스터: 공유/배타 잠금, 2단계 잠금 및 변형들</li>
<li>데드락 분석 및 처리: 감지, 방지, 타임아웃 전략</li>
<li>잠금 세분도와 다중 세분도 잠금을 위한 의도 잠금 이해</li>
<li>타임스탬프 기반 프로토콜과 Thomas의 쓰기 규칙 학습</li>
<li>다중 버전 동시성 제어(MVCC)와 그 구현 이해</li>
<li>낙관적 동시성 제어(OCC)를 비관적 방법과 비교</li>
</ul>
<hr />
<h2 id="1">1. 동시성 제어의 필요성<a class="header-link" href="#1" title="Permanent link">&para;</a></h2>
<h3 id="_2">동시성을 허용하는 이유?<a class="header-link" href="#_2" title="Permanent link">&para;</a></h3>
<p>현대 데이터베이스 시스템은 수천 개의 동시 트랜잭션을 처리한다. 동시성이 없으면:</p>
<div class="highlight"><pre><span></span><code>각각 10ms 소요되는 1000개 트랜잭션의 직렬 실행:
  총 시간 = 1000 × 10ms = 10초

100개 동시 트랜잭션:
  I/O 대기와 계산을 겹침
  총 시간 ≈ 100ms (+ 오버헤드)
</code></pre></div>

<p><strong>동시성의 이점:</strong>
- <strong>향상된 처리량(Throughput)</strong>: 초당 더 많은 트랜잭션
- <strong>감소된 응답 시간</strong>: 짧은 트랜잭션이 긴 트랜잭션 뒤에서 기다리지 않음
- <strong>더 나은 자원 활용</strong>: 다른 트랜잭션이 I/O를 기다리는 동안 CPU가 작동</p>
<h3 id="_3">제어 없이 무엇이 잘못될 수 있는가?<a class="header-link" href="#_3" title="Permanent link">&para;</a></h3>
<p>동시성 제어 없이, 인터리빙된 실행은 각 트랜잭션이 개별적으로 정확하더라도 잘못된 결과를 생성할 수 있다.</p>
<p><strong>손실된 업데이트 문제:</strong></p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">90</span><span class="w">    </span><span class="n">write</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">90</span>
<span class="n">T₂</span><span class="o">:</span><span class="w">       </span><span class="n">read</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">100</span><span class="w">    </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">20</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">120</span><span class="w">    </span><span class="n">write</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">120</span>

<span class="err">타임라인</span><span class="o">:</span>
<span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">A</span><span class="o">)=</span><span class="mi">100</span><span class="w">  </span><span class="err">─────────────</span><span class="w"> </span><span class="n">write</span><span class="o">(</span><span class="n">A</span><span class="o">)=</span><span class="mi">90</span>
<span class="n">T₂</span><span class="o">:</span><span class="w">      </span><span class="n">read</span><span class="o">(</span><span class="n">A</span><span class="o">)=</span><span class="mi">100</span><span class="w"> </span><span class="err">────────────────</span><span class="w"> </span><span class="n">write</span><span class="o">(</span><span class="n">A</span><span class="o">)=</span><span class="mi">120</span>

<span class="err">결과</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">120</span>
<span class="err">기대</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">110</span><span class="w"> </span><span class="o">(</span><span class="err">두</span><span class="w"> </span><span class="err">업데이트</span><span class="w"> </span><span class="err">모두</span><span class="w"> </span><span class="err">적용</span><span class="o">)</span>
<span class="n">T₁의</span><span class="w"> </span><span class="err">업데이트가</span><span class="w"> </span><span class="err">손실됨</span><span class="o">!</span>
</code></pre></div>

<p><strong>일관되지 않은 읽기 문제:</strong></p>
<div class="highlight"><pre><span></span><code><span class="err">불변식</span><span class="o">:</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">200</span><span class="w"> </span><span class="o">(</span><span class="err">초기</span><span class="w"> </span><span class="n">A</span><span class="o">=</span><span class="mi">100</span><span class="o">,</span><span class="w"> </span><span class="n">B</span><span class="o">=</span><span class="mi">100</span><span class="o">)</span>

<span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">A</span><span class="o">)=</span><span class="mi">100</span><span class="w">   </span><span class="n">A</span><span class="o">=</span><span class="n">A</span><span class="o">-</span><span class="mi">50</span><span class="o">=</span><span class="mi">50</span><span class="w">   </span><span class="n">write</span><span class="o">(</span><span class="n">A</span><span class="o">)=</span><span class="mi">50</span><span class="w"> </span><span class="err">────</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">B</span><span class="o">)=</span><span class="mi">100</span><span class="w">   </span><span class="n">B</span><span class="o">=</span><span class="n">B</span><span class="o">+</span><span class="mi">50</span><span class="o">=</span><span class="mi">150</span><span class="w">   </span><span class="n">write</span><span class="o">(</span><span class="n">B</span><span class="o">)=</span><span class="mi">150</span>
<span class="n">T₂</span><span class="o">:</span><span class="w">                                    </span><span class="n">read</span><span class="o">(</span><span class="n">A</span><span class="o">)=</span><span class="mi">50</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">B</span><span class="o">)=</span><span class="mi">100</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">A</span><span class="o">+</span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">150</span><span class="w"> </span><span class="err">≠</span><span class="w"> </span><span class="mi">200</span><span class="o">!</span>

<span class="n">T₂가</span><span class="w"> </span><span class="n">T₁의</span><span class="w"> </span><span class="err">업데이트</span><span class="w"> </span><span class="err">후에</span><span class="w"> </span><span class="n">A를</span><span class="w"> </span><span class="err">읽지만</span><span class="w"> </span><span class="n">T₁의</span><span class="w"> </span><span class="err">업데이트</span><span class="w"> </span><span class="err">전에</span><span class="w"> </span><span class="n">B를</span><span class="w"> </span><span class="err">읽음</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">일관되지</span><span class="w"> </span><span class="err">않은</span><span class="w"> </span><span class="err">뷰</span>
</code></pre></div>

<h3 id="_4">동시성 제어의 역할<a class="header-link" href="#_4" title="Permanent link">&para;</a></h3>
<p>동시성 제어 서브시스템은 트랜잭션의 동시 실행이 <strong>어떤 직렬 실행과 동등</strong>하도록 (직렬화 가능성) 보장하면서, 동시성 정도를 최대화한다.</p>
<div class="highlight"><pre><span></span><code>                    ┌──────────────────────┐
트랜잭션 ────→      │ 동시성 제어          │ ────→  직렬화 가능 스케줄
  T₁, T₂, T₃      │    서브시스템         │        (정확한 결과)
                    │  - 잠금              │
                    │  - 타임스탬프         │
                    │  - MVCC              │
                    └──────────────────────┘
</code></pre></div>

<hr />
<h2 id="2">2. 잠금 기반 프로토콜<a class="header-link" href="#2" title="Permanent link">&para;</a></h2>
<h3 id="21">2.1 잠금 유형<a class="header-link" href="#21" title="Permanent link">&para;</a></h3>
<p>가장 기본적인 동시성 제어 메커니즘은 데이터 항목에 대한 <strong>잠금(Locks)</strong>을 사용한다.</p>
<p><strong>공유 잠금(Shared Lock, S-lock):</strong>
- 데이터 항목 <strong>읽기</strong>를 위해 획득
- 여러 트랜잭션이 동일한 항목에 대해 동시에 S-잠금을 보유할 수 있음
- <strong>읽기 잠금</strong>이라고도 함</p>
<p><strong>배타 잠금(Exclusive Lock, X-lock):</strong>
- 데이터 항목 <strong>쓰기</strong>(수정)를 위해 획득
- 한 번에 하나의 트랜잭션만 항목에 대해 X-잠금을 보유할 수 있음
- 다른 트랜잭션은 항목에 대해 어떤 잠금(S 또는 X)도 동시에 보유할 수 없음
- <strong>쓰기 잠금</strong>이라고도 함</p>
<p><strong>잠금 호환성 행렬:</strong></p>
<div class="highlight"><pre><span></span><code>              요청된 잠금
              ┌─────┬─────┐
              │  S  │  X  │
         ┌────┼─────┼─────┤
보유     │ S  │ Yes │ No  │
잠금     ├────┼─────┼─────┤
         │ X  │ No  │ No  │
         └────┴─────┴─────┘

S + S = 호환 (둘 다 진행 가능)
S + X = 비호환 (대기해야 함)
X + S = 비호환 (대기해야 함)
X + X = 비호환 (대기해야 함)
</code></pre></div>

<p><strong>잠금 연산:</strong>
- <code>lock-S(X)</code> 또는 <code>S(X)</code>: 항목 X에 대한 공유 잠금 요청
- <code>lock-X(X)</code> 또는 <code>X(X)</code>: 항목 X에 대한 배타 잠금 요청
- <code>unlock(X)</code> 또는 <code>U(X)</code>: 항목 X에 대한 잠금 해제</p>
<h3 id="22">2.2 잠금 프로토콜 예<a class="header-link" href="#22" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>T₁ (A에서 B로 $50 이체):     T₂ (A + B 읽기):
  lock-X(A)                           lock-S(A)     ← BLOCKED (T₁이 A에 X 보유)
  read(A) = 100
  A = A - 50
  write(A) = 50
  lock-X(B)
  read(B) = 200
  B = B + 50
  write(B) = 250
  unlock(A)                           lock-S(A)     ← 이제 승인
  unlock(B)                           read(A) = 50
                                      lock-S(B)
                                      read(B) = 250
                                      print(A+B) = 300  ← 정확!
                                      unlock(A)
                                      unlock(B)
</code></pre></div>

<h3 id="23">2.3 기본 잠금의 문제<a class="header-link" href="#23" title="Permanent link">&para;</a></h3>
<p>접근 전에 잠금을 획득하고 사용 후에 해제하는 것만으로는 직렬화 가능성에 <strong>충분하지 않다</strong>:</p>
<div class="highlight"><pre><span></span><code>잘못된 프로토콜 (잠금, 사용, 즉시 잠금 해제):

T₁:  lock-X(A) read(A) write(A) unlock(A) lock-X(B) read(B) write(B) unlock(B)
T₂:                                lock-S(A) read(A) lock-S(B)
                                                          ↑ BLOCKED (T₁이 X(B) 보유)

타임라인:
T₁: X(A) r(A) w(A) U(A) ──── X(B) r(B) w(B) U(B)
T₂:                   S(A) r(A) ────── S(B) r(B)

T₂가 T₁의 업데이트 후에 A를 읽지만 T₁의 업데이트 전에 B를 읽음.
T₂가 일관되지 않은 상태를 봄. 직렬화 가능하지 않음.

문제: T₁이 A의 잠금을 너무 일찍 해제함.
</code></pre></div>

<p>이것이 <strong>2단계 잠금</strong>을 동기화한다.</p>
<hr />
<h2 id="3-2-2pl">3. 2단계 잠금 (2PL)<a class="header-link" href="#3-2-2pl" title="Permanent link">&para;</a></h2>
<h3 id="31-2">3.1 기본 2단계 잠금<a class="header-link" href="#31-2" title="Permanent link">&para;</a></h3>
<p>트랜잭션이 <strong>2단계 잠금(Two-Phase Locking, 2PL) 프로토콜</strong>을 따르는 경우, 모든 잠금 연산이 첫 번째 잠금 해제 연산보다 선행한다.</p>
<div class="highlight"><pre><span></span><code>단계 1: 성장 단계          단계 2: 축소 단계
(잠금 획득, 해제 없음)    (잠금 해제, 획득 없음)

보유된
잠금 수
    ^
    │        ╱╲
    │       ╱  ╲
    │      ╱    ╲
    │     ╱      ╲
    │    ╱        ╲
    │   ╱          ╲
    │  ╱            ╲
    │ ╱              ╲
    └──────┬──────────┬──→ 시간
     성장  잠금       축소
     단계  포인트    단계
</code></pre></div>

<p><strong>규칙:</strong>
1. 트랜잭션은 성장 단계에서 잠금을 획득할 수 있음
2. 트랜잭션이 잠금을 해제하면, 축소 단계에 들어감
3. 축소 단계에서는 새로운 잠금을 획득할 수 없음</p>
<p><strong>정리</strong>: 스케줄의 모든 트랜잭션이 2PL 프로토콜을 따르면, 스케줄은 <strong>충돌 직렬화 가능</strong>하다.</p>
<p><strong>증명 스케치</strong>: "잠금 포인트" (트랜잭션이 모든 잠금을 획득한 순간)가 직렬화 순서를 정의한다. T_i의 잠금 포인트가 T_j의 잠금 포인트보다 선행하면, T_i가 동등한 직렬 스케줄에서 T_j보다 먼저 나타난다. 이 순서는 충돌하는 연산이 잠금 호환성 규칙을 존중하기 때문에 일관적이다.</p>
<h3 id="32-2pl">3.2 예: 2PL 실행<a class="header-link" href="#32-2pl" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>T₁ (2PL):                           T₂ (2PL):
  lock-X(A)
  read(A)                             lock-S(B)
  A = A - 50                          read(B)
  write(A)                            lock-S(A) ← BLOCKED (T₁이 X(A) 보유)
  lock-X(B)
  read(B)          ← 잠금 포인트 T₁
  B = B + 50
  write(B)
  unlock(A)                           lock-S(A) ← 이제 승인 (축소 단계)
  unlock(B)                           read(A)
                                      ← 잠금 포인트 T₂
                                      unlock(A)
                                      unlock(B)

직렬화 순서: T₁ before T₂ (T₁의 잠금 포인트가 더 이름)
T₂가 T₁의 완전한 이체 후 데이터베이스를 봄. 정확!
</code></pre></div>

<h3 id="33-2pl">3.3 문제: 기본 2PL 하의 연쇄 롤백<a class="header-link" href="#33-2pl" title="Permanent link">&para;</a></h3>
<p>기본 2PL은 직렬화 가능성을 보장하지만 <strong>복구 가능성</strong>은 보장하지 <strong>않는다</strong>:</p>
<div class="highlight"><pre><span></span><code>T₁ (2PL):                           T₂:
  lock-X(A)
  read(A)
  write(A)
  unlock(A)          ← 축소 단계: A 해제
                                       lock-S(A)
                                       read(A)   ← T₁의 커밋되지 않은 데이터를 읽음!
  ...
  ABORT              ← T₁ 실패!

T₂가 T₁이 쓴 값을 읽었는데, 이제 중단되었음.
T₂도 롤백되어야 함 → 연쇄 롤백
</code></pre></div>

<h3 id="34-2-strict-2pl">3.4 엄격한 2단계 잠금 (Strict 2PL)<a class="header-link" href="#34-2-strict-2pl" title="Permanent link">&para;</a></h3>
<p><strong>엄격한 2PL</strong>은 규칙을 추가한다: 모든 <strong>배타(X) 잠금</strong>은 트랜잭션이 커밋하거나 중단할 때까지 유지된다.</p>
<div class="highlight"><pre><span></span><code>엄격한 2PL:
보유된
잠금 수
    ^
    │    S-잠금은       X-잠금은
    │    해제될 수 있음  커밋/중단 시 해제
    │      │                    │
    │      ╱╲                   │
    │     ╱  ╲─── ─── ─── ─── ─┤
    │    ╱         S-잠금       │
    │   ╱          해제됨       │
    │  ╱              ╲         │
    │ ╱                ╲        │
    └───────────────────┬──────→ 시간
                     커밋/중단
</code></pre></div>

<p><strong>특성:</strong>
- 충돌 직렬화 가능 (2PL에서 상속)
- <strong>엄격한</strong> 스케줄 (X-잠금된 항목에 대한 연쇄 롤백 없음)
- 실제로 가장 일반적으로 사용됨</p>
<h3 id="35-2-rigorous-2pl">3.5 엄밀한 2단계 잠금 (Rigorous 2PL)<a class="header-link" href="#35-2-rigorous-2pl" title="Permanent link">&para;</a></h3>
<p><strong>엄밀한 2PL</strong>은 <strong>모든 잠금</strong>(S와 X 모두)을 커밋 또는 중단까지 유지한다.</p>
<div class="highlight"><pre><span></span><code>엄밀한 2PL:
보유된
잠금 수
    ^
    │
    │    ╱──────────────────────┤
    │   ╱                       │
    │  ╱   모든 잠금이           │
    │ ╱    커밋/중단까지 유지    │
    │╱                          │
    └───────────────────┬──────→ 시간
                     커밋/중단
</code></pre></div>

<p><strong>특성:</strong>
- 충돌 직렬화 가능
- 엄격하고 연쇄 없음
- 직렬화 순서 = 커밋 순서 (추론하기 쉬움)
- 구현하기 가장 간단한 프로토콜
- 대부분의 데이터베이스 시스템이 사용하는 잠금 프로토콜</p>
<h3 id="36-2pl">3.6 2PL 변형 비교<a class="header-link" href="#36-2pl" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>변형</th>
<th>S-잠금 해제</th>
<th>X-잠금 해제</th>
<th>보장</th>
</tr>
</thead>
<tbody>
<tr>
<td>기본 2PL</td>
<td>잠금 포인트 후</td>
<td>잠금 포인트 후</td>
<td>충돌 직렬화 가능</td>
</tr>
<tr>
<td>엄격한 2PL</td>
<td>잠금 포인트 후</td>
<td>커밋/중단 시</td>
<td>+ 엄격 (쓰기로부터 연쇄 없음)</td>
</tr>
<tr>
<td>엄밀한 2PL</td>
<td>커밋/중단 시</td>
<td>커밋/중단 시</td>
<td>+ 엄격 + 연쇄 없음</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="4">4. 데드락<a class="header-link" href="#4" title="Permanent link">&para;</a></h2>
<h3 id="41">4.1 데드락이란?<a class="header-link" href="#41" title="Permanent link">&para;</a></h3>
<p><strong>데드락(Deadlock)</strong>은 두 개 이상의 트랜잭션이 서로 잠금을 해제하기를 기다릴 때 발생하며, 순환 대기를 생성한다.</p>
<div class="highlight"><pre><span></span><code>데드락 시나리오:

T₁: lock-X(A)   ───── lock-X(B) ← BLOCKED (T₂가 X(B) 보유)
T₂: lock-X(B)   ───── lock-X(A) ← BLOCKED (T₁이 X(A) 보유)

T₁이 T₂가 B를 해제하기를 기다림
T₂가 T₁이 A를 해제하기를 기다림
둘 다 진행할 수 없음 → 데드락
</code></pre></div>

<div class="highlight"><pre><span></span><code>대기<span class="o">-</span>포<span class="ss">(</span><span class="k">Wait</span><span class="o">-</span><span class="k">For</span><span class="ss">)</span><span class="w"> </span>그래프:

<span class="nv">T</span>₁<span class="w"> </span>──기다림──→<span class="w"> </span><span class="nv">T</span>₂
<span class="w"> </span>↑<span class="w">                  </span>│
<span class="w"> </span>└──기다림──────┘

사이클<span class="w"> </span>→<span class="w"> </span>데드락<span class="o">!</span>
</code></pre></div>

<h3 id="42">4.2 데드락 감지<a class="header-link" href="#42" title="Permanent link">&para;</a></h3>
<p><strong>대기-포 그래프(Wait-For Graph, WFG):</strong>
- 노드는 트랜잭션을 나타냄
- 간선 <code>T_i → T_j</code>는 <code>T_i</code>가 <code>T_j</code>가 잠금을 해제하기를 기다리고 있음을 의미
- WFG의 <strong>사이클</strong>은 데드락을 나타냄</p>
<div class="highlight"><pre><span></span><code>감지<span class="w"> </span>알고리즘:
<span class="nv">DETECT</span><span class="o">-</span><span class="nv">DEADLOCK</span><span class="ss">()</span>:
<span class="w">    </span>대기<span class="o">-</span>포<span class="w"> </span>그래프<span class="w"> </span><span class="nv">G</span><span class="w"> </span>유지
<span class="w">    </span>주기적으로<span class="w"> </span><span class="ss">(</span>또는<span class="w"> </span>각<span class="w"> </span>잠금<span class="w"> </span>대기<span class="w"> </span>시<span class="ss">)</span>:
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nv">G</span>가<span class="w"> </span>사이클<span class="w"> </span>포함:
<span class="w">            </span>사이클에서<span class="w"> </span>희생자<span class="w"> </span>트랜잭션<span class="w"> </span>선택
<span class="w">            </span>희생자<span class="w"> </span>중단
<span class="w">            </span>잠금<span class="w"> </span>해제<span class="w"> </span><span class="ss">(</span>사이클<span class="w"> </span>깨짐<span class="ss">)</span>
</code></pre></div>

<p><strong>희생자 선택 기준:</strong>
1. <strong>가장 젊은 트랜잭션</strong> (재실행할 작업이 가장 적음)
2. <strong>잠금이 가장 적은 트랜잭션</strong> (방해가 가장 적음)
3. <strong>완료에 가장 가까운 트랜잭션</strong> (이미 수행한 작업이 가장 많음 -- 낭비를 피하기 위해 선호되기도 함)
4. <strong>우선순위가 가장 낮은 트랜잭션</strong> (응용 프로그램 정의)</p>
<p><strong>기아 방지</strong>: 동일한 트랜잭션이 반복적으로 희생자로 선택되지 않도록 보장. 일반적인 접근: 각 중단 후 우선순위 증가.</p>
<p><strong>예:</strong></p>
<div class="highlight"><pre><span></span><code><span class="mf">4</span><span class="n">개</span><span class="w"> </span><span class="n">트랜잭션이</span><span class="w"> </span><span class="n">있는</span><span class="w"> </span><span class="n">대기</span><span class="o">-</span><span class="n">포</span><span class="w"> </span><span class="n">그래프</span><span class="p">:</span>

<span class="n">T₁</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₃</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₁</span><span class="w">   </span><span class="p">(</span><span class="n">T₁</span><span class="p">,</span><span class="w"> </span><span class="n">T₂</span><span class="p">,</span><span class="w"> </span><span class="n">T₃를</span><span class="w"> </span><span class="n">포함하는</span><span class="w"> </span><span class="n">사이클</span><span class="p">)</span>
<span class="w">          </span><span class="err">↗</span>
<span class="w">     </span><span class="n">T₄</span><span class="w"> </span><span class="err">─┘</span><span class="w">             </span><span class="p">(</span><span class="n">T₄는</span><span class="w"> </span><span class="n">T₃를</span><span class="w"> </span><span class="n">기다리지만</span><span class="w"> </span><span class="n">사이클에</span><span class="w"> </span><span class="n">없음</span><span class="p">)</span>

<span class="n">T₁</span><span class="p">,</span><span class="w"> </span><span class="n">T₂</span><span class="p">,</span><span class="w"> </span><span class="n">T₃</span><span class="w"> </span><span class="n">중</span><span class="w"> </span><span class="n">데드락</span><span class="w"> </span><span class="n">감지</span><span class="mf">.</span>
<span class="n">희생자</span><span class="w"> </span><span class="n">선택</span><span class="w"> </span><span class="p">(</span><span class="n">예</span><span class="p">:</span><span class="w"> </span><span class="n">가장</span><span class="w"> </span><span class="n">젊으면</span><span class="w"> </span><span class="n">T₁</span><span class="p">)</span><span class="mf">.</span>
<span class="n">T₁</span><span class="w"> </span><span class="n">중단</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">잠금</span><span class="w"> </span><span class="n">해제</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₃</span><span class="w"> </span><span class="n">진행</span><span class="w"> </span><span class="n">가능</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w"> </span><span class="n">진행</span><span class="w"> </span><span class="n">가능</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">T₄</span><span class="w"> </span><span class="n">진행</span><span class="w"> </span><span class="n">가능</span><span class="mf">.</span>
</code></pre></div>

<h3 id="43">4.3 데드락 방지<a class="header-link" href="#43" title="Permanent link">&para;</a></h3>
<p>데드락이 발생한 후 감지하는 대신, 발생하지 않도록 <strong>방지</strong>할 수 있다.</p>
<p><strong>Wait-Die 방식 (비선점형):</strong></p>
<div class="highlight"><pre><span></span><code>T_i가 T_j가 보유한 잠금을 요청할 때:

  If T_i가 T_j보다 오래됨 (T_i가 더 이른 타임스탬프):
      T_i가 대기 (오래된 것이 젊은 것을 기다림)
  Else:
      T_i가 죽음 (젊은 것이 롤백되고 재시작됨)
      (T_i는 기아를 피하기 위해 원래 타임스탬프로 재시작됨)

기억법: &quot;오래된 것 대기, 젊은 것 죽음&quot;
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">예</span><span class="o">:</span>
<span class="n">T₁</span><span class="w"> </span><span class="o">(</span><span class="n">ts</span><span class="o">=</span><span class="mi">100</span><span class="o">,</span><span class="w"> </span><span class="err">더</span><span class="w"> </span><span class="err">오래됨</span><span class="o">)</span><span class="w">  </span><span class="n">T₂</span><span class="w"> </span><span class="o">(</span><span class="n">ts</span><span class="o">=</span><span class="mi">200</span><span class="o">,</span><span class="w"> </span><span class="err">더</span><span class="w"> </span><span class="err">젊음</span><span class="o">)</span><span class="err">가</span><span class="w"> </span><span class="err">보유한</span><span class="w"> </span><span class="err">잠금</span><span class="w"> </span><span class="err">요청</span>
<span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="err">대기</span><span class="w"> </span><span class="o">(</span><span class="err">오래된</span><span class="w"> </span><span class="err">것이</span><span class="w"> </span><span class="err">젊은</span><span class="w"> </span><span class="err">것을</span><span class="w"> </span><span class="err">기다림</span><span class="o">)</span>

<span class="n">T₂</span><span class="w"> </span><span class="o">(</span><span class="n">ts</span><span class="o">=</span><span class="mi">200</span><span class="o">,</span><span class="w"> </span><span class="err">더</span><span class="w"> </span><span class="err">젊음</span><span class="o">)</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="o">(</span><span class="n">ts</span><span class="o">=</span><span class="mi">100</span><span class="o">,</span><span class="w"> </span><span class="err">더</span><span class="w"> </span><span class="err">오래됨</span><span class="o">)</span><span class="err">이</span><span class="w"> </span><span class="err">보유한</span><span class="w"> </span><span class="err">잠금</span><span class="w"> </span><span class="err">요청</span>
<span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w"> </span><span class="err">죽음</span><span class="w"> </span><span class="o">(</span><span class="err">젊은</span><span class="w"> </span><span class="err">것이</span><span class="w"> </span><span class="err">죽고</span><span class="o">,</span><span class="w"> </span><span class="err">롤백됨</span><span class="o">)</span>
</code></pre></div>

<p><strong>Wound-Wait 방식 (선점형):</strong></p>
<div class="highlight"><pre><span></span><code>T_i가 T_j가 보유한 잠금을 요청할 때:

  If T_i가 T_j보다 오래됨:
      T_i가 T_j를 상처 입힘 (T_j가 롤백되도록 강제, T_i가 잠금을 가짐)
  Else:
      T_i가 대기 (젊은 것이 오래된 것을 기다림)

기억법: &quot;오래된 것 상처 입힘, 젊은 것 대기&quot;
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="err">예</span><span class="o">:</span>
<span class="n">T₁</span><span class="w"> </span><span class="o">(</span><span class="n">ts</span><span class="o">=</span><span class="mi">100</span><span class="o">,</span><span class="w"> </span><span class="err">더</span><span class="w"> </span><span class="err">오래됨</span><span class="o">)</span><span class="w">  </span><span class="n">T₂</span><span class="w"> </span><span class="o">(</span><span class="n">ts</span><span class="o">=</span><span class="mi">200</span><span class="o">,</span><span class="w"> </span><span class="err">더</span><span class="w"> </span><span class="err">젊음</span><span class="o">)</span><span class="err">가</span><span class="w"> </span><span class="err">보유한</span><span class="w"> </span><span class="err">잠금</span><span class="w"> </span><span class="err">요청</span>
<span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="n">T₁이</span><span class="w"> </span><span class="n">T₂를</span><span class="w"> </span><span class="err">상처</span><span class="w"> </span><span class="err">입힘</span><span class="w"> </span><span class="o">(</span><span class="n">T₂가</span><span class="w"> </span><span class="err">롤백됨</span><span class="o">,</span><span class="w"> </span><span class="n">T₁이</span><span class="w"> </span><span class="err">잠금을</span><span class="w"> </span><span class="err">가짐</span><span class="o">)</span>

<span class="n">T₂</span><span class="w"> </span><span class="o">(</span><span class="n">ts</span><span class="o">=</span><span class="mi">200</span><span class="o">,</span><span class="w"> </span><span class="err">더</span><span class="w"> </span><span class="err">젊음</span><span class="o">)</span><span class="w"> </span><span class="n">T₁</span><span class="w"> </span><span class="o">(</span><span class="n">ts</span><span class="o">=</span><span class="mi">100</span><span class="o">,</span><span class="w"> </span><span class="err">더</span><span class="w"> </span><span class="err">오래됨</span><span class="o">)</span><span class="err">이</span><span class="w"> </span><span class="err">보유한</span><span class="w"> </span><span class="err">잠금</span><span class="w"> </span><span class="err">요청</span>
<span class="w">  </span><span class="err">→</span><span class="w"> </span><span class="n">T₂</span><span class="w"> </span><span class="err">대기</span><span class="w"> </span><span class="o">(</span><span class="err">젊은</span><span class="w"> </span><span class="err">것이</span><span class="w"> </span><span class="err">오래된</span><span class="w"> </span><span class="err">것을</span><span class="w"> </span><span class="err">기다림</span><span class="o">)</span>
</code></pre></div>

<p><strong>비교:</strong></p>
<table>
<thead>
<tr>
<th>방식</th>
<th>더 오래된 것이 더 젊은 것에게 요청</th>
<th>더 젊은 것이 더 오래된 것에게 요청</th>
</tr>
</thead>
<tbody>
<tr>
<td>Wait-Die</td>
<td>더 오래된 것 대기</td>
<td>더 젊은 것 죽음 (롤백됨)</td>
</tr>
<tr>
<td>Wound-Wait</td>
<td>더 오래된 것이 더 젊은 것 상처 입힘 (선점)</td>
<td>더 젊은 것 대기</td>
</tr>
</tbody>
</table>
<p>두 방식 모두 <strong>데드락이 없다</strong> 왜냐하면 전체 순서를 강제하기 때문: Wait-Die에서, 트랜잭션은 더 젊은 것만 기다림; Wound-Wait에서, 트랜잭션은 더 오래된 것만 기다림. 둘 다 순환 대기를 허용하지 않음.</p>
<p><strong>기아</strong>: 두 방식 모두 중단된 트랜잭션을 <strong>원래 타임스탬프</strong>로 재시작하므로, 점점 "오래되어" 결국 성공함.</p>
<h3 id="44">4.4 타임아웃 기반 접근<a class="header-link" href="#44" title="Permanent link">&para;</a></h3>
<p>단순하고 실용적인 접근: 트랜잭션이 <strong>타임아웃</strong> 임계값보다 오래 잠금을 기다리면, 데드락을 가정하고 중단한다.</p>
<div class="highlight"><pre><span></span><code><span class="nx">LOCK</span><span class="o">-</span><span class="nx">WITH</span><span class="o">-</span><span class="nx">TIMEOUT</span><span class="p">(</span><span class="nx">item</span><span class="p">,</span><span class="w"> </span><span class="nx">lock_type</span><span class="p">,</span><span class="w"> </span><span class="nx">timeout</span><span class="p">):</span>
<span class="w">    </span><span class="nx">start_time</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">current_time</span><span class="p">()</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="nx">lock</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="nx">grantable</span><span class="p">:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">current_time</span><span class="p">()</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nx">start_time</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">timeout</span><span class="p">:</span>
<span class="w">            </span><span class="nx">ABORT</span><span class="w"> </span><span class="nx">transaction</span><span class="w">  </span><span class="c1">// 데드락 가정</span>
<span class="w">        </span><span class="nx">wait</span><span class="p">(</span><span class="nx">short_interval</span><span class="p">)</span>
<span class="w">    </span><span class="nx">grant</span><span class="w"> </span><span class="nx">lock</span>
</code></pre></div>

<p><strong>장점:</strong>
- 구현이 간단
- 대기-포 그래프를 유지하는 오버헤드 없음
- 실제로 잘 작동 (대부분의 데드락이 빠르게 해결됨)</p>
<p><strong>단점:</strong>
- 실제로 데드락이 아닌 트랜잭션을 중단할 수 있음 (단지 느릴 뿐)
- 타임아웃이 너무 짧으면: 불필요한 중단
- 타임아웃이 너무 길면: 실제 데드락이 너무 오래 지속</p>
<p><strong>실제로</strong>: 대부분의 데이터베이스 시스템은 타임아웃(첫 번째 방어선)과 대기-포 그래프 감지(정확성)의 조합을 사용한다.</p>
<h3 id="45">4.5 실제 데드락<a class="header-link" href="#45" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1">-- PostgreSQL: 대기-포 그래프로 데드락 감지</span>
<span class="c1">-- 기본 deadlock_timeout = 1s</span>
<span class="k">SET</span><span class="w"> </span><span class="n">deadlock_timeout</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;1s&#39;</span><span class="p">;</span>

<span class="c1">-- 세션 1:</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">UPDATE</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="c1">-- 그 다음 시도:</span>
<span class="k">UPDATE</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">100</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="c1">-- 세션 2가 id=2에 잠금을 보유하면 BLOCKED</span>

<span class="c1">-- 세션 2:</span>
<span class="k">BEGIN</span><span class="p">;</span>
<span class="k">UPDATE</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="c1">-- 그 다음 시도:</span>
<span class="k">UPDATE</span><span class="w"> </span><span class="n">accounts</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">50</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">id</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="c1">-- 세션 1이 id=1에 잠금을 보유하면 BLOCKED</span>

<span class="c1">-- deadlock_timeout 후: PostgreSQL이 데드락 감지</span>
<span class="c1">-- ERROR: deadlock detected</span>
<span class="c1">-- 한 세션이 중단되고, 다른 세션이 진행</span>
</code></pre></div>

<hr />
<h2 id="5">5. 잠금 세분도<a class="header-link" href="#5" title="Permanent link">&para;</a></h2>
<h3 id="51">5.1 세분도 스펙트럼<a class="header-link" href="#51" title="Permanent link">&para;</a></h3>
<p>잠금은 데이터 계층의 다른 수준에서 적용될 수 있다:</p>
<div class="highlight"><pre><span></span><code>세분도 계층:

데이터베이스 ──→ 가장 조잡 (동시성 가장 낮음, 오버헤드 가장 낮음)
  │
  스키마
  │
  테이블
  │
  페이지 (블록)
  │
  행 (튜플) ──→ 가장 세밀 (동시성 가장 높음, 오버헤드 가장 높음)
  │
  필드 (속성) ──→ 실제로 거의 사용 안 됨
</code></pre></div>

<p><strong>트레이드오프:</strong></p>
<table>
<thead>
<tr>
<th>세밀한 세분도 (행)</th>
<th>조잡한 세분도 (테이블)</th>
</tr>
</thead>
<tbody>
<tr>
<td>높은 동시성</td>
<td>낮은 동시성</td>
</tr>
<tr>
<td>높은 오버헤드 (많은 잠금)</td>
<td>낮은 오버헤드 (적은 잠금)</td>
</tr>
<tr>
<td>OLTP에 최적</td>
<td>배치/분석에 최적</td>
</tr>
</tbody>
</table>
<h3 id="52">5.2 의도 잠금<a class="header-link" href="#52" title="Permanent link">&para;</a></h3>
<p><strong>다중 세분도 잠금(Multi-Granularity Locking, MGR)</strong>을 지원하려면, <strong>의도 잠금(Intention Locks)</strong>이 필요하다. 조잡한 항목에 대한 의도 잠금은 더 세밀한 잠금이 하위 항목에 존재함(또는 요청될 것임)을 나타낸다.</p>
<p><strong>의도 잠금을 포함한 잠금 유형:</strong></p>
<table>
<thead>
<tr>
<th>잠금</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>IS</strong> (Intention Shared)</td>
<td>일부 하위 항목이 S-잠금을 가지거나 가질 것임</td>
</tr>
<tr>
<td><strong>IX</strong> (Intention Exclusive)</td>
<td>일부 하위 항목이 X-잠금을 가지거나 가질 것임</td>
</tr>
<tr>
<td><strong>S</strong> (Shared)</td>
<td>이 노드와 모든 하위 항목에 공유 잠금</td>
</tr>
<tr>
<td><strong>X</strong> (Exclusive)</td>
<td>이 노드와 모든 하위 항목에 배타 잠금</td>
</tr>
<tr>
<td><strong>SIX</strong> (Shared + Intention Exclusive)</td>
<td>이 노드에 S-잠금, 일부 하위 항목에 IX</td>
</tr>
</tbody>
</table>
<h3 id="53">5.3 의도 잠금을 포함한 호환성 행렬<a class="header-link" href="#53" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>              요청된 잠금
         ┌─────┬─────┬─────┬─────┬─────┐
         │ IS  │ IX  │  S  │ SIX │  X  │
    ┌────┼─────┼─────┼─────┼─────┼─────┤
    │ IS │ Yes │ Yes │ Yes │ Yes │ No  │
    ├────┼─────┼─────┼─────┼─────┼─────┤
보유 │ IX │ Yes │ Yes │ No  │ No  │ No  │
잠금 ├────┼─────┼─────┼─────┼─────┼─────┤
    │ S  │ Yes │ No  │ Yes │ No  │ No  │
    ├────┼─────┼─────┼─────┼─────┼─────┤
    │SIX │ Yes │ No  │ No  │ No  │ No  │
    ├────┼─────┼─────┼─────┼─────┼─────┤
    │ X  │ No  │ No  │ No  │ No  │ No  │
    └────┴─────┴─────┴─────┴─────┴─────┘
</code></pre></div>

<h3 id="54">5.4 다중 세분도 잠금 프로토콜<a class="header-link" href="#54" title="Permanent link">&para;</a></h3>
<p>어떤 수준에서든 노드를 잠그려면:</p>
<div class="highlight"><pre><span></span><code><span class="nx">LOCK</span><span class="o">-</span><span class="nx">NODE</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span><span class="w"> </span><span class="nx">lock_type</span><span class="p">):</span>
<span class="w">    </span><span class="c1">// 단계 1: 모든 조상에 의도 잠금 획득</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="nx">each</span><span class="w"> </span><span class="nx">ancestor</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">root</span><span class="w"> </span><span class="nx">down</span><span class="w"> </span><span class="nx">to</span><span class="w"> </span><span class="nx">parent</span><span class="w"> </span><span class="nx">of</span><span class="w"> </span><span class="nx">node</span><span class="p">:</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">lock_type</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">S</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="nx">IS</span><span class="p">:</span>
<span class="w">            </span><span class="nx">acquire</span><span class="w"> </span><span class="nx">IS</span><span class="w"> </span><span class="nx">lock</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">ancestor</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">lock_type</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="nx">X</span><span class="p">,</span><span class="w"> </span><span class="nx">IX</span><span class="p">,</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="nx">SIX</span><span class="p">:</span>
<span class="w">            </span><span class="nx">acquire</span><span class="w"> </span><span class="nx">IX</span><span class="w"> </span><span class="nx">lock</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">ancestor</span>

<span class="w">    </span><span class="c1">// 단계 2: 노드에 실제 잠금 획득</span>
<span class="w">    </span><span class="nx">acquire</span><span class="w"> </span><span class="nx">lock_type</span><span class="w"> </span><span class="nx">on</span><span class="w"> </span><span class="nx">node</span>
</code></pre></div>

<p><strong>예: 트랜잭션 T₁이 테이블 T의 행 R₁을 읽고, 트랜잭션 T₂가 테이블 T의 행 R₂를 씀:</strong></p>
<div class="highlight"><pre><span></span><code>              데이터베이스
             ┌───┴───┐
           IS(T₁)  IX(T₂)
             │       │
             테이블 T
           ┌───┴───┐
         IS(T₁)  IX(T₂)
           │       │
         페이지 P1  페이지 P2
         IS(T₁)  IX(T₂)
           │       │
         행 R1   행 R2
         S(T₁)   X(T₂)

T₁과 T₂가 다른 행에서 작동 → 어떤 수준에서도 충돌 없음 → 동시 실행!
</code></pre></div>

<p><strong>예: 트랜잭션 T₃가 전체 테이블 T를 배타 접근으로 잠그려 함:</strong></p>
<div class="highlight"><pre><span></span><code>T₃가 테이블 T에 X-잠금 요청.
기존 잠금과의 호환성 확인:
  - 테이블 T의 IS(T₁): IS가 X와 호환? → 아니오!
  - 테이블 T의 IX(T₂): IX가 X와 호환? → 아니오!

T₃는 T₁과 T₂가 의도 잠금을 해제할 때까지 기다려야 함.
의도 잠금이 T₃가 행 수준 작업이 진행 중인 동안
테이블 수준 X-잠금을 얻는 것을 방지함.
</code></pre></div>

<h3 id="55-six">5.5 SIX 잠금<a class="header-link" href="#55-six" title="Permanent link">&para;</a></h3>
<p><strong>SIX</strong> (Shared + Intention Exclusive) 잠금은 트랜잭션이 <strong>전체 테이블을 읽지만</strong> <strong>몇 개의 행만 쓸</strong> 필요가 있을 때 유용하다.</p>
<div class="highlight"><pre><span></span><code>SIX 없이:
  옵션 1: 테이블에 S-잠금 (모든 쓰기자를 차단)
  옵션 2: 테이블에 IX-잠금 + 각 행에 S-잠금 (비쌈, 많은 잠금)

SIX와 함께:
  테이블에 SIX-잠금:
  - S 구성요소: 전체 테이블 읽기
  - IX 구성요소: 특정 행에 X-잠금 허용

예:
  트랜잭션: &quot;급여 &lt; 30000인 직원의 급여 업데이트&quot;
  employees 테이블에 SIX-잠금:
    - S: 급여 &lt; 30000인 행을 찾기 위해 모든 행 읽기
    - IX → X: 일치하는 특정 행에 씀
</code></pre></div>

<h3 id="56">5.6 잠금 확대<a class="header-link" href="#56" title="Permanent link">&para;</a></h3>
<p>트랜잭션이 너무 많은 세밀한 잠금을 획득하면, 시스템이 더 조잡한 세분도로 <strong>확대</strong>할 수 있다:</p>
<div class="highlight"><pre><span></span><code>잠금 확대:
  T₁이 테이블 T에 5000개의 행 수준 S-잠금을 가짐
  → 시스템이 단일 테이블 수준 S-잠금으로 확대
  → 모든 5000개 행 잠금 해제
  → 잠금 관리자의 메모리 사용 감소

임계값은 시스템마다 다름:
  - SQL Server: ~테이블당 5000개 잠금
  - Oracle: 잠금 확대 사용 안 함 (다른 접근 사용)
</code></pre></div>

<p><strong>트레이드오프</strong>: 확대는 잠금 오버헤드를 줄이지만 동시성을 감소시킴 (다른 트랜잭션이 테이블 수준 잠금에 의해 차단될 수 있음).</p>
<hr />
<h2 id="6">6. 타임스탬프 기반 프로토콜<a class="header-link" href="#6" title="Permanent link">&para;</a></h2>
<h3 id="61">6.1 기본 타임스탬프 순서<a class="header-link" href="#61" title="Permanent link">&para;</a></h3>
<p>잠금 대신, 각 트랜잭션 <code>T_i</code>는 시작 시 <strong>고유 타임스탬프</strong> <code>TS(T_i)</code>를 할당받는다. 프로토콜은 충돌하는 연산이 타임스탬프 순서로 실행되도록 보장한다.</p>
<p><strong>데이터 항목 메타데이터:</strong>
- <code>W-timestamp(Q)</code>: Q를 성공적으로 쓴 트랜잭션의 가장 큰 타임스탬프
- <code>R-timestamp(Q)</code>: Q를 성공적으로 읽은 트랜잭션의 가장 큰 타임스탬프</p>
<p><strong>프로토콜:</strong></p>
<div class="highlight"><pre><span></span><code>트랜잭션 T_i가 데이터 항목 Q를 읽기 원함:

  if TS(T_i) &lt; W-timestamp(Q):
      // T_i가 이미 더 젊은 트랜잭션에 의해 덮어쓰여진
      // 값을 읽으려 함 → T_i가 &quot;너무 늦음&quot;
      거부: T_i를 롤백하고 새 타임스탬프로 재시작

  else:
      읽기 허용
      R-timestamp(Q) = max(R-timestamp(Q), TS(T_i))


트랜잭션 T_i가 데이터 항목 Q를 쓰기 원함:

  if TS(T_i) &lt; R-timestamp(Q):
      // 더 젊은 트랜잭션이 이미 오래된 값을 읽음
      // T_i의 쓰기가 그 읽기를 무효화할 것임 → 거부
      거부: T_i를 롤백하고 새 타임스탬프로 재시작

  if TS(T_i) &lt; W-timestamp(Q):
      // 더 젊은 트랜잭션이 이미 더 새로운 값을 씀
      // T_i의 쓰기가 &quot;구식&quot;
      거부: T_i를 롤백하고 새 타임스탬프로 재시작

  else:
      쓰기 허용
      W-timestamp(Q) = TS(T_i)
</code></pre></div>

<p><strong>특성:</strong>
- 충돌 직렬화 가능성 보장 (직렬화 순서 = 타임스탬프 순서)
- <strong>데드락 없음</strong> (트랜잭션이 기다리지 않음; 대신 롤백됨)
- <strong>연쇄 롤백</strong> 발생 가능 (기본 버전)
- 잠금보다 중단률이 높음 (비관적 vs. 낙관적 트레이드오프)</p>
<h3 id="62">6.2 예: 타임스탬프 순서<a class="header-link" href="#62" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code> TS(T₁) = 100, TS(T₂) = 200

초기: W-ts(A) = 0, R-ts(A) = 0, W-ts(B) = 0, R-ts(B) = 0

T₁: read(A)
    TS(T₁)=100 ≥ W-ts(A)=0 → 허용
    R-ts(A) = max(0, 100) = 100

T₂: read(A)
    TS(T₂)=200 ≥ W-ts(A)=0 → 허용
    R-ts(A) = max(100, 200) = 200

T₁: write(A)
    TS(T₁)=100 &lt; R-ts(A)=200 → 거부!
    (더 젊은 T₂가 이미 A를 읽음. T₁의 쓰기가
     T₂의 읽기를 무효화할 것임.)
    T₁이 롤백되고 새 타임스탬프로 재시작됨.
</code></pre></div>

<h3 id="63-thomas">6.3 Thomas의 쓰기 규칙<a class="header-link" href="#63-thomas" title="Permanent link">&para;</a></h3>
<p>쓰기에 대한 기본 타임스탬프 순서의 최적화:</p>
<div class="highlight"><pre><span></span><code>트랜잭션 T_i가 데이터 항목 Q를 쓰기 원함:

  if TS(T_i) &lt; R-timestamp(Q):
      거부 (기본 TO와 동일)

  if TS(T_i) &lt; W-timestamp(Q):
      // 기본 TO에서: 거부
      // Thomas의 쓰기 규칙: 쓰기를 무시 (건너뜀!)
      // 이유? 더 젊은 트랜잭션이 이미 더 새로운 값을 씀.
      // T_i의 쓰기가 어차피 덮어쓰여질 것임.
      // 이것은 안전함 왜냐하면 미래 트랜잭션이 T_i의 값을 보지 않을 것이기 때문.

  else:
      쓰기 허용
      W-timestamp(Q) = TS(T_i)
</code></pre></div>

<p><strong>예:</strong></p>
<div class="highlight"><pre><span></span><code>TS(T₁) = 100, TS(T₂) = 200

T₂: write(A) → W-ts(A) = 200
T₁: write(A) → TS(T₁)=100 &lt; W-ts(A)=200

기본 TO: T₁ 롤백
Thomas의 쓰기 규칙: T₁의 쓰기 건너뜀 (어차피 T₂에 의해 덮어쓰여질 것임)
                     T₁ 정상 진행
</code></pre></div>

<p><strong>주의</strong>: Thomas의 쓰기 규칙은 <strong>뷰 직렬화 가능</strong>하지만 <strong>충돌 직렬화 가능</strong>하지 않을 수 있는 스케줄을 허용한다 (쓰기를 효과적으로 재정렬하기 때문).</p>
<hr />
<h2 id="7-mvcc">7. 다중 버전 동시성 제어 (MVCC)<a class="header-link" href="#7-mvcc" title="Permanent link">&para;</a></h2>
<h3 id="71">7.1 개념<a class="header-link" href="#71" title="Permanent link">&para;</a></h3>
<p><strong>MVCC</strong>는 각 데이터 항목의 여러 버전을 유지한다. 각 쓰기는 오래된 값을 덮어쓰는 대신 새 버전을 생성한다. 읽기는 오래된 버전에 접근할 수 있으므로, 읽기자가 쓰기자를 차단하지 않고 그 반대도 마찬가지다.</p>
<div class="highlight"><pre><span></span><code>MVCC 버전:

데이터 항목 A:
  버전 1: value=100, T₁이 타임스탬프 100에 씀
  버전 2: value=150, T₃가 타임스탬프 150에 씀
  버전 3: value=200, T₅가 타임스탬프 200에 씀

T₂ (타임스탬프 120): 버전 1 읽음 (value=100)
  → 타임스탬프 ≤ 120인 최신 버전

T₄ (타임스탬프 180): 버전 2 읽음 (value=150)
  → 타임스탬프 ≤ 180인 최신 버전
</code></pre></div>

<h3 id="72-mvcc">7.2 MVCC 읽기와 쓰기 규칙<a class="header-link" href="#72-mvcc" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>트랜잭션 T_i가 데이터 항목 Q를 읽음:

    버전 Q_k 찾기, 여기서:
    <span class="k">-</span> W-timestamp(Q_k) ≤ TS(T_i)
    <span class="k">-</span> W-timestamp(Q_k)가 그런 가장 큰 타임스탬프
    Q_k의 값 반환


트랜잭션 T_i가 데이터 항목 Q를 씀:

    버전 Q_k 찾기, 여기서:
    <span class="k">-</span> W-timestamp(Q_k) ≤ TS(T_i) (가장 가까운 오래된 버전)

    Q_j를 Q_k 바로 다음 W-timestamp를 가진 버전이라 하자

    if TS(T_i) &lt; R-timestamp(Q_k):
        거부 (더 젊은 트랜잭션이 Q_k를 읽고 그것이 변경되지 않기를 기대)
    else:
        W-timestamp = TS(T_i)인 새 버전 Q_i 생성
</code></pre></div>

<h3 id="73-mvcc">7.3 MVCC 이점과 비용<a class="header-link" href="#73-mvcc" title="Permanent link">&para;</a></h3>
<p><strong>이점:</strong>
- <strong>읽기자가 쓰기자를 차단하지 않음</strong>: 읽기가 항상 적절한 버전을 찾음
- <strong>쓰기자가 읽기자를 차단하지 않음</strong>: 오래된 버전이 동시 읽기자에게 사용 가능하게 유지됨
- <strong>일관된 스냅샷</strong>: 각 트랜잭션이 일관된 시점 뷰를 봄
- <strong>감소된 경합</strong>: 읽기 중심 워크로드에 대한 주요 성능 개선</p>
<p><strong>비용:</strong>
- <strong>저장 오버헤드</strong>: 각 데이터 항목의 여러 버전
- <strong>가비지 수집</strong>: 오래된 버전을 정리해야 함 (PostgreSQL의 vacuum)
- <strong>버전 탐색</strong>: 올바른 버전을 찾는 데 시간이 걸림 (특히 많은 버전이 있을 때)</p>
<h3 id="74-postgresql-mvcc">7.4 PostgreSQL의 MVCC<a class="header-link" href="#74-postgresql-mvcc" title="Permanent link">&para;</a></h3>
<p>PostgreSQL은 각 튜플(행 버전)에 <strong>xmin</strong>과 <strong>xmax</strong> 필드를 사용하여 MVCC를 구현한다:</p>
<div class="highlight"><pre><span></span><code>튜플 헤더 필드:
┌────────┬────────┬───────────┬──────────┐
│  xmin  │  xmax  │  ctid     │  data    │
│ (생성자│(삭제자│(물리적    │          │
│  트랜잭션│ 트랜잭션│ 위치)     │          │
│  ID)   │ ID)    │           │          │
└────────┴────────┴───────────┴──────────┘

xmin: 이 버전을 생성한 트랜잭션 ID
xmax: 이 버전을 삭제/업데이트한 트랜잭션 ID (라이브면 0)
ctid: 다음 버전의 물리적 위치 (업데이트용)
</code></pre></div>

<p><strong>PostgreSQL에서 UPDATE가 작동하는 방식:</strong></p>
<div class="highlight"><pre><span></span><code><span class="nt">UPDATE</span><span class="w"> </span><span class="nt">전</span><span class="o">:</span>
<span class="err">┌──────────┬──────────┬───────────────────┐</span>
<span class="err">│</span><span class="w"> </span><span class="nt">xmin</span><span class="o">=</span><span class="nt">100</span><span class="w"> </span><span class="err">│</span><span class="w"> </span><span class="nt">xmax</span><span class="o">=</span><span class="nt">0</span><span class="w">   </span><span class="err">│</span><span class="w"> </span><span class="nt">name</span><span class="o">=</span><span class="s1">&#39;Alice&#39;</span><span class="w">      </span><span class="err">│</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="nt">현재</span><span class="w"> </span><span class="nt">버전</span>
<span class="err">└──────────┴──────────┴───────────────────┘</span>

<span class="nt">트랜잭션</span><span class="w"> </span><span class="nt">200이</span><span class="w"> </span><span class="nt">실행</span><span class="o">:</span><span class="w"> </span><span class="nt">UPDATE</span><span class="w"> </span><span class="nt">emp</span><span class="w"> </span><span class="nt">SET</span><span class="w"> </span><span class="nt">name</span><span class="o">=</span><span class="s1">&#39;ALICE&#39;</span><span class="w"> </span><span class="nt">WHERE</span><span class="w"> </span><span class="nt">id</span><span class="o">=</span><span class="nt">1</span><span class="o">;</span>

<span class="nt">UPDATE</span><span class="w"> </span><span class="nt">후</span><span class="o">:</span>
<span class="err">┌──────────┬──────────┬───────────────────┐</span>
<span class="err">│</span><span class="w"> </span><span class="nt">xmin</span><span class="o">=</span><span class="nt">100</span><span class="w"> </span><span class="err">│</span><span class="w"> </span><span class="nt">xmax</span><span class="o">=</span><span class="nt">200</span><span class="w"> </span><span class="err">│</span><span class="w"> </span><span class="nt">name</span><span class="o">=</span><span class="s1">&#39;Alice&#39;</span><span class="w">      </span><span class="err">│</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="nt">오래된</span><span class="w"> </span><span class="nt">버전</span><span class="w"> </span><span class="o">(</span><span class="nt">죽은</span><span class="w"> </span><span class="nt">튜플</span><span class="o">)</span>
<span class="err">└──────────┴──────────┴───────────────────┘</span>
<span class="err">┌──────────┬──────────┬───────────────────┐</span>
<span class="err">│</span><span class="w"> </span><span class="nt">xmin</span><span class="o">=</span><span class="nt">200</span><span class="w"> </span><span class="err">│</span><span class="w"> </span><span class="nt">xmax</span><span class="o">=</span><span class="nt">0</span><span class="w">   </span><span class="err">│</span><span class="w"> </span><span class="nt">name</span><span class="o">=</span><span class="s1">&#39;ALICE&#39;</span><span class="w">      </span><span class="err">│</span><span class="w">  </span><span class="err">←</span><span class="w"> </span><span class="nt">새</span><span class="w"> </span><span class="nt">버전</span>
<span class="err">└──────────┴──────────┴───────────────────┘</span>

<span class="nt">트랜잭션</span><span class="w"> </span><span class="nt">150</span><span class="w"> </span><span class="o">(</span><span class="nt">200</span><span class="w"> </span><span class="nt">전에</span><span class="w"> </span><span class="nt">시작</span><span class="o">):</span><span class="w"> </span><span class="nt">name</span><span class="o">=</span><span class="s1">&#39;Alice&#39;</span><span class="w"> </span><span class="nt">봄</span><span class="w"> </span><span class="o">(</span><span class="nt">xmin</span><span class="o">=</span><span class="nt">100</span><span class="o">,</span><span class="w"> </span><span class="nt">xmax</span><span class="o">=</span><span class="nt">200</span><span class="o">&gt;</span><span class="nt">150</span><span class="o">)</span>
<span class="nt">트랜잭션</span><span class="w"> </span><span class="nt">250</span><span class="w"> </span><span class="o">(</span><span class="nt">200</span><span class="w"> </span><span class="nt">후에</span><span class="w"> </span><span class="nt">시작</span><span class="o">):</span><span class="w">  </span><span class="nt">name</span><span class="o">=</span><span class="s1">&#39;ALICE&#39;</span><span class="w"> </span><span class="nt">봄</span><span class="w"> </span><span class="o">(</span><span class="nt">xmin</span><span class="o">=</span><span class="nt">200</span><span class="err">≤</span><span class="nt">250</span><span class="o">,</span><span class="w"> </span><span class="nt">xmax</span><span class="o">=</span><span class="nt">0</span><span class="o">)</span>
</code></pre></div>

<p><strong>가시성 규칙 (간소화):</strong>
튜플이 트랜잭션 T에 보이는 경우:
1. <code>xmin</code>이 커밋되고 <code>xmin ≤ snapshot_of(T)</code>
2. <code>xmax = 0</code> (삭제 안 됨) 또는 <code>xmax &gt; snapshot_of(T)</code> (T의 스냅샷 후 삭제됨)</p>
<p><strong>VACUUM</strong>: PostgreSQL의 가비지 수집기가 더 이상 어떤 활성 트랜잭션에도 보이지 않는 죽은 튜플을 제거한다.</p>
<div class="highlight"><pre><span></span><code><span class="c1">-- 수동 vacuum</span>
<span class="k">VACUUM</span><span class="w"> </span><span class="n">employees</span><span class="p">;</span>

<span class="c1">-- 분석과 함께 vacuum (통계도 업데이트)</span>
<span class="k">VACUUM</span><span class="w"> </span><span class="k">ANALYZE</span><span class="w"> </span><span class="n">employees</span><span class="p">;</span>

<span class="c1">-- 죽은 튜플 보기</span>
<span class="k">SELECT</span><span class="w"> </span><span class="n">relname</span><span class="p">,</span><span class="w"> </span><span class="n">n_dead_tup</span><span class="p">,</span><span class="w"> </span><span class="n">n_live_tup</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">pg_stat_user_tables</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">relname</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s1">&#39;employees&#39;</span><span class="p">;</span>
</code></pre></div>

<h3 id="75-mysql-innodb-mvcc">7.5 MySQL InnoDB의 MVCC<a class="header-link" href="#75-mysql-innodb-mvcc" title="Permanent link">&para;</a></h3>
<p>InnoDB는 MVCC 데이터를 다르게 저장한다:</p>
<div class="highlight"><pre><span></span><code>InnoDB MVCC:
<span class="k">-</span> 클러스터드 인덱스가 최신 버전 저장
<span class="k">-</span> 오래된 버전은 UNDO LOG (롤백 세그먼트)에 저장
<span class="k">-</span> 각 행은 숨겨진 컬럼 보유: DB_TRX_ID, DB_ROLL_PTR

┌────────────────────────────────────────┐
│ 클러스터드 인덱스 (최신 버전)            │
│ DB_TRX_ID=200 │ DB_ROLL_PTR=ptr1       │
│ name=&#39;ALICE&#39;                            │
└────────────────────────┬───────────────┘
                         │ (롤백 포인터 따라가기)
                         ▼
┌────────────────────────────────────────┐
│ Undo Log (이전 버전)                    │
│ DB_TRX_ID=100 │ DB_ROLL_PTR=null       │
│ name=&#39;Alice&#39;                            │
└────────────────────────────────────────┘
</code></pre></div>

<p><strong>PostgreSQL과의 주요 차이:</strong>
- PostgreSQL: 힙에 새 버전, 오래된 버전이 죽은 튜플이 됨
- InnoDB: 클러스터드 인덱스에 최신 버전, 오래된 버전은 undo log에
- InnoDB 접근: 힙 블로트 적음, 하지만 undo log가 커질 수 있음</p>
<hr />
<h2 id="8-occ">8. 낙관적 동시성 제어 (OCC)<a class="header-link" href="#8-occ" title="Permanent link">&para;</a></h2>
<h3 id="81">8.1 개념<a class="header-link" href="#81" title="Permanent link">&para;</a></h3>
<p><strong>낙관적 동시성 제어</strong> (또는 <strong>검증 기반</strong> 프로토콜)는 충돌이 드물다고 가정하고 트랜잭션이 자유롭게 실행하도록 하며, 커밋 시점에만 정확성을 검증한다.</p>
<div class="highlight"><pre><span></span><code>비관적 (잠금):
  &quot;충돌이 발생하지 않도록 방지&quot;
  접근 전에 잠금 → 안전 보장 → 대기/차단 가능

낙관적 (OCC):
  &quot;충돌이 없다고 가정, 마지막에 확인&quot;
  자유롭게 실행 → 커밋 시 검증 → 충돌 감지되면 중단
</code></pre></div>

<h3 id="82">8.2 세 단계<a class="header-link" href="#82" title="Permanent link">&para;</a></h3>
<p>각 트랜잭션은 세 단계를 거친다:</p>
<div class="highlight"><pre><span></span><code>┌──────────────┐    ┌──────────────┐    ┌──────────────┐
│   단계 1:    │    │   단계 2:    │    │   단계 3:    │
│    읽기      │ →  │    검증      │ →  │    쓰기      │
│              │    │              │    │              │
│ DB에서 읽기  │    │ 충돌         │    │ 쓰기를       │
│ 쓰기는       │    │ 확인         │    │ 데이터베이스에│
│ 개인 작업     │    │ 다른         │    │ 적용         │
│ 영역으로      │    │ 트랜잭션과   │    │              │
└──────────────┘    └──────────────┘    └──────────────┘
</code></pre></div>

<p><strong>단계 1 -- 읽기 단계:</strong>
- 모든 읽기는 데이터베이스에서 옴
- 모든 쓰기는 <strong>개인 작업 영역</strong>으로 (데이터베이스가 아님)
- 잠금이 획득되지 않음</p>
<p><strong>단계 2 -- 검증 단계:</strong>
- 트랜잭션의 읽기와 쓰기가 다른 동시 트랜잭션과 충돌하는지 확인
- 검증 성공하면, 쓰기 단계로 진행
- 검증 실패하면, 중단하고 재시작</p>
<p><strong>단계 3 -- 쓰기 단계:</strong>
- 개인 작업 영역의 변경사항을 데이터베이스에 적용
- 이 단계는 원자적으로 수행됨 (짧은 잠금 사용)</p>
<h3 id="83">8.3 검증 규칙<a class="header-link" href="#83" title="Permanent link">&para;</a></h3>
<p>각 트랜잭션 <code>T_i</code>는 <strong>검증 단계 시작</strong> 시 타임스탬프를 할당받는다. <code>TS(T_i)</code>를 이 타임스탬프라 하자.</p>
<p><code>T_i</code>의 검증을 위해, <code>TS(T_j) &lt; TS(T_i)</code> (T_j가 먼저 검증됨)인 모든 트랜잭션 <code>T_j</code>에 대해 확인:</p>
<div class="highlight"><pre><span></span><code>VALIDATE(T_i):
    for each T_j where TS(T_j) &lt; TS(T_i):

        // 조건 1: T_j가 T_i가 읽기 단계 시작 전에 세 단계 모두 완료
        if T_j completed write phase before T_i started read phase:
            OK (전혀 겹치지 않음)

        // 조건 2: T_j가 T_i가 쓰기 단계 시작 전에 쓰기 단계 완료,
        // 그리고 T_j의 쓰기 집합이 T_i의 읽기 집합과 교차하지 않음
        else if T_j completed write phase before T_i started validation:
            if WriteSet(T_j) ∩ ReadSet(T_i) == ∅:
                OK
            else:
                FAIL → T_i 중단

        // 조건 3: T_j가 아직 쓰기 단계 완료 안 함
        // 그리고 T_j의 쓰기 집합이 T_i의 읽기나 쓰기 집합과 교차하지 않음
        else:
            if WriteSet(T_j) ∩ ReadSet(T_i) == ∅
               AND WriteSet(T_j) ∩ WriteSet(T_i) == ∅:
                OK
            else:
                FAIL → T_i 중단

    return VALID
</code></pre></div>

<h3 id="84-occ">8.4 예: OCC 검증<a class="header-link" href="#84-occ" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">ReadSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">A</span><span class="o">,</span><span class="w"> </span><span class="n">B</span><span class="o">},</span><span class="w"> </span><span class="n">WriteSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">A</span><span class="o">}</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">ReadSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">B</span><span class="o">,</span><span class="w"> </span><span class="n">C</span><span class="o">},</span><span class="w"> </span><span class="n">WriteSet</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">C</span><span class="o">}</span>

<span class="err">타임라인</span><span class="o">:</span>
<span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="err">──읽기──┤──검증</span><span class="o">(</span><span class="n">ts</span><span class="o">=</span><span class="mi">1</span><span class="o">)</span><span class="err">──┤──쓰기──┤</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="err">────읽기────┤──검증</span><span class="o">(</span><span class="n">ts</span><span class="o">=</span><span class="mi">2</span><span class="o">)</span><span class="err">──┤──쓰기──┤</span>

<span class="n">T₂를</span><span class="w"> </span><span class="n">T₁에</span><span class="w"> </span><span class="err">대해</span><span class="w"> </span><span class="err">검증</span><span class="w"> </span><span class="o">(</span><span class="n">TS</span><span class="o">(</span><span class="n">T₁</span><span class="o">)=</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">TS</span><span class="o">(</span><span class="n">T₂</span><span class="o">)=</span><span class="mi">2</span><span class="o">):</span>
<span class="w">  </span><span class="n">T₁이</span><span class="w"> </span><span class="n">T₂가</span><span class="w"> </span><span class="err">검증</span><span class="w"> </span><span class="err">시작하기</span><span class="w"> </span><span class="err">전에</span><span class="w"> </span><span class="err">쓰기</span><span class="w"> </span><span class="err">완료</span><span class="o">?</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">예</span><span class="w"> </span><span class="o">(</span><span class="err">조건</span><span class="w"> </span><span class="mi">2</span><span class="o">)</span>
<span class="w">  </span><span class="n">WriteSet</span><span class="o">(</span><span class="n">T₁</span><span class="o">)</span><span class="w"> </span><span class="err">∩</span><span class="w"> </span><span class="n">ReadSet</span><span class="o">(</span><span class="n">T₂</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">A</span><span class="o">}</span><span class="w"> </span><span class="err">∩</span><span class="w"> </span><span class="o">{</span><span class="n">B</span><span class="o">,</span><span class="w"> </span><span class="n">C</span><span class="o">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">∅</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">충돌</span><span class="w"> </span><span class="err">없음</span><span class="o">!</span>
<span class="w">  </span><span class="n">T₂</span><span class="w"> </span><span class="err">유효</span><span class="w"> </span><span class="err">✓</span>

<span class="err">대신</span><span class="w"> </span><span class="n">WriteSet</span><span class="o">(</span><span class="n">T₁</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">B</span><span class="o">}</span><span class="err">이면</span><span class="o">:</span>
<span class="w">  </span><span class="n">WriteSet</span><span class="o">(</span><span class="n">T₁</span><span class="o">)</span><span class="w"> </span><span class="err">∩</span><span class="w"> </span><span class="n">ReadSet</span><span class="o">(</span><span class="n">T₂</span><span class="o">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">B</span><span class="o">}</span><span class="w"> </span><span class="err">∩</span><span class="w"> </span><span class="o">{</span><span class="n">B</span><span class="o">,</span><span class="w"> </span><span class="n">C</span><span class="o">}</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">{</span><span class="n">B</span><span class="o">}</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">충돌</span><span class="o">!</span>
<span class="w">  </span><span class="n">T₂</span><span class="w"> </span><span class="err">무효</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="err">중단하고</span><span class="w"> </span><span class="err">재시작</span>
</code></pre></div>

<h3 id="85-occ">8.5 OCC를 사용해야 할 때<a class="header-link" href="#85-occ" title="Permanent link">&para;</a></h3>
<p><strong>OCC가 이상적인 경우:</strong>
- 충돌이 <strong>드물</strong> (대부분 읽기 전용 워크로드)
- 트랜잭션이 <strong>짧음</strong> (검증 오버헤드가 작업에 비해 작음)
- 높은 경합이 잠금으로 과도한 차단을 일으킬 것</p>
<p><strong>OCC가 나쁜 경우:</strong>
- 충돌이 <strong>빈번</strong> (높은 중단률이 작업 낭비)
- 트랜잭션이 <strong>김</strong> (중단 후 재실행 비용이 높음)
- 쓰기 중심 워크로드 (많은 충돌)</p>
<p><strong>실제 사용:</strong>
- Google의 Spanner가 읽기-쓰기 트랜잭션에 OCC 변형 사용
- 많은 웹 응용 프로그램이 "낙관적 잠금" 패턴 사용 (버전 번호)</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 응용 프로그램 수준 낙관적 잠금 패턴:</span>
<span class="c1"># 단계 1: 버전과 함께 레코드 읽기</span>
<span class="n">row</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT *, version FROM products WHERE id = ?&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">product_id</span><span class="p">])</span>
<span class="n">old_version</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">version</span>

<span class="c1"># 단계 2: 새 값 계산 (응용 프로그램 코드에서)</span>
<span class="n">new_price</span> <span class="o">=</span> <span class="n">compute_new_price</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>

<span class="c1"># 단계 3: 버전 확인과 함께 쓰기</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span>
    <span class="s2">&quot;UPDATE products SET price = ?, version = version + 1 &quot;</span>
    <span class="s2">&quot;WHERE id = ? AND version = ?&quot;</span><span class="p">,</span>
    <span class="p">[</span><span class="n">new_price</span><span class="p">,</span> <span class="n">product_id</span><span class="p">,</span> <span class="n">old_version</span><span class="p">]</span>
<span class="p">)</span>

<span class="c1"># 단계 4: 업데이트 성공 확인</span>
<span class="k">if</span> <span class="n">result</span><span class="o">.</span><span class="n">rows_affected</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="c1"># 버전 변경됨 → 다른 사람이 수정 → 재시도</span>
    <span class="k">raise</span> <span class="n">ConflictError</span><span class="p">(</span><span class="s2">&quot;동시 수정 감지됨&quot;</span><span class="p">)</span>
</code></pre></div>

<hr />
<h2 id="9">9. 동시성 제어 방법 비교<a class="header-link" href="#9" title="Permanent link">&para;</a></h2>
<h3 id="91">9.1 요약 표<a class="header-link" href="#91" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>방법</th>
<th>접근</th>
<th>데드락</th>
<th>연쇄</th>
<th>최적 용도</th>
</tr>
</thead>
<tbody>
<tr>
<td>기본 2PL</td>
<td>비관적 (잠금)</td>
<td>가능</td>
<td>가능</td>
<td>범용</td>
</tr>
<tr>
<td>엄격한 2PL</td>
<td>비관적 (잠금)</td>
<td>가능</td>
<td>아니오 (쓰기)</td>
<td>대부분의 OLTP 시스템</td>
</tr>
<tr>
<td>엄밀한 2PL</td>
<td>비관적 (잠금)</td>
<td>가능</td>
<td>아니오</td>
<td>단순성이 중요할 때</td>
</tr>
<tr>
<td>타임스탬프 순서</td>
<td>낙관적 (타임스탬프)</td>
<td>불가능</td>
<td>가능</td>
<td>낮은 충돌 워크로드</td>
</tr>
<tr>
<td>Thomas의 쓰기 규칙</td>
<td>낙관적 (타임스탬프)</td>
<td>불가능</td>
<td>가능</td>
<td>쓰기 중심, 낮은 충돌</td>
</tr>
<tr>
<td>MVCC</td>
<td>다중 버전</td>
<td>구현에 따름</td>
<td>아니오 (스냅샷 통해)</td>
<td>읽기 중심, 혼합</td>
</tr>
<tr>
<td>OCC (검증)</td>
<td>낙관적 (검증)</td>
<td>불가능</td>
<td>아니오</td>
<td>대부분 읽기, 짧은 트랜잭션</td>
</tr>
</tbody>
</table>
<h3 id="92">9.2 결정 가이드<a class="header-link" href="#92" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>시작
  │
  ├─ 워크로드가 읽기 중심?
  │   ├─ 예 → MVCC (PostgreSQL, Oracle 스타일)
  │   └─ 아니오 → 계속
  │
  ├─ 충돌이 드물?
  │   ├─ 예 → OCC 또는 타임스탬프 순서
  │   └─ 아니오 → 계속
  │
  ├─ 범위 쿼리 / 술어 잠금 필요?
  │   ├─ 예 → 인덱스 범위 잠금을 포함한 2PL
  │   └─ 아니오 → 계속
  │
  ├─ 엄격한 복구 가능성 필요?
  │   ├─ 예 → 엄격한 2PL 또는 엄밀한 2PL
  │   └─ 아니오 → 기본 2PL로 충분할 수 있음
  │
  └─ 분산 시스템?
      ├─ 예 → MVCC + 분산 타임스탬프 (Spanner)
      └─ 아니오 → 엄격한 2PL이 안전한 기본값
</code></pre></div>

<h3 id="93">9.3 실제 시스템이 사용하는 것<a class="header-link" href="#93" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>데이터베이스</th>
<th>주요 방법</th>
</tr>
</thead>
<tbody>
<tr>
<td>PostgreSQL</td>
<td>MVCC (힙 기반) + Serializable용 SSI</td>
</tr>
<tr>
<td>MySQL InnoDB</td>
<td>MVCC (undo log) + Serializable용 넥스트 키 잠금</td>
</tr>
<tr>
<td>Oracle</td>
<td>MVCC (undo 테이블스페이스) + 행 수준 잠금</td>
</tr>
<tr>
<td>SQL Server</td>
<td>잠금 기반 (기본) + MVCC (SNAPSHOT 격리 선택)</td>
</tr>
<tr>
<td>CockroachDB</td>
<td>MVCC + SSI (기본적으로 직렬화 가능)</td>
</tr>
<tr>
<td>Google Spanner</td>
<td>MVCC + TrueTime + 2PL (외부 일관성)</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="10">10. 연습문제<a class="header-link" href="#10" title="Permanent link">&para;</a></h2>
<h3 id="_5">개념적 질문<a class="header-link" href="#_5" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 1</strong>: 공유(S)와 배타(X) 잠금의 차이를 설명하라. 왜 여러 S-잠금이 동일한 데이터 항목에 공존할 수 있지만 여러 X-잠금은 안 되는가?</p>
<p><strong>연습문제 2</strong>: 트랜잭션 T가 2PL을 따르지만 모든 잠금을 맨 처음(모든 읽기나 쓰기 전)에 획득하고 맨 마지막(마지막 연산 후)에 모두 해제한다. T가 엄격한 2PL을 따르는가? 엄밀한 2PL은? 둘 다? 설명하라.</p>
<p><strong>연습문제 3</strong>: Wait-Die와 Wound-Wait 데드락 방지 방식을 비교하라. 각각에 대해, 어떤 트랜잭션이 우선권을 얻는지와 기아가 왜 피해지는지 설명하라.</p>
<h3 id="_6">잠금 기반 프로토콜 문제<a class="header-link" href="#_6" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 4</strong>: 세 트랜잭션을 고려하라:</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">A</span><span class="o">),</span><span class="w"> </span><span class="n">write</span><span class="o">(</span><span class="n">A</span><span class="o">),</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">B</span><span class="o">),</span><span class="w"> </span><span class="n">write</span><span class="o">(</span><span class="n">B</span><span class="o">)</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">B</span><span class="o">),</span><span class="w"> </span><span class="n">write</span><span class="o">(</span><span class="n">B</span><span class="o">)</span>
<span class="n">T₃</span><span class="o">:</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">A</span><span class="o">),</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">B</span><span class="o">)</span>
</code></pre></div>

<p>(a) T₁과 T₃가 동시에 진행할 수 있지만 T₂가 대기해야 하는 엄격한 2PL 하의 가능한 실행을 보여라.
(b) 2PL 하에서 T₁과 T₂ 사이에 데드락이 발생할 수 있는가? 그렇다면, 시나리오를 보여라.</p>
<p><strong>연습문제 5</strong>: 다음 잠금 요청이 순서대로 도착한다고 고려하라:</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">lock</span><span class="o">-</span><span class="n">S</span><span class="o">(</span><span class="n">A</span><span class="o">)</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">lock</span><span class="o">-</span><span class="n">X</span><span class="o">(</span><span class="n">B</span><span class="o">)</span>
<span class="n">T₃</span><span class="o">:</span><span class="w"> </span><span class="n">lock</span><span class="o">-</span><span class="n">S</span><span class="o">(</span><span class="n">A</span><span class="o">)</span>
<span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">lock</span><span class="o">-</span><span class="n">X</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w">     </span><span class="err">→</span><span class="w"> </span><span class="n">wait</span><span class="w"> </span><span class="o">(</span><span class="n">T₂가</span><span class="w"> </span><span class="n">X</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w"> </span><span class="err">보유</span><span class="o">)</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">lock</span><span class="o">-</span><span class="n">S</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w">     </span><span class="err">→</span><span class="w"> </span><span class="o">?</span>
<span class="n">T₃</span><span class="o">:</span><span class="w"> </span><span class="n">lock</span><span class="o">-</span><span class="n">X</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w">     </span><span class="err">→</span><span class="w"> </span><span class="o">?</span>
</code></pre></div>

<p>(a) 각 단계에서 무슨 일이 일어나는가?
(b) 데드락이 있는가? 그렇다면, 대기-포 그래프의 사이클을 식별하라.
(c) Wait-Die가 이를 어떻게 해결하는가 (TS(T₁) &lt; TS(T₂) &lt; TS(T₃) 가정)?</p>
<p><strong>연습문제 6</strong>: 다중 세분도 잠금 시스템에서, 트랜잭션 T₁이 테이블 A의 행을 읽고 테이블 B의 특정 행을 배타적으로 업데이트하려 한다. 트랜잭션 T₂가 전체 테이블 B를 읽으려 한다. 각 트랜잭션이 획득해야 하는 의도 잠금을 보여주고 동시에 실행할 수 있는지 결정하라.</p>
<h3 id="mvcc">타임스탬프와 MVCC 문제<a class="header-link" href="#mvcc" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 7</strong>: TS(T₁)=100, TS(T₂)=150, TS(T₃)=200이 주어졌다. 초기 타임스탬프: W-ts(A)=0, R-ts(A)=0, W-ts(B)=0, R-ts(B)=0.</p>
<p>기본 타임스탬프 순서를 사용하여 다음 연산을 실행하라. 각 연산에 대해, 허용되는지 또는 거부되는지 명시하고, 타임스탬프를 업데이트하라.</p>
<div class="highlight"><pre><span></span><code><span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">A</span><span class="o">)</span>
<span class="n">T₃</span><span class="o">:</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">A</span><span class="o">)</span>
<span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">write</span><span class="o">(</span><span class="n">A</span><span class="o">)</span><span class="w">    </span><span class="err">←</span><span class="w"> </span><span class="err">무슨</span><span class="w"> </span><span class="err">일이</span><span class="w"> </span><span class="err">일어나는가</span><span class="o">?</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">write</span><span class="o">(</span><span class="n">A</span><span class="o">)</span>
<span class="n">T₃</span><span class="o">:</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">B</span><span class="o">)</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">write</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w">    </span><span class="err">←</span><span class="w"> </span><span class="err">무슨</span><span class="w"> </span><span class="err">일이</span><span class="w"> </span><span class="err">일어나는가</span><span class="o">?</span>
<span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">read</span><span class="o">(</span><span class="n">B</span><span class="o">)</span><span class="w">     </span><span class="err">←</span><span class="w"> </span><span class="err">무슨</span><span class="w"> </span><span class="err">일이</span><span class="w"> </span><span class="err">일어나는가</span><span class="o">?</span>
</code></pre></div>

<p>이제 Thomas의 쓰기 규칙을 사용하여 연습문제를 반복하라. 어떤 연산이 다른 결과를 가지는가?</p>
<p><strong>연습문제 8</strong>: PostgreSQL의 MVCC 구현에서, 다음이 단계별로 무슨 일이 일어나는지 설명하라:
1. 트랜잭션 T₁ (txid=100)이 행을 삽입
2. 트랜잭션 T₂ (txid=150)가 테이블을 읽음
3. 트랜잭션 T₁이 커밋
4. 트랜잭션 T₃ (txid=200)가 테이블을 읽음
5. 트랜잭션 T₂가 테이블을 다시 읽음</p>
<p>각 트랜잭션이 각 단계에서 무엇을 보는가? READ COMMITTED와 REPEATABLE READ 격리 수준 모두를 고려하라.</p>
<h3 id="occ">OCC 문제<a class="header-link" href="#occ" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 9</strong>: 세 트랜잭션이 OCC 하에서 실행된다:</p>
<div class="highlight"><pre><span></span><code><span class="n">T₁</span><span class="o">:</span><span class="w"> </span><span class="n">ReadSet</span><span class="o">={</span><span class="n">A</span><span class="o">,</span><span class="n">B</span><span class="o">},</span><span class="w"> </span><span class="n">WriteSet</span><span class="o">={</span><span class="n">A</span><span class="o">}</span><span class="w">     </span><span class="n">Start</span><span class="o">:</span><span class="w"> </span><span class="n">t</span><span class="o">=</span><span class="mi">0</span><span class="o">,</span><span class="w"> </span><span class="n">Validate</span><span class="o">:</span><span class="w"> </span><span class="n">t</span><span class="o">=</span><span class="mi">5</span>
<span class="n">T₂</span><span class="o">:</span><span class="w"> </span><span class="n">ReadSet</span><span class="o">={</span><span class="n">B</span><span class="o">,</span><span class="n">C</span><span class="o">},</span><span class="w"> </span><span class="n">WriteSet</span><span class="o">={</span><span class="n">B</span><span class="o">}</span><span class="w">     </span><span class="n">Start</span><span class="o">:</span><span class="w"> </span><span class="n">t</span><span class="o">=</span><span class="mi">1</span><span class="o">,</span><span class="w"> </span><span class="n">Validate</span><span class="o">:</span><span class="w"> </span><span class="n">t</span><span class="o">=</span><span class="mi">6</span>
<span class="n">T₃</span><span class="o">:</span><span class="w"> </span><span class="n">ReadSet</span><span class="o">={</span><span class="n">A</span><span class="o">,</span><span class="n">C</span><span class="o">},</span><span class="w"> </span><span class="n">WriteSet</span><span class="o">={</span><span class="n">C</span><span class="o">}</span><span class="w">     </span><span class="n">Start</span><span class="o">:</span><span class="w"> </span><span class="n">t</span><span class="o">=</span><span class="mi">2</span><span class="o">,</span><span class="w"> </span><span class="n">Validate</span><span class="o">:</span><span class="w"> </span><span class="n">t</span><span class="o">=</span><span class="mi">7</span>
</code></pre></div>

<p>(a) T₂를 T₁에 대해 검증하라. 통과하는가?
(b) T₃를 T₁과 T₂에 대해 검증하라. 통과하는가?
(c) T₁의 WriteSet이 {A} 대신 {B}이면, 어떤 검증이 변경되는가?</p>
<h3 id="_7">분석과 설계<a class="header-link" href="#_7" title="Permanent link">&para;</a></h3>
<p><strong>연습문제 10</strong>: 은행 응용 프로그램이 다음 트랜잭션 유형을 가진다:
- 잔액 조회 (하나의 계좌 읽기): 트랜잭션의 60%
- 이체 (두 계좌 쓰기): 트랜잭션의 30%
- 월말 보고서 (모든 계좌 읽기): 트랜잭션의 10%</p>
<p>어떤 동시성 제어 방식 (엄격한 2PL, MVCC, 또는 OCC)를 추천하는가? 처리량, 응답 시간, 각 트랜잭션 유형의 특성을 고려하여 답을 정당화하라.</p>
<p><strong>연습문제 11</strong>: PostgreSQL의 MVCC가 VACUUM을 필요로 하는 이유를 설명하라. VACUUM이 절대 실행되지 않으면 어떤 일이 일어나는가? 누락되거나 느린 VACUUM 프로세스의 증상은 무엇인가 (테이블 블로트, 트랜잭션 ID 랩어라운드)?</p>
<p><strong>연습문제 12</strong>: Google Spanner는 TrueTime (GPS + 원자 시계)을 사용하여 트랜잭션에 전역적으로 일관된 타임스탬프를 할당한다. 일반 시계 동기화(NTP)가 전역 분산 MVCC 시스템에 왜 충분하지 않은지 설명하라. TrueTime이 NTP가 보장할 수 없는 어떤 속성을 제공하는가?</p>
<hr />
<p><strong>이전</strong>: <a href="./10_Transaction_Theory.md">트랜잭션 이론</a> | <strong>다음</strong>: <a href="./12_Recovery_Systems.md">복구 시스템</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Database_Theory/10_Transaction_Theory.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">10. 트랜잭션 이론</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Database_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Database_Theory/12_Recovery_Systems.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">12. 복구 시스템</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}