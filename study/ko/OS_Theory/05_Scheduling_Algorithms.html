{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>스케줄링 알고리즘 - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/OS_Theory/">OS Theory</a>
    <span class="separator">/</span>
    <span class="current">스케줄링 알고리즘</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>스케줄링 알고리즘</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/OS_Theory/04_CPU_Scheduling_Basics.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">CPU 스케줄링 기초</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/OS_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/OS_Theory/06_Advanced_Scheduling.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">고급 스케줄링</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#_2">개요</a></li>
<li><a href="#_3">목차</a></li>
<li><a href="#1-fcfs-first-come-first-served">1. FCFS (First-Come, First-Served)</a><ul>
<li><a href="#_4">개념</a></li>
<li><a href="#1">예제 1: 기본</a></li>
<li><a href="#convoy-effect">Convoy Effect (호위 효과)</a></li>
<li><a href="#fcfs">FCFS 특징</a></li>
</ul>
</li>
<li><a href="#2-sjf-shortest-job-first">2. SJF (Shortest Job First)</a><ul>
<li><a href="#_5">개념</a></li>
<li><a href="#2-sjf">예제 2: SJF 비선점</a></li>
<li><a href="#_6">실행 시간 예측 문제</a></li>
</ul>
</li>
<li><a href="#3-srtf-shortest-remaining-time-first">3. SRTF (Shortest Remaining Time First)</a><ul>
<li><a href="#_7">개념</a></li>
<li><a href="#3-srtf">예제 3: SRTF</a></li>
<li><a href="#srtf">SRTF 특징</a></li>
</ul>
</li>
<li><a href="#4-priority-scheduling">4. Priority Scheduling</a><ul>
<li><a href="#_8">개념</a></li>
<li><a href="#4-priority">예제 4: Priority (비선점)</a></li>
<li><a href="#starvation-aging">Starvation과 Aging</a></li>
</ul>
</li>
<li><a href="#5-round-robin">5. Round Robin</a><ul>
<li><a href="#_9">개념</a></li>
<li><a href="#5-round-robin_1">예제 5: Round Robin</a></li>
<li><a href="#time-quantum">Time Quantum 영향</a></li>
</ul>
</li>
<li><a href="#6">6. 알고리즘 비교</a><ul>
<li><a href="#_10">종합 비교표</a></li>
<li><a href="#_11">동일 데이터 비교 예제</a></li>
</ul>
</li>
<li><a href="#7">7. 연습 문제</a><ul>
<li><a href="#1-fcfs">문제 1: FCFS</a></li>
<li><a href="#2-sjf_1">문제 2: SJF (비선점)</a></li>
<li><a href="#3-round-robin">문제 3: Round Robin</a></li>
<li><a href="#4-priority_1">문제 4: Priority (선점)</a></li>
<li><a href="#5">문제 5: 알고리즘 선택</a></li>
</ul>
</li>
<li><a href="#_12">다음 단계</a></li>
<li><a href="#_13">참고 자료</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="_1">스케줄링 알고리즘<a class="header-link" href="#_1" title="Permanent link">&para;</a></h1>
<h2 id="_2">개요<a class="header-link" href="#_2" title="Permanent link">&para;</a></h2>
<p>이 레슨에서는 다양한 CPU 스케줄링 알고리즘을 학습합니다. FCFS, SJF, SRTF, Priority, Round Robin 알고리즘의 동작 원리를 이해하고, 간트 차트를 통해 평균 대기 시간과 총 처리 시간을 계산합니다.</p>
<hr />
<h2 id="_3">목차<a class="header-link" href="#_3" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#1-fcfs-first-come-first-served">FCFS (First-Come, First-Served)</a></li>
<li><a href="#2-sjf-shortest-job-first">SJF (Shortest Job First)</a></li>
<li><a href="#3-srtf-shortest-remaining-time-first">SRTF (Shortest Remaining Time First)</a></li>
<li><a href="#4-priority-scheduling">Priority Scheduling</a></li>
<li><a href="#5-round-robin">Round Robin</a></li>
<li><a href="#6-알고리즘-비교">알고리즘 비교</a></li>
<li><a href="#7-연습-문제">연습 문제</a></li>
</ol>
<hr />
<h2 id="1-fcfs-first-come-first-served">1. FCFS (First-Come, First-Served)<a class="header-link" href="#1-fcfs-first-come-first-served" title="Permanent link">&para;</a></h2>
<h3 id="_4">개념<a class="header-link" href="#_4" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>FCFS = 먼저 도착한 프로세스를 먼저 처리
     = 가장 간단한 스케줄링 알고리즘
     = 비선점 (Non-preemptive)

┌─────────────────────────────────────────────────────────┐
│                      FCFS 동작                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Ready Queue (FIFO):                                   │
│  ┌───┐   ┌───┐   ┌───┐   ┌───┐                         │
│  │P1 │ → │P2 │ → │P3 │ → │P4 │ →  CPU                  │
│  └───┘   └───┘   └───┘   └───┘                         │
│  먼저     두번째   세번째   네번째                       │
│  도착     도착     도착     도착                         │
│                                                         │
│  실행 순서: P1 → P2 → P3 → P4                          │
│                                                         │
└─────────────────────────────────────────────────────────┘
</code></pre></div>

<h3 id="1">예제 1: 기본<a class="header-link" href="#1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>입력:
┌──────────┬───────────┬───────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │
├──────────┼───────────┼───────────┤
│    P1    │     0     │    24     │
│    P2    │     0     │     3     │
│    P3    │     0     │     3     │
└──────────┴───────────┴───────────┘

간트 차트 (순서: P1 → P2 → P3):
┌────────────────────────────────────┬──────┬──────┐
│               P1                   │  P2  │  P3  │
└────────────────────────────────────┴──────┴──────┘
0                                   24     27     30

계산:
┌──────────┬────────────┬───────────────────────┐
│ 프로세스  │ 대기 시간   │ 총 처리 시간           │
├──────────┼────────────┼───────────────────────┤
│    P1    │ 0          │ 24 - 0 = 24           │
│    P2    │ 24         │ 27 - 0 = 27           │
│    P3    │ 27         │ 30 - 0 = 30           │
├──────────┼────────────┼───────────────────────┤
│   평균    │ (0+24+27)/3 = 17 │ (24+27+30)/3 = 27│
└──────────┴────────────┴───────────────────────┘
</code></pre></div>

<h3 id="convoy-effect">Convoy Effect (호위 효과)<a class="header-link" href="#convoy-effect" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>┌─────────────────────────────────────────────────────────┐
│                    Convoy Effect                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  긴 프로세스가 먼저 도착하면:                            │
│  ┌────────────────────────┬──┬──┬──┐                    │
│  │          P1 (긴 작업)    │P2│P3│P4│                    │
│  └────────────────────────┴──┴──┴──┘                    │
│  0                        100                           │
│                                                         │
│  짧은 프로세스들이 긴 프로세스를 기다림                   │
│  → 평균 대기 시간 크게 증가                              │
│                                                         │
│  만약 순서가 바뀌었다면 (P2, P3, P4, P1):                │
│  ┌──┬──┬──┬────────────────────────┐                    │
│  │P2│P3│P4│          P1 (긴 작업)    │                    │
│  └──┴──┴──┴────────────────────────┘                    │
│  0  3  6  9                       109                   │
│                                                         │
│  짧은 작업들이 빠르게 완료됨                             │
│  → 평균 대기 시간 감소                                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
</code></pre></div>

<h3 id="fcfs">FCFS 특징<a class="header-link" href="#fcfs" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>┌──────────┬─────────────────────────────────────────────┐
│   장점    │ • 구현이 매우 간단 (FIFO 큐)                 │
│          │ • 기아(Starvation) 없음                     │
│          │ • 공정함 (먼저 온 순서대로)                   │
├──────────┼─────────────────────────────────────────────┤
│   단점    │ • Convoy Effect 발생 가능                   │
│          │ • 평균 대기 시간이 길어질 수 있음             │
│          │ • I/O-bound 프로세스에 불리                  │
├──────────┼─────────────────────────────────────────────┤
│ 적합한 상황│ • 모든 프로세스의 실행 시간이 비슷한 경우    │
│          │ • 배치 시스템                               │
└──────────┴─────────────────────────────────────────────┘
</code></pre></div>

<hr />
<h2 id="2-sjf-shortest-job-first">2. SJF (Shortest Job First)<a class="header-link" href="#2-sjf-shortest-job-first" title="Permanent link">&para;</a></h2>
<h3 id="_5">개념<a class="header-link" href="#_5" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>SJF = 실행 시간이 가장 짧은 프로세스를 먼저 실행
    = 최적의 평균 대기 시간 제공 (비선점 경우)
    = 비선점 (Non-preemptive)

┌─────────────────────────────────────────────────────────┐
│                      SJF 동작                           │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Ready Queue에서 실행 시간이 가장 짧은 것 선택:          │
│                                                         │
│  ┌───┐   ┌───┐   ┌───┐   ┌───┐                         │
│  │P1 │   │P2 │   │P3 │   │P4 │                         │
│  │24 │   │ 3 │   │ 3 │   │ 5 │  ← 실행 시간            │
│  └───┘   └───┘   └───┘   └───┘                         │
│                                                         │
│  선택 순서: P2(3) → P3(3) → P4(5) → P1(24)             │
│                                                         │
└─────────────────────────────────────────────────────────┘
</code></pre></div>

<h3 id="2-sjf">예제 2: SJF 비선점<a class="header-link" href="#2-sjf" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>입력:
┌──────────┬───────────┬───────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │
├──────────┼───────────┼───────────┤
│    P1    │     0     │     6     │
│    P2    │     2     │     8     │
│    P3    │     4     │     7     │
│    P4    │     5     │     3     │
└──────────┴───────────┴───────────┘

간트 차트:
시간 0: P1만 도착 → P1 실행
시간 6: P1 완료, P2,P3,P4 중 가장 짧은 P4 선택
시간 9: P4 완료, P2,P3 중 가장 짧은 P3 선택
시간 16: P3 완료, P2 실행
시간 24: P2 완료

┌──────────┬─────┬──────────┬────────────┐
│    P1    │ P4  │    P3    │     P2     │
└──────────┴─────┴──────────┴────────────┘
0          6     9         16          24

계산:
┌──────────┬─────────────────────────┬───────────────────────┐
│ 프로세스  │ 대기 시간                │ 총 처리 시간           │
├──────────┼─────────────────────────┼───────────────────────┤
│    P1    │ 0 - 0 = 0              │ 6 - 0 = 6             │
│    P2    │ 16 - 2 = 14            │ 24 - 2 = 22           │
│    P3    │ 9 - 4 = 5              │ 16 - 4 = 12           │
│    P4    │ 6 - 5 = 1              │ 9 - 5 = 4             │
├──────────┼─────────────────────────┼───────────────────────┤
│   평균    │ (0+14+5+1)/4 = 5       │ (6+22+12+4)/4 = 11    │
└──────────┴─────────────────────────┴───────────────────────┘
</code></pre></div>

<h3 id="_6">실행 시간 예측 문제<a class="header-link" href="#_6" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>┌─────────────────────────────────────────────────────────┐
│              SJF의 실행 시간 예측 문제                   │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  문제: 프로세스의 다음 CPU burst 길이를 어떻게 알 수 있나?│
│                                                         │
│  해결책: 과거 기록을 기반으로 예측 (지수 평균)           │
│                                                         │
│  τ(n+1) = α <span class="gs">* t(n) + (1 - α) *</span> τ(n)                    │
│                                                         │
│  여기서:                                                │
│  τ(n+1) = 다음 CPU burst 예측값                        │
│  t(n)   = 실제 n번째 CPU burst 값                      │
│  τ(n)   = 이전 예측값                                  │
│  α      = 0 ≤ α ≤ 1 (가중치)                          │
│                                                         │
│  α = 0.5 예시:                                         │
│  ┌───────┬────────┬────────┬────────┐                  │
│  │  n    │ t(n)   │ τ(n)   │ τ(n+1) │                  │
│  ├───────┼────────┼────────┼────────┤                  │
│  │  0    │   -    │  10    │   -    │                  │
│  │  1    │   6    │  10    │   8    │                  │
│  │  2    │   4    │   8    │   6    │                  │
│  │  3    │   6    │   6    │   6    │                  │
│  └───────┴────────┴────────┴────────┘                  │
│                                                         │
└─────────────────────────────────────────────────────────┘
</code></pre></div>

<hr />
<h2 id="3-srtf-shortest-remaining-time-first">3. SRTF (Shortest Remaining Time First)<a class="header-link" href="#3-srtf-shortest-remaining-time-first" title="Permanent link">&para;</a></h2>
<h3 id="_7">개념<a class="header-link" href="#_7" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>SRTF = SJF의 선점 버전
     = 남은 실행 시간이 가장 짧은 프로세스 선택
     = 새 프로세스 도착 시 선점 가능

┌─────────────────────────────────────────────────────────┐
│                      SRTF 동작                          │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  시간 0: P1(6) 실행 중                                  │
│  시간 2: P2(8) 도착                                    │
│     P1 남은 시간 = 4                                   │
│     P2 남은 시간 = 8                                   │
│     → P1(4) &lt; P2(8) → P1 계속 실행                     │
│                                                         │
│  시간 4: P3(7) 도착                                    │
│     P1 남은 시간 = 2                                   │
│     P2 남은 시간 = 8                                   │
│     P3 남은 시간 = 7                                   │
│     → P1(2) 가장 짧음 → P1 계속 실행                   │
│                                                         │
│  시간 5: P4(3) 도착                                    │
│     P1 남은 시간 = 1                                   │
│     → P1(1) 가장 짧음 → P1 계속 실행                   │
│                                                         │
└─────────────────────────────────────────────────────────┘
</code></pre></div>

<h3 id="3-srtf">예제 3: SRTF<a class="header-link" href="#3-srtf" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>입력:
┌──────────┬───────────┬───────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │
├──────────┼───────────┼───────────┤
│    P1    │     0     │     8     │
│    P2    │     1     │     4     │
│    P3    │     2     │     9     │
│    P4    │     3     │     5     │
└──────────┴───────────┴───────────┘

간트 차트 분석:
시간 0: P1(8) 실행 시작
시간 1: P2(4) 도착
        P1 남은=7, P2 남은=4 → P2로 선점!
시간 2: P3(9) 도착
        P1 남은=7, P2 남은=3, P3 남은=9 → P2 계속
시간 3: P4(5) 도착
        P1 남은=7, P2 남은=2, P3 남은=9, P4 남은=5 → P2 계속
시간 5: P2 완료
        P1 남은=7, P3 남은=9, P4 남은=5 → P4 선택
시간 10: P4 완료
        P1 남은=7, P3 남은=9 → P1 선택
시간 17: P1 완료
        P3 남은=9 → P3 선택
시간 26: P3 완료

┌──┬────────┬──────────┬──────────────┬──────────────────┐
│P1│   P2   │    P4    │      P1      │        P3        │
└──┴────────┴──────────┴──────────────┴──────────────────┘
0  1        5         10             17                 26

계산:
┌──────────┬─────────────────────────────────┬─────────────────────┐
│ 프로세스  │ 대기 시간                        │ 총 처리 시간         │
├──────────┼─────────────────────────────────┼─────────────────────┤
│    P1    │ (10-1)-(0) = 9                 │ 17 - 0 = 17         │
│    P2    │ 0 (선점 후 바로 실행)            │ 5 - 1 = 4           │
│    P3    │ 17 - 2 = 15                    │ 26 - 2 = 24         │
│    P4    │ 5 - 3 = 2                      │ 10 - 3 = 7          │
├──────────┼─────────────────────────────────┼─────────────────────┤
│   평균    │ (9+0+15+2)/4 = 6.5             │ (17+4+24+7)/4 = 13  │
└──────────┴─────────────────────────────────┴─────────────────────┘
</code></pre></div>

<h3 id="srtf">SRTF 특징<a class="header-link" href="#srtf" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>┌──────────┬─────────────────────────────────────────────┐
│   장점    │ • 이론적으로 최적의 평균 대기 시간           │
│          │ • 짧은 프로세스에 우선권                     │
├──────────┼─────────────────────────────────────────────┤
│   단점    │ • 실행 시간 예측 필요                       │
│          │ • 긴 프로세스가 기아 상태에 빠질 수 있음      │
│          │ • 컨텍스트 스위치 오버헤드                   │
├──────────┼─────────────────────────────────────────────┤
│  Starvation│ 짧은 프로세스가 계속 도착하면               │
│  (기아)    │ 긴 프로세스는 영원히 실행되지 못할 수 있음   │
└──────────┴─────────────────────────────────────────────┘
</code></pre></div>

<hr />
<h2 id="4-priority-scheduling">4. Priority Scheduling<a class="header-link" href="#4-priority-scheduling" title="Permanent link">&para;</a></h2>
<h3 id="_8">개념<a class="header-link" href="#_8" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Priority Scheduling = 우선순위가 높은 프로세스를 먼저 실행
                    = 선점/비선점 모두 가능
                    = 낮은 숫자 = 높은 우선순위 (일반적)

┌─────────────────────────────────────────────────────────┐
│                  Priority Scheduling                    │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Ready Queue에서 우선순위 비교:                          │
│                                                         │
│  ┌───┐   ┌───┐   ┌───┐   ┌───┐                         │
│  │P1 │   │P2 │   │P3 │   │P4 │                         │
│  │ 3 │   │ 1 │   │ 4 │   │ 2 │  ← 우선순위             │
│  └───┘   └───┘   └───┘   └───┘                         │
│                                                         │
│  선택 순서: P2(1) → P4(2) → P1(3) → P3(4)              │
│                                                         │
│  우선순위 결정 기준:                                    │
│  • 내부: 시간 제한, 메모리 요구량, I/O 대 CPU 비율      │
│  • 외부: 사용자 중요도, 비용, 정치적 요소               │
│                                                         │
└─────────────────────────────────────────────────────────┘
</code></pre></div>

<h3 id="4-priority">예제 4: Priority (비선점)<a class="header-link" href="#4-priority" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>입력:
┌──────────┬───────────┬───────────┬──────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │ 우선순위  │
├──────────┼───────────┼───────────┼──────────┤
│    P1    │     0     │    10     │    3     │
│    P2    │     0     │     1     │    1     │
│    P3    │     0     │     2     │    4     │
│    P4    │     0     │     1     │    5     │
│    P5    │     0     │     5     │    2     │
└──────────┴───────────┴───────────┴──────────┘
(낮은 숫자 = 높은 우선순위)

간트 차트:
우선순위 순서: P2(1) → P5(2) → P1(3) → P3(4) → P4(5)

┌──┬───────┬────────────┬────┬──┐
│P2│  P5   │     P1     │ P3 │P4│
└──┴───────┴────────────┴────┴──┘
0  1       6           16   18 19

계산:
┌──────────┬────────────┬───────────────────────┐
│ 프로세스  │ 대기 시간   │ 총 처리 시간           │
├──────────┼────────────┼───────────────────────┤
│    P1    │ 6          │ 16                    │
│    P2    │ 0          │ 1                     │
│    P3    │ 16         │ 18                    │
│    P4    │ 18         │ 19                    │
│    P5    │ 1          │ 6                     │
├──────────┼────────────┼───────────────────────┤
│   평균    │ 8.2        │ 12                    │
└──────────┴────────────┴───────────────────────┘
</code></pre></div>

<h3 id="starvation-aging">Starvation과 Aging<a class="header-link" href="#starvation-aging" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>┌─────────────────────────────────────────────────────────┐
│              기아(Starvation) 문제                       │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  문제 상황:                                             │
│  ┌────────────────────────────────────────────────────┐ │
│  │  Ready Queue:                                      │ │
│  │  P(우선순위 낮음) ──────────────────────────────▶   │ │
│  │        ↑ 높은 우선순위 프로세스가 계속 도착        │ │
│  │  P(고), P(고), P(고), P(고), ...                  │ │
│  │                                                    │ │
│  │  낮은 우선순위 프로세스는 영원히 실행 안 됨         │ │
│  └────────────────────────────────────────────────────┘ │
│                                                         │
│  해결책: Aging (에이징)                                 │
│  ┌────────────────────────────────────────────────────┐ │
│  │  대기 시간이 증가하면 우선순위를 점진적으로 높임     │ │
│  │                                                    │ │
│  │  시간 0: P 우선순위 = 100 (낮음)                   │ │
│  │  시간 10: P 우선순위 = 90                         │ │
│  │  시간 20: P 우선순위 = 80                         │ │
│  │  ...                                              │ │
│  │  시간 100: P 우선순위 = 0 (최고) → 결국 실행됨     │ │
│  │                                                    │ │
│  │  → 기아 문제 해결                                  │ │
│  └────────────────────────────────────────────────────┘ │
│                                                         │
└─────────────────────────────────────────────────────────┘
</code></pre></div>

<hr />
<h2 id="5-round-robin">5. Round Robin<a class="header-link" href="#5-round-robin" title="Permanent link">&para;</a></h2>
<h3 id="_9">개념<a class="header-link" href="#_9" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Round Robin (RR) = 시분할 시스템을 위한 알고리즘
                 = 각 프로세스에 동일한 시간(Time Quantum) 할당
                 = 선점 (Preemptive)
                 = FCFS + 선점

┌─────────────────────────────────────────────────────────┐
│                   Round Robin 동작                      │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Time Quantum (타임 퀀텀) = 4ms                         │
│                                                         │
│  Ready Queue (순환):                                   │
│  ┌───┐   ┌───┐   ┌───┐                                 │
│  │P1 │ → │P2 │ → │P3 │ ─┐                              │
│  └───┘   └───┘   └───┘   │                             │
│    ↑                     │                              │
│    └─────────────────────┘                              │
│                                                         │
│  동작:                                                  │
│  1. P1이 4ms 동안 실행                                 │
│  2. 타임 퀀텀 만료 → P1은 Ready Queue 끝으로           │
│  3. P2가 4ms 동안 실행                                 │
│  4. 반복...                                            │
│                                                         │
└─────────────────────────────────────────────────────────┘
</code></pre></div>

<h3 id="5-round-robin_1">예제 5: Round Robin<a class="header-link" href="#5-round-robin_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>입력:
┌──────────┬───────────┬───────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │
├──────────┼───────────┼───────────┤
│    P1    │     0     │    24     │
│    P2    │     0     │     3     │
│    P3    │     0     │     3     │
└──────────┴───────────┴───────────┘

Time Quantum = 4ms

간트 차트:
시간 0: P1 실행 (4ms)
시간 4: P1 중단 (남은=20), P2 실행 (3ms에 완료)
시간 7: P2 완료, P3 실행 (3ms에 완료)
시간 10: P3 완료, P1 실행 (4ms)
시간 14: P1 중단 (남은=16), 다른 프로세스 없음, P1 실행
시간 18: P1 중단 (남은=12), P1 실행
시간 22: P1 중단 (남은=8), P1 실행
시간 26: P1 중단 (남은=4), P1 실행
시간 30: P1 완료

┌────┬───┬───┬────┬────┬────┬────┬────┐
│ P1 │P2 │P3 │ P1 │ P1 │ P1 │ P1 │ P1 │
└────┴───┴───┴────┴────┴────┴────┴────┘
0    4   7  10   14   18   22   26   30

계산:
┌──────────┬────────────┬───────────────────────┐
│ 프로세스  │ 대기 시간   │ 총 처리 시간           │
├──────────┼────────────┼───────────────────────┤
│    P1    │ 30-24 = 6  │ 30 - 0 = 30           │
│    P2    │ 4 - 0 = 4  │ 7 - 0 = 7             │
│    P3    │ 7 - 0 = 7  │ 10 - 0 = 10           │
├──────────┼────────────┼───────────────────────┤
│   평균    │ (6+4+7)/3 = 5.67│ (30+7+10)/3 = 15.67│
└──────────┴────────────┴───────────────────────┘
</code></pre></div>

<h3 id="time-quantum">Time Quantum 영향<a class="header-link" href="#time-quantum" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>┌─────────────────────────────────────────────────────────┐
│              Time Quantum의 영향                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Time Quantum이 매우 크면:                              │
│  ┌─────────────────────────────────────────────────┐    │
│  │  → FCFS와 동일해짐                               │    │
│  │  → 응답 시간 증가                                │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  Time Quantum이 매우 작으면:                            │
│  ┌─────────────────────────────────────────────────┐    │
│  │  → 컨텍스트 스위치 오버헤드 증가                  │    │
│  │  → CPU 시간 낭비                                 │    │
│  └─────────────────────────────────────────────────┘    │
│                                                         │
│  권장 Time Quantum:                                    │
│  • 평균 CPU burst의 80%가 Time Quantum 내에 완료되도록  │
│  • 일반적으로 10~100ms                                 │
│  • Context switch time의 10배 이상                    │
│                                                         │
│  시각화:                                                │
│                                                         │
│  q=∞: │P1(전체)                    │P2(전체)    │P3...  │
│       └────────────────────────────┴───────────┴──...  │
│                                                         │
│  q=1: │P│P│P│P│P│P│...│ ← 컨텍스트 스위치 너무 많음    │
│       └─┴─┴─┴─┴─┴─┴...┘                                │
│                                                         │
│  적절한 q: │──P1──│──P2──│──P1──│──P3──│...│           │
│           └──────┴──────┴──────┴──────┴...┘            │
│                                                         │
└─────────────────────────────────────────────────────────┘
</code></pre></div>

<hr />
<h2 id="6">6. 알고리즘 비교<a class="header-link" href="#6" title="Permanent link">&para;</a></h2>
<h3 id="_10">종합 비교표<a class="header-link" href="#_10" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>┌─────────────┬────────┬─────────┬─────────┬─────────────┬──────────┐
│  알고리즘    │  선점   │  기아   │ 평균대기 │    구현      │   특징    │
├─────────────┼────────┼─────────┼─────────┼─────────────┼──────────┤
│ FCFS        │   X    │   X     │  길다   │ 매우 단순   │Convoy효과│
├─────────────┼────────┼─────────┼─────────┼─────────────┼──────────┤
│ SJF         │   X    │   O     │  최적   │ 실행시간예측│ 기아가능 │
├─────────────┼────────┼─────────┼─────────┼─────────────┼──────────┤
│ SRTF        │   O    │   O     │  최적   │ 실행시간예측│ 기아가능 │
├─────────────┼────────┼─────────┼─────────┼─────────────┼──────────┤
│ Priority    │  O/X   │   O     │  다양   │ 우선순위관리│Aging필요 │
├─────────────┼────────┼─────────┼─────────┼─────────────┼──────────┤
│ RR          │   O    │   X     │  중간   │ 단순       │TQ선택중요│
└─────────────┴────────┴─────────┴─────────┴─────────────┴──────────┘
</code></pre></div>

<h3 id="_11">동일 데이터 비교 예제<a class="header-link" href="#_11" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>입력:
┌──────────┬───────────┬───────────┐
│ 프로세스  │ 도착 시간  │ 실행 시간  │
├──────────┼───────────┼───────────┤
│    P1    │     0     │     7     │
│    P2    │     2     │     4     │
│    P3    │     4     │     1     │
│    P4    │     5     │     4     │
└──────────┴───────────┴───────────┘

FCFS:
┌────────────────┬─────────┬──┬─────────┐
│       P1       │    P2   │P3│   P4    │
└────────────────┴─────────┴──┴─────────┘
0                7        11 12        16
평균 대기 시간: (0 + 5 + 7 + 7) / 4 = 4.75

SJF (비선점):
┌────────────────┬──┬─────────┬─────────┐
│       P1       │P3│    P4   │   P2    │
└────────────────┴──┴─────────┴─────────┘
0                7  8        12        16
평균 대기 시간: (0 + 10 + 3 + 3) / 4 = 4.00

SRTF:
┌────┬─────────┬──┬─────────┬────────┐
│ P1 │   P2    │P3│   P4    │   P1   │
└────┴─────────┴──┴─────────┴────────┘
0    2         6  7        11       16
평균 대기 시간: (9 + 0 + 2 + 2) / 4 = 3.25

RR (q=2):
┌────┬────┬────┬──┬────┬────┬────┐
│ P1 │ P2 │ P1 │P3│ P4 │ P2 │ P1 │
└────┴────┴────┴──┴────┴────┴────┘
0    2    4    6  7    9   11   14   16
평균 대기 시간: 계산 필요...

결론: SRTF가 가장 짧은 평균 대기 시간 제공
</code></pre></div>

<hr />
<h2 id="7">7. 연습 문제<a class="header-link" href="#7" title="Permanent link">&para;</a></h2>
<h3 id="1-fcfs">문제 1: FCFS<a class="header-link" href="#1-fcfs" title="Permanent link">&para;</a></h3>
<p>다음 프로세스에 대해 FCFS 스케줄링을 적용하고 평균 대기 시간을 계산하세요.</p>
<table>
<thead>
<tr>
<th>프로세스</th>
<th>도착 시간</th>
<th>실행 시간</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>0</td>
<td>5</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>P3</td>
<td>2</td>
<td>8</td>
</tr>
<tr>
<td>P4</td>
<td>3</td>
<td>6</td>
</tr>
</tbody>
</table>
<details>
<summary>정답 보기</summary>

**간트 차트:**

<div class="highlight"><pre><span></span><code>┌───────┬─────┬──────────┬────────┐
│  P1   │ P2  │    P3    │   P4   │
└───────┴─────┴──────────┴────────┘
0       5     8         16       22
</code></pre></div>



**계산:**
- P1 대기: 0
- P2 대기: 5 - 1 = 4
- P3 대기: 8 - 2 = 6
- P4 대기: 16 - 3 = 13

**평균 대기 시간:** (0 + 4 + 6 + 13) / 4 = **5.75**

</details>

<h3 id="2-sjf_1">문제 2: SJF (비선점)<a class="header-link" href="#2-sjf_1" title="Permanent link">&para;</a></h3>
<p>문제 1과 동일한 데이터에 대해 SJF(비선점)를 적용하세요.</p>
<details>
<summary>정답 보기</summary>

**간트 차트:**

<div class="highlight"><pre><span></span><code>시간 0: P1(5) 실행 (P1만 도착)
시간 5: P1 완료, P2(3), P3(8), P4(6) 중 P2 선택
시간 8: P2 완료, P3(8), P4(6) 중 P4 선택
시간 14: P4 완료, P3 선택
시간 22: P3 완료

┌───────┬─────┬────────┬──────────┐
│  P1   │ P2  │   P4   │    P3    │
└───────┴─────┴────────┴──────────┘
0       5     8       14        22
</code></pre></div>



**계산:**
- P1 대기: 0
- P2 대기: 5 - 1 = 4
- P3 대기: 14 - 2 = 12
- P4 대기: 8 - 3 = 5

**평균 대기 시간:** (0 + 4 + 12 + 5) / 4 = **5.25**

</details>

<h3 id="3-round-robin">문제 3: Round Robin<a class="header-link" href="#3-round-robin" title="Permanent link">&para;</a></h3>
<p>문제 1과 동일한 데이터에 대해 RR(Time Quantum = 2)를 적용하세요.</p>
<details>
<summary>정답 보기</summary>

**간트 차트:**

<div class="highlight"><pre><span></span><code>시간 0-2: P1(남은 3)
시간 2-4: P2(남은 1) - P2가 시간 1에 도착했으므로
시간 4-6: P3(남은 6) - P3가 시간 2에 도착
시간 6-8: P4(남은 4) - P4가 시간 3에 도착
시간 8-10: P1(남은 1)
시간 10-11: P2 완료
시간 11-13: P3(남은 4)
시간 13-15: P4(남은 2)
시간 15-16: P1 완료
시간 16-18: P3(남은 2)
시간 18-20: P4 완료
시간 20-22: P3 완료

┌──┬──┬──┬──┬──┬─┬──┬──┬─┬──┬──┬──┐
│P1│P2│P3│P4│P1│P2│P3│P4│P1│P3│P4│P3│
└──┴──┴──┴──┴──┴─┴──┴──┴─┴──┴──┴──┘
0  2  4  6  8 10 11 13 15 16 18 20 22
</code></pre></div>



**대기 시간 계산:**
- P1: 16 - 0 - 5 = 11 (총 처리 16, 실행 5)
- P2: 11 - 1 - 3 = 7 (총 처리 10, 도착 1, 실행 3)
- P3: 22 - 2 - 8 = 12
- P4: 20 - 3 - 6 = 11

**평균 대기 시간:** (11 + 7 + 12 + 11) / 4 = **10.25**

</details>

<h3 id="4-priority_1">문제 4: Priority (선점)<a class="header-link" href="#4-priority_1" title="Permanent link">&para;</a></h3>
<p>다음 데이터에 대해 Priority(선점) 스케줄링을 적용하세요.
(낮은 숫자 = 높은 우선순위)</p>
<table>
<thead>
<tr>
<th>프로세스</th>
<th>도착 시간</th>
<th>실행 시간</th>
<th>우선순위</th>
</tr>
</thead>
<tbody>
<tr>
<td>P1</td>
<td>0</td>
<td>4</td>
<td>2</td>
</tr>
<tr>
<td>P2</td>
<td>1</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>P3</td>
<td>2</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>P4</td>
<td>3</td>
<td>5</td>
<td>4</td>
</tr>
</tbody>
</table>
<details>
<summary>정답 보기</summary>

**간트 차트:**

<div class="highlight"><pre><span></span><code>시간 0: P1(우선순위 2) 실행
시간 1: P2(우선순위 1) 도착 → P1 선점, P2 실행
시간 4: P2 완료, P1(우선순위 2), P3(우선순위 3), P4(우선순위 4) 중 P1 선택
시간 7: P1 완료, P3와 P4 중 P3 선택
시간 9: P3 완료, P4 선택
시간 14: P4 완료

┌─┬─────┬─────┬────┬────────────┐
│P1│  P2 │ P1  │ P3 │     P4     │
└─┴─────┴─────┴────┴────────────┘
0 1     4     7    9           14
</code></pre></div>



**대기 시간:**
- P1: 4-1 = 3 (시간 1에 선점됨, 시간 4에 재개)
- P2: 0
- P3: 7 - 2 = 5
- P4: 9 - 3 = 6

**평균 대기 시간:** (3 + 0 + 5 + 6) / 4 = **3.5**

</details>

<h3 id="5">문제 5: 알고리즘 선택<a class="header-link" href="#5" title="Permanent link">&para;</a></h3>
<p>다음 상황에 가장 적합한 스케줄링 알고리즘을 선택하고 이유를 설명하세요.</p>
<ol>
<li>배치 처리 시스템에서 처리량을 최대화하고 싶다</li>
<li>대화형 시스템에서 응답 시간을 최소화하고 싶다</li>
<li>모든 프로세스를 공정하게 처리하고 싶다</li>
</ol>
<details>
<summary>정답 보기</summary>

1. **SJF (또는 SRTF)**
   - 짧은 작업을 먼저 처리하여 평균 대기 시간 최소화
   - 처리량 최대화
   - 배치 시스템에서는 실행 시간 예측이 가능한 경우가 많음

2. **Round Robin**
   - 모든 프로세스에 빠르게 CPU 시간 할당
   - 응답 시간이 짧음
   - 적절한 Time Quantum 선택이 중요

3. **Round Robin** 또는 **FCFS**
   - 모든 프로세스에 동등한 기회 제공
   - FCFS: 도착 순서대로 공정하게 처리
   - RR: 각 프로세스에 동일한 시간 할당
   - 기아 현상 없음

</details>

<hr />
<h2 id="_12">다음 단계<a class="header-link" href="#_12" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="./06_Advanced_Scheduling.md">06_Advanced_Scheduling.md</a> - MLFQ, 멀티프로세서 스케줄링, 실시간 스케줄링</li>
</ul>
<hr />
<h2 id="_13">참고 자료<a class="header-link" href="#_13" title="Permanent link">&para;</a></h2>
<ul>
<li><a href="https://pages.cs.wisc.edu/~remzi/OSTEP/cpu-sched-mlfq.pdf">OSTEP - Scheduling: The Multi-Level Feedback Queue</a></li>
<li><a href="https://www.os-book.com/">Operating System Concepts - Chapter 5</a></li>
<li><a href="https://github.com/topics/process-scheduling-simulator">Process Scheduling Simulator</a></li>
</ul>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/OS_Theory/04_CPU_Scheduling_Basics.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">CPU 스케줄링 기초</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/OS_Theory/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/OS_Theory/06_Advanced_Scheduling.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">고급 스케줄링</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}