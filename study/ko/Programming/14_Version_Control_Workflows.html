{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>버전 관리와 협업 - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Programming/">Programming</a>
    <span class="separator">/</span>
    <span class="current">버전 관리와 협업</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>버전 관리와 협업</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Programming/13_API_Design.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">API 설계 원칙</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Programming/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Programming/15_Software_Architecture.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">소프트웨어 아키텍처 기초</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#_2">소개</a></li>
<li><a href="#_3">버전 관리의 간략한 역사</a><ul>
<li><a href="#vs">중앙 집중식 vs 분산</a></li>
</ul>
</li>
<li><a href="#git">Git 기초(빠른 복습)</a><ul>
<li><a href="#_4">저장소, 커밋, 브랜치</a></li>
<li><a href="#_5">세 가지 트리</a></li>
<li><a href="#merge-vs-rebase">Merge vs Rebase</a></li>
</ul>
</li>
<li><a href="#_6">브랜칭 전략</a><ul>
<li><a href="#1-git-flow">1. Git Flow</a></li>
<li><a href="#2-github-flow">2. GitHub Flow</a></li>
<li><a href="#3">3. 트랙 기반 개발</a></li>
<li><a href="#_7">비교 표</a></li>
</ul>
</li>
<li><a href="#_8">풀 리퀘스트 / 머지 리퀘스트</a><ul>
<li><a href="#pr">좋은 PR의 구조</a></li>
<li><a href="#pr-vs-pr">작은 PR vs 큰 PR</a></li>
</ul>
</li>
<li><a href="#_9">코드 리뷰 모범 사례</a><ul>
<li><a href="#_10">무엇을 확인할 것인가</a></li>
<li><a href="#_11">건설적 피드백</a></li>
<li><a href="#_12">자동화할 수 있는 것은 자동화</a></li>
<li><a href="#_13">코드 리뷰 체크리스트</a></li>
</ul>
</li>
<li><a href="#_14">병합 전략</a><ul>
<li><a href="#1">1. 병합 커밋</a></li>
<li><a href="#2">2. 스쿼시와 병합</a></li>
<li><a href="#3_1">3. 리베이스와 병합</a></li>
<li><a href="#_15">권장사항</a></li>
</ul>
</li>
<li><a href="#cicd">CI/CD 기초</a><ul>
<li><a href="#ci">CI 파이프라인 예제</a></li>
<li><a href="#cd">CD 파이프라인 예제</a></li>
<li><a href="#_16">파이프라인 단계</a></li>
</ul>
</li>
<li><a href="#vs_1">모노레포 vs 폴리레포</a><ul>
<li><a href="#_17">모노레포</a></li>
<li><a href="#_18">폴리레포</a></li>
<li><a href="#_19">권장사항</a></li>
</ul>
</li>
<li><a href="#_20">시맨틱 버전 관리</a></li>
<li><a href="#_21">커밋 메시지 규칙</a><ul>
<li><a href="#_22">관례적 커밋</a></li>
<li><a href="#_23">의미 있는 메시지 작성</a></li>
</ul>
</li>
<li><a href="#_24">연습 문제</a><ul>
<li><a href="#1_1">연습 문제 1: 브랜칭 전략 선택</a></li>
<li><a href="#2_1">연습 문제 2: 코드 리뷰 체크리스트 작성</a></li>
<li><a href="#3-cicd">연습 문제 3: CI/CD 파이프라인 설계</a></li>
<li><a href="#4-pr">연습 문제 4: PR 품질 평가</a></li>
<li><a href="#5">연습 문제 5: 시맨틱 버전 관리</a></li>
</ul>
</li>
<li><a href="#_25">요약</a></li>
<li><a href="#_26">내비게이션</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="_1">버전 관리와 협업<a class="header-link" href="#_1" title="Permanent link">&para;</a></h1>
<blockquote>
<p><strong>토픽</strong>: Programming
<strong>레슨</strong>: 14 of 16
<strong>선수 지식</strong>: 기본 Git 지식(clone, commit, push, pull), 명령줄 익숙함
<strong>목표</strong>: 전문 소프트웨어 개발을 위한 브랜칭 전략, 코드 리뷰 관행, CI/CD 기초, 협업 워크플로우 마스터</p>
</blockquote>
<h2 id="_2">소개<a class="header-link" href="#_2" title="Permanent link">&para;</a></h2>
<p>버전 관리는 현대 소프트웨어 개발의 기초입니다. 이를 통해:
- <strong>히스토리 추적</strong>: 모든 변경 사항이 컨텍스트와 함께 기록됨
- <strong>협업</strong>: 여러 개발자가 충돌 없이 동시에 작업
- <strong>실험</strong>: 위험한 변경을 두려움 없이 시도
- <strong>롤백 기능</strong>: 실수를 쉽게 되돌림
- <strong>코드 리뷰</strong>: 병합 전 체계적 품질 게이트</p>
<p>이 레슨은 팀을 생산적으로 만드는 버전 관리 도구 위에 구축된 <strong>워크플로우</strong>—인간 프로세스—를 다룹니다.</p>
<h2 id="_3">버전 관리의 간략한 역사<a class="header-link" href="#_3" title="Permanent link">&para;</a></h2>
<p>진화를 이해하면 현대 도구가 왜 그런 방식으로 작동하는지 이해하는 데 도움이 됩니다:</p>
<ol>
<li><strong>RCS(1982)</strong>: 단일 파일 잠금, 한 번에 한 개발자</li>
<li><strong>CVS(1986)</strong>: 다중 파일 버전 관리, 동시 편집</li>
<li><strong>SVN/Subversion(2000)</strong>: 중앙 집중식 서버, 원자적 커밋, 더 나은 바이너리 처리</li>
<li><strong>Git(2005)</strong>: 분산, 브랜칭 우선 설계, 매우 빠름</li>
<li><strong>Mercurial(2005)</strong>: 분산, Git보다 단순, 적은 채택</li>
</ol>
<p><strong>주요 패러다임 전환</strong>: <strong>중앙 집중식(Centralized)</strong>(SVN) → <strong>분산(Distributed)</strong>(Git)</p>
<h3 id="vs">중앙 집중식 vs 분산<a class="header-link" href="#vs" title="Permanent link">&para;</a></h3>
<p><strong>중앙 집중식(SVN)</strong>:</p>
<div class="highlight"><pre><span></span><code>        중앙 서버
             |
     +-------+-------+
     |       |       |
  개발자 A 개발자 B 개발자 C
</code></pre></div>

<ul>
<li>서버의 단일 진실 공급원</li>
<li>커밋에 네트워크 연결 필요</li>
<li>브랜치가 비쌈(서버에 전체 복사본)</li>
</ul>
<p><strong>분산(Git)</strong>:</p>
<div class="highlight"><pre><span></span><code>    원격 저장소(GitHub/GitLab)
             |
     +-------+-------+
     |       |       |
   로컬    로컬    로컬
  저장소 A 저장소 B 저장소 C
</code></pre></div>

<ul>
<li>모든 개발자가 전체 히스토리 보유</li>
<li>커밋은 로컬(빠르고, 오프라인 가능)</li>
<li>브랜치가 저렴(커밋에 대한 포인터)</li>
<li>Push/pull로 원격과 동기화</li>
</ul>
<h2 id="git">Git 기초(빠른 복습)<a class="header-link" href="#git" title="Permanent link">&para;</a></h2>
<p>워크플로우로 들어가기 전에 다음 개념을 이해하고 있는지 확인하세요:</p>
<h3 id="_4">저장소, 커밋, 브랜치<a class="header-link" href="#_4" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># 저장소: 모든 히스토리를 포함하는 .git 폴더</span>
git<span class="w"> </span>init

<span class="c1"># 커밋: 특정 시점의 프로젝트 스냅샷</span>
git<span class="w"> </span>add<span class="w"> </span>file.txt
git<span class="w"> </span>commit<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Add feature X&quot;</span>

<span class="c1"># 브랜치: 커밋에 대한 이동 가능한 포인터</span>
git<span class="w"> </span>branch<span class="w"> </span>feature-login
git<span class="w"> </span>checkout<span class="w"> </span>feature-login<span class="w">  </span><span class="c1"># 또는: git checkout -b feature-login</span>
</code></pre></div>

<h3 id="_5">세 가지 트리<a class="header-link" href="#_5" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>작업 디렉토리  →  스테이징 영역  →  저장소
              (git add)      (git commit)
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1"># 파일 수정</span>
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Hello&quot;</span><span class="w"> </span>&gt;<span class="w"> </span>file.txt

<span class="c1"># 변경 사항 스테이징</span>
git<span class="w"> </span>add<span class="w"> </span>file.txt

<span class="c1"># 저장소에 커밋</span>
git<span class="w"> </span>commit<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Add greeting&quot;</span>
</code></pre></div>

<h3 id="merge-vs-rebase">Merge vs Rebase<a class="header-link" href="#merge-vs-rebase" title="Permanent link">&para;</a></h3>
<p><strong>Merge</strong>: 브랜치를 결합하고 히스토리 보존</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>checkout<span class="w"> </span>main
git<span class="w"> </span>merge<span class="w"> </span>feature-branch
</code></pre></div>

<div class="highlight"><pre><span></span><code>    A---B---C  main
         \   \
          D---E  feature-branch
</code></pre></div>

<p><strong>Rebase</strong>: 다른 브랜치 위에 커밋을 재생하여 히스토리 재작성</p>
<div class="highlight"><pre><span></span><code>git<span class="w"> </span>checkout<span class="w"> </span>feature-branch
git<span class="w"> </span>rebase<span class="w"> </span>main
</code></pre></div>

<div class="highlight"><pre><span></span><code>    A---B---C  main
             \
              D&#39;---E&#39;  feature-branch (rebased)
</code></pre></div>

<p><strong>언제 사용</strong>:
- <strong>Merge</strong>: 공개 브랜치, 완전한 히스토리 보존
- <strong>Rebase</strong>: 비공개 브랜치, 더 깨끗한 선형 히스토리</p>
<h2 id="_6">브랜칭 전략<a class="header-link" href="#_6" title="Permanent link">&para;</a></h2>
<p>브랜칭 전략은 속도, 안정성, 협업의 균형을 맞추기 위해 <strong>팀이 코드 변경을 조직하는 방법</strong>을 정의합니다.</p>
<h3 id="1-git-flow">1. Git Flow<a class="header-link" href="#1-git-flow" title="Permanent link">&para;</a></h3>
<p><strong>Git Flow</strong>는 여러 장기 브랜치를 가진 구조화된 브랜칭 모델입니다.</p>
<p><strong>브랜치</strong>:
- <strong>main</strong>: 프로덕션 준비 코드
- <strong>develop</strong>: 기능을 위한 통합 브랜치
- <strong>feature/</strong>: 새 기능(develop에서 분기)
- <strong>release/</strong>: 릴리스 준비(develop에서 분기)
- <strong>hotfix/</strong>: 긴급 수정(main에서 분기)</p>
<p><strong>워크플로우</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 새 기능 시작</span>
git<span class="w"> </span>checkout<span class="w"> </span>develop
git<span class="w"> </span>checkout<span class="w"> </span>-b<span class="w"> </span>feature/user-authentication

<span class="c1"># 기능 작업</span>
git<span class="w"> </span>commit<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Add login form&quot;</span>
git<span class="w"> </span>commit<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Add password validation&quot;</span>

<span class="c1"># develop으로 다시 병합</span>
git<span class="w"> </span>checkout<span class="w"> </span>develop
git<span class="w"> </span>merge<span class="w"> </span>feature/user-authentication

<span class="c1"># 릴리스 준비</span>
git<span class="w"> </span>checkout<span class="w"> </span>-b<span class="w"> </span>release/v1.2.0
<span class="c1"># 버그 수정, 버전 번호 업데이트</span>
git<span class="w"> </span>checkout<span class="w"> </span>main
git<span class="w"> </span>merge<span class="w"> </span>release/v1.2.0
git<span class="w"> </span>tag<span class="w"> </span>v1.2.0

<span class="c1"># 프로덕션 핫픽스</span>
git<span class="w"> </span>checkout<span class="w"> </span>main
git<span class="w"> </span>checkout<span class="w"> </span>-b<span class="w"> </span>hotfix/security-patch
git<span class="w"> </span>commit<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Fix CVE-2024-1234&quot;</span>
git<span class="w"> </span>checkout<span class="w"> </span>main
git<span class="w"> </span>merge<span class="w"> </span>hotfix/security-patch
git<span class="w"> </span>tag<span class="w"> </span>v1.2.1
git<span class="w"> </span>checkout<span class="w"> </span>develop
git<span class="w"> </span>merge<span class="w"> </span>hotfix/security-patch
</code></pre></div>

<p><strong>장점</strong>:
- 명확한 관심사 분리
- 예정된 릴리스에 적합(예: 월별)
- 기능과 릴리스의 병렬 개발</p>
<p><strong>단점</strong>:
- 많은 브랜치로 복잡
- 소규모 팀이나 지속적 배포에는 오버헤드
- develop에서 병합 충돌이 누적될 수 있음</p>
<p><strong>최적</strong>: 예정된 릴리스가 있는 전통적 소프트웨어(분기별, 월별).</p>
<h3 id="2-github-flow">2. GitHub Flow<a class="header-link" href="#2-github-flow" title="Permanent link">&para;</a></h3>
<p><strong>GitHub Flow</strong>는 하나의 장기 브랜치 <code>main</code>을 가진 단순화된 워크플로우입니다.</p>
<p><strong>워크플로우</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># main에서 기능 브랜치 생성</span>
git<span class="w"> </span>checkout<span class="w"> </span>main
git<span class="w"> </span>pull<span class="w"> </span>origin<span class="w"> </span>main
git<span class="w"> </span>checkout<span class="w"> </span>-b<span class="w"> </span>add-search-feature

<span class="c1"># 변경</span>
git<span class="w"> </span>commit<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Add search endpoint&quot;</span>
git<span class="w"> </span>commit<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Add search UI&quot;</span>

<span class="c1"># Push하고 Pull Request 열기</span>
git<span class="w"> </span>push<span class="w"> </span>origin<span class="w"> </span>add-search-feature
<span class="c1"># GitHub에서 PR 열기</span>

<span class="c1"># 코드 리뷰와 CI 통과 후, PR 병합</span>
<span class="c1"># 브랜치 삭제</span>
</code></pre></div>

<p><strong>규칙</strong>:
1. <code>main</code>은 항상 배포 가능
2. 설명적인 브랜치 이름 생성(<code>fix-login-bug</code>, <code>patch-1</code> 아님)
3. 논의를 위해 PR을 일찍 열기
4. 병합 후 <code>main</code>에서 배포</p>
<p><strong>장점</strong>:
- 단순: 추적할 브랜치가 하나
- 빠른 반복
- 지속적 배포와 작동</p>
<p><strong>단점</strong>:
- 강력한 CI/CD 필요
- main의 불완전한 기능에 기능 플래그 필요
- 대규모 팀에는 구조가 적음</p>
<p><strong>최적</strong>: 지속적 배포를 하는 웹 애플리케이션, 중소 규모 팀.</p>
<h3 id="3">3. 트랙 기반 개발<a class="header-link" href="#3" title="Permanent link">&para;</a></h3>
<p><strong>트랙 기반 개발(Trunk-Based Development)</strong>은 단기 브랜치(&lt; 1일)와 빈번한 통합을 강조합니다.</p>
<p><strong>워크플로우</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 작은 변경은 main에 직접 커밋</span>
git<span class="w"> </span>checkout<span class="w"> </span>main
git<span class="w"> </span>pull<span class="w"> </span>origin<span class="w"> </span>main
<span class="c1"># 작은 변경</span>
git<span class="w"> </span>commit<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Refactor user service&quot;</span>
git<span class="w"> </span>push<span class="w"> </span>origin<span class="w"> </span>main

<span class="c1"># 큰 변경은 단기 브랜치 사용</span>
git<span class="w"> </span>checkout<span class="w"> </span>-b<span class="w"> </span>refactor-database
<span class="c1"># 몇 시간 작업</span>
git<span class="w"> </span>commit<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Extract repository pattern&quot;</span>
git<span class="w"> </span>push<span class="w"> </span>origin<span class="w"> </span>refactor-database
<span class="c1"># PR 열기, 빠른 리뷰, 당일 병합</span>
</code></pre></div>

<p><strong>규칙</strong>:
- 하루에 최소 한 번 <code>main</code>에 커밋
- 불완전한 기능에 기능 플래그 사용
- 장기 브랜치 없음
- 엄격한 자동화 테스트</p>
<p><strong>장점</strong>:
- 병합 충돌 최소화(빈번한 통합)
- 작고 점진적인 변경 장려
- 빠른 피드백 루프</p>
<p><strong>단점</strong>:
- 성숙한 CI/CD와 테스트 필요
- 기능 플래그가 복잡성 추가
- 강한 엔지니어링 규율 없이는 위험</p>
<p><strong>최적</strong>: 고성능 팀, 지속적 배포를 하는 SaaS 제품.</p>
<h3 id="_7">비교 표<a class="header-link" href="#_7" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>전략</th>
<th>브랜치 복잡도</th>
<th>릴리스 주기</th>
<th>팀 규모</th>
<th>CI/CD 필요</th>
</tr>
</thead>
<tbody>
<tr>
<td>Git Flow</td>
<td>높음</td>
<td>예정됨</td>
<td>대규모</td>
<td>보통</td>
</tr>
<tr>
<td>GitHub Flow</td>
<td>낮음</td>
<td>지속적</td>
<td>중소</td>
<td>높음</td>
</tr>
<tr>
<td>트랙 기반</td>
<td>매우 낮음</td>
<td>지속적</td>
<td>모두</td>
<td>매우 높음</td>
</tr>
</tbody>
</table>
<h2 id="_8">풀 리퀘스트 / 머지 리퀘스트<a class="header-link" href="#_8" title="Permanent link">&para;</a></h2>
<p><strong>풀 리퀘스트(PR)</strong>는 병합 전 코드 리뷰와 논의 메커니즘입니다.</p>
<h3 id="pr">좋은 PR의 구조<a class="header-link" href="#pr" title="Permanent link">&para;</a></h3>
<p><strong>1. 제목</strong>: 간결하고 설명적</p>
<div class="highlight"><pre><span></span><code>✅ OAuth2로 사용자 인증 추가
❌ 코드 업데이트
</code></pre></div>

<p><strong>2. 설명</strong>: 컨텍스트와 테스트 지침</p>
<div class="highlight"><pre><span></span><code><span class="gu">## 요약</span>
Google 로그인을 사용한 OAuth2 인증 플로우 구현.

<span class="gu">## 변경사항</span>
<span class="k">-</span><span class="w"> </span>OAuth2 클라이언트 라이브러리 추가
<span class="k">-</span><span class="w"> </span>로그인/콜백 라우트 생성
<span class="k">-</span><span class="w"> </span>Redis에 사용자 세션 저장
<span class="k">-</span><span class="w"> </span>인증 미들웨어 추가

<span class="gu">## 테스트</span>
<span class="k">1.</span> Redis 시작: <span class="sb">`docker run -p 6379:6379 redis`</span>
<span class="k">2.</span> <span class="sb">`.env`</span>에 환경 변수 설정
<span class="k">3.</span> <span class="sb">`/login`</span> 방문하여 Google로 로그인
<span class="k">4.</span> <span class="sb">`/dashboard`</span>로 리다이렉트 확인

<span class="gu">## 스크린샷</span>
[로그인 플로우 스크린샷]

<span class="gu">## 관련 이슈</span>
Closes <span class="ni">#123</span>
</code></pre></div>

<p><strong>3. 범위</strong>: 작은 PR이 더 빠르게 리뷰됨</p>
<div class="highlight"><pre><span></span><code><span class="err">✅</span><span class="w"> </span><span class="nt">50-200줄</span><span class="o">:</span><span class="w"> </span><span class="nt">빠른</span><span class="w"> </span><span class="nt">리뷰</span>
<span class="err">⚠️</span><span class="w"> </span><span class="nt">200-500줄</span><span class="o">:</span><span class="w"> </span><span class="nt">시간</span><span class="w"> </span><span class="nt">소요</span>
<span class="err">❌</span><span class="w"> </span><span class="nt">1000</span><span class="o">+</span><span class="nt">줄</span><span class="o">:</span><span class="w"> </span><span class="nt">피하기</span><span class="o">;</span><span class="w"> </span><span class="nt">여러</span><span class="w"> </span><span class="nt">PR로</span><span class="w"> </span><span class="nt">분할</span>
</code></pre></div>

<h3 id="pr-vs-pr">작은 PR vs 큰 PR<a class="header-link" href="#pr-vs-pr" title="Permanent link">&para;</a></h3>
<p><strong>작은 PR</strong>:
- 리뷰하기 쉬움(인지 부하 적음)
- 더 빠른 병합(컨텍스트 전환 적음)
- 낮은 위험(제한된 영향 범위)
- 더 빈번한 통합(충돌 적음)</p>
<p><strong>큰 PR</strong>:
- 리뷰 피로: 리뷰어가 주의 깊게 읽지 않고 승인
- 장기 브랜치: 병합 충돌 누적
- 높은 위험: 큰 변경은 되돌리기 어려움</p>
<p><strong>전략</strong>: 작업을 점진적 PR로 분할:</p>
<div class="highlight"><pre><span></span><code>❌ 하나의 PR: &quot;사용자 대시보드 구현&quot;(1500줄)

✅ 점진적 PR:
  1. &quot;사용자 모델과 데이터베이스 스키마 추가&quot;(100줄)
  2. &quot;사용자 서비스 API 추가&quot;(150줄)
  3. &quot;대시보드 UI 추가&quot;(200줄)
  4. &quot;대시보드 데이터 가져오기 추가&quot;(100줄)
</code></pre></div>

<h2 id="_9">코드 리뷰 모범 사례<a class="header-link" href="#_9" title="Permanent link">&para;</a></h2>
<p>코드 리뷰는 <strong>기술</strong>입니다. 작성자와 리뷰어 모두 신중해야 합니다.</p>
<h3 id="_10">무엇을 확인할 것인가<a class="header-link" href="#_10" title="Permanent link">&para;</a></h3>
<p><strong>1. 정확성</strong>: 코드가 작동하는가?
- 논리 오류
- 엣지 케이스 처리
- 오류 처리</p>
<p><strong>2. 설계</strong>: 잘 구조화되었는가?
- 관심사 분리
- 적절한 추상화
- 디자인 패턴 사용</p>
<p><strong>3. 복잡도</strong>: 이해하기 쉬운가?
- 지나치게 영리한 코드
- 명확하지 않은 논리에 대한 주석 누락</p>
<p><strong>4. 테스트</strong>: 적절히 테스트되었는가?
- 새 코드에 대한 테스트 커버리지
- 엣지 케이스 테스트
- 테스트가 읽기 쉬운가</p>
<p><strong>5. 보안</strong>: 취약점이 있는가?
- SQL 인젝션, XSS 위험
- 코드의 시크릿
- 인증/권한 부여</p>
<p><strong>6. 성능</strong>: 효율적인가?
- 불필요한 루프
- 비효율적인 데이터베이스 쿼리(N+1)
- 메모리 누수</p>
<p><strong>7. 스타일</strong>: 규칙을 따르는가?
- 네이밍 규칙
- 코드 포맷팅
- 문서화</p>
<h3 id="_11">건설적 피드백<a class="header-link" href="#_11" title="Permanent link">&para;</a></h3>
<p><strong>친절하고 구체적으로</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">❌</span><span class="w"> </span><span class="s2">&quot;잘못되었습니다.&quot;</span>
<span class="n">✅</span><span class="w"> </span><span class="s2">&quot;이 함수는 `data`가 null이면 예외를 던질 수 있습니다.</span>
<span class="s2">   23줄에 null 체크를 추가하는 것을 고려하세요.&quot;</span>

<span class="n">❌</span><span class="w"> </span><span class="s2">&quot;나쁜 네이밍.&quot;</span>
<span class="n">✅</span><span class="w"> </span><span class="s2">&quot;변수 이름 `d`가 불명확합니다. 명확성을 위해</span>
<span class="s2">   `daysUntilExpiration`으로 변경하는 것을 고려하세요.&quot;</span>
</code></pre></div>

<p><strong>요구하지 말고 질문하기</strong>:</p>
<div class="highlight"><pre><span></span><code>❌ &quot;HashMap을 사용하도록 변경하세요.&quot;
✅ &quot;O(n) 대신 O(1) 조회를 위해 여기서 HashMap을 사용할 수 있을까요?&quot;
</code></pre></div>

<p><strong>좋은 작업 칭찬</strong>:</p>
<div class="highlight"><pre><span></span><code>✅ &quot;좋은 리팩토링! 훨씬 더 읽기 쉽습니다.&quot;
✅ &quot;엣지 케이스에 대한 훌륭한 테스트 커버리지.&quot;
</code></pre></div>

<h3 id="_12">자동화할 수 있는 것은 자동화<a class="header-link" href="#_12" title="Permanent link">&para;</a></h3>
<p>기계가 확인할 수 있는 것에 인간 시간을 낭비하지 마세요:</p>
<ul>
<li><strong>린터</strong>: <code>eslint</code>, <code>pylint</code>, <code>rubocop</code></li>
<li><strong>포매터</strong>: <code>prettier</code>, <code>black</code>, <code>gofmt</code></li>
<li><strong>타입 체커</strong>: <code>TypeScript</code>, <code>mypy</code>, <code>Flow</code></li>
<li><strong>보안 스캐너</strong>: <code>Snyk</code>, <code>Dependabot</code></li>
</ul>
<p>CI에서 자동으로 실행되도록 구성하세요.</p>
<h3 id="_13">코드 리뷰 체크리스트<a class="header-link" href="#_13" title="Permanent link">&para;</a></h3>
<p>팀별 체크리스트 생성:</p>
<div class="highlight"><pre><span></span><code><span class="gu">## 코드 리뷰 체크리스트</span>

<span class="gu">### 기능</span>
<span class="k">- [ ]</span> 코드가 의도대로 작동함
<span class="k">- [ ]</span> 엣지 케이스 처리됨
<span class="k">- [ ]</span> 오류 처리가 적절함

<span class="gu">### 테스트</span>
<span class="k">- [ ]</span> 새 코드에 테스트 있음
<span class="k">- [ ]</span> 테스트가 포괄적임
<span class="k">- [ ]</span> 로컬에서 테스트 통과

<span class="gu">### 설계</span>
<span class="k">- [ ]</span> 코드가 모듈화되고 SOLID 원칙 따름
<span class="k">- [ ]</span> 불필요한 복잡성 없음

<span class="gu">### 보안</span>
<span class="k">- [ ]</span> 하드코딩된 시크릿 없음
<span class="k">- [ ]</span> 입력 유효성 검증 있음
<span class="k">- [ ]</span> 권한 확인이 올바름

<span class="gu">### 문서화</span>
<span class="k">- [ ]</span> 공개 API 문서화됨
<span class="k">- [ ]</span> README 업데이트됨(필요시)
</code></pre></div>

<h2 id="_14">병합 전략<a class="header-link" href="#_14" title="Permanent link">&para;</a></h2>
<p>PR을 병합할 때 세 가지 옵션이 있습니다:</p>
<h3 id="1">1. 병합 커밋<a class="header-link" href="#1" title="Permanent link">&para;</a></h3>
<p>전체 히스토리를 보존하는 병합 커밋 생성:</p>
<div class="highlight"><pre><span></span><code>    A---B---C  main
         \   \
          D---E  feature (F에서 병합 커밋)
               \
                F  main (병합 후)
</code></pre></div>

<div class="highlight"><pre><span></span><code>git<span class="w"> </span>checkout<span class="w"> </span>main
git<span class="w"> </span>merge<span class="w"> </span>--no-ff<span class="w"> </span>feature-branch
</code></pre></div>

<p><strong>장점</strong>: 전체 히스토리 보존, 전체 기능 되돌리기 쉬움
<strong>단점</strong>: 많은 병합 커밋으로 히스토리 복잡</p>
<h3 id="2">2. 스쿼시와 병합<a class="header-link" href="#2" title="Permanent link">&para;</a></h3>
<p>모든 기능 커밋을 하나로 결합:</p>
<div class="highlight"><pre><span></span><code>    A---B---C---D  main
         \
          E---F---G  feature (D로 스쿼시됨)
</code></pre></div>

<div class="highlight"><pre><span></span><code>git<span class="w"> </span>checkout<span class="w"> </span>main
git<span class="w"> </span>merge<span class="w"> </span>--squash<span class="w"> </span>feature-branch
git<span class="w"> </span>commit<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Add feature X (squashed)&quot;</span>
</code></pre></div>

<p><strong>장점</strong>: 깨끗한 선형 히스토리, 기능당 하나의 커밋
<strong>단점</strong>: 개별 커밋 히스토리 손실, bisect 어려움</p>
<h3 id="3_1">3. 리베이스와 병합<a class="header-link" href="#3_1" title="Permanent link">&para;</a></h3>
<p>main 위에 커밋 재생:</p>
<div class="highlight"><pre><span></span><code>    A---B---C  main
             \
              D&#39;---E&#39;  feature (rebased)
</code></pre></div>

<div class="highlight"><pre><span></span><code>git<span class="w"> </span>checkout<span class="w"> </span>feature-branch
git<span class="w"> </span>rebase<span class="w"> </span>main
git<span class="w"> </span>checkout<span class="w"> </span>main
git<span class="w"> </span>merge<span class="w"> </span>feature-branch<span class="w">  </span><span class="c1"># Fast-forward 병합</span>
</code></pre></div>

<p><strong>장점</strong>: 선형 히스토리, 개별 커밋 보존
<strong>단점</strong>: 히스토리 재작성(공개 브랜치는 리베이스하지 말 것)</p>
<h3 id="_15">권장사항<a class="header-link" href="#_15" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>스쿼시</strong>: 작은 기능, 버그 수정(가장 일반적)</li>
<li><strong>리베이스</strong>: 보존할 가치가 있는 잘 구조화된 커밋</li>
<li><strong>병합 커밋</strong>: 대규모 기능, 릴리스 브랜치</li>
</ul>
<h2 id="cicd">CI/CD 기초<a class="header-link" href="#cicd" title="Permanent link">&para;</a></h2>
<p><strong>지속적 통합(CI)</strong>: 모든 push에서 자동으로 코드 빌드 및 테스트.
<strong>지속적 전달(CD)</strong>: main 브랜치를 항상 배포 가능하게 유지.
<strong>지속적 배포</strong>: 테스트 통과 후 프로덕션에 자동 배포.</p>
<h3 id="ci">CI 파이프라인 예제<a class="header-link" href="#ci" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># .github/workflows/ci.yml (GitHub Actions)</span>
<span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">CI</span>

<span class="nt">on</span><span class="p">:</span>
<span class="w">  </span><span class="nt">push</span><span class="p">:</span>
<span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">main</span><span class="p p-Indicator">]</span>
<span class="w">  </span><span class="nt">pull_request</span><span class="p">:</span>
<span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">main</span><span class="p p-Indicator">]</span>

<span class="nt">jobs</span><span class="p">:</span>
<span class="w">  </span><span class="nt">test</span><span class="p">:</span>
<span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">ubuntu-latest</span>
<span class="w">    </span><span class="nt">steps</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">actions/checkout@v3</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Set up Node.js</span>
<span class="w">        </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">actions/setup-node@v3</span>
<span class="w">        </span><span class="nt">with</span><span class="p">:</span>
<span class="w">          </span><span class="nt">node-version</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;18&#39;</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Install dependencies</span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">npm ci</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Run linter</span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">npm run lint</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Run tests</span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">npm test</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Build</span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">npm run build</span>

<span class="w">  </span><span class="nt">security</span><span class="p">:</span>
<span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">ubuntu-latest</span>
<span class="w">    </span><span class="nt">steps</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">actions/checkout@v3</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Run security scan</span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">npm audit</span>
</code></pre></div>

<h3 id="cd">CD 파이프라인 예제<a class="header-link" href="#cd" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># .github/workflows/deploy.yml</span>
<span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Deploy</span>

<span class="nt">on</span><span class="p">:</span>
<span class="w">  </span><span class="nt">push</span><span class="p">:</span>
<span class="w">    </span><span class="nt">branches</span><span class="p">:</span><span class="w"> </span><span class="p p-Indicator">[</span><span class="nv">main</span><span class="p p-Indicator">]</span>

<span class="nt">jobs</span><span class="p">:</span>
<span class="w">  </span><span class="nt">deploy</span><span class="p">:</span>
<span class="w">    </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">ubuntu-latest</span>
<span class="w">    </span><span class="nt">steps</span><span class="p">:</span>
<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">actions/checkout@v3</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Run tests</span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">npm test</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Build Docker image</span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker build -t myapp:${{ github.sha }} .</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Push to registry</span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">docker push myapp:${{ github.sha }}</span>

<span class="w">      </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Deploy to production</span>
<span class="w">        </span><span class="nt">run</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">kubectl set image deployment/myapp myapp=myapp:${{ github.sha }}</span>
</code></pre></div>

<h3 id="_16">파이프라인 단계<a class="header-link" href="#_16" title="Permanent link">&para;</a></h3>
<p>일반적인 순서의 단계:
1. <strong>코드 체크아웃</strong>: 저장소 복제
2. <strong>의존성 설치</strong>: <code>npm install</code>, <code>pip install</code>
3. <strong>린트</strong>: 코드 스타일 확인
4. <strong>테스트</strong>: 단위, 통합 테스트 실행
5. <strong>보안 스캔</strong>: 취약점 확인
6. <strong>빌드</strong>: 컴파일, 번들
7. <strong>배포</strong>: 스테이징/프로덕션으로 푸시</p>
<p><strong>빠른 피드백</strong>: 빠르게 실패—느린 것(E2E 테스트) 전에 빠른 확인(린트) 실행.</p>
<h2 id="vs_1">모노레포 vs 폴리레포<a class="header-link" href="#vs_1" title="Permanent link">&para;</a></h2>
<h3 id="_17">모노레포<a class="header-link" href="#_17" title="Permanent link">&para;</a></h3>
<p><strong>모든 프로젝트를 하나의 저장소에</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">company</span><span class="o">-</span><span class="n">repo</span><span class="o">/</span>
<span class="err">├──</span><span class="w"> </span><span class="n">services</span><span class="o">/</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">api</span><span class="o">/</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">frontend</span><span class="o">/</span>
<span class="err">│</span><span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="n">worker</span><span class="o">/</span>
<span class="err">├──</span><span class="w"> </span><span class="n">libraries</span><span class="o">/</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">shared</span><span class="o">-</span><span class="n">utils</span><span class="o">/</span>
<span class="err">│</span><span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="n">ui</span><span class="o">-</span><span class="n">components</span><span class="o">/</span>
<span class="err">└──</span><span class="w"> </span><span class="n">tools</span><span class="o">/</span>
</code></pre></div>

<p><strong>장점</strong>:
- 프로젝트 간 원자적 변경
- 코드 공유가 쉬움
- 단일 CI/CD 구성
- 단순화된 의존성 관리</p>
<p><strong>단점</strong>:
- 대규모 저장소(clone, checkout 느림)
- 관련 없는 변경에 대해 CI 실행
- 툴링 필요(Bazel, Nx, Turborepo)</p>
<p><strong>사용</strong>: Google, Facebook, Microsoft</p>
<h3 id="_18">폴리레포<a class="header-link" href="#_18" title="Permanent link">&para;</a></h3>
<p><strong>각 프로젝트에 대해 별도 저장소</strong>:</p>
<div class="highlight"><pre><span></span><code>company-api/
company-frontend/
company-worker/
shared-utils/
ui-components/
</code></pre></div>

<p><strong>장점</strong>:
- 명확한 소유권 경계
- 더 빠른 clone
- 대상 CI(영향받은 저장소만)</p>
<p><strong>단점</strong>:
- 저장소 간 변경이 고통스러움
- 의존성 버전 지옥
- 코드 중복</p>
<p><strong>사용</strong>: 대부분의 중소 기업</p>
<h3 id="_19">권장사항<a class="header-link" href="#_19" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>모노레포</strong>: 프로젝트가 긴밀하게 결합되고, 빈번한 프로젝트 간 변경</li>
<li><strong>폴리레포</strong>: 프로젝트가 독립적인 마이크로서비스</li>
</ul>
<h2 id="_20">시맨틱 버전 관리<a class="header-link" href="#_20" title="Permanent link">&para;</a></h2>
<p><strong>시맨틱 버전 관리(SemVer)</strong>는 버전 번호를 통해 변경의 성격을 전달합니다:</p>
<div class="highlight"><pre><span></span><code>MAJOR.MINOR.PATCH
  2  . 3   . 1
</code></pre></div>

<ul>
<li><strong>MAJOR</strong>: 파괴적 변경(호환되지 않는 API 변경)</li>
<li><strong>MINOR</strong>: 새 기능(하위 호환)</li>
<li><strong>PATCH</strong>: 버그 수정(하위 호환)</li>
</ul>
<p><strong>예제</strong>:
- <code>1.0.0 → 1.0.1</code>: 버그 수정
- <code>1.0.1 → 1.1.0</code>: 새 기능 추가
- <code>1.1.0 → 2.0.0</code>: 파괴적 변경(API 변경됨)</p>
<p><strong>사전 릴리스 버전</strong>:
- <code>1.0.0-alpha.1</code>: 알파 릴리스
- <code>1.0.0-beta.2</code>: 베타 릴리스
- <code>1.0.0-rc.1</code>: 릴리스 후보</p>
<h2 id="_21">커밋 메시지 규칙<a class="header-link" href="#_21" title="Permanent link">&para;</a></h2>
<p>좋은 커밋 메시지는 다음을 가능하게 합니다:
- 변경 사항의 빠른 이해
- 자동화된 변경 로그 생성
- 히스토리의 쉬운 탐색</p>
<h3 id="_22">관례적 커밋<a class="header-link" href="#_22" title="Permanent link">&para;</a></h3>
<p>형식:</p>
<div class="highlight"><pre><span></span><code><span class="p">&lt;</span><span class="k">type</span><span class="p">&gt;(&lt;</span><span class="nx">scope</span><span class="p">&gt;):</span><span class="w"> </span><span class="p">&lt;</span><span class="nx">description</span><span class="p">&gt;</span>

<span class="p">[</span><span class="nx">선택적</span><span class="w"> </span><span class="nx">본문</span><span class="p">]</span>

<span class="p">[</span><span class="nx">선택적</span><span class="w"> </span><span class="nx">바닥글</span><span class="p">]</span>
</code></pre></div>

<p><strong>타입</strong>:
- <code>feat</code>: 새 기능
- <code>fix</code>: 버그 수정
- <code>docs</code>: 문서 변경
- <code>style</code>: 포맷팅(코드 변경 없음)
- <code>refactor</code>: 코드 재구조화
- <code>test</code>: 테스트 추가
- <code>chore</code>: 툴링, 의존성</p>
<p><strong>예제</strong>:</p>
<div class="highlight"><pre><span></span><code>feat(auth): OAuth2 로그인 추가

OAuth2를 사용한 Google 로그인 플로우 구현.
사용자가 이제 Google 계정으로 로그인할 수 있습니다.

Closes #123

---

fix(api): getUser 엔드포인트에서 null 사용자 ID 처리

이전에는 null ID가 500 오류를 발생시켰습니다.
이제 오류 메시지와 함께 400 Bad Request 반환.

---

docs(readme): 설치 지침 업데이트

---

refactor(db): 저장소 패턴 추출

더 나은 관심사 분리를 위해
서비스에서 저장소로 데이터베이스 논리 이동.
</code></pre></div>

<h3 id="_23">의미 있는 메시지 작성<a class="header-link" href="#_23" title="Permanent link">&para;</a></h3>
<p><strong>나쁨</strong>:</p>
<div class="highlight"><pre><span></span><code>git commit -m &quot;fix bug&quot;
git commit -m &quot;update code&quot;
git commit -m &quot;changes&quot;
</code></pre></div>

<p><strong>좋음</strong>:</p>
<div class="highlight"><pre><span></span><code>git commit -m &quot;fix: 사용자 등록에서 경쟁 조건 방지&quot;
git commit -m &quot;refactor: 이메일 유효성 검증을 유틸리티 함수로 추출&quot;
git commit -m &quot;feat: 사용자 목록 엔드포인트에 페이지네이션 추가&quot;
</code></pre></div>

<p><strong>팁</strong>:
- 명령형 사용: "Add feature" not "Added feature"
- 첫 줄: 간결한 요약(50자)
- 본문: <strong>왜</strong>를 설명, 무엇이 아니라(코드가 무엇을 보여줌)</p>
<h2 id="_24">연습 문제<a class="header-link" href="#_24" title="Permanent link">&para;</a></h2>
<h3 id="1_1">연습 문제 1: 브랜칭 전략 선택<a class="header-link" href="#1_1" title="Permanent link">&para;</a></h3>
<p>다음 특성을 가진 팀을 이끌고 있습니다:
- 5명의 개발자
- Heroku에 배포되는 웹 애플리케이션
- 하루에 여러 번 배포
- 불완전한 기능에 기능 플래그 사용</p>
<p>어떤 브랜칭 전략을 추천하시겠습니까? 선택을 정당화하세요.</p>
<h3 id="2_1">연습 문제 2: 코드 리뷰 체크리스트 작성<a class="header-link" href="#2_1" title="Permanent link">&para;</a></h3>
<p>Flask와 PostgreSQL을 사용하는 Python 웹 API 프로젝트를 위한 코드 리뷰 체크리스트를 만드세요. 기능, 보안, 성능, 스타일을 다루는 최소 10개 항목을 포함하세요.</p>
<h3 id="3-cicd">연습 문제 3: CI/CD 파이프라인 설계<a class="header-link" href="#3-cicd" title="Permanent link">&para;</a></h3>
<p>다음을 수행하는 Node.js 애플리케이션을 위한 CI/CD 파이프라인을 설계하세요:
1. 모든 브랜치의 push에서 실행
2. 린팅, 테스트, 보안 스캔 실행
3. Docker 이미지 빌드
4. <code>main</code>에 대한 push에서 스테이징에 배포
5. git 태그(<code>v*</code>)에서 프로덕션에 배포</p>
<p>YAML로 파이프라인 구성 작성(GitHub Actions 또는 GitLab CI).</p>
<h3 id="4-pr">연습 문제 4: PR 품질 평가<a class="header-link" href="#4-pr" title="Permanent link">&para;</a></h3>
<p>이 풀 리퀘스트를 평가하고 피드백을 제공하세요:</p>
<p><strong>제목</strong>: "사용자 관련 업데이트"
<strong>설명</strong>: (비어 있음)
<strong>변경사항</strong>: 45개 파일 변경, 2,300줄 추가, 800 삭제
<strong>커밋</strong>: "wip", "fix", "more changes"와 같은 메시지가 있는 37개 커밋</p>
<p>문제는 무엇입니까? 작성자가 어떻게 개선해야 합니까?</p>
<h3 id="5">연습 문제 5: 시맨틱 버전 관리<a class="header-link" href="#5" title="Permanent link">&para;</a></h3>
<p>API가 현재 버전 <code>2.3.5</code>입니다. 각 시나리오에 대한 다음 버전 번호를 결정하세요:</p>
<ol>
<li>인증 미들웨어의 버그 수정</li>
<li>기존 엔드포인트에 새로운 선택적 매개변수 추가</li>
<li>폐기된 엔드포인트 제거</li>
<li>내부 캐싱 개선(API 변경 없음)</li>
<li>JSON 응답의 필드 이름을 <code>user_name</code>에서 <code>username</code>으로 변경</li>
</ol>
<h2 id="_25">요약<a class="header-link" href="#_25" title="Permanent link">&para;</a></h2>
<p>효과적인 버전 관리 워크플로우는 팀이 깨뜨리지 않고 빠르게 움직일 수 있게 합니다:</p>
<ul>
<li><strong>브랜칭 전략</strong>: Git Flow(구조화), GitHub Flow(단순), 트랙 기반(빠름)</li>
<li><strong>풀 리퀘스트</strong>: 명확한 설명이 있는 작고 집중된 PR이 더 빠르게 리뷰됨</li>
<li><strong>코드 리뷰</strong>: 건설적이고, 스타일 체크 자동화, 설계와 정확성에 집중</li>
<li><strong>병합 전략</strong>: 스쿼시(깨끗한 히스토리), 리베이스(커밋 보존), 병합(전체 히스토리)</li>
<li><strong>CI/CD</strong>: 자동화된 테스트와 배포가 인적 오류를 줄이고 전달 가속화</li>
<li><strong>모노레포 vs 폴리레포</strong>: 긴밀한 결합에는 모노레포, 독립성에는 폴리레포</li>
<li><strong>시맨틱 버전 관리</strong>: MAJOR.MINOR.PATCH가 변경의 영향 전달</li>
<li><strong>커밋 메시지</strong>: 관례적 커밋은 자동화와 명확성 가능</li>
</ul>
<p>훌륭한 워크플로우는 <strong>속도</strong>(기능 빠르게 배송)와 <strong>품질</strong>(버그 방지, 코드베이스 유지) 사이의 균형을 맞춥니다.</p>
<h2 id="_26">내비게이션<a class="header-link" href="#_26" title="Permanent link">&para;</a></h2>
<p><a href="13_API_Design.md">← 이전: API 설계</a> | <a href="15_Software_Architecture.md">다음: 소프트웨어 아키텍처 →</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Programming/13_API_Design.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">API 설계 원칙</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Programming/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Programming/15_Software_Architecture.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">소프트웨어 아키텍처 기초</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}