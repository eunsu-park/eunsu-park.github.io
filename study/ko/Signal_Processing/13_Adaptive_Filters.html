{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>13. 적응 필터 - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Signal_Processing/">Signal Processing</a>
    <span class="separator">/</span>
    <span class="current">13. 적응 필터</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>13. 적응 필터</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Signal_Processing/12_Spectral_Analysis.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">스펙트럼 분석(Spectral Analysis)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Signal_Processing/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Signal_Processing/14_Time_Frequency_Analysis.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">14. 시간-주파수 분석(Time-Frequency Analysis)</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#_1">목차</a></li>
<li><a href="#1">1. 적응 필터링이 필요한 이유</a><ul>
<li><a href="#11">1.1 고정 필터의 한계</a></li>
<li><a href="#12">1.2 적응 필터링 프레임워크</a></li>
<li><a href="#13_1">1.3 주요 구성</a></li>
</ul>
</li>
<li><a href="#2-mmse">2. 위너 필터: 최적 MMSE 해</a><ul>
<li><a href="#21">2.1 비용 함수</a></li>
<li><a href="#22-wiener-hopf-equation">2.2 위너-호프 방정식(Wiener-Hopf Equation)</a></li>
<li><a href="#23">2.3 성능 곡면</a></li>
<li><a href="#24">2.4 위너 해의 한계</a></li>
</ul>
</li>
<li><a href="#3">3. 최급강하법</a><ul>
<li><a href="#31-mse">3.1 MSE 곡면에서의 경사 하강</a></li>
<li><a href="#32">3.2 수렴 분석</a></li>
<li><a href="#33">3.3 수렴 속도와 고유값 분산</a></li>
<li><a href="#34">3.4 학습 곡선</a></li>
</ul>
</li>
<li><a href="#4-lms">4. LMS 알고리즘</a><ul>
<li><a href="#41">4.1 유도</a></li>
<li><a href="#42">4.2 알고리즘 요약</a></li>
<li><a href="#43-lms">4.3 LMS의 특성</a></li>
</ul>
</li>
<li><a href="#5-lms">5. LMS 수렴 분석</a><ul>
<li><a href="#51">5.1 평균 수렴</a></li>
<li><a href="#52">5.2 평균 제곱 수렴</a></li>
<li><a href="#53-mse">5.3 초과 MSE와 오조정</a></li>
<li><a href="#54">5.4 스텝 크기 선택 지침</a></li>
<li><a href="#55">5.5 수렴 시간</a></li>
</ul>
</li>
<li><a href="#6-lms-nlms">6. 정규화 LMS (NLMS)</a><ul>
<li><a href="#61">6.1 동기</a></li>
<li><a href="#62">6.2 유도</a></li>
<li><a href="#63">6.3 제약 최적화로부터의 유도</a></li>
<li><a href="#64-nlms">6.4 NLMS의 장점</a></li>
<li><a href="#65-nlms">6.5 NLMS 수렴</a></li>
</ul>
</li>
<li><a href="#7-rls">7. RLS 알고리즘</a><ul>
<li><a href="#71">7.1 동기</a></li>
<li><a href="#72-ls">7.2 가중 LS에 대한 정규 방정식</a></li>
<li><a href="#73">7.3 행렬 역 보조정리</a></li>
<li><a href="#74-rls">7.4 RLS 알고리즘 요약</a></li>
<li><a href="#75">7.5 망각 인자</a></li>
<li><a href="#76-rls">7.6 RLS의 특성</a></li>
</ul>
</li>
<li><a href="#8-lms-vs-rls">8. 비교: LMS vs RLS</a></li>
<li><a href="#9">9. 응용: 시스템 식별</a><ul>
<li><a href="#91">9.1 문제 설정</a></li>
<li><a href="#92">9.2 사용 시기</a></li>
</ul>
</li>
<li><a href="#10">10. 응용: 잡음 제거</a><ul>
<li><a href="#101-anc">10.1 적응 잡음 제거기 (ANC)</a></li>
<li><a href="#102">10.2 수학적 정당성</a></li>
</ul>
</li>
<li><a href="#11_1">11. 응용: 에코 제거</a><ul>
<li><a href="#111-aec">11.1 음향 에코 제거 (AEC)</a></li>
<li><a href="#112">11.2 네트워크 에코 제거</a></li>
</ul>
</li>
<li><a href="#12_1">12. 응용: 채널 등화</a><ul>
<li><a href="#121">12.1 문제</a></li>
<li><a href="#122">12.2 훈련 및 결정 주도 모드</a></li>
</ul>
</li>
<li><a href="#13_2">13. 응용: 적응 빔포밍</a><ul>
<li><a href="#131">13.1 문제</a></li>
<li><a href="#132-mvdr">13.2 최소 분산 왜곡 없는 응답 (MVDR)</a></li>
</ul>
</li>
<li><a href="#14-python">14. Python 구현: 완전한 적응 필터링 툴킷</a><ul>
<li><a href="#141-lms-nlms-rls">14.1 LMS, NLMS, RLS 구현</a></li>
<li><a href="#142">14.2 시스템 식별 예제</a></li>
<li><a href="#143">14.3 잡음 제거 데모</a></li>
<li><a href="#144">14.4 시변 시스템 추적</a></li>
</ul>
</li>
<li><a href="#15">15. 연습 문제</a><ul>
<li><a href="#1_1">연습 문제 1: 위너 필터</a></li>
<li><a href="#2-lms">연습 문제 2: LMS 수렴</a></li>
<li><a href="#3-nlms-vs-lms">연습 문제 3: NLMS vs LMS</a></li>
<li><a href="#4-rls">연습 문제 4: RLS 구현</a></li>
<li><a href="#5">연습 문제 5: 에코 제거 시뮬레이션</a></li>
<li><a href="#6">연습 문제 6: 적응 등화</a></li>
<li><a href="#7">연습 문제 7: 필터 차수의 영향</a></li>
</ul>
</li>
<li><a href="#16">16. 요약</a></li>
<li><a href="#17">17. 참고 문헌</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="13">13. 적응 필터<a class="header-link" href="#13" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./12_Multirate_Signal_Processing.md">12. 다중 레이트 신호 처리</a> | <strong>다음</strong>: <a href="./14_Time_Frequency_Analysis.md">14. 시간-주파수 분석</a></p>
<hr />
<p>적응 필터(adaptive filter)는 최적화 알고리즘에 따라 계수가 자동으로 조정되는 필터입니다. 신호 및 잡음 통계에 대한 완전한 사전 지식을 바탕으로 설계된 고정 필터와 달리, 적응 필터는 데이터로부터 지속적으로 파라미터를 갱신함으로써 미지(未知) 또는 시변(time-varying) 환경에서도 동작할 수 있습니다. 이는 노이즈 캔슬링 헤드폰, 전화기의 에코 제거, 모뎀의 채널 등화(channel equalization) 등 수많은 실제 시스템의 핵심 기술입니다.</p>
<p><strong>난이도</strong>: ⭐⭐⭐⭐</p>
<p><strong>선수 지식</strong>: FIR/IIR 필터 설계, 선형대수, 기본 최적화 개념</p>
<p><strong>학습 목표</strong>:
- 위너 필터(Wiener filter)를 최적 MMSE 선형 필터로 유도
- 최급강하법(method of steepest descent)과 수렴 특성 이해
- LMS 알고리즘 유도 및 구현, 수렴 동작 분석
- 향상된 수렴을 위한 정규화 LMS(Normalized LMS, NLMS) 구현
- 행렬 역 보조정리(matrix inversion lemma)를 이용한 RLS 알고리즘 유도 및 구현
- 복잡도, 수렴, 추적 측면에서 LMS와 RLS 비교
- 시스템 식별, 잡음 제거, 에코 제거, 등화에 적응 필터 적용</p>
<hr />
<h2 id="_1">목차<a class="header-link" href="#_1" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#1-적응-필터링이-필요한-이유">적응 필터링이 필요한 이유</a></li>
<li><a href="#2-위너-필터-최적-mmse-해">위너 필터: 최적 MMSE 해</a></li>
<li><a href="#3-최급강하법">최급강하법</a></li>
<li><a href="#4-lms-알고리즘">LMS 알고리즘</a></li>
<li><a href="#5-lms-수렴-분석">LMS 수렴 분석</a></li>
<li><a href="#6-정규화-lms-nlms">정규화 LMS (NLMS)</a></li>
<li><a href="#7-rls-알고리즘">RLS 알고리즘</a></li>
<li><a href="#8-비교-lms-vs-rls">비교: LMS vs RLS</a></li>
<li><a href="#9-응용-시스템-식별">응용: 시스템 식별</a></li>
<li><a href="#10-응용-잡음-제거">응용: 잡음 제거</a></li>
<li><a href="#11-응용-에코-제거">응용: 에코 제거</a></li>
<li><a href="#12-응용-채널-등화">응용: 채널 등화</a></li>
<li><a href="#13-응용-적응-빔포밍">응용: 적응 빔포밍</a></li>
<li><a href="#14-python-구현-완전한-적응-필터링-툴킷">Python 구현: 완전한 적응 필터링 툴킷</a></li>
<li><a href="#15-연습-문제">연습 문제</a></li>
<li><a href="#16-요약">요약</a></li>
<li><a href="#17-참고-문헌">참고 문헌</a></li>
</ol>
<hr />
<h2 id="1">1. 적응 필터링이 필요한 이유<a class="header-link" href="#1" title="Permanent link">&para;</a></h2>
<h3 id="11">1.1 고정 필터의 한계<a class="header-link" href="#11" title="Permanent link">&para;</a></h3>
<p>기존 FIR 및 IIR 필터는 설계 시점에 신호 및 잡음 특성에 대한 완전한 지식을 필요로 합니다. 다음과 같은 경우를 고려해 보세요:</p>
<ul>
<li><strong>통계를 모를 때</strong>: 잡음의 스펙트럼 특성을 모르면 최적 필터를 설계할 수 없습니다.</li>
<li><strong>통계가 시변일 때</strong>: 무선 채널은 송수신기의 이동에 따라 변합니다. 한 채널 실현(realization)에 맞게 설계된 필터는 잠시 후 준최적(suboptimal)이 됩니다.</li>
<li><strong>실시간 동작이 필요할 때</strong>: 일부 환경에서는 오프라인 설계 단계 없이 지속적인 적응이 필요합니다.</li>
</ul>
<h3 id="12">1.2 적응 필터링 프레임워크<a class="header-link" href="#12" title="Permanent link">&para;</a></h3>
<p>적응 필터는 두 부분으로 구성됩니다:</p>
<ol>
<li><strong>파라미터화된 필터 구조</strong> (보통 FIR): 입력 $x(n)$으로부터 출력 $y(n)$을 계산합니다.</li>
<li><strong>적응 알고리즘</strong>: 어떤 비용 함수를 최소화하도록 필터 계수 $\mathbf{w}(n)$을 조정합니다.</li>
</ol>
<div class="highlight"><pre><span></span><code><span class="w">                    </span><span class="err">┌──────────────────────┐</span>
<span class="w">     </span><span class="n">x</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="err">────────▶│</span><span class="w">   </span><span class="n">Adaptive</span><span class="w"> </span><span class="n">Filter</span><span class="w">    </span><span class="err">│────────▶</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="w">                    </span><span class="err">│</span><span class="w">   </span><span class="n">w</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w">               </span><span class="err">│</span>
<span class="w">                    </span><span class="err">└──────────┬───────────┘</span>
<span class="w">                               </span><span class="err">│</span>
<span class="w">                               </span><span class="err">│</span><span class="w">  </span><span class="n">e</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">y</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
<span class="w">                               </span><span class="err">│</span>
<span class="w">     </span><span class="n">d</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="err">─────────────────────┴─────────▶</span><span class="w"> </span><span class="n">Error</span>
<span class="w">     </span><span class="p">(</span><span class="n">desired</span><span class="w"> </span><span class="k">signal</span><span class="p">)</span><span class="w">                      </span><span class="n">Computation</span>
<span class="w">                                              </span><span class="err">│</span>
<span class="w">                                              </span><span class="err">▼</span>
<span class="w">                                     </span><span class="n">Adaptation</span><span class="w"> </span><span class="n">Algorithm</span>
<span class="w">                                     </span><span class="p">(</span><span class="n">update</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
</code></pre></div>

<p><strong>오차 신호(error signal)</strong>는:</p>
<p>$$e(n) = d(n) - y(n) = d(n) - \mathbf{w}^T(n) \mathbf{x}(n)$$</p>
<p>여기서:
- $d(n)$은 <strong>원하는(기준) 신호(desired/reference signal)</strong>
- $\mathbf{x}(n) = [x(n), x(n-1), \ldots, x(n-M+1)]^T$는 입력 벡터
- $\mathbf{w}(n) = [w_0(n), w_1(n), \ldots, w_{M-1}(n)]^T$는 필터 가중치 벡터
- $M$은 필터 차수</p>
<h3 id="13_1">1.3 주요 구성<a class="header-link" href="#13_1" title="Permanent link">&para;</a></h3>
<p>적응 필터는 네 가지 주요 구성으로 사용됩니다:</p>
<table>
<thead>
<tr>
<th>구성</th>
<th>입력 $x(n)$</th>
<th>원하는 신호 $d(n)$</th>
<th>목적</th>
</tr>
</thead>
<tbody>
<tr>
<td>시스템 식별</td>
<td>미지 시스템의 입력</td>
<td>미지 시스템의 출력</td>
<td>미지 시스템 모델링</td>
</tr>
<tr>
<td>역 모델링</td>
<td>미지 시스템의 출력</td>
<td>지연된 입력</td>
<td>채널 등화</td>
</tr>
<tr>
<td>잡음 제거</td>
<td>상관된 잡음 기준</td>
<td>신호 + 잡음</td>
<td>신호 추출</td>
</tr>
<tr>
<td>예측</td>
<td>신호의 지연 버전</td>
<td>현재 신호</td>
<td>미래 값 예측</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="2-mmse">2. 위너 필터: 최적 MMSE 해<a class="header-link" href="#2-mmse" title="Permanent link">&para;</a></h2>
<h3 id="21">2.1 비용 함수<a class="header-link" href="#21" title="Permanent link">&para;</a></h3>
<p><strong>최소 평균 제곱 오차(minimum mean square error, MMSE)</strong> 기준은 기대 제곱 오차를 최소화합니다:</p>
<p>$$J(\mathbf{w}) = E\left[|e(n)|^2\right] = E\left[|d(n) - \mathbf{w}^T \mathbf{x}(n)|^2\right]$$</p>
<p>전개하면:</p>
<p>$$J(\mathbf{w}) = E[d^2(n)] - 2\mathbf{w}^T E[d(n)\mathbf{x}(n)] + \mathbf{w}^T E[\mathbf{x}(n)\mathbf{x}^T(n)] \mathbf{w}$$</p>
<p>다음을 정의합니다:
- <strong>자기상관 행렬(autocorrelation matrix)</strong>: $\mathbf{R} = E[\mathbf{x}(n)\mathbf{x}^T(n)]$ ($M \times M$ 양정치 행렬)
- <strong>상호상관 벡터(cross-correlation vector)</strong>: $\mathbf{p} = E[d(n)\mathbf{x}(n)]$ ($M \times 1$ 벡터)
- $\sigma_d^2 = E[d^2(n)]$</p>
<p>비용 함수는 <strong>2차 볼(quadratic bowl)</strong> 형태가 됩니다:</p>
<p>$$J(\mathbf{w}) = \sigma_d^2 - 2\mathbf{w}^T \mathbf{p} + \mathbf{w}^T \mathbf{R} \mathbf{w}$$</p>
<h3 id="22-wiener-hopf-equation">2.2 위너-호프 방정식(Wiener-Hopf Equation)<a class="header-link" href="#22-wiener-hopf-equation" title="Permanent link">&para;</a></h3>
<p>기울기를 구하고 0으로 설정하면:</p>
<p>$$\nabla_{\mathbf{w}} J = -2\mathbf{p} + 2\mathbf{R}\mathbf{w} = \mathbf{0}$$</p>
<p>이로부터 <strong>위너-호프 방정식(Wiener-Hopf equation)</strong>(정규 방정식)이 도출됩니다:</p>
<p>$$\boxed{\mathbf{R}\mathbf{w}_{opt} = \mathbf{p}}$$</p>
<p>최적(위너) 필터는:</p>
<p>$$\mathbf{w}_{opt} = \mathbf{R}^{-1}\mathbf{p}$$</p>
<p>최적 해에서의 <strong>최소 MSE</strong>는:</p>
<p>$$J_{min} = \sigma_d^2 - \mathbf{p}^T \mathbf{R}^{-1} \mathbf{p}$$</p>
<h3 id="23">2.3 성능 곡면<a class="header-link" href="#23" title="Permanent link">&para;</a></h3>
<p>$\mathbf{R}$이 양정치이므로, 비용 함수 $J(\mathbf{w})$는 볼록 2차함수로 그릇 모양의 곡면(타원 포물면)을 형성합니다. 모든 하강 알고리즘은 유일한 전역 최솟값으로 수렴합니다.</p>
<p>고유분해 $\mathbf{R} = \mathbf{Q}\boldsymbol{\Lambda}\mathbf{Q}^T$를 사용하면, 회전 좌표계 $\mathbf{v} = \mathbf{Q}^T(\mathbf{w} - \mathbf{w}_{opt})$에서의 비용 함수는:</p>
<p>$$J(\mathbf{v}) = J_{min} + \sum_{k=0}^{M-1} \lambda_k v_k^2$$</p>
<p>여기서 $\lambda_k$는 $\mathbf{R}$의 고유값입니다. $J$의 등고선은 고유벡터 방향으로 정렬되고 고유값에 의해 크기가 결정되는 타원입니다.</p>
<h3 id="24">2.4 위너 해의 한계<a class="header-link" href="#24" title="Permanent link">&para;</a></h3>
<p>위너 필터는 다음을 필요로 합니다:
1. $\mathbf{R}$과 $\mathbf{p}$에 대한 지식 (2차 통계)
2. 신호의 정상성(stationarity)
3. $\mathbf{R}^{-1}$ 계산 ($O(M^3)$ 연산)</p>
<p>실제로 이 조건들은 정확히 만족되기 어렵기 때문에, 반복적이고 적응적인 접근법이 필요합니다.</p>
<hr />
<h2 id="3">3. 최급강하법<a class="header-link" href="#3" title="Permanent link">&para;</a></h2>
<h3 id="31-mse">3.1 MSE 곡면에서의 경사 하강<a class="header-link" href="#31-mse" title="Permanent link">&para;</a></h3>
<p>위너-호프 방정식을 직접 풀지 않고, 경사 하강(gradient descent)을 통해 반복적으로 $\mathbf{w}_{opt}$에 도달할 수 있습니다:</p>
<p>$$\mathbf{w}(n+1) = \mathbf{w}(n) - \mu \nabla_{\mathbf{w}} J(n)$$</p>
<p>MSE 비용 함수의 진짜 기울기는:</p>
<p>$$\nabla_{\mathbf{w}} J = -2\mathbf{p} + 2\mathbf{R}\mathbf{w}(n)$$</p>
<p>따라서 갱신 규칙은:</p>
<p>$$\boxed{\mathbf{w}(n+1) = \mathbf{w}(n) + 2\mu\left(\mathbf{p} - \mathbf{R}\mathbf{w}(n)\right)}$$</p>
<p>이것이 <strong>최급강하법(steepest descent)</strong> 알고리즘입니다. 여전히 $\mathbf{R}$과 $\mathbf{p}$에 대한 지식이 필요하므로 진정한 적응형은 아닙니다.</p>
<h3 id="32">3.2 수렴 분석<a class="header-link" href="#32" title="Permanent link">&para;</a></h3>
<p>가중치 오차 벡터를 정의합니다: $\boldsymbol{\epsilon}(n) = \mathbf{w}(n) - \mathbf{w}_{opt}$</p>
<p>갱신식에 대입하면:</p>
<p>$$\boldsymbol{\epsilon}(n+1) = (\mathbf{I} - 2\mu\mathbf{R})\boldsymbol{\epsilon}(n)$$</p>
<p>고유분해 $\mathbf{R} = \mathbf{Q}\boldsymbol{\Lambda}\mathbf{Q}^T$를 사용하여, 회전 좌표 $\mathbf{v}(n) = \mathbf{Q}^T \boldsymbol{\epsilon}(n)$에서:</p>
<p>$$v_k(n+1) = (1 - 2\mu\lambda_k) v_k(n)$$</p>
<p>수렴을 위해서는 모든 $k$에 대해 $|1 - 2\mu\lambda_k| < 1$이 필요하며, 이는:</p>
<p>$$\boxed{0 < \mu < \frac{1}{\lambda_{max}}}$$</p>
<p>여기서 $\lambda_{max}$는 $\mathbf{R}$의 최대 고유값입니다.</p>
<h3 id="33">3.3 수렴 속도와 고유값 분산<a class="header-link" href="#33" title="Permanent link">&para;</a></h3>
<p>각 모드 $v_k$의 수렴 속도는 $|1 - 2\mu\lambda_k|$에 의해 결정됩니다. 각 모드에 대한 최적 스텝 크기는 $\mu_k = 1/(2\lambda_k)$이지만, 단일 $\mu$를 사용하므로:</p>
<ul>
<li>가장 빠르게 수렴하는 모드는 $\lambda_{max}$에 해당</li>
<li>가장 느리게 수렴하는 모드는 $\lambda_{min}$에 해당</li>
</ul>
<p><strong>고유값 분산(eigenvalue spread)</strong>(조건수, condition number):</p>
<p>$$\chi(\mathbf{R}) = \frac{\lambda_{max}}{\lambda_{min}}$$</p>
<p>이것이 전체 수렴 속도를 지배합니다. 큰 고유값 분산은 느린 수렴을 의미합니다. 알고리즘이 성능 곡면의 좁은 계곡을 가로질러 "지그재그"로 움직이기 때문입니다.</p>
<h3 id="34">3.4 학습 곡선<a class="header-link" href="#34" title="Permanent link">&para;</a></h3>
<p>반복 횟수의 함수로서의 MSE가 <strong>학습 곡선(learning curve)</strong>입니다:</p>
<p>$$J(n) = J_{min} + \sum_{k=0}^{M-1} \lambda_k v_k^2(0)(1 - 2\mu\lambda_k)^{2n}$$</p>
<p>각 모드는 시상수(time constant)와 함께 기하급수적으로 감소합니다:</p>
<p>$$\tau_k = \frac{-1}{2\ln|1 - 2\mu\lambda_k|} \approx \frac{1}{4\mu\lambda_k} \quad \text{(소 } \mu \text{에 대해)}$$</p>
<p>가장 느린 모드의 시상수는 $\tau_{max} \approx 1/(4\mu\lambda_{min})$입니다.</p>
<hr />
<h2 id="4-lms">4. LMS 알고리즘<a class="header-link" href="#4-lms" title="Permanent link">&para;</a></h2>
<h3 id="41">4.1 유도<a class="header-link" href="#41" title="Permanent link">&para;</a></h3>
<p>최급강하법 알고리즘은 진짜 기울기 $\nabla J = -2\mathbf{p} + 2\mathbf{R}\mathbf{w}(n)$을 필요로 합니다. Widrow와 Hoff (1960)의 핵심 통찰은 진짜 기울기를 <strong>순간 추정값(instantaneous estimate)</strong>으로 대체하는 것입니다:</p>
<p>$$\hat{\nabla} J(n) = -2e(n)\mathbf{x}(n)$$</p>
<p>이는 기댓값을 순간 샘플로 대체하여 얻어집니다:
- $\mathbf{R}\mathbf{w}(n) \approx \mathbf{x}(n)\mathbf{x}^T(n)\mathbf{w}(n) = \mathbf{x}(n)y(n)$
- $\mathbf{p} \approx d(n)\mathbf{x}(n)$</p>
<p><strong>LMS 알고리즘</strong>은:</p>
<p>$$\boxed{\mathbf{w}(n+1) = \mathbf{w}(n) + \mu \, e(n) \, \mathbf{x}(n)}$$</p>
<p>여기서 $e(n) = d(n) - \mathbf{w}^T(n)\mathbf{x}(n)$.</p>
<h3 id="42">4.2 알고리즘 요약<a class="header-link" href="#42" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="nv">LMS</span><span class="w"> </span><span class="nv">Algorithm</span>
─────────────────────────────────────────────
<span class="nv">Initialize</span>:<span class="w"> </span><span class="nv">w</span><span class="ss">(</span><span class="mi">0</span><span class="ss">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="ss">(</span><span class="nv">or</span><span class="w"> </span><span class="nv">small</span><span class="w"> </span><span class="k">random</span><span class="w"> </span><span class="nv">values</span><span class="ss">)</span>
<span class="nv">Parameters</span>:<span class="w"> </span><span class="nv">step</span><span class="w"> </span><span class="nv">size</span><span class="w"> </span>μ,<span class="w"> </span><span class="nv">filter</span><span class="w"> </span><span class="nv">order</span><span class="w"> </span><span class="nv">M</span>

<span class="k">For</span><span class="w"> </span><span class="nv">each</span><span class="w"> </span><span class="nv">new</span><span class="w"> </span><span class="nv">sample</span><span class="w"> </span><span class="nv">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>,<span class="w"> </span><span class="mi">1</span>,<span class="w"> </span><span class="mi">2</span>,<span class="w"> </span>...
<span class="w">  </span><span class="mi">1</span>.<span class="w"> </span><span class="nv">Form</span><span class="w"> </span><span class="nv">input</span><span class="w"> </span><span class="nv">vector</span>:<span class="w"> </span><span class="nv">x</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>[<span class="nv">x</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">x</span><span class="ss">(</span><span class="nv">n</span><span class="o">-</span><span class="mi">1</span><span class="ss">)</span>,<span class="w"> </span>...,<span class="w"> </span><span class="nv">x</span><span class="ss">(</span><span class="nv">n</span><span class="o">-</span><span class="nv">M</span><span class="o">+</span><span class="mi">1</span><span class="ss">)</span>]<span class="o">^</span><span class="nv">T</span>
<span class="w">  </span><span class="mi">2</span>.<span class="w"> </span><span class="nv">Compute</span><span class="w"> </span><span class="nv">output</span>:<span class="w">    </span><span class="nv">y</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">w</span><span class="o">^</span><span class="nv">T</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="w"> </span><span class="nv">x</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span>
<span class="w">  </span><span class="mi">3</span>.<span class="w"> </span><span class="nv">Compute</span><span class="w"> </span><span class="nv">error</span>:<span class="w">     </span><span class="nv">e</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">d</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="nv">y</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span>
<span class="w">  </span><span class="mi">4</span>.<span class="w"> </span><span class="nv">Update</span><span class="w"> </span><span class="nv">weights</span>:<span class="w">    </span><span class="nv">w</span><span class="ss">(</span><span class="nv">n</span><span class="o">+</span><span class="mi">1</span><span class="ss">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">w</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span>μ<span class="w"> </span><span class="nv">e</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span><span class="w"> </span><span class="nv">x</span><span class="ss">(</span><span class="nv">n</span><span class="ss">)</span>
</code></pre></div>

<p><strong>계산 복잡도</strong>: 샘플당 $O(M)$ 곱셈과 덧셈 - 매우 효율적입니다.</p>
<h3 id="43-lms">4.3 LMS의 특성<a class="header-link" href="#43-lms" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>단순성</strong>: 행렬 역산 없음, 자기상관 추정 없음</li>
<li><strong>낮은 복잡도</strong>: 반복당 $2M$ 곱셈</li>
<li><strong>확률적 기울기</strong>: 기울기 추정값에 잡음이 있지만 불편향(unbiased): $E[\hat{\nabla}J] = \nabla J$</li>
<li><strong>자기 조정</strong>: 신호 통계의 느린 변화를 자동으로 추적</li>
</ol>
<hr />
<h2 id="5-lms">5. LMS 수렴 분석<a class="header-link" href="#5-lms" title="Permanent link">&para;</a></h2>
<h3 id="51">5.1 평균 수렴<a class="header-link" href="#51" title="Permanent link">&para;</a></h3>
<p>LMS 갱신의 기댓값 계산 (<strong>독립성 가정</strong> 하에 - $\mathbf{x}(n)$이 $\mathbf{w}(n)$에 독립):</p>
<p>$$E[\mathbf{w}(n+1)] = E[\mathbf{w}(n)] + \mu E[e(n)\mathbf{x}(n)]$$</p>
<p>대수 계산 후:</p>
<p>$$E[\boldsymbol{\epsilon}(n+1)] = (\mathbf{I} - 2\mu\mathbf{R}) E[\boldsymbol{\epsilon}(n)]$$</p>
<p>이는 최급강하법과 동일한 점화식이므로, <strong>평균 수렴</strong> 조건은:</p>
<p>$$0 < \mu < \frac{1}{\lambda_{max}}$$</p>
<p>실제로는 다음을 사용합니다:</p>
<p>$$0 < \mu < \frac{1}{\text{tr}(\mathbf{R})} = \frac{1}{M \cdot \sigma_x^2}$$</p>
<p>$\text{tr}(\mathbf{R}) = \sum_k \lambda_k \geq \lambda_{max}$이고, 정상 입력에 대해 $\text{tr}(\mathbf{R}) = M\sigma_x^2$이기 때문입니다.</p>
<h3 id="52">5.2 평균 제곱 수렴<a class="header-link" href="#52" title="Permanent link">&para;</a></h3>
<p>MSE가 수렴하기 위한 조건(평균 제곱 안정성)은 더 엄격합니다:</p>
<p>$$0 < \mu < \frac{2}{\lambda_{max} + \text{tr}(\mathbf{R})}$$</p>
<p>실용적으로 안전한 선택은:</p>
<p>$$\mu < \frac{1}{3 \, \text{tr}(\mathbf{R})} = \frac{1}{3M\sigma_x^2}$$</p>
<h3 id="53-mse">5.3 초과 MSE와 오조정<a class="header-link" href="#53-mse" title="Permanent link">&para;</a></h3>
<p>수렴 후에도 LMS 알고리즘은 확률적 기울기가 가중치 갱신에 잡음을 도입하기 때문에 $J_{min}$에 도달하지 못합니다. <strong>초과 MSE(excess MSE)</strong>는:</p>
<p>$$J_{excess} = J_{steady-state} - J_{min}$$</p>
<p><strong>오조정(misadjustment)</strong>은:</p>
<p>$$\mathcal{M} = \frac{J_{excess}}{J_{min}} \approx \mu \, \text{tr}(\mathbf{R}) = \mu M \sigma_x^2$$</p>
<p>이는 근본적인 <strong>트레이드오프</strong>를 드러냅니다:
- <strong>큰 $\mu$</strong>: 빠른 수렴이지만 큰 오조정 (잡음이 많은 정상 상태)
- <strong>작은 $\mu$</strong>: 느린 수렴이지만 작은 오조정 (정확한 정상 상태)</p>
<h3 id="54">5.4 스텝 크기 선택 지침<a class="header-link" href="#54" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>기준</th>
<th>스텝 크기</th>
</tr>
</thead>
<tbody>
<tr>
<td>안정성 (평균)</td>
<td>$\mu < 1/\lambda_{max}$</td>
</tr>
<tr>
<td>안정성 (평균 제곱)</td>
<td>$\mu < 2/(\lambda_{max} + \text{tr}(\mathbf{R}))$</td>
</tr>
<tr>
<td>실용적 규칙</td>
<td>$\mu \in [0.01, 0.1] / (M \sigma_x^2)$</td>
</tr>
<tr>
<td>오조정 $\leq$ 10%</td>
<td>$\mu \leq 0.1 / (M \sigma_x^2)$</td>
</tr>
</tbody>
</table>
<h3 id="55">5.5 수렴 시간<a class="header-link" href="#55" title="Permanent link">&para;</a></h3>
<p>가장 느린 모드의 근사 시상수는:</p>
<p>$$\tau_{mse} \approx \frac{1}{4\mu\lambda_{min}}$$</p>
<p>오조정 제약 $\mathcal{M} = \mu M \sigma_x^2$와 결합하면:</p>
<p>$$\tau_{mse} \approx \frac{M \sigma_x^2}{4\mathcal{M}\lambda_{min}} = \frac{\chi(\mathbf{R})}{4\mathcal{M}} \cdot \frac{M\sigma_x^2}{\lambda_{max}}$$</p>
<p>큰 고유값 분산 $\chi(\mathbf{R})$은 주어진 오조정에서 수렴하는 데 많은 반복이 필요함을 의미합니다.</p>
<hr />
<h2 id="6-lms-nlms">6. 정규화 LMS (NLMS)<a class="header-link" href="#6-lms-nlms" title="Permanent link">&para;</a></h2>
<h3 id="61">6.1 동기<a class="header-link" href="#61" title="Permanent link">&para;</a></h3>
<p>표준 LMS는 고정 스텝 크기 $\mu$를 가지므로, 실제 적응 속도가 입력 전력 $\|\mathbf{x}(n)\|^2$에 따라 달라집니다. 입력 전력이 변할 때 LMS는 불안정해지거나 너무 느리게 수렴할 수 있습니다.</p>
<h3 id="62">6.2 유도<a class="header-link" href="#62" title="Permanent link">&para;</a></h3>
<p>NLMS 알고리즘은 스텝 크기를 입력 전력으로 정규화하여 얻어집니다:</p>
<p>$$\boxed{\mathbf{w}(n+1) = \mathbf{w}(n) + \frac{\tilde{\mu}}{\|\mathbf{x}(n)\|^2 + \delta} \, e(n) \, \mathbf{x}(n)}$$</p>
<p>여기서:
- $\tilde{\mu} \in (0, 2)$는 정규화된 스텝 크기
- $\delta > 0$는 0으로 나누는 것을 방지하는 작은 정규화 상수</p>
<h3 id="63">6.3 제약 최적화로부터의 유도<a class="header-link" href="#63" title="Permanent link">&para;</a></h3>
<p>NLMS는 다음 제약 최적화 문제를 풀어서 유도할 수 있습니다:</p>
<p>$$\min_{\mathbf{w}(n+1)} \|\mathbf{w}(n+1) - \mathbf{w}(n)\|^2 \quad \text{제약 조건:} \quad \mathbf{w}^T(n+1)\mathbf{x}(n) = d(n)$$</p>
<p>즉, 최신 데이터 포인트를 완벽하게 피팅하는 현재 가중치 벡터에 가장 가까운 가중치 벡터를 찾는 것입니다. 라그랑주 승수(Lagrange multipliers)를 사용하면 $\tilde{\mu} = 1$인 NLMS 갱신이 얻어집니다.</p>
<h3 id="64-nlms">6.4 NLMS의 장점<a class="header-link" href="#64-nlms" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>강건한 수렴</strong>: 스텝 크기가 입력 전력에 자동 적응</li>
<li><strong>단순한 튜닝</strong>: 설정할 파라미터가 $\tilde{\mu} \in (0, 2)$ 하나뿐</li>
<li><strong>비정상 입력에 적합</strong>: 변동하는 신호 레벨에서도 잘 작동</li>
<li><strong>최소한의 추가 비용</strong>: 반복당 한 번의 내적만 추가</li>
</ol>
<h3 id="65-nlms">6.5 NLMS 수렴<a class="header-link" href="#65-nlms" title="Permanent link">&para;</a></h3>
<p>NLMS의 수렴 조건은 단순합니다:</p>
<p>$$0 < \tilde{\mu} < 2$$</p>
<p>오조정은 근사적으로:</p>
<p>$$\mathcal{M}_{NLMS} \approx \frac{\tilde{\mu}}{2 - \tilde{\mu}} \cdot \frac{1}{M}$$</p>
<p>일반적인 선택은 $\tilde{\mu} \in [0.1, 1.0]$입니다.</p>
<hr />
<h2 id="7-rls">7. RLS 알고리즘<a class="header-link" href="#7-rls" title="Permanent link">&para;</a></h2>
<h3 id="71">7.1 동기<a class="header-link" href="#71" title="Permanent link">&para;</a></h3>
<p>LMS가 기울기를 확률적으로 추정하는(한 번에 한 샘플) 반면, <strong>순환 최소 제곱(Recursive Least Squares, RLS)</strong> 알고리즘은 모든 과거 데이터에 걸친 결정론적 비용 함수를 최소화합니다:</p>
<p>$$J_{RLS}(n) = \sum_{i=0}^{n} \lambda^{n-i} |e(i)|^2$$</p>
<p>여기서 $\lambda \in (0, 1]$은 <strong>망각 인자(forgetting factor)</strong>(보통 $0.95 \leq \lambda \leq 1.0$)입니다. 최근 샘플에 오래된 샘플보다 더 큰 가중치가 부여되어 비정상 환경에서 추적 능력을 제공합니다.</p>
<h3 id="72-ls">7.2 가중 LS에 대한 정규 방정식<a class="header-link" href="#72-ls" title="Permanent link">&para;</a></h3>
<p>비용 함수는 다음에 의해 최소화됩니다:</p>
<p>$$\mathbf{w}(n) = \boldsymbol{\Phi}^{-1}(n) \boldsymbol{\theta}(n)$$</p>
<p>여기서:
- $\boldsymbol{\Phi}(n) = \sum_{i=0}^{n} \lambda^{n-i} \mathbf{x}(i)\mathbf{x}^T(i)$는 가중 샘플 상관 행렬
- $\boldsymbol{\theta}(n) = \sum_{i=0}^{n} \lambda^{n-i} d(i)\mathbf{x}(i)$는 가중 상호상관 벡터</p>
<p>둘 다 순환 갱신을 가집니다:</p>
<p>$$\boldsymbol{\Phi}(n) = \lambda \boldsymbol{\Phi}(n-1) + \mathbf{x}(n)\mathbf{x}^T(n)$$</p>
<p>$$\boldsymbol{\theta}(n) = \lambda \boldsymbol{\theta}(n-1) + d(n)\mathbf{x}(n)$$</p>
<h3 id="73">7.3 행렬 역 보조정리<a class="header-link" href="#73" title="Permanent link">&para;</a></h3>
<p>각 단계에서 $\boldsymbol{\Phi}^{-1}(n)$을 다시 계산하는 것($O(M^3)$)을 피하기 위해 <strong>행렬 역 보조정리(matrix inversion lemma, Woodbury identity)</strong>를 사용합니다:</p>
<p>$$(\mathbf{A} + \mathbf{u}\mathbf{v}^T)^{-1} = \mathbf{A}^{-1} - \frac{\mathbf{A}^{-1}\mathbf{u}\mathbf{v}^T\mathbf{A}^{-1}}{1 + \mathbf{v}^T\mathbf{A}^{-1}\mathbf{u}}$$</p>
<p>$\mathbf{P}(n) = \boldsymbol{\Phi}^{-1}(n)$으로 정의하면:</p>
<p>$$\mathbf{P}(n) = \lambda^{-1}\mathbf{P}(n-1) - \lambda^{-1}\mathbf{k}(n)\mathbf{x}^T(n)\mathbf{P}(n-1)$$</p>
<p>여기서 <strong>이득 벡터(gain vector)</strong>는:</p>
<p>$$\mathbf{k}(n) = \frac{\lambda^{-1}\mathbf{P}(n-1)\mathbf{x}(n)}{1 + \lambda^{-1}\mathbf{x}^T(n)\mathbf{P}(n-1)\mathbf{x}(n)}$$</p>
<h3 id="74-rls">7.4 RLS 알고리즘 요약<a class="header-link" href="#74-rls" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">RLS</span><span class="w"> </span><span class="n">Algorithm</span>
<span class="err">─────────────────────────────────────────────</span>
<span class="nl">Initialize:</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="mh">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0</span><span class="p">,</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="mh">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">δ</span><span class="o">^</span><span class="p">{</span><span class="o">-</span><span class="mh">1</span><span class="p">}</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="p">(</span><span class="err">δ</span><span class="w"> </span><span class="k">small</span><span class="p">,</span><span class="w"> </span><span class="n">e</span><span class="p">.</span><span class="n">g</span><span class="p">.,</span><span class="w"> </span><span class="mf">0.01</span><span class="p">)</span>
<span class="nl">Parameters:</span><span class="w"> </span><span class="n">forgetting</span><span class="w"> </span><span class="n">factor</span><span class="w"> </span><span class="err">λ</span><span class="w"> </span><span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">g</span><span class="p">.,</span><span class="w"> </span><span class="mf">0.99</span><span class="p">),</span><span class="w"> </span><span class="n">regularization</span><span class="w"> </span><span class="err">δ</span>

<span class="n">For</span><span class="w"> </span><span class="n">each</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">sample</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">1</span><span class="p">,</span><span class="w"> </span><span class="mh">2</span><span class="p">,</span><span class="w"> </span><span class="p">...</span>
<span class="w">  </span><span class="mf">1.</span><span class="w"> </span><span class="n">Compute</span><span class="w"> </span><span class="n">gain</span><span class="w"> </span><span class="nl">vector:</span>
<span class="w">     </span><span class="n">k</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="p">[</span><span class="err">λ</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">x</span><span class="o">^</span><span class="n">T</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span>

<span class="w">  </span><span class="mf">2.</span><span class="w"> </span><span class="n">Compute</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">priori</span><span class="w"> </span><span class="nl">error:</span>
<span class="w">     </span><span class="n">e</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">d</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">w</span><span class="o">^</span><span class="n">T</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="w">  </span><span class="mf">3.</span><span class="w"> </span><span class="n">Update</span><span class="w"> </span><span class="nl">weights:</span>
<span class="w">     </span><span class="n">w</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">w</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">k</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">e</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

<span class="w">  </span><span class="mf">4.</span><span class="w"> </span><span class="n">Update</span><span class="w"> </span><span class="n">inverse</span><span class="w"> </span><span class="n">correlation</span><span class="w"> </span><span class="nl">matrix:</span>
<span class="w">     </span><span class="n">P</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="err">λ</span><span class="o">^</span><span class="p">{</span><span class="o">-</span><span class="mh">1</span><span class="p">}</span><span class="w"> </span><span class="p">[</span><span class="n">P</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mh">1</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">k</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">x</span><span class="o">^</span><span class="n">T</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="n">P</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mh">1</span><span class="p">)]</span>
</code></pre></div>

<p><strong>계산 복잡도</strong>: 샘플당 $O(M^2)$ ($\mathbf{P}$ 행렬 갱신 때문).</p>
<h3 id="75">7.5 망각 인자<a class="header-link" href="#75" title="Permanent link">&para;</a></h3>
<p>망각 인자 $\lambda$는 알고리즘의 <strong>유효 메모리(effective memory)</strong>를 결정합니다:</p>
<p>$$N_{eff} = \frac{1}{1 - \lambda}$$</p>
<table>
<thead>
<tr>
<th>$\lambda$</th>
<th>$N_{eff}$</th>
<th>동작</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.0</td>
<td>$\infty$</td>
<td>성장하는 윈도우 (정상 환경)</td>
</tr>
<tr>
<td>0.99</td>
<td>100</td>
<td>느리게 변하는 통계에 적합</td>
</tr>
<tr>
<td>0.95</td>
<td>20</td>
<td>빠르게 변하는 통계에 적합</td>
</tr>
<tr>
<td>0.9</td>
<td>10</td>
<td>매우 빠른 추적, 하지만 잡음이 많음</td>
</tr>
</tbody>
</table>
<h3 id="76-rls">7.6 RLS의 특성<a class="header-link" href="#76-rls" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>빠른 수렴</strong>: 약 $2M$ 반복에서 수렴 (고유값 분산에 독립적)</li>
<li><strong>고유값 분산 문제 없음</strong>: $\mathbf{P}$ 행렬이 입력을 백색화(whitens)</li>
<li><strong>높은 복잡도</strong>: LMS의 $O(M)$ 대비 $O(M^2)$</li>
<li><strong>수치적 민감성</strong>: $\mathbf{P}$ 행렬이 양정치성을 잃을 수 있음; 안정화된 버전 존재 (QR-RLS, 격자 RLS)</li>
</ol>
<hr />
<h2 id="8-lms-vs-rls">8. 비교: LMS vs RLS<a class="header-link" href="#8-lms-vs-rls" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>특성</th>
<th>LMS</th>
<th>NLMS</th>
<th>RLS</th>
</tr>
</thead>
<tbody>
<tr>
<td>샘플당 복잡도</td>
<td>$O(M)$</td>
<td>$O(M)$</td>
<td>$O(M^2)$</td>
</tr>
<tr>
<td>메모리</td>
<td>$O(M)$</td>
<td>$O(M)$</td>
<td>$O(M^2)$</td>
</tr>
<tr>
<td>수렴 속도</td>
<td>느림 ($\chi$에 의존)</td>
<td>보통</td>
<td>빠름 ($\sim 2M$ 반복)</td>
</tr>
<tr>
<td>오조정</td>
<td>높음</td>
<td>보통</td>
<td>낮음</td>
</tr>
<tr>
<td>추적 능력</td>
<td>보통</td>
<td>보통</td>
<td>좋음</td>
</tr>
<tr>
<td>수치적 안정성</td>
<td>우수</td>
<td>우수</td>
<td>불안정할 수 있음</td>
</tr>
<tr>
<td>고유값 분산 민감도</td>
<td>높음</td>
<td>보통</td>
<td>없음</td>
</tr>
<tr>
<td>스텝 크기 파라미터</td>
<td>$\mu$ (설정 까다로움)</td>
<td>$\tilde{\mu} \in (0,2)$</td>
<td>$\lambda$ (설정 더 쉬움)</td>
</tr>
</tbody>
</table>
<p><strong>경험 규칙</strong>: 계산 비용이 최우선이거나 필터가 길 때는 LMS/NLMS를 사용합니다. 빠른 수렴이 필수적이고 필터 차수가 적절할 때는 RLS를 사용합니다.</p>
<hr />
<h2 id="9">9. 응용: 시스템 식별<a class="header-link" href="#9" title="Permanent link">&para;</a></h2>
<h3 id="91">9.1 문제 설정<a class="header-link" href="#91" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>                    ┌────────────────────┐
     x(n) ────────▶│  Unknown System     │────────▶ d(n) = h*x(n) + v(n)
         │          │  h = [h0, h1, ...]  │
         │          └────────────────────┘
         │
         │          ┌────────────────────┐
         └────────▶│  Adaptive Filter   │────────▶ y(n) = w^T x(n)
                    │  w(n)              │
                    └────────────────────┘
                                                    e(n) = d(n) - y(n) → 0
</code></pre></div>

<p>적응 필터는 미지 시스템의 임펄스 응답을 학습합니다. 알고리즘이 수렴하면 $\mathbf{w}_{opt} \approx \mathbf{h}$가 됩니다.</p>
<h3 id="92">9.2 사용 시기<a class="header-link" href="#92" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>플랜트 모델링</strong>: 제어 시스템에는 시스템 모델이 필요합니다</li>
<li><strong>음향 경로 식별</strong>: 실내 임펄스 응답 파악</li>
<li><strong>적응 역 제어</strong>: 순방향 모델을 식별한 후 역산</li>
</ul>
<hr />
<h2 id="10">10. 응용: 잡음 제거<a class="header-link" href="#10" title="Permanent link">&para;</a></h2>
<h3 id="101-anc">10.1 적응 잡음 제거기 (ANC)<a class="header-link" href="#101-anc" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>     Signal s(n) + Noise n0(n) = d(n)    (primary input)

     Noise reference n1(n)               (reference input, correlated with n0)
              │
              ▼
     ┌────────────────────┐
     │  Adaptive Filter   │ ──▶ ŷ(n) ≈ n0(n)
     │  w(n)              │
     └────────────────────┘
                                         e(n) = d(n) - ŷ(n) ≈ s(n)
</code></pre></div>

<p><strong>핵심 통찰</strong>: 기준 입력 $n_1(n)$은 잡음 $n_0(n)$과 상관되어 있지만 신호 $s(n)$과는 상관되지 않습니다. 적응 필터는 $n_1(n)$을 $n_0(n)$의 추정값으로 변환합니다. 그러면 오차 신호가 깨끗한 신호 $s(n)$의 추정값이 됩니다.</p>
<h3 id="102">10.2 수학적 정당성<a class="header-link" href="#102" title="Permanent link">&para;</a></h3>
<p>MSE는:</p>
<p>$$E[e^2(n)] = E[(s(n) + n_0(n) - \hat{y}(n))^2]$$</p>
<p>$s(n)$이 $n_0(n)$과 $n_1(n)$ 모두와 상관되지 않으므로:</p>
<p>$$E[e^2(n)] = E[s^2(n)] + E[(n_0(n) - \hat{y}(n))^2]$$</p>
<p>$\mathbf{w}$에 대해 $E[e^2(n)]$을 최소화하면 $E[(n_0(n) - \hat{y}(n))^2]$가 최소화되어 $\hat{y}(n) \to n_0(n)$이 되고 $e(n) \to s(n)$이 됩니다.</p>
<p><strong>신호는 잡음 추정의 부산물로 추출됩니다.</strong></p>
<hr />
<h2 id="11_1">11. 응용: 에코 제거<a class="header-link" href="#11_1" title="Permanent link">&para;</a></h2>
<h3 id="111-aec">11.1 음향 에코 제거 (AEC)<a class="header-link" href="#111-aec" title="Permanent link">&para;</a></h3>
<p>스피커폰 시스템에서 원단(far-end) 음성이 스피커를 통해 재생되고, 방 안에서 반향되어 마이크로폰에 포착됩니다. 적응 필터는 스피커에서 마이크로폰까지의 음향 경로를 모델링합니다.</p>
<div class="highlight"><pre><span></span><code>Far-end ──▶ Loudspeaker ──▶ Room ──▶ Microphone ──▶ Near-end + Echo
  x(n)                   h(n)                        d(n) = s(n) + h*x(n)
    │
    │         ┌──────────────────┐
    └────────▶│  Adaptive Filter │──▶ ŷ(n) ≈ h*x(n)
              │  w(n) ≈ h        │
              └──────────────────┘
                                       e(n) = d(n) - ŷ(n) ≈ s(n)
</code></pre></div>

<p><strong>도전 과제</strong>:
- 음향 임펄스 응답은 매우 길 수 있습니다 (8 kHz에서 100-500 ms = 800-4000 탭)
- 이중 통화(double-talk): 두 화자가 동시에 활성화
- 비정상성: 사람이 이동하고 문이 열림</p>
<h3 id="112">11.2 네트워크 에코 제거<a class="header-link" href="#112" title="Permanent link">&para;</a></h3>
<p>전화 네트워크에서 하이브리드(2선-4선 변환)의 임피던스 불일치가 전기적 에코를 생성합니다. 에코 경로는 짧지만 요구 사항이 엄격합니다 (&gt;40 dB 에코 반환 손실 향상).</p>
<hr />
<h2 id="12_1">12. 응용: 채널 등화<a class="header-link" href="#12_1" title="Permanent link">&para;</a></h2>
<h3 id="121">12.1 문제<a class="header-link" href="#121" title="Permanent link">&para;</a></h3>
<p>전송된 신호 $a(n)$이 분산 채널 $c(n)$을 통과하여 심볼 간 간섭(inter-symbol interference, ISI)을 생성합니다:</p>
<p>$$x(n) = \sum_k c(k) a(n-k) + v(n)$$</p>
<p>등화기(equalizer)는 채널 왜곡을 되돌리는 적응 필터입니다:</p>
<p>$$\hat{a}(n - \Delta) = \mathbf{w}^T(n) \mathbf{x}(n)$$</p>
<p>여기서 $\Delta$는 $w(n) * c(n) \approx \delta(n - \Delta)$가 되도록 선택된 결정 지연(decision delay)입니다.</p>
<h3 id="122">12.2 훈련 및 결정 주도 모드<a class="header-link" href="#122" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>훈련 모드</strong>: 알려진 시퀀스가 전송됩니다; $d(n) = a(n-\Delta)$</li>
<li><strong>결정 주도 모드</strong>: 초기 수렴 후, 슬라이서(slicer) 출력 $\hat{a}(n-\Delta)$를 $d(n)$으로 사용</li>
</ul>
<hr />
<h2 id="13_2">13. 응용: 적응 빔포밍<a class="header-link" href="#13_2" title="Permanent link">&para;</a></h2>
<h3 id="131">13.1 문제<a class="header-link" href="#131" title="Permanent link">&para;</a></h3>
<p>$M$개의 센서로 구성된 배열이 여러 방향에서 신호를 수신합니다. 목표는 원하는 신호 방향으로 빔을 조향하면서 간섭원(interferer)을 널링(nulling)하는 것입니다.</p>
<p>배열에서 수신된 신호는:</p>
<p>$$\mathbf{x}(n) = s(n)\mathbf{a}(\theta_s) + \sum_{k=1}^{K} i_k(n)\mathbf{a}(\theta_k) + \mathbf{v}(n)$$</p>
<p>여기서 $\mathbf{a}(\theta)$는 방향 $\theta$에 대한 <strong>조향 벡터(steering vector)</strong>입니다.</p>
<h3 id="132-mvdr">13.2 최소 분산 왜곡 없는 응답 (MVDR)<a class="header-link" href="#132-mvdr" title="Permanent link">&para;</a></h3>
<p>Capon 빔포머는 다음을 풉니다:</p>
<p>$$\min_{\mathbf{w}} \mathbf{w}^H \mathbf{R} \mathbf{w} \quad \text{제약 조건:} \quad \mathbf{w}^H \mathbf{a}(\theta_s) = 1$$</p>
<p>해:</p>
<p>$$\mathbf{w}_{MVDR} = \frac{\mathbf{R}^{-1}\mathbf{a}(\theta_s)}{\mathbf{a}^H(\theta_s)\mathbf{R}^{-1}\mathbf{a}(\theta_s)}$$</p>
<p>적응형 변형은 RLS와 유사한 갱신을 사용하여 $\mathbf{R}$을 순환적으로 추정합니다.</p>
<hr />
<h2 id="14-python">14. Python 구현: 완전한 적응 필터링 툴킷<a class="header-link" href="#14-python" title="Permanent link">&para;</a></h2>
<h3 id="141-lms-nlms-rls">14.1 LMS, NLMS, RLS 구현<a class="header-link" href="#141-lms-nlms-rls" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>


<span class="k">def</span><span class="w"> </span><span class="nf">lms_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">mu</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    LMS adaptive filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Input signal</span>
<span class="sd">    d : ndarray</span>
<span class="sd">        Desired (reference) signal</span>
<span class="sd">    M : int</span>
<span class="sd">        Filter order (number of taps)</span>
<span class="sd">    mu : float</span>
<span class="sd">        Step size</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y : ndarray</span>
<span class="sd">        Filter output</span>
<span class="sd">    e : ndarray</span>
<span class="sd">        Error signal</span>
<span class="sd">    w_history : ndarray</span>
<span class="sd">        Weight history (N x M)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">w_history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">x_vec</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">:</span><span class="n">n</span><span class="o">-</span><span class="n">M</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">M</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]])</span>
        <span class="c1"># Proper construction of input vector</span>
        <span class="n">x_vec</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x_vec</span><span class="p">)</span>
        <span class="n">e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">+</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_vec</span>
        <span class="n">w_history</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>

    <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">w_history</span>


<span class="k">def</span><span class="w"> </span><span class="nf">nlms_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">mu_tilde</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">1e-6</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Normalized LMS adaptive filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Input signal</span>
<span class="sd">    d : ndarray</span>
<span class="sd">        Desired (reference) signal</span>
<span class="sd">    M : int</span>
<span class="sd">        Filter order</span>
<span class="sd">    mu_tilde : float</span>
<span class="sd">        Normalized step size (0 &lt; mu_tilde &lt; 2)</span>
<span class="sd">    delta : float</span>
<span class="sd">        Regularization constant</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y, e, w_history : ndarrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">w_history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">x_vec</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x_vec</span><span class="p">)</span>
        <span class="n">e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

        <span class="n">norm_sq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">x_vec</span><span class="p">,</span> <span class="n">x_vec</span><span class="p">)</span> <span class="o">+</span> <span class="n">delta</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">+</span> <span class="p">(</span><span class="n">mu_tilde</span> <span class="o">/</span> <span class="n">norm_sq</span><span class="p">)</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">x_vec</span>
        <span class="n">w_history</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>

    <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">w_history</span>


<span class="k">def</span><span class="w"> </span><span class="nf">rls_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">0.99</span><span class="p">,</span> <span class="n">delta</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursive Least Squares adaptive filter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : ndarray</span>
<span class="sd">        Input signal</span>
<span class="sd">    d : ndarray</span>
<span class="sd">        Desired (reference) signal</span>
<span class="sd">    M : int</span>
<span class="sd">        Filter order</span>
<span class="sd">    lam : float</span>
<span class="sd">        Forgetting factor (0 &lt; lambda &lt;= 1)</span>
<span class="sd">    delta : float</span>
<span class="sd">        Regularization for P initialization</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    y, e, w_history : ndarrays</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">delta</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">w_history</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span> <span class="n">M</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="n">x_vec</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Gain vector</span>
        <span class="n">Px</span> <span class="o">=</span> <span class="n">P</span> <span class="o">@</span> <span class="n">x_vec</span>
        <span class="n">denom</span> <span class="o">=</span> <span class="n">lam</span> <span class="o">+</span> <span class="n">x_vec</span> <span class="o">@</span> <span class="n">Px</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">Px</span> <span class="o">/</span> <span class="n">denom</span>

        <span class="c1"># A priori error</span>
        <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">x_vec</span><span class="p">)</span>
        <span class="n">e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">-</span> <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

        <span class="c1"># Weight update</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">w</span> <span class="o">+</span> <span class="n">k</span> <span class="o">*</span> <span class="n">e</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

        <span class="c1"># Inverse correlation matrix update</span>
        <span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="n">lam</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">P</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">x_vec</span> <span class="o">@</span> <span class="n">P</span><span class="p">))</span>

        <span class="n">w_history</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>

    <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">w_history</span>
</code></pre></div>

<h3 id="142">14.2 시스템 식별 예제<a class="header-link" href="#142" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># System Identification Demo</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="c1"># Unknown system (FIR)</span>
<span class="n">h_true</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">])</span>
<span class="n">M</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h_true</span><span class="p">)</span>

<span class="c1"># Generate input signal (white noise)</span>
<span class="n">N</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># System output + measurement noise</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">h_true</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)[:</span><span class="n">N</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># Run adaptive filters</span>
<span class="n">mu_lms</span> <span class="o">=</span> <span class="mf">0.01</span>
<span class="n">_</span><span class="p">,</span> <span class="n">e_lms</span><span class="p">,</span> <span class="n">w_lms</span> <span class="o">=</span> <span class="n">lms_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">mu_lms</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">e_nlms</span><span class="p">,</span> <span class="n">w_nlms</span> <span class="o">=</span> <span class="n">nlms_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">mu_tilde</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">e_rls</span><span class="p">,</span> <span class="n">w_rls</span> <span class="o">=</span> <span class="n">rls_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">0.99</span><span class="p">)</span>

<span class="c1"># Plot learning curves</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>

<span class="c1"># MSE learning curves (smoothed)</span>
<span class="n">window</span> <span class="o">=</span> <span class="mi">50</span>
<span class="n">mse_lms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">e_lms</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="n">window</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
<span class="n">mse_nlms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">e_nlms</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="n">window</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>
<span class="n">mse_rls</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">e_rls</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="n">window</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;valid&#39;</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">mse_lms</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;LMS&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">mse_nlms</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;NLMS&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">mse_rls</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;RLS&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Iteration&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;MSE&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Learning Curves: System Identification&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="c1"># Final weight comparison</span>
<span class="n">x_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="n">width</span> <span class="o">=</span> <span class="mf">0.2</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x_pos</span> <span class="o">-</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="n">h_true</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True&#39;</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;black&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x_pos</span> <span class="o">-</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="n">w_lms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">width</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;LMS&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x_pos</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="n">w_nlms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">width</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;NLMS&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x_pos</span> <span class="o">+</span> <span class="mf">1.5</span><span class="o">*</span><span class="n">width</span><span class="p">,</span> <span class="n">w_rls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">width</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;RLS&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Tap index&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Weight value&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Identified Impulse Response&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;system_identification.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Print final weights</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;True system:  &quot;</span><span class="p">,</span> <span class="n">h_true</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;LMS weights:  &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">w_lms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;NLMS weights: &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">w_nlms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;RLS weights:  &quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">w_rls</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
</code></pre></div>

<h3 id="143">14.3 잡음 제거 데모<a class="header-link" href="#143" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># Adaptive Noise Cancellation Demo</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">5000</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1000.0</span>  <span class="c1"># 1 kHz sampling rate</span>

<span class="c1"># Clean signal: sum of sinusoids</span>
<span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">50</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="mi">120</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>

<span class="c1"># Noise source</span>
<span class="n">noise_source</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># Noise that corrupts the signal (filtered version of noise source)</span>
<span class="n">noise_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.1</span><span class="p">])</span>
<span class="n">n0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">noise_source</span><span class="p">,</span> <span class="n">noise_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)[:</span><span class="n">N</span><span class="p">]</span>

<span class="c1"># Primary input: signal + noise</span>
<span class="n">d</span> <span class="o">=</span> <span class="n">s</span> <span class="o">+</span> <span class="n">n0</span>

<span class="c1"># Reference input: correlated with noise but not with signal</span>
<span class="c1"># (different path from the noise source)</span>
<span class="n">ref_path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="n">n1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">noise_source</span><span class="p">,</span> <span class="n">ref_path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)[:</span><span class="n">N</span><span class="p">]</span>

<span class="c1"># Apply adaptive noise canceller</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">8</span>  <span class="c1"># Filter order (longer than the noise path to be safe)</span>
<span class="n">mu</span> <span class="o">=</span> <span class="mf">0.01</span>

<span class="n">y_lms</span><span class="p">,</span> <span class="n">e_lms</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">lms_filter</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">mu</span><span class="p">)</span>
<span class="n">y_nlms</span><span class="p">,</span> <span class="n">e_nlms</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">nlms_filter</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">mu_tilde</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">y_rls</span><span class="p">,</span> <span class="n">e_rls</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">rls_filter</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">0.995</span><span class="p">)</span>

<span class="c1"># Plot results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="mi">500</span><span class="p">],</span> <span class="n">s</span><span class="p">[:</span><span class="mi">500</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Clean signal&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Original Clean Signal&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="mi">500</span><span class="p">],</span> <span class="n">d</span><span class="p">[:</span><span class="mi">500</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Signal + Noise&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Noisy Signal (Primary Input)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="mi">500</span><span class="p">],</span> <span class="n">e_nlms</span><span class="p">[:</span><span class="mi">500</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;NLMS output&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="mi">500</span><span class="p">],</span> <span class="n">s</span><span class="p">[:</span><span class="mi">500</span><span class="p">],</span> <span class="s1">&#39;g--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Clean (reference)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Recovered Signal (NLMS Noise Canceller)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="c1"># SNR improvement over time</span>
<span class="n">window</span> <span class="o">=</span> <span class="mi">200</span>
<span class="n">snr_input</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="n">window</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">/</span>
    <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">n0</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="n">window</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span>
<span class="p">)</span>
<span class="n">residual_nlms</span> <span class="o">=</span> <span class="n">e_nlms</span> <span class="o">-</span> <span class="n">s</span>
<span class="n">snr_output</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="n">window</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">/</span>
    <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">residual_nlms</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">window</span><span class="p">)</span><span class="o">/</span><span class="n">window</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span>
<span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">snr_input</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Input SNR&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">snr_output</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Output SNR (NLMS)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;SNR (dB)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;SNR Improvement&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;noise_cancellation.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># Compute overall SNR improvement</span>
<span class="n">snr_in</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">M</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">n0</span><span class="p">[</span><span class="n">M</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
<span class="n">snr_out_nlms</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span>
    <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1000</span><span class="p">:]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">((</span><span class="n">e_nlms</span><span class="p">[</span><span class="mi">1000</span><span class="p">:]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="mi">1000</span><span class="p">:])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Input SNR:       </span><span class="si">{</span><span class="n">snr_in</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> dB&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Output SNR (NLMS): </span><span class="si">{</span><span class="n">snr_out_nlms</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> dB&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;SNR improvement:   </span><span class="si">{</span><span class="n">snr_out_nlms</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">snr_in</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> dB&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="144">14.4 시변 시스템 추적<a class="header-link" href="#144" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c1"># Tracking a time-varying system</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">4000</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

<span class="c1"># Time-varying system: coefficients change at n=2000</span>
<span class="n">h1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">])</span>
<span class="n">h2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="n">M</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
<span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
    <span class="n">x_vec</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="n">M</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">2000</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">h1</span><span class="p">,</span> <span class="n">x_vec</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">d</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">h2</span><span class="p">,</span> <span class="n">x_vec</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.01</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span>

<span class="c1"># Compare algorithms</span>
<span class="n">_</span><span class="p">,</span> <span class="n">e_lms</span><span class="p">,</span> <span class="n">w_lms</span> <span class="o">=</span> <span class="n">lms_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">e_nlms</span><span class="p">,</span> <span class="n">w_nlms</span> <span class="o">=</span> <span class="n">nlms_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">mu_tilde</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="n">_</span><span class="p">,</span> <span class="n">e_rls</span><span class="p">,</span> <span class="n">w_rls</span> <span class="o">=</span> <span class="n">rls_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">lam</span><span class="o">=</span><span class="mf">0.98</span><span class="p">)</span>

<span class="c1"># Plot weight trajectories</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">10</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">titles</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;LMS&#39;</span><span class="p">,</span> <span class="s1">&#39;NLMS&#39;</span><span class="p">,</span> <span class="s1">&#39;RLS&#39;</span><span class="p">]</span>
<span class="n">w_histories</span> <span class="o">=</span> <span class="p">[</span><span class="n">w_lms</span><span class="p">,</span> <span class="n">w_nlms</span><span class="p">,</span> <span class="n">w_rls</span><span class="p">]</span>
<span class="n">colors</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tab:blue&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:orange&#39;</span><span class="p">,</span> <span class="s1">&#39;tab:green&#39;</span><span class="p">]</span>

<span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">title</span><span class="p">,</span> <span class="n">w_hist</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">titles</span><span class="p">,</span> <span class="n">w_histories</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">w_hist</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;w[</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">]&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
    <span class="c1"># Plot true values</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">h1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">h1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axhline</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">h1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;:&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="mi">2000</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;System change&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">title</span><span class="si">}</span><span class="s1"> Weight Tracking&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;upper right&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Iteration&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;tracking_demo.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="15">15. 연습 문제<a class="header-link" href="#15" title="Permanent link">&para;</a></h2>
<h3 id="1_1">연습 문제 1: 위너 필터<a class="header-link" href="#1_1" title="Permanent link">&para;</a></h3>
<p>$x(n)$이 분산 $\sigma_x^2 = 1$인 백색 잡음이고, 원하는 신호가 $d(n) = 0.8x(n) + 0.5x(n-1) - 0.3x(n-2) + v(n)$인 시스템을 고려하세요. 여기서 $v(n)$은 분산 $\sigma_v^2 = 0.1$인 백색 잡음으로 $x(n)$과 독립입니다.</p>
<p>(a) 3탭 위너 필터에 대한 자기상관 행렬 $\mathbf{R}$을 계산하세요.</p>
<p>(b) 상호상관 벡터 $\mathbf{p}$를 계산하세요.</p>
<p>(c) $\mathbf{R}\mathbf{w}_{opt} = \mathbf{p}$를 풀어 최적 위너 필터 $\mathbf{w}_{opt}$를 구하세요.</p>
<p>(d) 최소 MSE $J_{min}$을 계산하세요.</p>
<h3 id="2-lms">연습 문제 2: LMS 수렴<a class="header-link" href="#2-lms" title="Permanent link">&para;</a></h3>
<p>$M = 10$ 탭을 가진 LMS 필터가 자기상관 행렬의 고유값이 $\lambda_{max} = 5.0$, $\lambda_{min} = 0.1$인 입력 신호에 적용됩니다.</p>
<p>(a) 평균 수렴을 위한 최대 스텝 크기는 얼마입니까?</p>
<p>(b) 조건수 $\chi(\mathbf{R})$은 얼마입니까?</p>
<p>(c) $\mu = 0.01$이면, $\text{tr}(\mathbf{R}) = 10$일 때 오조정 $\mathcal{M}$을 계산하세요.</p>
<p>(d) 가장 느린 모드의 수렴 시상수 $\tau_{mse}$를 추정하세요.</p>
<p>(e) LMS를 적용하기 전에 입력을 백색화(whitening)하면 수렴이 어떻게 변할지 질적으로 설명하세요.</p>
<h3 id="3-nlms-vs-lms">연습 문제 3: NLMS vs LMS<a class="header-link" href="#3-nlms-vs-lms" title="Permanent link">&para;</a></h3>
<p>전력이 500 샘플마다 0.1과 10.0 사이를 교대하는 비정상 입력 신호에 대해 잡음 제거를 위한 LMS와 NLMS를 모두 구현하세요. 필터 차수 $M = 16$을 사용하세요.</p>
<p>(a) 고정 스텝 크기를 가진 LMS가 고전력 구간에서 발산하거나 저전력 구간에서 너무 느리게 수렴함을 보이세요.</p>
<p>(b) NLMS가 전력 변동을 우아하게 처리함을 시연하세요.</p>
<p>(c) 두 알고리즘의 MSE 학습 곡선을 그리세요.</p>
<h3 id="4-rls">연습 문제 4: RLS 구현<a class="header-link" href="#4-rls" title="Permanent link">&para;</a></h3>
<p>임펄스 응답 $h = [1, -0.5, 0.25, -0.125]$를 가진 시스템을 식별하기 위해 망각 인자 $\lambda = 0.99$로 RLS를 구현하세요.</p>
<p>(a) 각 가중치가 실제 값으로 수렴하는 것을 그래프로 나타내세요. LMS 및 NLMS와 비교하세요.</p>
<p>(b) $\lambda$를 0.9에서 1.0까지 변화시키고 정상 상태 MSE 대 수렴 시간 트레이드오프를 그리세요.</p>
<p>(c) $n = 1000$에서 시스템 변화를 도입하세요 ($h$를 $[0.5, 0.3, -0.2, 0.1]$로 변경). LMS, NLMS, RLS의 추적 성능을 비교하세요.</p>
<h3 id="5">연습 문제 5: 에코 제거 시뮬레이션<a class="header-link" href="#5" title="Permanent link">&para;</a></h3>
<p>음향 에코 제거 시나리오를 시뮬레이션하세요:</p>
<p>(a) 다양한 주파수의 정현파 합으로 "원단 음성" 신호를 생성하세요.</p>
<p>(b) 실내 임펄스 응답을 생성하세요 (길이 100의 지수적으로 감소하는 랜덤 시퀀스 사용).</p>
<p>(c) 근단(near-end) 잡음을 추가하세요.</p>
<p>(d) 필터 차수 128의 NLMS를 적용하세요. 시간에 따른 에코 반환 손실 향상(ERLE)을 그리세요:</p>
<p>$$\text{ERLE}(n) = 10 \log_{10} \frac{E[d^2(n)]}{E[e^2(n)]}$$</p>
<p>(e) 이중 통화(근단 음성 추가)가 적응 필터에 미치는 영향을 조사하세요.</p>
<h3 id="6">연습 문제 6: 적응 등화<a class="header-link" href="#6" title="Permanent link">&para;</a></h3>
<p>디지털 통신 채널이 임펄스 응답 $c = [0.5, 1.0, 0.5]$를 가집니다 (ISI 발생).</p>
<p>(a) 랜덤 BPSK 신호($a(n) \in \{-1, +1\}$)를 생성하고 채널을 통과시키세요. SNR = 20 dB에서 잡음을 추가하세요.</p>
<p>(b) $M = 11$ 탭과 결정 지연 $\Delta = 5$로 LMS를 사용하여 적응 등화기를 설계하세요.</p>
<p>(c) 훈련 길이의 함수로 비트 오류율(BER)을 그리세요.</p>
<p>(d) 500개의 훈련 심볼 후 결정 주도 모드로 전환하고 BER이 안정적으로 유지됨을 검증하세요.</p>
<p>(e) 등화 전후의 아이 다이어그램(eye diagram)을 비교하세요.</p>
<h3 id="7">연습 문제 7: 필터 차수의 영향<a class="header-link" href="#7" title="Permanent link">&para;</a></h3>
<p>실제 시스템 $h = [0.5, 1.2, -0.8, 0.3, -0.1]$에 대한 시스템 식별 문제에서:</p>
<p>(a) 필터 차수 $M = 3, 5, 7, 10, 20$으로 LMS를 실행하고 정상 상태 MSE를 비교하세요.</p>
<p>(b) $M < 5$ (과소 모델링)와 $M > 5$ (과대 모델링)일 때 어떤 일이 발생하는지 설명하세요.</p>
<p>(c) 각 $M$에 대해 식별된 임펄스 응답을 그리세요.</p>
<hr />
<h2 id="16">16. 요약<a class="header-link" href="#16" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>개념</th>
<th>핵심 공식 / 아이디어</th>
</tr>
</thead>
<tbody>
<tr>
<td>위너 필터</td>
<td>$\mathbf{w}_{opt} = \mathbf{R}^{-1}\mathbf{p}$ (최적 MMSE)</td>
</tr>
<tr>
<td>최급강하법</td>
<td>$\mathbf{w}(n+1) = \mathbf{w}(n) + 2\mu(\mathbf{p} - \mathbf{R}\mathbf{w}(n))$</td>
</tr>
<tr>
<td>수렴 조건</td>
<td>$0 < \mu < 1/\lambda_{max}$</td>
</tr>
<tr>
<td>LMS 갱신</td>
<td>$\mathbf{w}(n+1) = \mathbf{w}(n) + \mu \, e(n) \, \mathbf{x}(n)$</td>
</tr>
<tr>
<td>LMS 오조정</td>
<td>$\mathcal{M} = \mu \, \text{tr}(\mathbf{R})$</td>
</tr>
<tr>
<td>NLMS 갱신</td>
<td>$\mathbf{w}(n+1) = \mathbf{w}(n) + \frac{\tilde{\mu}}{\|\mathbf{x}\|^2+\delta} e(n)\mathbf{x}(n)$</td>
</tr>
<tr>
<td>RLS 이득</td>
<td>$\mathbf{k}(n) = \frac{\mathbf{P}(n-1)\mathbf{x}(n)}{\lambda + \mathbf{x}^T(n)\mathbf{P}(n-1)\mathbf{x}(n)}$</td>
</tr>
<tr>
<td>망각 인자 메모리</td>
<td>$N_{eff} = 1/(1-\lambda)$</td>
</tr>
<tr>
<td>잡음 제거</td>
<td>오차 신호 $e(n) = d(n) - \hat{y}(n) \approx s(n)$</td>
</tr>
<tr>
<td>트레이드오프</td>
<td>빠른 수렴 vs 낮은 오조정</td>
</tr>
</tbody>
</table>
<p><strong>핵심 정리</strong>:
1. 위너 필터는 이론적 최적을 제공하지만 알려진 통계가 필요합니다.
2. LMS는 기울기를 순간 추정값으로 근사합니다 - 단순하고 강건하며 $O(M)$입니다.
3. NLMS는 입력 전력으로 정규화합니다 - 변동하는 신호 레벨에서 더 나은 안정성을 제공합니다.
4. RLS는 지수 가중치로 모든 과거 데이터를 사용합니다 - $O(M^2)$ 비용으로 빠른 수렴을 달성합니다.
5. 오조정-수렴 트레이드오프는 모든 적응 알고리즘에 근본적입니다.
6. 적응 필터는 잡음 제거에서 등화까지 수많은 응용을 지원합니다.</p>
<hr />
<h2 id="17">17. 참고 문헌<a class="header-link" href="#17" title="Permanent link">&para;</a></h2>
<ol>
<li>S. Haykin, <em>Adaptive Filter Theory</em>, 5th ed., Pearson, 2014.</li>
<li>A.H. Sayed, <em>Adaptive Filters</em>, Wiley-IEEE Press, 2008.</li>
<li>P.S.R. Diniz, <em>Adaptive Filtering: Algorithms and Practical Implementation</em>, 4th ed., Springer, 2013.</li>
<li>B. Widrow and S.D. Stearns, <em>Adaptive Signal Processing</em>, Pearson, 1985.</li>
<li>S. Haykin, "Adaptive filter theory," in <em>Proc. IEEE</em>, vol. 90, no. 2, pp. 211-259, 2002.</li>
<li>B. Farhang-Boroujeny, <em>Adaptive Filters: Theory and Applications</em>, 2nd ed., Wiley, 2013.</li>
</ol>
<hr />
<p><strong>이전</strong>: <a href="./12_Multirate_Signal_Processing.md">12. 다중 레이트 신호 처리</a> | <strong>다음</strong>: <a href="./14_Time_Frequency_Analysis.md">14. 시간-주파수 분석</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Signal_Processing/12_Spectral_Analysis.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">스펙트럼 분석(Spectral Analysis)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Signal_Processing/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Signal_Processing/14_Time_Frequency_Analysis.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">14. 시간-주파수 분석(Time-Frequency Analysis)</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}