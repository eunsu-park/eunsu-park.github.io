{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>16. 신호 처리의 응용 - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Signal_Processing/">Signal Processing</a>
    <span class="separator">/</span>
    <span class="current">16. 신호 처리의 응용</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>16. 신호 처리의 응용</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Signal_Processing/15_Image_Signal_Processing.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">15. 영상 신호 처리(Image Signal Processing)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Signal_Processing/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#_1">목차</a></li>
<li><a href="#1">1. 오디오 신호 처리</a><ul>
<li><a href="#11">1.1 오디오 신호 체인</a></li>
<li><a href="#12">1.2 주파수 대역</a></li>
</ul>
</li>
<li><a href="#2">2. 오디오 표현과 포맷</a><ul>
<li><a href="#21-pulse-code-modulation-pcm">2.1 펄스 코드 변조(Pulse Code Modulation, PCM)</a></li>
<li><a href="#22">2.2 데이터 레이트</a></li>
<li><a href="#23-dithering">2.3 디더링(Dithering)</a></li>
</ul>
</li>
<li><a href="#3">3. 디지털 오디오 이펙트</a><ul>
<li><a href="#31">3.1 지연 기반 이펙트</a><ul>
<li><a href="#echodelay">에코/딜레이(Echo/Delay)</a></li>
<li><a href="#reverb">리버브(Reverb)</a></li>
</ul>
</li>
<li><a href="#32">3.2 변조 기반 이펙트</a><ul>
<li><a href="#chorus">코러스(Chorus)</a></li>
<li><a href="#flanger">플랜저(Flanger)</a></li>
<li><a href="#vibrato">비브라토(Vibrato)</a></li>
</ul>
</li>
<li><a href="#33">3.3 다이나믹스 처리</a><ul>
<li><a href="#compressor">컴프레서(Compressor)</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#4">4. 피치 검출</a><ul>
<li><a href="#41">4.1 자기상관 방법</a></li>
<li><a href="#42">4.2 켑스트럼 방법</a></li>
<li><a href="#43">4.3 비교</a></li>
</ul>
</li>
<li><a href="#5">5. 오디오 이퀄라이제이션</a><ul>
<li><a href="#51-graphic-equalizer">5.1 그래픽 이퀄라이저(Graphic Equalizer)</a></li>
<li><a href="#52-parametric-equalizer">5.2 파라메트릭 이퀄라이저(Parametric Equalizer)</a></li>
<li><a href="#53-shelving-filter">5.3 쉘빙 필터(Shelving Filter)</a></li>
</ul>
</li>
<li><a href="#6-lpc">6. 음성 코딩: 선형 예측 코딩(LPC)</a><ul>
<li><a href="#61-">6.1 소스-필터 모델</a></li>
<li><a href="#62">6.2 선형 예측</a></li>
<li><a href="#63-lpc">6.3 LPC 계수 계산</a></li>
<li><a href="#64-lpc-vocoder">6.4 LPC 보코더(Vocoder)</a></li>
<li><a href="#65-lpc">6.5 LPC 스펙트럼</a></li>
</ul>
</li>
<li><a href="#7">7. 통신: 아날로그 변조</a><ul>
<li><a href="#71">7.1 변조가 필요한 이유</a></li>
<li><a href="#72-amplitude-modulation-am">7.2 진폭 변조(Amplitude Modulation, AM)</a></li>
<li><a href="#73-frequency-modulation-fm">7.3 주파수 변조(Frequency Modulation, FM)</a></li>
<li><a href="#74-phase-modulation-pm">7.4 위상 변조(Phase Modulation, PM)</a></li>
</ul>
</li>
<li><a href="#8">8. 통신: 디지털 변조</a><ul>
<li><a href="#81">8.1 디지털 변조 개요</a></li>
<li><a href="#82-binary-phase-shift-keying-bpsk">8.2 이진 위상 편이 변조(Binary Phase Shift Keying, BPSK)</a></li>
<li><a href="#83-quadrature-phase-shift-keying-qpsk">8.3 직교 위상 편이 변조(Quadrature Phase Shift Keying, QPSK)</a></li>
<li><a href="#84-quadrature-amplitude-modulation-qam">8.4 직교 진폭 변조(Quadrature Amplitude Modulation, QAM)</a></li>
<li><a href="#85-i-q">8.5 I-Q 표현</a></li>
</ul>
</li>
<li><a href="#9">9. 펄스 성형과 정합 필터링</a><ul>
<li><a href="#91-inter-symbol-interference-isi">9.1 심벌간 간섭(Inter-Symbol Interference, ISI) 문제</a></li>
<li><a href="#92-isi">9.2 나이퀴스트 ISI 기준</a></li>
<li><a href="#93-raised-cosine-pulse">9.3 상승 코사인 펄스(Raised Cosine Pulse)</a></li>
<li><a href="#94-matched-filter">9.4 정합 필터(Matched Filter)</a></li>
</ul>
</li>
<li><a href="#10">10. 채널 모델과 등화</a><ul>
<li><a href="#101-additive-white-gaussian-noise-awgn">10.1 가법 백색 가우시안 잡음(Additive White Gaussian Noise, AWGN) 채널</a></li>
<li><a href="#102-multipath-channel">10.2 다중경로 채널(Multipath Channel)</a></li>
<li><a href="#103-zero-forcing-zf">10.3 영점 강제(Zero-Forcing, ZF) 등화기</a></li>
<li><a href="#104-mmse">10.4 MMSE 등화기</a></li>
<li><a href="#105-adaptive-equalization">10.5 적응 등화(Adaptive Equalization)</a></li>
</ul>
</li>
<li><a href="#11-ofdm">11. OFDM 기초</a><ul>
<li><a href="#111">11.1 동기</a></li>
<li><a href="#112-ofdm">11.2 OFDM 시스템 모델</a></li>
<li><a href="#113-cyclic-prefix-cp">11.3 순환 전치(Cyclic Prefix, CP)</a></li>
<li><a href="#114-one-tap-equalization">11.4 단일 탭 등화(One-Tap Equalization)</a></li>
<li><a href="#115-ofdm-wifi">11.5 OFDM 파라미터(WiFi 예시)</a></li>
</ul>
</li>
<li><a href="#12_1">12. 레이더 신호 처리</a><ul>
<li><a href="#121">12.1 레이더 기초</a></li>
<li><a href="#122-range-resolution">12.2 거리 해상도(Range Resolution)</a></li>
<li><a href="#123-doppler-processing">12.3 도플러 처리(Doppler Processing)</a></li>
<li><a href="#124">12.4 레이더용 정합 필터</a></li>
</ul>
</li>
<li><a href="#13">13. 처프 신호와 펄스 압축</a><ul>
<li><a href="#131-fm-linear-fm-chirp">13.1 선형 FM 처프(Linear FM Chirp)</a></li>
<li><a href="#132-pulse-compression">13.2 펄스 압축(Pulse Compression)</a></li>
<li><a href="#133">13.3 압축 후 거리 해상도</a></li>
<li><a href="#134">13.4 사이드로브와 윈도잉</a></li>
</ul>
</li>
<li><a href="#14">14. 모호 함수</a><ul>
<li><a href="#141">14.1 정의</a></li>
<li><a href="#142">14.2 특성</a></li>
<li><a href="#143">14.3 일반적인 파형의 모호 함수</a></li>
<li><a href="#144">14.4 파형 설계</a></li>
</ul>
</li>
<li><a href="#15-ecg">15. 생체의학 신호 처리: ECG</a><ul>
<li><a href="#151-ecg">15.1 ECG 신호</a></li>
<li><a href="#152-ecg">15.2 ECG 신호 특성</a></li>
<li><a href="#153-ecg">15.3 ECG 잡음 소스</a></li>
<li><a href="#154-ecg">15.4 ECG 전처리 파이프라인</a></li>
<li><a href="#155-qrs-pan-tompkins">15.5 QRS 검출: Pan-Tompkins 알고리즘</a></li>
</ul>
</li>
<li><a href="#16-eeg">16. 생체의학 신호 처리: EEG</a><ul>
<li><a href="#161-eeg">16.1 EEG 신호</a></li>
<li><a href="#162-eeg">16.2 EEG 주파수 대역</a></li>
<li><a href="#163-eeg">16.3 EEG 스펙트럼 분석</a></li>
<li><a href="#164-event-related-potentials-erps">16.4 사건 관련 전위(Event-Related Potentials, ERPs)</a></li>
<li><a href="#165-eeg">16.5 EEG를 위한 스펙트럼 분석 방법</a></li>
</ul>
</li>
<li><a href="#17-hrv">17. 심박 변이도(HRV)</a><ul>
<li><a href="#171-hrv">17.1 HRV란?</a></li>
<li><a href="#172">17.2 시간 영역 측정값</a></li>
<li><a href="#173">17.3 주파수 영역 측정값</a></li>
<li><a href="#174-hrv">17.4 HRV 분석 파이프라인</a></li>
</ul>
</li>
<li><a href="#18-python">18. Python 구현</a><ul>
<li><a href="#181">18.1 디지털 오디오 이펙트</a></li>
<li><a href="#182">18.2 디지털 변조</a></li>
<li><a href="#183">18.3 레이더: 처프 펄스 압축</a></li>
<li><a href="#184-ecg">18.4 생체의학: ECG 처리</a></li>
<li><a href="#185">18.5 피치 검출 시연</a></li>
</ul>
</li>
<li><a href="#19">19. 연습 문제</a><ul>
<li><a href="#1_1">연습 1: 오디오 이펙트 체인</a></li>
<li><a href="#2_1">연습 2: 피치 검출 강인성</a></li>
<li><a href="#3-ber">연습 3: 디지털 변조 BER</a></li>
<li><a href="#4-ofdm">연습 4: OFDM 시스템</a></li>
<li><a href="#5_1">연습 5: 레이더 파형 설계</a></li>
<li><a href="#6-ecg">연습 6: ECG 분석 파이프라인</a></li>
<li><a href="#7-eeg">연습 7: EEG 스펙트럼 분석</a></li>
</ul>
</li>
<li><a href="#20">20. 요약</a></li>
<li><a href="#21">21. 참고 문헌</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="16">16. 신호 처리의 응용<a class="header-link" href="#16" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./15_Image_Signal_Processing.md">15. 영상 신호 처리</a> | <a href="./00_Overview.md">개요</a></p>
<hr />
<p>신호 처리는 단순한 이론적 학문이 아니라, 우리가 매일 사용하는 시스템을 지탱하는 공학적 근간입니다. 이 마지막 레슨에서는 오디오, 통신, 레이더/소나, 생체의학 신호 처리라는 네 가지 주요 응용 분야를 살펴봅니다. 각 분야에 대해 핵심 신호 처리 개념을 전개하고, 수학적 기반을 제공하며, 동작하는 Python 시연을 구현합니다. 목표는 앞선 열다섯 레슨에서 배운 도구들이 실제 시스템에서 어떻게 결합되는지를 보여주는 것입니다.</p>
<p><strong>난이도</strong>: ⭐⭐⭐</p>
<p><strong>선수 지식</strong>: DFT/FFT, 필터링(FIR/IIR), 변조 기초, 상관관계, 스펙트럼 분석</p>
<p><strong>학습 목표</strong>:
- 오디오 신호 표현을 이해하고 디지털 오디오 이펙트를 구현한다
- 자기상관(autocorrelation)과 켑스트럼(cepstrum) 방법을 사용한 피치(pitch) 검출을 구현한다
- 아날로그 및 디지털 변조 방식(AM, FM, ASK, FSK, PSK, QAM)을 설명한다
- 펄스 성형(pulse shaping), 정합 필터링(matched filtering), OFDM 기초를 설명한다
- 레이더 신호 처리에 정합 필터링과 처프(chirp) 압축을 적용한다
- 레이더 파형 설계를 위한 모호 함수(ambiguity function)를 계산하고 해석한다
- 본 과정의 기법을 사용하여 생체의학 신호(ECG, EEG)를 처리한다
- 각 응용의 동작하는 Python 시연을 구현한다</p>
<hr />
<h2 id="_1">목차<a class="header-link" href="#_1" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#1-오디오-신호-처리">오디오 신호 처리</a></li>
<li><a href="#2-오디오-표현과-포맷">오디오 표현과 포맷</a></li>
<li><a href="#3-디지털-오디오-이펙트">디지털 오디오 이펙트</a></li>
<li><a href="#4-피치-검출">피치 검출</a></li>
<li><a href="#5-오디오-이퀄라이제이션">오디오 이퀄라이제이션</a></li>
<li><a href="#6-음성-코딩-선형-예측-코딩lpc">음성 코딩: 선형 예측 코딩(LPC)</a></li>
<li><a href="#7-통신-아날로그-변조">통신: 아날로그 변조</a></li>
<li><a href="#8-통신-디지털-변조">통신: 디지털 변조</a></li>
<li><a href="#9-펄스-성형과-정합-필터링">펄스 성형과 정합 필터링</a></li>
<li><a href="#10-채널-모델과-등화">채널 모델과 등화</a></li>
<li><a href="#11-ofdm-기초">OFDM 기초</a></li>
<li><a href="#12-레이더-신호-처리">레이더 신호 처리</a></li>
<li><a href="#13-처프-신호와-펄스-압축">처프 신호와 펄스 압축</a></li>
<li><a href="#14-모호-함수">모호 함수</a></li>
<li><a href="#15-생체의학-신호-처리-ecg">생체의학 신호 처리: ECG</a></li>
<li><a href="#16-생체의학-신호-처리-eeg">생체의학 신호 처리: EEG</a></li>
<li><a href="#17-심박-변이도hrv">심박 변이도(HRV)</a></li>
<li><a href="#18-python-구현">Python 구현</a></li>
<li><a href="#19-연습-문제">연습 문제</a></li>
<li><a href="#20-요약">요약</a></li>
<li><a href="#21-참고-문헌">참고 문헌</a></li>
</ol>
<hr />
<h2 id="1">1. 오디오 신호 처리<a class="header-link" href="#1" title="Permanent link">&para;</a></h2>
<h3 id="11">1.1 오디오 신호 체인<a class="header-link" href="#11" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>음원 → 마이크 → ADC → 디지털 처리 → DAC → 앰프 → 스피커
(아날로그)  (변환기)      (DSP 알고리즘)        (변환기)   (아날로그)
</code></pre></div>

<p>오디오 신호 처리는 음파의 디지털 표현을 대상으로 동작합니다. 주요 파라미터는 다음과 같습니다:</p>
<ul>
<li><strong>샘플링 레이트</strong>(sampling rate) ($f_s$): 44.1 kHz(CD), 48 kHz(전문가용), 96/192 kHz(고해상도)</li>
<li><strong>비트 심도</strong>(bit depth): 16비트(CD), 24비트(전문가용), 32비트 부동소수점(내부 처리)</li>
<li><strong>채널</strong>: 모노(1), 스테레오(2), 서라운드(5.1, 7.1), 공간음향(앰비소닉스)</li>
</ul>
<h3 id="12">1.2 주파수 대역<a class="header-link" href="#12" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>대역</th>
<th>주파수</th>
<th>음악적 맥락</th>
</tr>
</thead>
<tbody>
<tr>
<td>서브 베이스</td>
<td>20-60 Hz</td>
<td>듣는다기보다 느껴짐</td>
</tr>
<tr>
<td>베이스</td>
<td>60-250 Hz</td>
<td>킥 드럼, 베이스 기타</td>
</tr>
<tr>
<td>저중음</td>
<td>250-500 Hz</td>
<td>따뜻함, 악기 몸통감</td>
</tr>
<tr>
<td>중음</td>
<td>500 Hz - 2 kHz</td>
<td>보컬 명료도, 존재감</td>
</tr>
<tr>
<td>고중음</td>
<td>2-4 kHz</td>
<td>체감 음량, 어택감</td>
</tr>
<tr>
<td>프레젠스</td>
<td>4-6 kHz</td>
<td>정의감, 명확성</td>
</tr>
<tr>
<td>브릴리언스</td>
<td>6-20 kHz</td>
<td>공기감, 반짝임, 치찰음</td>
</tr>
</tbody>
</table>
<p>인간 청각은 약 20 Hz에서 20 kHz에 걸쳐 있으며, 외이도 공명으로 인해 2-5 kHz 부근에서 최대 감도를 보입니다.</p>
<hr />
<h2 id="2">2. 오디오 표현과 포맷<a class="header-link" href="#2" title="Permanent link">&para;</a></h2>
<h3 id="21-pulse-code-modulation-pcm">2.1 펄스 코드 변조(Pulse Code Modulation, PCM)<a class="header-link" href="#21-pulse-code-modulation-pcm" title="Permanent link">&para;</a></h3>
<p>PCM은 표준 비압축 디지털 오디오 표현입니다:</p>
<ol>
<li><strong>샘플링</strong>: 아날로그 신호를 $f_s$ 속도로 샘플링</li>
<li><strong>양자화(Quantize)</strong>: 각 샘플을 $2^B$개 레벨 중 하나에 매핑($B$비트 해상도)</li>
<li><strong>부호화(Encode)</strong>: 각 양자화된 샘플의 이진 표현</li>
</ol>
<p>풀 스케일 정현파에 대한 <strong>신호 대 양자화 잡음비(signal-to-quantization-noise ratio, SQNR)</strong>:</p>
<p>$$\text{SQNR} = 6.02B + 1.76 \text{ dB}$$</p>
<p>16비트 오디오의 경우: $\text{SQNR} \approx 98$ dB. 24비트의 경우: $\text{SQNR} \approx 146$ dB.</p>
<h3 id="22">2.2 데이터 레이트<a class="header-link" href="#22" title="Permanent link">&para;</a></h3>
<p>비압축 데이터 레이트:</p>
<p>$$R = f_s \times B \times C$$</p>
<p>여기서 $C$는 채널 수입니다.</p>
<p>CD 오디오(44.1 kHz, 16비트, 스테레오)의 경우: $R = 44100 \times 16 \times 2 = 1.41$ Mbps.</p>
<h3 id="23-dithering">2.3 디더링(Dithering)<a class="header-link" href="#23-dithering" title="Permanent link">&para;</a></h3>
<p>비트 심도를 줄일 때 <strong>디더링</strong>은 양자화 전에 소량의 잡음을 추가하여 왜곡(고조파)을 잡음(광대역)으로 변환합니다. 이를 통해 약간의 잡음 바닥(noise floor) 상승을 감수하는 대신 양자화 왜곡 아티팩트를 제거합니다.</p>
<p>디더 잡음은 일반적으로 진폭이 $\pm 1$ LSB인 삼각형 확률 밀도 함수(triangular probability density function, TPDF)를 사용합니다.</p>
<hr />
<h2 id="3">3. 디지털 오디오 이펙트<a class="header-link" href="#3" title="Permanent link">&para;</a></h2>
<h3 id="31">3.1 지연 기반 이펙트<a class="header-link" href="#31" title="Permanent link">&para;</a></h3>
<p>대부분의 오디오 이펙트는 지연 라인(delay line)으로 구성됩니다:</p>
<p>$$y[n] = x[n] + g \cdot x[n - D]$$</p>
<p>여기서 $D$는 샘플 단위 지연이고 $g$는 피드백/피드포워드 이득입니다.</p>
<h4 id="echodelay">에코/딜레이(Echo/Delay)<a class="header-link" href="#echodelay" title="Permanent link">&para;</a></h4>
<p>피드백이 있는 단순 지연:</p>
<p>$$y[n] = x[n] + g \cdot y[n - D]$$</p>
<p>청취 가능한 에코의 경우: $D > 50$ ms ($D > 0.05 f_s$ 샘플).</p>
<h4 id="reverb">리버브(Reverb)<a class="header-link" href="#reverb" title="Permanent link">&para;</a></h4>
<p>리버브는 방의 음향 응답을 시뮬레이션합니다. 가장 간단한 모델은 빗살 필터(comb filter)와 전역 통과 필터(allpass filter)를 사용합니다(슈뢰더 리버브레이터):</p>
<p><strong>빗살 필터(피드백)</strong>:
$$y[n] = x[n] + g \cdot y[n - D]$$</p>
<p><strong>전역 통과 필터(Allpass filter)</strong>:
$$y[n] = -g \cdot x[n] + x[n - D] + g \cdot y[n - D]$$</p>
<p>슈뢰더 리버브레이터는 4개의 병렬 빗살 필터에 이어 2개의 직렬 전역 통과 필터를 연결합니다.</p>
<p>더 정교한 리버브는 <strong>컨볼루션 리버브(convolution reverb)</strong>를 사용합니다: 건식 신호(dry signal)를 측정된 실내 임펄스 응답(room impulse response, RIR)과 컨볼루션합니다.</p>
<h3 id="32">3.2 변조 기반 이펙트<a class="header-link" href="#32" title="Permanent link">&para;</a></h3>
<h4 id="chorus">코러스(Chorus)<a class="header-link" href="#chorus" title="Permanent link">&para;</a></h4>
<p>코러스 이펙트는 지연이 천천히 변조되는 원본 신호와 지연된 복사본을 혼합하여 같은 음표를 연주하는 여러 악기를 시뮬레이션합니다:</p>
<p>$$y[n] = x[n] + g \cdot x[n - D(n)]$$</p>
<p>여기서 $D(n) = D_0 + A \sin(2\pi f_{LFO} n / f_s)$이며, $D_0 \approx 20$-30 ms, $A \approx 1$-5 ms, $f_{LFO} \approx 0.5$-3 Hz입니다.</p>
<h4 id="flanger">플랜저(Flanger)<a class="header-link" href="#flanger" title="Permanent link">&para;</a></h4>
<p>코러스와 유사하지만 더 짧은 지연과 피드백을 사용합니다:</p>
<p>$$y[n] = x[n] + g \cdot y[n - D(n)]$$</p>
<p>$D_0 \approx 1$-10 ms로, 스위핑하는 빗살 필터 이펙트를 만들어냅니다.</p>
<h4 id="vibrato">비브라토(Vibrato)<a class="header-link" href="#vibrato" title="Permanent link">&para;</a></h4>
<p>순수한 피치 변조(건식 신호 혼합 없음):</p>
<p>$$y[n] = x[n - D(n)]$$</p>
<p>정현파 지연 변조를 사용합니다.</p>
<h3 id="33">3.3 다이나믹스 처리<a class="header-link" href="#33" title="Permanent link">&para;</a></h3>
<h4 id="compressor">컴프레서(Compressor)<a class="header-link" href="#compressor" title="Permanent link">&para;</a></h4>
<p>임계값을 초과하는 신호를 감쇠시켜 다이나믹 레인지를 줄입니다:</p>
<p>$$g_{dB}[n] = \begin{cases} 0 & x_{dB}[n] < T \\ (1 - 1/R)(T - x_{dB}[n]) & x_{dB}[n] \geq T \end{cases}$$</p>
<p>여기서 $T$는 임계값(threshold)이고 $R$은 압축 비율(compression ratio)입니다.</p>
<p><strong>파라미터</strong>:
- <strong>임계값(Threshold)</strong>: 압축이 시작되는 레벨
- <strong>비율(Ratio)</strong>: 압축량(2:1, 4:1, $\infty$:1 = 리미터)
- <strong>어택(Attack)</strong>: 컴프레서가 반응하는 속도
- <strong>릴리즈(Release)</strong>: 컴프레서가 단위 이득으로 돌아가는 속도
- <strong>니(Knee)</strong>: 임계값에서의 하드 또는 소프트 전환</p>
<p>어택과 릴리즈는 지수 스무딩(exponential smoothing)을 사용하는 엔벨로프 팔로워(envelope follower)로 구현됩니다:</p>
<p>$$x_{env}[n] = \begin{cases} \alpha_a x_{env}[n-1] + (1-\alpha_a)|x[n]| & |x[n]| > x_{env}[n-1] \\ \alpha_r x_{env}[n-1] + (1-\alpha_r)|x[n]| & |x[n]| \leq x_{env}[n-1] \end{cases}$$</p>
<p>여기서 $\alpha_a = e^{-1/(f_s \cdot t_{attack})}$이고 $\alpha_r = e^{-1/(f_s \cdot t_{release})}$입니다.</p>
<hr />
<h2 id="4">4. 피치 검출<a class="header-link" href="#4" title="Permanent link">&para;</a></h2>
<h3 id="41">4.1 자기상관 방법<a class="header-link" href="#41" title="Permanent link">&para;</a></h3>
<p>주기 신호의 기본 주파수(fundamental frequency)는 자기상관 함수(autocorrelation function)로 검출할 수 있습니다:</p>
<p>$$R_{xx}[\tau] = \sum_{n=0}^{N-1} x[n] \cdot x[n + \tau]$$</p>
<p>주기 $T_0$(샘플 단위)를 가진 주기 신호에서 $R_{xx}[\tau]$는 $\tau = 0, T_0, 2T_0, \ldots$에서 피크를 가집니다. 기본 주파수는:</p>
<p>$$f_0 = \frac{f_s}{T_0}$$</p>
<p><strong>알고리즘</strong>:
1. 신호를 윈도우 처리(해닝 윈도우, 20-50 ms 프레임)
2. 자기상관 계산
3. 원점 이후 첫 번째 유의미한 피크 찾기
4. 피크 위치가 $T_0$를 결정</p>
<p><strong>피치 범위 제약</strong>: 음성의 경우 $f_0 \in [80, 400]$ Hz이므로 $\tau \in [f_s/400, f_s/80]$에서 피크를 탐색합니다.</p>
<h3 id="42">4.2 켑스트럼 방법<a class="header-link" href="#42" title="Permanent link">&para;</a></h3>
<p><strong>켑스트럼(cepstrum)</strong>("spectrum"의 철자 재배열)은 다음과 같이 정의됩니다:</p>
<p>$$c[n] = \text{IDFT}\{\log|\text{DFT}\{x[n]\}|\}$$</p>
<p>켑스트럼 영역의 독립 변수 $n$은 <strong>퀘프런시(quefrency)</strong>("frequency"의 철자 재배열)라고 하며 샘플(또는 시간) 단위를 가집니다.</p>
<p>유성음(voiced speech) 신호의 경우 켑스트럼은 <strong>성도 엔벨로프(vocal tract envelope)</strong>(낮은 퀘프런시)와 <strong>피치 여기(pitch excitation)</strong>(피치 주기의 퀘프런시에서 피크)를 분리합니다:</p>
<div class="highlight"><pre><span></span><code>Speech spectrum = Vocal tract envelope × Pitch harmonics
    (smooth)              (fine structure)

log(Speech spectrum) = log(Envelope) + log(Harmonics)
    cepstrum domain:    low quefrency   + peak at T₀
</code></pre></div>

<p><strong>알고리즘</strong>:
1. 윈도우 처리된 프레임의 DFT 계산
2. 크기 스펙트럼의 로그 취하기
3. IDFT 계산(켑스트럼)
4. 예상 피치 범위에서 피크 찾기
5. 피크 퀘프런시 = 피치 주기 $T_0$</p>
<h3 id="43">4.3 비교<a class="header-link" href="#43" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>방법</th>
<th>장점</th>
<th>단점</th>
</tr>
</thead>
<tbody>
<tr>
<td>자기상관</td>
<td>강인함, 단순함</td>
<td>옥타브 오류, 넓은 피크</td>
</tr>
<tr>
<td>켑스트럼</td>
<td>소스/필터 분리 우수</td>
<td>잡음 민감성, 해상도 제한</td>
</tr>
<tr>
<td>YIN(개선된 자기상관)</td>
<td>최신 정확도</td>
<td>더 복잡함</td>
</tr>
<tr>
<td>pYIN</td>
<td>확률론적, 매우 강인함</td>
<td>연산 비용</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="5">5. 오디오 이퀄라이제이션<a class="header-link" href="#5" title="Permanent link">&para;</a></h2>
<h3 id="51-graphic-equalizer">5.1 그래픽 이퀄라이저(Graphic Equalizer)<a class="header-link" href="#51-graphic-equalizer" title="Permanent link">&para;</a></h3>
<p>그래픽 이퀄라이저는 고정된 중심 주파수(일반적으로 옥타브 또는 1/3 옥타브 간격)에서 병렬 대역 통과 필터들로 구성됩니다. 각 대역은 조절 가능한 이득을 가집니다.</p>
<p>표준 옥타브 대역 중심 주파수: 31.5, 63, 125, 250, 500, 1000, 2000, 4000, 8000, 16000 Hz.</p>
<h3 id="52-parametric-equalizer">5.2 파라메트릭 이퀄라이저(Parametric Equalizer)<a class="header-link" href="#52-parametric-equalizer" title="Permanent link">&para;</a></h3>
<p>파라메트릭 이퀄라이저는 각 대역에 대해 조절 가능한 <strong>중심 주파수</strong>, <strong>이득</strong>, <strong>대역폭</strong>(Q 팩터)을 제공합니다:</p>
<p><strong>피킹(벨) 필터</strong>(2차 IIR):</p>
<p>$$H(z) = \frac{1 + \alpha A \cdot z^{-1} \cdot b_1 + \alpha z^{-2}}{1 + \alpha/A \cdot z^{-1} \cdot a_1 + \alpha z^{-2}}$$</p>
<p>여기서 $A = 10^{G_{dB}/40}$, $\omega_0 = 2\pi f_0/f_s$, $\alpha = \sin(\omega_0)/(2Q)$입니다.</p>
<p>피킹 EQ의 쿡북 바이쿼드(biquad) 계수:</p>
<p>$$b_0 = 1 + \alpha A, \quad b_1 = -2\cos\omega_0, \quad b_2 = 1 - \alpha A$$
$$a_0 = 1 + \alpha/A, \quad a_1 = -2\cos\omega_0, \quad a_2 = 1 - \alpha/A$$</p>
<h3 id="53-shelving-filter">5.3 쉘빙 필터(Shelving Filter)<a class="header-link" href="#53-shelving-filter" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>로우 쉘프(Low shelf)</strong>: $f_0$ 이하의 주파수를 부스트/컷</li>
<li><strong>하이 쉘프(High shelf)</strong>: $f_0$ 이상의 주파수를 부스트/컷</li>
</ul>
<p>오디오 장비의 베이스 및 트레블 컨트롤에 사용됩니다.</p>
<hr />
<h2 id="6-lpc">6. 음성 코딩: 선형 예측 코딩(LPC)<a class="header-link" href="#6-lpc" title="Permanent link">&para;</a></h2>
<h3 id="61-">6.1 소스-필터 모델<a class="header-link" href="#61-" title="Permanent link">&para;</a></h3>
<p>음성 생성은 다음과 같이 모델링됩니다:</p>
<p>$$\text{여기 소스} \to \text{성도 필터} \to \text{음성 신호}$$</p>
<ul>
<li><strong>유성음(Voiced sounds)</strong>(모음): 여기 = 피치 주파수의 주기적 펄스열</li>
<li><strong>무성음(Unvoiced sounds)</strong>(마찰음): 여기 = 백색 잡음</li>
<li><strong>성도(Vocal tract)</strong>: 전극 필터(all-pole filter, 공명 관 모델)</li>
</ul>
<h3 id="62">6.2 선형 예측<a class="header-link" href="#62" title="Permanent link">&para;</a></h3>
<p>현재 샘플은 과거 샘플들로부터 예측됩니다:</p>
<p>$$\hat{x}[n] = \sum_{k=1}^{p} a_k x[n-k]$$</p>
<p>예측 오차(잔차)는:</p>
<p>$$e[n] = x[n] - \hat{x}[n] = x[n] - \sum_{k=1}^{p} a_k x[n-k]$$</p>
<p>LPC 계수 $\{a_k\}$는 $E[e^2[n]]$을 최소화하도록 선택됩니다.</p>
<h3 id="63-lpc">6.3 LPC 계수 계산<a class="header-link" href="#63-lpc" title="Permanent link">&para;</a></h3>
<p>예측 오차를 최소화하면 <strong>율-워커(Yule-Walker, 정규) 방정식</strong>이 도출됩니다:</p>
<p>$$\mathbf{R}\mathbf{a} = \mathbf{r}$$</p>
<p>여기서 $\mathbf{R}$은 토플리츠 자기상관 행렬이고 $\mathbf{r}$은 자기상관 벡터입니다.</p>
<p><strong>레빈슨-더빈 알고리즘(Levinson-Durbin algorithm)</strong>은 토플리츠 구조를 활용하여 $O(p^2)$ 연산으로 이를 풀어냅니다.</p>
<h3 id="64-lpc-vocoder">6.4 LPC 보코더(Vocoder)<a class="header-link" href="#64-lpc-vocoder" title="Permanent link">&para;</a></h3>
<p>LPC 보코더는 다음만을 전송합니다:
1. <strong>LPC 계수</strong> ($\{a_k\}$, 협대역 음성의 경우 일반적으로 $p = 10$-16)
2. <strong>피치 주기</strong> (유성음 프레임의 경우)
3. <strong>유성음/무성음 플래그</strong>
4. <strong>이득</strong> (프레임의 에너지)</p>
<p>이를 통해 음성 품질을 일부 희생하고 매우 낮은 비트율(LPC-10의 경우 2.4 kbps)을 달성합니다.</p>
<h3 id="65-lpc">6.5 LPC 스펙트럼<a class="header-link" href="#65-lpc" title="Permanent link">&para;</a></h3>
<p>LPC 모델은 성도를 전극 필터로 표현합니다:</p>
<p>$$H(z) = \frac{G}{1 - \sum_{k=1}^{p} a_k z^{-k}} = \frac{G}{A(z)}$$</p>
<p>LPC 스펙트럼 $|H(e^{j\omega})|^2$는 음성 신호의 부드러운 스펙트럼 엔벨로프를 제공합니다. $H(z)$의 극(pole)들은 <strong>포르만트 주파수(formant frequency, 성도의 공명)</strong>에 해당합니다.</p>
<hr />
<h2 id="7">7. 통신: 아날로그 변조<a class="header-link" href="#7" title="Permanent link">&para;</a></h2>
<h3 id="71">7.1 변조가 필요한 이유<a class="header-link" href="#71" title="Permanent link">&para;</a></h3>
<p>변조(modulation)는 기저대역(baseband) 신호를 더 높은 반송파(carrier) 주파수로 이동시킵니다:
1. <strong>안테나 효율</strong>: 안테나 크기 $\sim \lambda/4$; 높은 주파수 = 작은 안테나
2. <strong>주파수 분할 다중화</strong>: 여러 신호가 스펙트럼 공유
3. <strong>잡음 성능</strong>: 일부 변조 방식은 잡음 개선 제공</p>
<h3 id="72-amplitude-modulation-am">7.2 진폭 변조(Amplitude Modulation, AM)<a class="header-link" href="#72-amplitude-modulation-am" title="Permanent link">&para;</a></h3>
<p>AM 신호는:</p>
<p>$$x_{AM}(t) = [1 + m \cdot x(t)] \cos(2\pi f_c t)$$</p>
<p>여기서:
- $f_c$는 반송파 주파수
- $m$은 변조 지수(왜곡 없으려면 $0 < m \leq 1$)
- $x(t)$는 정규화된 메시지 신호($|x(t)| \leq 1$)</p>
<p><strong>스펙트럼</strong>: AM 스펙트럼은 반송파와 상부 및 하부 측대역(sideband)으로 구성됩니다:
$$X_{AM}(f) = \frac{1}{2}\delta(f - f_c) + \frac{m}{4}[X(f - f_c) + X(f + f_c)]$$</p>
<p><strong>대역폭</strong>: $B_{AM} = 2W$ (여기서 $W$는 메시지 대역폭)</p>
<p><strong>복조</strong>: 엔벨로프 검파(단순 다이오드 + RC 회로)</p>
<h3 id="73-frequency-modulation-fm">7.3 주파수 변조(Frequency Modulation, FM)<a class="header-link" href="#73-frequency-modulation-fm" title="Permanent link">&para;</a></h3>
<p>FM 신호는:</p>
<p>$$x_{FM}(t) = A_c \cos\!\left(2\pi f_c t + 2\pi k_f \int_0^t x(\tau) \, d\tau\right)$$</p>
<p>여기서 $k_f$는 주파수 편이 상수(Hz/V)입니다.</p>
<p><strong>순시 주파수(instantaneous frequency)</strong>는:</p>
<p>$$f_i(t) = f_c + k_f x(t)$$</p>
<p><strong>대역폭</strong>(카슨의 법칙, Carson's rule):</p>
<p>$$B_{FM} \approx 2(\Delta f + W) = 2W(\beta + 1)$$</p>
<p>여기서 $\Delta f = k_f \max|x(t)|$는 최대 주파수 편이이고 $\beta = \Delta f / W$는 변조 지수입니다.</p>
<p><strong>AM 대비 FM의 장점</strong>:
- 일정한 엔벨로프(진폭 변동 없음) -- 비선형 증폭기에 강인함
- 더 나은 잡음 성능(FM은 잡음을 진폭 변동으로 포착하며, 이는 리미팅으로 제거됨)
- 캡처 효과: 강한 신호가 약한 간섭을 억압</p>
<h3 id="74-phase-modulation-pm">7.4 위상 변조(Phase Modulation, PM)<a class="header-link" href="#74-phase-modulation-pm" title="Permanent link">&para;</a></h3>
<p>$$x_{PM}(t) = A_c \cos\!\left(2\pi f_c t + k_p x(t)\right)$$</p>
<p>PM과 FM은 연관되어 있습니다: $x(t)$의 FM은 $\int x(t)dt$의 PM과 동일합니다.</p>
<hr />
<h2 id="8">8. 통신: 디지털 변조<a class="header-link" href="#8" title="Permanent link">&para;</a></h2>
<h3 id="81">8.1 디지털 변조 개요<a class="header-link" href="#81" title="Permanent link">&para;</a></h3>
<p>디지털 변조(digital modulation)는 이산 심벌을 전송을 위한 아날로그 파형에 매핑합니다:</p>
<table>
<thead>
<tr>
<th>방식</th>
<th>변하는 것</th>
<th>성상도(Constellation)</th>
</tr>
</thead>
<tbody>
<tr>
<td>ASK(진폭 편이 변조)</td>
<td>진폭</td>
<td>실수축 위의 점들</td>
</tr>
<tr>
<td>FSK(주파수 편이 변조)</td>
<td>주파수</td>
<td>직교 신호들</td>
</tr>
<tr>
<td>PSK(위상 편이 변조)</td>
<td>위상</td>
<td>단위원 위의 점들</td>
</tr>
<tr>
<td>QAM(직교 진폭 변조)</td>
<td>진폭 + 위상</td>
<td>I-Q 평면의 격자</td>
</tr>
</tbody>
</table>
<h3 id="82-binary-phase-shift-keying-bpsk">8.2 이진 위상 편이 변조(Binary Phase Shift Keying, BPSK)<a class="header-link" href="#82-binary-phase-shift-keying-bpsk" title="Permanent link">&para;</a></h3>
<p>가장 단순한 PSK 방식으로 비트를 대척점 신호에 매핑합니다:</p>
<p>$$s(t) = \begin{cases} +A\cos(2\pi f_c t) & \text{비트 } 1 \\ -A\cos(2\pi f_c t) & \text{비트 } 0 \end{cases}$$</p>
<p>AWGN에서의 <strong>비트 오율(Bit error rate, BER)</strong>:</p>
<p>$$P_b = Q\!\left(\sqrt{\frac{2E_b}{N_0}}\right) = \frac{1}{2}\text{erfc}\!\left(\sqrt{\frac{E_b}{N_0}}\right)$$</p>
<p>여기서 $E_b$는 비트당 에너지이고 $N_0$는 잡음 전력 스펙트럼 밀도입니다.</p>
<h3 id="83-quadrature-phase-shift-keying-qpsk">8.3 직교 위상 편이 변조(Quadrature Phase Shift Keying, QPSK)<a class="header-link" href="#83-quadrature-phase-shift-keying-qpsk" title="Permanent link">&para;</a></h3>
<p>QPSK는 비트 쌍(다이비트)을 네 개의 위상 상태에 매핑합니다:</p>
<p>$$s_k(t) = A\cos\!\left(2\pi f_c t + \frac{\pi}{4} + \frac{k\pi}{2}\right), \quad k = 0, 1, 2, 3$$</p>
<p><strong>성상도</strong>: $\{\pi/4, 3\pi/4, 5\pi/4, 7\pi/4\}$ 각도의 4점.</p>
<p>QPSK는 <strong>BPSK와 동일한 BER</strong>을 가지지만 같은 대역폭에서 <strong>두 배의 데이터 레이트</strong>를 전달합니다.</p>
<h3 id="84-quadrature-amplitude-modulation-qam">8.4 직교 진폭 변조(Quadrature Amplitude Modulation, QAM)<a class="header-link" href="#84-quadrature-amplitude-modulation-qam" title="Permanent link">&para;</a></h3>
<p>$M$-QAM은 진폭과 위상 모두를 사용하여 심벌당 $\log_2 M$ 비트를 매핑합니다:</p>
<p>$$s(t) = A_I \cos(2\pi f_c t) - A_Q \sin(2\pi f_c t)$$</p>
<p>여기서 $(A_I, A_Q)$는 규칙적인 격자에서 선택됩니다.</p>
<p><strong>16-QAM</strong>: 심벌당 4비트, $4 \times 4$ 격자의 16개 성상도 점.</p>
<p><strong>64-QAM</strong>: 심벌당 6비트(WiFi, 케이블 TV에서 사용).</p>
<p><strong>256-QAM</strong>: 심벌당 8비트(고처리량 WiFi).</p>
<p>트레이드오프: $M$이 높을수록 스펙트럼 효율이 높아지지만 더 높은 SNR이 필요합니다.</p>
<h3 id="85-i-q">8.5 I-Q 표현<a class="header-link" href="#85-i-q" title="Permanent link">&para;</a></h3>
<p>모든 대역 통과 신호는 다음과 같이 표현할 수 있습니다:</p>
<p>$$s(t) = I(t)\cos(2\pi f_c t) - Q(t)\sin(2\pi f_c t)$$</p>
<p>여기서 $I(t)$는 <strong>동위상(in-phase)</strong> 성분이고 $Q(t)$는 <strong>직교(quadrature)</strong> 성분입니다. 복소 기저대역 등가는:</p>
<p>$$\tilde{s}(t) = I(t) + jQ(t)$$</p>
<p>모든 디지털 변조 방식은 심벌을 $I$-$Q$ 평면의 점에 매핑하는 것으로 설명할 수 있습니다.</p>
<hr />
<h2 id="9">9. 펄스 성형과 정합 필터링<a class="header-link" href="#9" title="Permanent link">&para;</a></h2>
<h3 id="91-inter-symbol-interference-isi">9.1 심벌간 간섭(Inter-Symbol Interference, ISI) 문제<a class="header-link" href="#91-inter-symbol-interference-isi" title="Permanent link">&para;</a></h3>
<p>디지털 심벌이 펄스로 전송될 때, 한 심벌 펄스의 꼬리가 인접 심벌을 간섭할 수 있습니다:</p>
<p>$$r(t) = \sum_k a_k \, p(t - kT_s)$$</p>
<p>여기서 $a_k$는 심벌 값, $p(t)$는 펄스 형태, $T_s$는 심벌 주기입니다.</p>
<h3 id="92-isi">9.2 나이퀴스트 ISI 기준<a class="header-link" href="#92-isi" title="Permanent link">&para;</a></h3>
<p>샘플링 순간에 펄스 $p(t)$가 ISI를 일으키지 않으려면:</p>
<p>$$p(kT_s) = \begin{cases} 1 & k = 0 \\ 0 & k \neq 0 \end{cases}$$</p>
<p>sinc 펄스 $p(t) = \text{sinc}(t/T_s)$는 최소 대역폭 $W = 1/(2T_s)$로 이를 달성하지만 천천히 감소하여 실용적이지 않습니다.</p>
<h3 id="93-raised-cosine-pulse">9.3 상승 코사인 펄스(Raised Cosine Pulse)<a class="header-link" href="#93-raised-cosine-pulse" title="Permanent link">&para;</a></h3>
<p>상승 코사인 펄스는 더 빠른 감소로 ISI를 제로로 만듭니다:</p>
<p>$$P(f) = \begin{cases} T_s & |f| \leq \frac{1-\alpha}{2T_s} \\[6pt] \frac{T_s}{2}\left[1 + \cos\!\left(\frac{\pi T_s}{\alpha}\left(|f| - \frac{1-\alpha}{2T_s}\right)\right)\right] & \frac{1-\alpha}{2T_s} < |f| \leq \frac{1+\alpha}{2T_s} \\[6pt] 0 & |f| > \frac{1+\alpha}{2T_s} \end{cases}$$</p>
<p>여기서 $\alpha \in [0, 1]$은 <strong>롤오프 팩터(rolloff factor)</strong>입니다.</p>
<p><strong>대역폭</strong>: $W = \frac{1+\alpha}{2T_s}$</p>
<p>실제로는 <strong>루트 상승 코사인(root-raised cosine, RRC)</strong> 필터를 송신기와 수신기에 나누어 사용합니다: $P_{RRC}(f) = \sqrt{P_{RC}(f)}$. 이 방식으로 $P_{TX}(f) \cdot P_{RX}(f) = P_{RC}(f)$가 되며, 수신기 필터는 전송된 펄스의 정합 필터가 됩니다.</p>
<h3 id="94-matched-filter">9.4 정합 필터(Matched Filter)<a class="header-link" href="#94-matched-filter" title="Permanent link">&para;</a></h3>
<p><strong>정합 필터</strong>는 가법 백색 잡음(additive white noise)에서 알려진 펄스 $s(t)$에 대해 출력 SNR을 최대화합니다:</p>
<p>$$h_{matched}(t) = s^*(T - t)$$</p>
<p>정합 필터는 신호의 시간 반전 후 켤레 복소수를 취하고 $T$만큼 지연한 것입니다.</p>
<p>정합 필터의 <strong>출력 SNR</strong>:</p>
<p>$$\text{SNR}_{max} = \frac{2E_s}{N_0}$$</p>
<p>여기서 $E_s = \int |s(t)|^2 \, dt$는 신호 에너지입니다. 이는 필터에 관계없이 달성 가능한 최대 SNR입니다.</p>
<hr />
<h2 id="10">10. 채널 모델과 등화<a class="header-link" href="#10" title="Permanent link">&para;</a></h2>
<h3 id="101-additive-white-gaussian-noise-awgn">10.1 가법 백색 가우시안 잡음(Additive White Gaussian Noise, AWGN) 채널<a class="header-link" href="#101-additive-white-gaussian-noise-awgn" title="Permanent link">&para;</a></h3>
<p>$$r(t) = s(t) + n(t)$$</p>
<p>여기서 $n(t)$는 전력 스펙트럼 밀도 $N_0/2$인 백색 가우시안 잡음입니다.</p>
<h3 id="102-multipath-channel">10.2 다중경로 채널(Multipath Channel)<a class="header-link" href="#102-multipath-channel" title="Permanent link">&para;</a></h3>
<p>$$r(t) = \sum_{k=0}^{L-1} h_k \, s(t - \tau_k) + n(t)$$</p>
<p>이산 시간 등가:</p>
<p>$$r[n] = \sum_{k=0}^{L-1} h[k] \, s[n-k] + v[n] = (h * s)[n] + v[n]$$</p>
<p>다중경로는 다음을 초래합니다:
- <strong>ISI</strong>: 신호의 지연된 복사본이 현재 심벌을 간섭
- <strong>주파수 선택적 페이딩(Frequency-selective fading)</strong>: 일부 주파수가 다른 주파수보다 더 많이 감쇠</p>
<h3 id="103-zero-forcing-zf">10.3 영점 강제(Zero-Forcing, ZF) 등화기<a class="header-link" href="#103-zero-forcing-zf" title="Permanent link">&para;</a></h3>
<p>ZF 등화기는 채널을 역변환합니다:</p>
<p>$$W_{ZF}(f) = \frac{1}{H(f)}$$</p>
<p><strong>문제</strong>: $|H(f)|$가 작은 주파수에서의 잡음 증폭.</p>
<h3 id="104-mmse">10.4 MMSE 등화기<a class="header-link" href="#104-mmse" title="Permanent link">&para;</a></h3>
<p>$$W_{MMSE}(f) = \frac{H^*(f)}{|H(f)|^2 + N_0/E_s}$$</p>
<p>MMSE 등화기는 ISI 제거와 잡음 억제의 균형을 맞춥니다. $N_0 = 0$일 때 ZF 등화기로 환원됩니다.</p>
<h3 id="105-adaptive-equalization">10.5 적응 등화(Adaptive Equalization)<a class="header-link" href="#105-adaptive-equalization" title="Permanent link">&para;</a></h3>
<p>실제로는 채널이 알려지지 않고 시변합니다. 적응 등화기(레슨 13의 LMS, RLS)가 다음과 함께 사용됩니다:
- <strong>훈련 시퀀스</strong>: 초기 수렴을 위한 알려진 심벌
- <strong>결정 지향 모드</strong>: 수렴 후 검출된 심벌을 기준으로 사용</p>
<hr />
<h2 id="11-ofdm">11. OFDM 기초<a class="header-link" href="#11-ofdm" title="Permanent link">&para;</a></h2>
<h3 id="111">11.1 동기<a class="header-link" href="#111" title="Permanent link">&para;</a></h3>
<p>직교 주파수 분할 다중화(Orthogonal Frequency Division Multiplexing, OFDM)는 광대역 무선(WiFi, LTE, 5G) 및 유선(DSL, 케이블) 통신의 지배적인 변조 방식입니다.</p>
<p>핵심 아이디어: 주파수 선택적 채널을 통해 하나의 고속 스트림을 전송하는 대신, 각각 평탄 페이딩(flat fading)을 경험하는 병렬 협대역 부반송파(subcarrier)에서 많은 저속 스트림을 전송합니다.</p>
<h3 id="112-ofdm">11.2 OFDM 시스템 모델<a class="header-link" href="#112-ofdm" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="n">Transmitter</span><span class="o">:</span>
<span class="w">  </span><span class="n">Data</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">S</span><span class="sr">/P → QAM Map → IFFT → Add CP → P/</span><span class="n">S</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">DAC</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">Channel</span>

<span class="n">Receiver</span><span class="o">:</span>
<span class="w">  </span><span class="n">ADC</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">S</span><span class="sr">/P → Remove CP → FFT → QAM Demap → P/</span><span class="n">S</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">Data</span>
</code></pre></div>

<p>전송된 OFDM 심벌(이산 시간):</p>
<p>$$x[n] = \frac{1}{\sqrt{N}} \sum_{k=0}^{N-1} X[k] \, e^{j2\pi kn/N}, \quad n = 0, 1, \ldots, N-1$$</p>
<p>이것은 단순히 주파수 영역 데이터 심벌 $X[k]$의 <strong>IFFT</strong>입니다.</p>
<h3 id="113-cyclic-prefix-cp">11.3 순환 전치(Cyclic Prefix, CP)<a class="header-link" href="#113-cyclic-prefix-cp" title="Permanent link">&para;</a></h3>
<p>순환 전치는 OFDM 심벌 시작 부분에 마지막 $L_{CP}$ 샘플을 복사합니다:</p>
<p>$$\tilde{x}[n] = x[n \mod N], \quad n = -L_{CP}, \ldots, N-1$$</p>
<p>목적: 선형 컨볼루션(채널)을 DFT에 의해 대각화되는 <strong>순환 컨볼루션</strong>으로 변환합니다. 이는 OFDM 심벌 간의 심벌간 간섭을 제거합니다.</p>
<p><strong>조건</strong>: $L_{CP} \geq L_{channel} - 1$ (CP 길이가 채널 임펄스 응답 길이 마이너스 1 이상이어야 함).</p>
<h3 id="114-one-tap-equalization">11.4 단일 탭 등화(One-Tap Equalization)<a class="header-link" href="#114-one-tap-equalization" title="Permanent link">&para;</a></h3>
<p>CP를 제거하고 수신기에서 FFT를 취한 후:</p>
<p>$$Y[k] = H[k] \cdot X[k] + V[k]$$</p>
<p>각 부반송파는 <strong>평탄한</strong>(스칼라) 채널 $H[k]$를 경험합니다. 등화는 간단합니다:</p>
<p>$$\hat{X}[k] = \frac{Y[k]}{H[k]}$$</p>
<p>이것이 OFDM의 엄청난 장점입니다: 복잡한 주파수 선택적 등화 문제를 $N$개의 독립적인 단일 탭 등화로 줄입니다.</p>
<h3 id="115-ofdm-wifi">11.5 OFDM 파라미터(WiFi 예시)<a class="header-link" href="#115-ofdm-wifi" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>파라미터</th>
<th>802.11a/g (20 MHz)</th>
</tr>
</thead>
<tbody>
<tr>
<td>부반송파 수 ($N$)</td>
<td>64</td>
</tr>
<tr>
<td>데이터 부반송파</td>
<td>48</td>
</tr>
<tr>
<td>파일럿 부반송파</td>
<td>4</td>
</tr>
<tr>
<td>부반송파 간격</td>
<td>312.5 kHz</td>
</tr>
<tr>
<td>심벌 지속 시간</td>
<td>3.2 $\mu$s</td>
</tr>
<tr>
<td>CP 지속 시간</td>
<td>0.8 $\mu$s</td>
</tr>
<tr>
<td>전체 심벌</td>
<td>4.0 $\mu$s</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="12_1">12. 레이더 신호 처리<a class="header-link" href="#12_1" title="Permanent link">&para;</a></h2>
<h3 id="121">12.1 레이더 기초<a class="header-link" href="#121" title="Permanent link">&para;</a></h3>
<p><strong>레이더(RADAR)</strong>: 전파 탐지 및 거리 측정(Radio Detection and Ranging). 레이더는 펄스를 전송하고, 표적에서 돌아온 에코는 다음을 알려줍니다:</p>
<ul>
<li><strong>거리</strong>: $R = \frac{c \cdot \tau}{2}$ (여기서 $\tau$는 왕복 지연, $c$는 광속)</li>
<li><strong>속도</strong>: 도플러 편이(Doppler shift) $f_d = \frac{2v_r}{\lambda}$ (여기서 $v_r$은 반경 방향 속도, $\lambda$는 파장)</li>
</ul>
<h3 id="122-range-resolution">12.2 거리 해상도(Range Resolution)<a class="header-link" href="#122-range-resolution" title="Permanent link">&para;</a></h3>
<p>거리 해상도는 전송 펄스의 대역폭으로 결정됩니다:</p>
<p>$$\Delta R = \frac{c}{2B}$$</p>
<p>여기서 $B$는 신호 대역폭입니다.</p>
<p>지속 시간 $\tau_p$의 단순 직사각형 펄스의 경우:
- 대역폭: $B \approx 1/\tau_p$
- 거리 해상도: $\Delta R = c\tau_p/2$</p>
<p><strong>딜레마</strong>: 좋은 거리 해상도는 짧은 펄스(넓은 대역폭)를 필요로 하지만, 짧은 펄스는 에너지가 낮아 탐지 거리를 제한합니다. 펄스 압축이 이를 해결합니다.</p>
<h3 id="123-doppler-processing">12.3 도플러 처리(Doppler Processing)<a class="header-link" href="#123-doppler-processing" title="Permanent link">&para;</a></h3>
<p>이동하는 표적에서 수신된 신호는 주파수 편이를 가집니다:</p>
<p>$$f_d = \frac{2v_r f_c}{c} = \frac{2v_r}{\lambda}$$</p>
<p>지속 시간 $T_{CPI}$의 코히어런트 처리 구간(coherent processing interval, CPI)으로부터의 속도 해상도:</p>
<p>$$\Delta v = \frac{\lambda}{2T_{CPI}}$$</p>
<h3 id="124">12.4 레이더용 정합 필터<a class="header-link" href="#124" title="Permanent link">&para;</a></h3>
<p>레이더 수신기는 출력 SNR을 최대화하기 위해 정합 필터를 사용합니다:</p>
<p>$$h_{MF}[n] = s^*[N-1-n]$$</p>
<p>정합 필터 출력은 수신 신호와 전송 파형의 <strong>교차 상관(cross-correlation)</strong>입니다:</p>
<p>$$y[n] = \sum_k r[k] \, s^*[k - n]$$</p>
<p>단순 펄스의 경우 정합 필터 출력은 표적 지연에서 피크를 가지는 삼각형입니다.</p>
<hr />
<h2 id="13">13. 처프 신호와 펄스 압축<a class="header-link" href="#13" title="Permanent link">&para;</a></h2>
<h3 id="131-fm-linear-fm-chirp">13.1 선형 FM 처프(Linear FM Chirp)<a class="header-link" href="#131-fm-linear-fm-chirp" title="Permanent link">&para;</a></h3>
<p><strong>처프(chirp)</strong>(선형 주파수 변조 펄스)는 펄스 지속 시간에 걸쳐 주파수를 선형적으로 스윕합니다:</p>
<p>$$s(t) = \text{rect}\!\left(\frac{t}{\tau_p}\right) \exp\!\left(j\pi \frac{B}{\tau_p} t^2\right) \exp(j2\pi f_c t)$$</p>
<p>순시 주파수는 펄스 지속 시간 $\tau_p$ 동안 $f_c - B/2$에서 $f_c + B/2$로 변합니다.</p>
<p><strong>핵심 특성</strong>: 처프는 대역폭 $B$와 지속 시간 $\tau_p$를 가지므로 <strong>시간-대역폭 곱(time-bandwidth product)</strong>은:</p>
<p>$$\text{TBP} = B \tau_p \gg 1$$</p>
<h3 id="132-pulse-compression">13.2 펄스 압축(Pulse Compression)<a class="header-link" href="#132-pulse-compression" title="Permanent link">&para;</a></h3>
<p>처프의 정합 필터는 긴 펄스를 짧은 피크로 압축합니다:</p>
<ul>
<li><strong>입력 펄스</strong>: 지속 시간 $\tau_p$, 대역폭 $B$</li>
<li><strong>압축된 펄스</strong>: 지속 시간 $\approx 1/B$, 피크 진폭 $\approx \sqrt{B\tau_p}$</li>
</ul>
<p><strong>압축비(compression ratio)</strong>는:</p>
<p>$$\text{CR} = B\tau_p$$</p>
<p><strong>처리 이득(processing gain)</strong>은:</p>
<p>$$G_p = 10\log_{10}(B\tau_p) \text{ dB}$$</p>
<p>예시: $\tau_p = 10$ $\mu$s, $B = 10$ MHz $\Rightarrow$ TBP = 100 $\Rightarrow$ 처리 이득 = 20 dB.</p>
<h3 id="133">13.3 압축 후 거리 해상도<a class="header-link" href="#133" title="Permanent link">&para;</a></h3>
<p>펄스 압축 후 거리 해상도는:</p>
<p>$$\Delta R = \frac{c}{2B}$$</p>
<p>이는 펄스 지속 시간 $\tau_p$가 아닌 대역폭 $B$에 의해 결정됩니다. 긴 처프 펄스는 훨씬 더 많은 에너지를 가지면서도 짧은 연속파(CW) 펄스와 동일한 거리 해상도를 달성합니다.</p>
<h3 id="134">13.4 사이드로브와 윈도잉<a class="header-link" href="#134" title="Permanent link">&para;</a></h3>
<p>압축된 펄스는 사이드로브(sinc 함수의 사이드로브에 유사)를 가집니다. 정합 필터에 적용된 윈도우 함수(해밍, 테일러 등)는 약간 넓어진 메인로브(저하된 해상도)를 대가로 사이드로브를 줄입니다.</p>
<hr />
<h2 id="14">14. 모호 함수<a class="header-link" href="#14" title="Permanent link">&para;</a></h2>
<h3 id="141">14.1 정의<a class="header-link" href="#141" title="Permanent link">&para;</a></h3>
<p><strong>모호 함수(ambiguity function)</strong>는 레이더 파형이 거리와 속도에서 표적을 동시에 분해하는 능력을 기술합니다:</p>
<p>$$\chi(\tau, f_d) = \int_{-\infty}^{\infty} s(t) \, s^*(t - \tau) \, e^{j2\pi f_d t} \, dt$$</p>
<p>여기서 $\tau$는 시간 지연(거리)이고 $f_d$는 도플러 주파수(속도)입니다.</p>
<h3 id="142">14.2 특성<a class="header-link" href="#142" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>원점에서 최대값</strong>: $|\chi(0, 0)| = E_s$ (신호 에너지)</li>
<li><strong>부피 불변성(Volume invariance)</strong>: $\iint |\chi(\tau, f_d)|^2 \, d\tau \, df_d = E_s^2$</li>
<li><strong>대칭성</strong>: $|\chi(\tau, f_d)| = |\chi(-\tau, -f_d)|$</li>
</ol>
<p>부피 불변성은 모호 함수가 고정된 부피 표면임을 의미합니다: 한 차원에서 날카롭게 만들면 다른 차원이 반드시 넓어집니다. 이는 불확정성 원리의 레이더 유사체입니다.</p>
<h3 id="143">14.3 일반적인 파형의 모호 함수<a class="header-link" href="#143" title="Permanent link">&para;</a></h3>
<p><strong>CW 펄스(직사각형)</strong>:
- $\tau$ 축을 따라 엄지 못(thumbtack) 모양(폭 $\sim \tau_p$)
- $f_d$ 축을 따라 sinc 모양(폭 $\sim 1/\tau_p$)
- 좋은 도플러 해상도, 낮은 거리 해상도(긴 $\tau_p$의 경우)</p>
<p><strong>선형 FM 처프</strong>:
- 대각선 능선을 따라 좁음(거리-도플러 결합)
- 좋은 거리 해상도($B$에 의해 결정)
- 능선은 도플러 편이가 거리 편이처럼 보인다는 것을 의미 -- 보상이 필요</p>
<p><strong>위상 코딩 파형</strong>(예: 바커 코드(Barker code)):
- 엄지 못 모양의 모호 함수
- 거리와 도플러 모두에서 낮은 사이드로브
- 특정 코드 길이로 제한</p>
<h3 id="144">14.4 파형 설계<a class="header-link" href="#144" title="Permanent link">&para;</a></h3>
<p>이상적인 모호 함수는 원점의 단일 스파이크(거리와 속도 모두에서 완벽한 해상도)이겠지만, 부피 불변성이 이를 금지합니다. 파형 설계는 응용에 가장 적합한 형태를 선택하는 것입니다:</p>
<ul>
<li><strong>감시 레이더</strong>: 좋은 도플러 해상도 필요 → 긴 CW 펄스</li>
<li><strong>추적 레이더</strong>: 좋은 거리 해상도 필요 → 처프</li>
<li><strong>펄스-도플러 레이더</strong>: 둘 다 필요 → 처프 펄스의 코히어런트 열</li>
</ul>
<hr />
<h2 id="15-ecg">15. 생체의학 신호 처리: ECG<a class="header-link" href="#15-ecg" title="Permanent link">&para;</a></h2>
<h3 id="151-ecg">15.1 ECG 신호<a class="header-link" href="#151-ecg" title="Permanent link">&para;</a></h3>
<p>심전도(electrocardiogram, ECG 또는 EKG)는 심장의 전기적 활동을 기록합니다. 단일 심박 주기는 특징적인 PQRST 파형을 생성합니다:</p>
<div class="highlight"><pre><span></span><code>    R
    ▲
    │╲
    │ ╲
    │  ╲
    │   ╲      T
P   │    ╲    ╱╲
╱╲  │     ╲  ╱  ╲
    │      ╲╱    ╲
────┼──────S──────────── baseline
    Q

P파:    심방 탈분극           (0.08-0.10 s)
QRS:    심실 탈분극           (0.06-0.10 s)
T파:    심실 재분극           (0.16 s)
PR 간격: AV 전도 시간         (0.12-0.20 s)
QT 간격: 심실 활동            (0.30-0.44 s)
</code></pre></div>

<h3 id="152-ecg">15.2 ECG 신호 특성<a class="header-link" href="#152-ecg" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>파라미터</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>진폭</td>
<td>0.1 - 5 mV</td>
</tr>
<tr>
<td>대역폭</td>
<td>0.05 - 150 Hz</td>
</tr>
<tr>
<td>일반적인 샘플링 레이트</td>
<td>250 - 1000 Hz</td>
</tr>
<tr>
<td>심박수</td>
<td>60-100 bpm (1-1.67 Hz)</td>
</tr>
</tbody>
</table>
<h3 id="153-ecg">15.3 ECG 잡음 소스<a class="header-link" href="#153-ecg" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>기저선 방랑(Baseline wander)</strong>: 호흡, 신체 움직임으로 인한 저주파 드리프트(&lt; 0.5 Hz)</li>
<li><strong>전원선 간섭</strong>: 50/60 Hz 및 고조파</li>
<li><strong>근육 잡음(EMG)</strong>: 광대역, 20-500 Hz</li>
<li><strong>동작 아티팩트</strong>: 전극 움직임, 광대역</li>
</ol>
<h3 id="154-ecg">15.4 ECG 전처리 파이프라인<a class="header-link" href="#154-ecg" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>Raw ECG → Baseline removal → Notch filter → Bandpass filter → QRS detection
           (highpass 0.5 Hz)  (50/60 Hz)    (0.5-40 Hz)      (Pan-Tompkins)
</code></pre></div>

<p><strong>기저선 방랑 제거</strong>: 차단 주파수 0.5 Hz의 고역 통과 필터(또는 200 ms 및 600 ms 윈도우의 중앙값 필터).</p>
<p><strong>전원선 간섭</strong>: 50 또는 60 Hz에서의 노치 필터(좁은 대역 저지 IIR 필터).</p>
<h3 id="155-qrs-pan-tompkins">15.5 QRS 검출: Pan-Tompkins 알고리즘<a class="header-link" href="#155-qrs-pan-tompkins" title="Permanent link">&para;</a></h3>
<p>Pan-Tompkins 알고리즘(1985)은 표준 QRS 검출기입니다:</p>
<ol>
<li><strong>대역 통과 필터</strong>(5-15 Hz): QRS 에너지를 최대화하면서 P/T 파와 잡음을 억압</li>
<li><strong>미분</strong>: QRS의 가파른 기울기를 강조: $y[n] = \frac{1}{8}(-x[n-2] - 2x[n-1] + 2x[n+1] + x[n+2])$</li>
<li><strong>제곱</strong>: $z[n] = y[n]^2$ (모든 값을 양수로 만들고, 큰 기울기를 강조)</li>
<li><strong>이동 윈도우 적분</strong>: $w[n] = \frac{1}{N}\sum_{k=0}^{N-1} z[n-k]$ ($N \approx 150$ ms)</li>
<li><strong>적응 임계값 처리</strong>: 신호와 잡음 레벨에 적응하는 두 임계값</li>
</ol>
<hr />
<h2 id="16-eeg">16. 생체의학 신호 처리: EEG<a class="header-link" href="#16-eeg" title="Permanent link">&para;</a></h2>
<h3 id="161-eeg">16.1 EEG 신호<a class="header-link" href="#161-eeg" title="Permanent link">&para;</a></h3>
<p>뇌전도(electroencephalogram, EEG)는 두피 전극에서 뇌의 전기적 활동을 기록합니다. EEG 신호는 ECG보다 훨씬 약합니다.</p>
<table>
<thead>
<tr>
<th>파라미터</th>
<th>값</th>
</tr>
</thead>
<tbody>
<tr>
<td>진폭</td>
<td>1 - 200 $\mu$V</td>
</tr>
<tr>
<td>대역폭</td>
<td>0.5 - 100 Hz</td>
</tr>
<tr>
<td>샘플링 레이트</td>
<td>256 - 1024 Hz</td>
</tr>
<tr>
<td>채널</td>
<td>1-256 (10-20 시스템)</td>
</tr>
</tbody>
</table>
<h3 id="162-eeg">16.2 EEG 주파수 대역<a class="header-link" href="#162-eeg" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>대역</th>
<th>주파수</th>
<th>상태</th>
</tr>
</thead>
<tbody>
<tr>
<td>델타($\delta$)</td>
<td>0.5-4 Hz</td>
<td>깊은 수면</td>
</tr>
<tr>
<td>세타($\theta$)</td>
<td>4-8 Hz</td>
<td>졸음, 얕은 수면, 명상</td>
</tr>
<tr>
<td>알파($\alpha$)</td>
<td>8-13 Hz</td>
<td>편안함, 눈 감음</td>
</tr>
<tr>
<td>베타($\beta$)</td>
<td>13-30 Hz</td>
<td>활발한 사고, 집중</td>
</tr>
<tr>
<td>감마($\gamma$)</td>
<td>30-100 Hz</td>
<td>고차 인지 기능, 지각</td>
</tr>
</tbody>
</table>
<h3 id="163-eeg">16.3 EEG 스펙트럼 분석<a class="header-link" href="#163-eeg" title="Permanent link">&para;</a></h3>
<p>EEG의 전력 스펙트럼 밀도(power spectral density, PSD)는 지배적인 뇌 상태를 드러냅니다:</p>
<p>$$S_{xx}(f) = \frac{1}{N}|X(f)|^2$$</p>
<p><strong>대역 전력(Band power)</strong>은 각 주파수 대역에 걸쳐 PSD를 적분하여 계산됩니다:</p>
<p>$$P_{band} = \int_{f_1}^{f_2} S_{xx}(f) \, df$$</p>
<p><strong>상대 대역 전력</strong>: $P_{rel} = P_{band} / P_{total}$은 각 대역의 전체 전력 대비 비율을 나타냅니다.</p>
<h3 id="164-event-related-potentials-erps">16.4 사건 관련 전위(Event-Related Potentials, ERPs)<a class="header-link" href="#164-event-related-potentials-erps" title="Permanent link">&para;</a></h3>
<p>ERP는 자극에 시간 잠금된 많은 EEG 시행을 평균하여 얻습니다:</p>
<p>$$\text{ERP}[n] = \frac{1}{K}\sum_{k=1}^{K} x_k[n]$$</p>
<p>평균화는 시간 잠금된 반응을 보존하면서 배경 잡음을 $\sqrt{K}$만큼 줄입니다.</p>
<h3 id="165-eeg">16.5 EEG를 위한 스펙트럼 분석 방법<a class="header-link" href="#165-eeg" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>웰치 방법(Welch's method)</strong>: 강인한 PSD 추정을 위한 평균화된 주기도</li>
<li><strong>다중 테이퍼 방법(Multitaper method)</strong>: 분산 감소를 위한 여러 직교 테이퍼</li>
<li><strong>단시간 푸리에 변환(Short-Time Fourier Transform)</strong>: 시변 스펙트럼 내용(사건 관련 스펙트럼 섭동)</li>
<li><strong>웨이블릿 분석(Wavelet analysis)</strong>: 일시적 뇌 사건의 다중 스케일 시간-주파수 분석</li>
</ul>
<hr />
<h2 id="17-hrv">17. 심박 변이도(HRV)<a class="header-link" href="#17-hrv" title="Permanent link">&para;</a></h2>
<h3 id="171-hrv">17.1 HRV란?<a class="header-link" href="#171-hrv" title="Permanent link">&para;</a></h3>
<p>심박 변이도(Heart Rate Variability, HRV)는 연속 심박 사이의 시간 간격(RR 간격)의 변화입니다. HRV는 자율 신경계 기능의 지표입니다.</p>
<h3 id="172">17.2 시간 영역 측정값<a class="header-link" href="#172" title="Permanent link">&para;</a></h3>
<p>RR 간격 시퀀스 $\{RR_i\}$에서:</p>
<table>
<thead>
<tr>
<th>측정값</th>
<th>공식</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>SDNN</td>
<td>$\sqrt{\frac{1}{N}\sum(RR_i - \overline{RR})^2}$</td>
<td>전체 변이도</td>
</tr>
<tr>
<td>RMSSD</td>
<td>$\sqrt{\frac{1}{N-1}\sum(RR_{i+1} - RR_i)^2}$</td>
<td>단기 변이도</td>
</tr>
<tr>
<td>pNN50</td>
<td>$\frac{\#\{|RR_{i+1} - RR_i| > 50\text{ms}\}}{N-1} \times 100\%$</td>
<td>부교감 신경 활동</td>
</tr>
</tbody>
</table>
<h3 id="173">17.3 주파수 영역 측정값<a class="header-link" href="#173" title="Permanent link">&para;</a></h3>
<p>RR 간격 시계열의 PSD는 자율 조절을 드러냅니다:</p>
<table>
<thead>
<tr>
<th>대역</th>
<th>주파수</th>
<th>기원</th>
</tr>
</thead>
<tbody>
<tr>
<td>VLF</td>
<td>0.003-0.04 Hz</td>
<td>체온 조절, RAAS</td>
</tr>
<tr>
<td>LF</td>
<td>0.04-0.15 Hz</td>
<td>교감 + 부교감 신경</td>
</tr>
<tr>
<td>HF</td>
<td>0.15-0.40 Hz</td>
<td>부교감 신경(호흡성 동성 부정맥)</td>
</tr>
</tbody>
</table>
<p><strong>LF/HF 비율</strong>은 교감-미주 신경 균형의 (논란이 있는) 지표입니다.</p>
<h3 id="174-hrv">17.4 HRV 분석 파이프라인<a class="header-link" href="#174-hrv" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>QRS 검출</strong>: Pan-Tompkins 알고리즘</li>
<li><strong>RR 간격 추출</strong>: 연속 R 피크 사이의 시간</li>
<li><strong>아티팩트 제거</strong>: 이소성 박동 및 놓친 검출 제거</li>
<li><strong>보간</strong>: RR 간격을 균일한 시간 격자로 리샘플링(예: 4 Hz, 큐빅 스플라인)</li>
<li><strong>PSD 추정</strong>: 웰치 방법 또는 AR 모델</li>
<li><strong>대역 전력 계산</strong>: VLF, LF, HF 대역에서 PSD 적분</li>
</ol>
<hr />
<h2 id="18-python">18. Python 구현<a class="header-link" href="#18-python" title="Permanent link">&para;</a></h2>
<h3 id="181">18.1 디지털 오디오 이펙트<a class="header-link" href="#181" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>


<span class="k">def</span><span class="w"> </span><span class="nf">generate_audio_signal</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">44100</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a test audio signal (guitar-like pluck).&quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
    <span class="c1"># Karplus-Strong synthesis approximation</span>
    <span class="n">f0</span> <span class="o">=</span> <span class="mi">220</span>  <span class="c1"># A3</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
    <span class="c1"># Harmonics with decay</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
        <span class="n">decay</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">k</span> <span class="o">*</span> <span class="mf">1.5</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span>
        <span class="n">signal</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">k</span><span class="o">*</span><span class="n">f0</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">*</span> <span class="n">decay</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">signal</span>


<span class="k">def</span><span class="w"> </span><span class="nf">delay_effect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">delay_ms</span><span class="o">=</span><span class="mi">300</span><span class="p">,</span> <span class="n">feedback</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">mix</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply delay/echo effect.&quot;&quot;&quot;</span>
    <span class="n">delay_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">delay_ms</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">delay_samples</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
    <span class="n">y</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">delay_samples</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)):</span>
        <span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">feedback</span> <span class="o">*</span> <span class="n">y</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">delay_samples</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">mix</span> <span class="o">*</span> <span class="n">y</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mix</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span>


<span class="k">def</span><span class="w"> </span><span class="nf">chorus_effect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">depth_ms</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">rate_hz</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">mix</span><span class="o">=</span><span class="mf">0.5</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply chorus effect with LFO-modulated delay.&quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">fs</span>
    <span class="n">base_delay</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">25</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># 25 ms base delay</span>
    <span class="n">depth</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">depth_ms</span> <span class="o">*</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>

    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">base_delay</span> <span class="o">+</span> <span class="n">depth</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="c1"># LFO modulates the delay</span>
        <span class="n">mod</span> <span class="o">=</span> <span class="n">depth</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">rate_hz</span> <span class="o">*</span> <span class="n">t</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="n">delay</span> <span class="o">=</span> <span class="n">base_delay</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">mod</span><span class="p">)</span>

        <span class="c1"># Linear interpolation for fractional delay</span>
        <span class="n">d_int</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
        <span class="n">d_frac</span> <span class="o">=</span> <span class="n">delay</span> <span class="o">-</span> <span class="n">d_int</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">-</span> <span class="n">d_int</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">delayed</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">d_frac</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">d_int</span><span class="p">]</span> <span class="o">+</span> <span class="n">d_frac</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">d_int</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">delayed</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">d_int</span><span class="p">]</span>

        <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">mix</span><span class="p">)</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="n">mix</span> <span class="o">*</span> <span class="n">delayed</span>

    <span class="k">return</span> <span class="n">y</span>


<span class="k">def</span><span class="w"> </span><span class="nf">compressor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">threshold_db</span><span class="o">=-</span><span class="mi">20</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">attack_ms</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">release_ms</span><span class="o">=</span><span class="mi">50</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply dynamic range compression.&quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">threshold_db</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>
    <span class="n">alpha_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">fs</span> <span class="o">*</span> <span class="n">attack_ms</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">))</span>
    <span class="n">alpha_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">fs</span> <span class="o">*</span> <span class="n">release_ms</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">))</span>

    <span class="n">env</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">gain</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">N</span><span class="p">):</span>
        <span class="c1"># Envelope follower</span>
        <span class="n">abs_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">abs_x</span> <span class="o">&gt;</span> <span class="n">env</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">env</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha_a</span> <span class="o">*</span> <span class="n">env</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_a</span><span class="p">)</span> <span class="o">*</span> <span class="n">abs_x</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">env</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">alpha_r</span> <span class="o">*</span> <span class="n">env</span><span class="p">[</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">alpha_r</span><span class="p">)</span> <span class="o">*</span> <span class="n">abs_x</span>

        <span class="c1"># Compute gain</span>
        <span class="k">if</span> <span class="n">env</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">:</span>
            <span class="n">env_db</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">env</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
            <span class="n">thresh_db</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">threshold</span><span class="p">)</span>
            <span class="n">gain_db</span> <span class="o">=</span> <span class="n">thresh_db</span> <span class="o">+</span> <span class="p">(</span><span class="n">env_db</span> <span class="o">-</span> <span class="n">thresh_db</span><span class="p">)</span> <span class="o">/</span> <span class="n">ratio</span> <span class="o">-</span> <span class="n">env_db</span>
            <span class="n">gain</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="n">gain_db</span> <span class="o">/</span> <span class="mi">20</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gain</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="n">y</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">gain</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">y</span><span class="p">,</span> <span class="n">gain</span>


<span class="c1"># Demo</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mi">44100</span>
<span class="n">t</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="n">generate_audio_signal</span><span class="p">(</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

<span class="c1"># Apply effects</span>
<span class="n">x_delay</span> <span class="o">=</span> <span class="n">delay_effect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">delay_ms</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">feedback</span><span class="o">=</span><span class="mf">0.4</span><span class="p">)</span>
<span class="n">x_chorus</span> <span class="o">=</span> <span class="n">chorus_effect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">depth_ms</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">rate_hz</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">x_comp</span><span class="p">,</span> <span class="n">gain</span> <span class="o">=</span> <span class="n">compressor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">threshold_db</span><span class="o">=-</span><span class="mi">12</span><span class="p">,</span> <span class="n">ratio</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>

<span class="c1"># Plot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="mi">4000</span><span class="p">],</span> <span class="n">x</span><span class="p">[:</span><span class="mi">4000</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Original Signal&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="mi">4000</span><span class="p">],</span> <span class="n">x_delay</span><span class="p">[:</span><span class="mi">4000</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Delay Effect (200ms, feedback=0.4)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="mi">4000</span><span class="p">],</span> <span class="n">x_chorus</span><span class="p">[:</span><span class="mi">4000</span><span class="p">],</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Chorus Effect&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="mi">4000</span><span class="p">],</span> <span class="n">x</span><span class="p">[:</span><span class="mi">4000</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Original&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[:</span><span class="mi">4000</span><span class="p">],</span> <span class="n">x_comp</span><span class="p">[:</span><span class="mi">4000</span><span class="p">],</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Compressed&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Compressor (threshold=-12dB, ratio=4:1)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;audio_effects.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<h3 id="182">18.2 디지털 변조<a class="header-link" href="#182" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>


<span class="k">def</span><span class="w"> </span><span class="nf">qpsk_modulate</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="n">samples_per_symbol</span><span class="o">=</span><span class="mi">20</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;QPSK modulation.&quot;&quot;&quot;</span>
    <span class="c1"># Ensure even number of bits</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">bits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bits</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">n_symbols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
    <span class="n">symbols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_symbols</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

    <span class="c1"># Gray coding: 00-&gt;pi/4, 01-&gt;3pi/4, 11-&gt;5pi/4, 10-&gt;7pi/4</span>
    <span class="n">mapping</span> <span class="o">=</span> <span class="p">{(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
               <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
               <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">),</span>
               <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="mi">7</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">)}</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_symbols</span><span class="p">):</span>
        <span class="n">dibit</span> <span class="o">=</span> <span class="p">(</span><span class="n">bits</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="p">],</span> <span class="n">bits</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">symbols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">[</span><span class="n">dibit</span><span class="p">]</span>

    <span class="c1"># Upsample</span>
    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_symbols</span> <span class="o">*</span> <span class="n">samples_per_symbol</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">signal</span><span class="p">[::</span><span class="n">samples_per_symbol</span><span class="p">]</span> <span class="o">=</span> <span class="n">symbols</span>

    <span class="c1"># Pulse shaping (raised cosine)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">4</span><span class="o">*</span><span class="n">samples_per_symbol</span><span class="p">,</span> <span class="mi">4</span><span class="o">*</span><span class="n">samples_per_symbol</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">alpha</span> <span class="o">=</span> <span class="mf">0.35</span>
    <span class="n">Ts</span> <span class="o">=</span> <span class="n">samples_per_symbol</span>
    <span class="n">rc_pulse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sinc</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="o">*</span><span class="n">t</span><span class="o">/</span><span class="n">Ts</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
    <span class="n">rc_pulse</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">rc_pulse</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

    <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">rc_pulse</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">symbols</span><span class="p">,</span> <span class="n">signal</span>


<span class="k">def</span><span class="w"> </span><span class="nf">qam16_constellation</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate 16-QAM constellation.&quot;&quot;&quot;</span>
    <span class="n">levels</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
    <span class="n">constellation</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">levels</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">levels</span><span class="p">:</span>
            <span class="n">constellation</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">complex</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">q</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">constellation</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>  <span class="c1"># Normalize</span>


<span class="c1"># Generate random bits</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">bits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>

<span class="c1"># QPSK modulation</span>
<span class="n">symbols</span><span class="p">,</span> <span class="n">signal</span> <span class="o">=</span> <span class="n">qpsk_modulate</span><span class="p">(</span><span class="n">bits</span><span class="p">)</span>

<span class="c1"># Add AWGN noise at different SNR levels</span>
<span class="n">snr_values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">25</span><span class="p">]</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">snr_db</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">snr_values</span><span class="p">):</span>
    <span class="n">noise_power</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">snr_db</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">))</span>
                                       <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">symbols</span><span class="p">)))</span>
    <span class="n">received</span> <span class="o">=</span> <span class="n">symbols</span> <span class="o">+</span> <span class="n">noise</span>

    <span class="c1"># Constellation diagram</span>
    <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">received</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">received</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Received&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">symbols</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">symbols</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
               <span class="n">linewidths</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ideal&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;QPSK: SNR = </span><span class="si">{</span><span class="n">snr_db</span><span class="si">}</span><span class="s1"> dB&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;In-phase (I)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Quadrature (Q)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="c1"># 16-QAM constellation</span>
<span class="n">qam_const</span> <span class="o">=</span> <span class="n">qam16_constellation</span><span class="p">()</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">snr_db</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">snr_values</span><span class="p">):</span>
    <span class="n">noise_power</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">snr_db</span><span class="o">/</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">n_sym</span> <span class="o">=</span> <span class="mi">500</span>
    <span class="c1"># Random symbols from constellation</span>
    <span class="n">sym_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="n">n_sym</span><span class="p">)</span>
    <span class="n">tx_symbols</span> <span class="o">=</span> <span class="n">qam_const</span><span class="p">[</span><span class="n">sym_idx</span><span class="p">]</span>
    <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">noise_power</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_sym</span><span class="p">)</span>
                                       <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">n_sym</span><span class="p">))</span>
    <span class="n">rx_symbols</span> <span class="o">=</span> <span class="n">tx_symbols</span> <span class="o">+</span> <span class="n">noise</span>

    <span class="n">ax</span> <span class="o">=</span> <span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">idx</span><span class="p">]</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">rx_symbols</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">rx_symbols</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Received&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">qam_const</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">qam_const</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">marker</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span>
               <span class="n">linewidths</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Ideal&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_aspect</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;16-QAM: SNR = </span><span class="si">{</span><span class="n">snr_db</span><span class="si">}</span><span class="s1"> dB&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;In-phase (I)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Quadrature (Q)&#39;</span><span class="p">)</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">8</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;digital_modulation.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<h3 id="183">18.3 레이더: 처프 펄스 압축<a class="header-link" href="#183" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>


<span class="k">def</span><span class="w"> </span><span class="nf">generate_chirp</span><span class="p">(</span><span class="n">tau_p</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a linear FM chirp pulse.&quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tau_p</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">chirp_rate</span> <span class="o">=</span> <span class="n">B</span> <span class="o">/</span> <span class="n">tau_p</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">chirp_rate</span> <span class="o">*</span> <span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">s</span>


<span class="k">def</span><span class="w"> </span><span class="nf">matched_filter</span><span class="p">(</span><span class="n">received</span><span class="p">,</span> <span class="n">template</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Apply matched filter (cross-correlation).&quot;&quot;&quot;</span>
    <span class="n">mf</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">template</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">received</span><span class="p">,</span> <span class="n">mf</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>


<span class="c1"># Radar parameters</span>
<span class="n">c</span> <span class="o">=</span> <span class="mf">3e8</span>           <span class="c1"># Speed of light (m/s)</span>
<span class="n">fc</span> <span class="o">=</span> <span class="mf">10e9</span>         <span class="c1"># Carrier frequency (10 GHz, X-band)</span>
<span class="n">tau_p</span> <span class="o">=</span> <span class="mf">10e-6</span>     <span class="c1"># Pulse width (10 μs)</span>
<span class="n">B</span> <span class="o">=</span> <span class="mf">5e6</span>           <span class="c1"># Bandwidth (5 MHz)</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mf">20e6</span>         <span class="c1"># Sampling frequency</span>

<span class="c1"># Range resolution</span>
<span class="n">delta_R</span> <span class="o">=</span> <span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">B</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Range resolution: </span><span class="si">{</span><span class="n">delta_R</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> m&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Time-bandwidth product: </span><span class="si">{</span><span class="n">B</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">tau_p</span><span class="si">:</span><span class="s2">.0f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Processing gain: </span><span class="si">{</span><span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="n">tau_p</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> dB&quot;</span><span class="p">)</span>

<span class="c1"># Generate chirp</span>
<span class="n">t_chirp</span><span class="p">,</span> <span class="n">chirp</span> <span class="o">=</span> <span class="n">generate_chirp</span><span class="p">(</span><span class="n">tau_p</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

<span class="c1"># Simulate two targets at different ranges</span>
<span class="n">R1</span> <span class="o">=</span> <span class="mi">5000</span>    <span class="c1"># Target 1 at 5 km</span>
<span class="n">R2</span> <span class="o">=</span> <span class="mi">5060</span>    <span class="c1"># Target 2 at 5.06 km (60 m apart)</span>
<span class="n">A1</span> <span class="o">=</span> <span class="mf">1.0</span>     <span class="c1"># Target 1 amplitude</span>
<span class="n">A2</span> <span class="o">=</span> <span class="mf">0.5</span>     <span class="c1"># Target 2 amplitude (weaker)</span>

<span class="c1"># Convert ranges to time delays</span>
<span class="n">tau1</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">R1</span> <span class="o">/</span> <span class="n">c</span>
<span class="n">tau2</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">R2</span> <span class="o">/</span> <span class="n">c</span>

<span class="c1"># Create received signal</span>
<span class="n">N_total</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">15000</span> <span class="o">/</span> <span class="n">c</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>  <span class="c1"># Enough samples for 15 km range</span>
<span class="n">received</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N_total</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>

<span class="c1"># Add noise</span>
<span class="n">noise_level</span> <span class="o">=</span> <span class="mf">0.3</span>
<span class="n">received</span> <span class="o">+=</span> <span class="n">noise_level</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N_total</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">N_total</span><span class="p">))</span>

<span class="c1"># Add target returns</span>
<span class="n">idx1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tau1</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
<span class="n">idx2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">tau2</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
<span class="k">if</span> <span class="n">idx1</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">chirp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N_total</span><span class="p">:</span>
    <span class="n">received</span><span class="p">[</span><span class="n">idx1</span><span class="p">:</span><span class="n">idx1</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">chirp</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">A1</span> <span class="o">*</span> <span class="n">chirp</span>
<span class="k">if</span> <span class="n">idx2</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">chirp</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N_total</span><span class="p">:</span>
    <span class="n">received</span><span class="p">[</span><span class="n">idx2</span><span class="p">:</span><span class="n">idx2</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">chirp</span><span class="p">)]</span> <span class="o">+=</span> <span class="n">A2</span> <span class="o">*</span> <span class="n">chirp</span>

<span class="c1"># Matched filter output</span>
<span class="n">mf_output</span> <span class="o">=</span> <span class="n">matched_filter</span><span class="p">(</span><span class="n">received</span><span class="p">,</span> <span class="n">chirp</span><span class="p">)</span>

<span class="c1"># Convert to range</span>
<span class="n">range_axis</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">mf_output</span><span class="p">))</span> <span class="o">*</span> <span class="n">c</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>  <span class="c1"># km</span>

<span class="c1"># Plot results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">12</span><span class="p">))</span>

<span class="c1"># Chirp waveform</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t_chirp</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">,</span> <span class="n">chirp</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (μs)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Linear FM Chirp Pulse (B=</span><span class="si">{</span><span class="n">B</span><span class="o">/</span><span class="mf">1e6</span><span class="si">:</span><span class="s1">.0f</span><span class="si">}</span><span class="s1"> MHz, τ=</span><span class="si">{</span><span class="n">tau_p</span><span class="o">*</span><span class="mf">1e6</span><span class="si">:</span><span class="s1">.0f</span><span class="si">}</span><span class="s1"> μs)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="c1"># Chirp spectrogram</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span>
<span class="n">f_stft</span><span class="p">,</span> <span class="n">t_stft</span><span class="p">,</span> <span class="n">Sxx</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">spectrogram</span><span class="p">(</span>
    <span class="n">chirp</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">nperseg</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span> <span class="n">noverlap</span><span class="o">=</span><span class="mi">56</span><span class="p">,</span> <span class="n">nfft</span><span class="o">=</span><span class="mi">256</span>
<span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">t_stft</span><span class="o">*</span><span class="mf">1e6</span><span class="p">,</span> <span class="n">f_stft</span><span class="o">/</span><span class="mf">1e6</span><span class="p">,</span> <span class="mi">10</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">Sxx</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">),</span>
                   <span class="n">shading</span><span class="o">=</span><span class="s1">&#39;gouraud&#39;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;viridis&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (μs)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (MHz)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Chirp Spectrogram&#39;</span><span class="p">)</span>

<span class="c1"># Matched filter output</span>
<span class="n">mf_db</span> <span class="o">=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mf_output</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">mf_output</span><span class="p">))</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">range_axis</span> <span class="o">&gt;</span> <span class="mf">4.5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">range_axis</span> <span class="o">&lt;</span> <span class="mf">5.5</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">range_axis</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">mf_db</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">R1</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Target 1: </span><span class="si">{</span><span class="n">R1</span><span class="o">/</span><span class="mi">1000</span><span class="si">:</span><span class="s1">.1f</span><span class="si">}</span><span class="s1"> km&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">R2</span><span class="o">/</span><span class="mi">1000</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;--&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="s1">&#39;Target 2: </span><span class="si">{</span><span class="n">R2</span><span class="o">/</span><span class="mi">1000</span><span class="si">:</span><span class="s1">.3f</span><span class="si">}</span><span class="s1"> km&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Range (km)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (dB)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Matched Filter Output (ΔR = </span><span class="si">{</span><span class="n">delta_R</span><span class="si">:</span><span class="s1">.0f</span><span class="si">}</span><span class="s1"> m)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">40</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;radar_pulse_compression.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<h3 id="184-ecg">18.4 생체의학: ECG 처리<a class="header-link" href="#184-ecg" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy</span><span class="w"> </span><span class="kn">import</span> <span class="n">signal</span>


<span class="k">def</span><span class="w"> </span><span class="nf">generate_synthetic_ecg</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="mi">360</span><span class="p">,</span> <span class="n">heart_rate</span><span class="o">=</span><span class="mi">72</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a synthetic ECG signal.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    duration : float</span>
<span class="sd">        Duration in seconds</span>
<span class="sd">    fs : int</span>
<span class="sd">        Sampling rate</span>
<span class="sd">    heart_rate : int</span>
<span class="sd">        Heart rate in bpm</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    t : ndarray</span>
<span class="sd">        Time axis</span>
<span class="sd">    ecg : ndarray</span>
<span class="sd">        Synthetic ECG signal</span>
<span class="sd">    r_peaks : ndarray</span>
<span class="sd">        Indices of R-peaks</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
    <span class="n">ecg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
    <span class="n">rr_interval</span> <span class="o">=</span> <span class="mi">60</span> <span class="o">/</span> <span class="n">heart_rate</span>  <span class="c1"># seconds</span>
    <span class="n">rr_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rr_interval</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>

    <span class="n">r_peaks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Generate each heartbeat</span>
    <span class="n">beat_start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">beat_start</span> <span class="o">+</span> <span class="n">rr_samples</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="c1"># P wave</span>
        <span class="n">p_center</span> <span class="o">=</span> <span class="n">beat_start</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.16</span> <span class="o">*</span> <span class="n">rr_samples</span><span class="p">)</span>
        <span class="n">p_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.04</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
        <span class="n">t_local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">p_width</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">p_width</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">p_wave</span> <span class="o">=</span> <span class="mf">0.15</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t_local</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">p_width</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">p_center</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">p_width</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">p_center</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">p_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ecg</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">+=</span> <span class="n">p_wave</span><span class="p">[:</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">]</span>

        <span class="c1"># QRS complex</span>
        <span class="n">r_center</span> <span class="o">=</span> <span class="n">beat_start</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.25</span> <span class="o">*</span> <span class="n">rr_samples</span><span class="p">)</span>
        <span class="n">r_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_center</span><span class="p">)</span>

        <span class="c1"># Q wave</span>
        <span class="n">q_center</span> <span class="o">=</span> <span class="n">r_center</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
        <span class="n">q_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.01</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
        <span class="n">t_local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">q_width</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">q_width</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">q_wave</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t_local</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">q_width</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">q_center</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">q_width</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">q_center</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">q_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ecg</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">+=</span> <span class="n">q_wave</span><span class="p">[:</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">]</span>

        <span class="c1"># R wave</span>
        <span class="n">r_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.008</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
        <span class="n">t_local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">r_width</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">r_width</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">r_wave</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t_local</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">r_width</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">r_center</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">r_width</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">r_center</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">r_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ecg</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">+=</span> <span class="n">r_wave</span><span class="p">[:</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">]</span>

        <span class="c1"># S wave</span>
        <span class="n">s_center</span> <span class="o">=</span> <span class="n">r_center</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.02</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
        <span class="n">s_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.012</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
        <span class="n">t_local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">s_width</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">s_width</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">s_wave</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t_local</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s_width</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">s_center</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">s_width</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">s_center</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">s_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ecg</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">+=</span> <span class="n">s_wave</span><span class="p">[:</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">]</span>

        <span class="c1"># T wave</span>
        <span class="n">t_center</span> <span class="o">=</span> <span class="n">beat_start</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.5</span> <span class="o">*</span> <span class="n">rr_samples</span><span class="p">)</span>
        <span class="n">t_width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.06</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
        <span class="n">t_local</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">-</span><span class="mi">3</span><span class="o">*</span><span class="n">t_width</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">t_width</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">t_wave</span> <span class="o">=</span> <span class="mf">0.3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t_local</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">t_width</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">t_center</span> <span class="o">-</span> <span class="mi">3</span><span class="o">*</span><span class="n">t_width</span><span class="p">)</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">t_center</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">t_width</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ecg</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="o">+=</span> <span class="n">t_wave</span><span class="p">[:</span><span class="n">end</span><span class="o">-</span><span class="n">start</span><span class="p">]</span>

        <span class="c1"># Add some RR variability</span>
        <span class="n">rr_var</span> <span class="o">=</span> <span class="n">rr_samples</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">()</span> <span class="o">*</span> <span class="mf">0.02</span> <span class="o">*</span> <span class="n">rr_samples</span><span class="p">)</span>
        <span class="n">beat_start</span> <span class="o">+=</span> <span class="n">rr_var</span>

    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">ecg</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r_peaks</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">pan_tompkins_qrs</span><span class="p">(</span><span class="n">ecg</span><span class="p">,</span> <span class="n">fs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Simplified Pan-Tompkins QRS detector.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    ecg : ndarray</span>
<span class="sd">        ECG signal</span>
<span class="sd">    fs : int</span>
<span class="sd">        Sampling rate</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    r_peaks : ndarray</span>
<span class="sd">        Detected R-peak indices</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1: Bandpass filter (5-15 Hz)</span>
    <span class="n">nyq</span> <span class="o">=</span> <span class="n">fs</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">b_bp</span><span class="p">,</span> <span class="n">a_bp</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="mi">5</span><span class="o">/</span><span class="n">nyq</span><span class="p">,</span> <span class="mi">15</span><span class="o">/</span><span class="n">nyq</span><span class="p">],</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
    <span class="n">filtered</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b_bp</span><span class="p">,</span> <span class="n">a_bp</span><span class="p">,</span> <span class="n">ecg</span><span class="p">)</span>

    <span class="c1"># Step 2: Derivative</span>
    <span class="n">h_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">8</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">filtered</span><span class="p">,</span> <span class="n">h_diff</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>

    <span class="c1"># Step 3: Squaring</span>
    <span class="n">squared</span> <span class="o">=</span> <span class="n">diff</span><span class="o">**</span><span class="mi">2</span>

    <span class="c1"># Step 4: Moving window integration (150 ms)</span>
    <span class="n">win_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.15</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>
    <span class="n">integrator</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">convolve</span><span class="p">(</span><span class="n">squared</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">win_size</span><span class="p">)</span><span class="o">/</span><span class="n">win_size</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>

    <span class="c1"># Step 5: Thresholding</span>
    <span class="n">threshold</span> <span class="o">=</span> <span class="mf">0.4</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">integrator</span><span class="p">)</span>
    <span class="n">peaks_mask</span> <span class="o">=</span> <span class="n">integrator</span> <span class="o">&gt;</span> <span class="n">threshold</span>

    <span class="c1"># Find peaks</span>
    <span class="n">r_peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">min_distance</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.3</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>  <span class="c1"># Minimum 300 ms between beats</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">peaks_mask</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">peaks_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="c1"># Find the actual R-peak (maximum in the raw ECG)</span>
            <span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="n">win_size</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ecg</span><span class="p">),</span> <span class="n">i</span> <span class="o">+</span> <span class="n">win_size</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">r_idx</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ecg</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_peaks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">r_idx</span> <span class="o">-</span> <span class="n">r_peaks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">min_distance</span><span class="p">:</span>
                <span class="n">r_peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r_idx</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">r_idx</span> <span class="o">+</span> <span class="n">min_distance</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">r_peaks</span><span class="p">)</span>


<span class="c1"># Generate and process ECG</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mi">360</span>
<span class="n">t</span><span class="p">,</span> <span class="n">clean_ecg</span><span class="p">,</span> <span class="n">true_r_peaks</span> <span class="o">=</span> <span class="n">generate_synthetic_ecg</span><span class="p">(</span><span class="n">duration</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">fs</span><span class="o">=</span><span class="n">fs</span><span class="p">,</span> <span class="n">heart_rate</span><span class="o">=</span><span class="mi">72</span><span class="p">)</span>

<span class="c1"># Add noise</span>
<span class="n">baseline_wander</span> <span class="o">=</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.15</span><span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.05</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">0.3</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">powerline</span> <span class="o">=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">60</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">muscle_noise</span> <span class="o">=</span> <span class="mf">0.03</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="n">noisy_ecg</span> <span class="o">=</span> <span class="n">clean_ecg</span> <span class="o">+</span> <span class="n">baseline_wander</span> <span class="o">+</span> <span class="n">powerline</span> <span class="o">+</span> <span class="n">muscle_noise</span>

<span class="c1"># Preprocessing</span>
<span class="c1"># Baseline removal (highpass 0.5 Hz)</span>
<span class="n">b_hp</span><span class="p">,</span> <span class="n">a_hp</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="o">/</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;high&#39;</span><span class="p">)</span>
<span class="n">ecg_no_baseline</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b_hp</span><span class="p">,</span> <span class="n">a_hp</span><span class="p">,</span> <span class="n">noisy_ecg</span><span class="p">)</span>

<span class="c1"># Notch filter for 60 Hz</span>
<span class="n">b_notch</span><span class="p">,</span> <span class="n">a_notch</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">iirnotch</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
<span class="n">ecg_notched</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b_notch</span><span class="p">,</span> <span class="n">a_notch</span><span class="p">,</span> <span class="n">ecg_no_baseline</span><span class="p">)</span>

<span class="c1"># Bandpass 0.5-40 Hz</span>
<span class="n">b_bp</span><span class="p">,</span> <span class="n">a_bp</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">butter</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mf">0.5</span><span class="o">/</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span> <span class="mi">40</span><span class="o">/</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="mi">2</span><span class="p">)],</span> <span class="n">btype</span><span class="o">=</span><span class="s1">&#39;band&#39;</span><span class="p">)</span>
<span class="n">ecg_filtered</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">filtfilt</span><span class="p">(</span><span class="n">b_bp</span><span class="p">,</span> <span class="n">a_bp</span><span class="p">,</span> <span class="n">noisy_ecg</span><span class="p">)</span>

<span class="c1"># QRS detection</span>
<span class="n">detected_r_peaks</span> <span class="o">=</span> <span class="n">pan_tompkins_qrs</span><span class="p">(</span><span class="n">ecg_filtered</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

<span class="c1"># Plot results</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">14</span><span class="p">))</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">clean_ecg</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">true_r_peaks</span><span class="p">],</span> <span class="n">clean_ecg</span><span class="p">[</span><span class="n">true_r_peaks</span><span class="p">],</span> <span class="s1">&#39;rv&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Clean ECG with True R-peaks&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (mV)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">noisy_ecg</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Noisy ECG (baseline wander + 60Hz + muscle noise)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (mV)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ecg_filtered</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Filtered ECG (0.5-40 Hz bandpass)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (mV)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">ecg_filtered</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">detected_r_peaks</span><span class="p">],</span> <span class="n">ecg_filtered</span><span class="p">[</span><span class="n">detected_r_peaks</span><span class="p">],</span>
             <span class="s1">&#39;rv&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Detected R-peaks&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;QRS Detection (Pan-Tompkins): </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">detected_r_peaks</span><span class="p">)</span><span class="si">}</span><span class="s1"> beats detected&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude (mV)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;ecg_processing.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

<span class="c1"># HRV Analysis</span>
<span class="n">rr_intervals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">detected_r_peaks</span><span class="p">)</span> <span class="o">/</span> <span class="n">fs</span> <span class="o">*</span> <span class="mi">1000</span>  <span class="c1"># Convert to ms</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">HRV Time-Domain Measures:&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Mean RR: </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rr_intervals</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  SDNN:    </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">rr_intervals</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  RMSSD:   </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">rr_intervals</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> ms&quot;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  Mean HR: </span><span class="si">{</span><span class="mi">60000</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">rr_intervals</span><span class="p">)</span><span class="si">:</span><span class="s2">.1f</span><span class="si">}</span><span class="s2"> bpm&quot;</span><span class="p">)</span>
</code></pre></div>

<h3 id="185">18.5 피치 검출 시연<a class="header-link" href="#185" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>


<span class="k">def</span><span class="w"> </span><span class="nf">autocorrelation_pitch</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pitch detection using autocorrelation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frame : ndarray</span>
<span class="sd">        Signal frame</span>
<span class="sd">    fs : float</span>
<span class="sd">        Sampling rate</span>
<span class="sd">    fmin, fmax : float</span>
<span class="sd">        Min/max expected pitch frequency</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f0 : float</span>
<span class="sd">        Estimated pitch frequency (0 if unvoiced)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="c1"># Compute autocorrelation</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">N</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>  <span class="c1"># Take positive lags only</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Normalize</span>

    <span class="c1"># Search range</span>
    <span class="n">lag_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fs</span> <span class="o">/</span> <span class="n">fmax</span><span class="p">)</span>
    <span class="n">lag_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span> <span class="o">/</span> <span class="n">fmin</span><span class="p">),</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="c1"># Find the first significant peak</span>
    <span class="k">if</span> <span class="n">lag_max</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="n">lag_max</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

    <span class="n">r_search</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">lag_min</span><span class="p">:</span><span class="n">lag_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">r_search</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">peak_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">r_search</span><span class="p">)</span> <span class="o">+</span> <span class="n">lag_min</span>

    <span class="c1"># Voiced/unvoiced decision</span>
    <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="n">peak_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>  <span class="c1"># Threshold</span>
        <span class="k">return</span> <span class="n">fs</span> <span class="o">/</span> <span class="n">peak_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>


<span class="k">def</span><span class="w"> </span><span class="nf">cepstrum_pitch</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">fs</span><span class="p">,</span> <span class="n">fmin</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">fmax</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pitch detection using cepstrum.&quot;&quot;&quot;</span>
    <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="c1"># Compute cepstrum</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">N</span><span class="p">)</span>
    <span class="n">log_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)</span>
    <span class="n">cepstrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">log_spectrum</span><span class="p">))</span>

    <span class="c1"># Search range (quefrency = period in samples)</span>
    <span class="n">q_min</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fs</span> <span class="o">/</span> <span class="n">fmax</span><span class="p">)</span>
    <span class="n">q_max</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span> <span class="o">/</span> <span class="n">fmin</span><span class="p">),</span> <span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">cep_search</span> <span class="o">=</span> <span class="n">cepstrum</span><span class="p">[</span><span class="n">q_min</span><span class="p">:</span><span class="n">q_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cep_search</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">peak_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">cep_search</span><span class="p">)</span> <span class="o">+</span> <span class="n">q_min</span>

    <span class="k">if</span> <span class="n">cepstrum</span><span class="p">[</span><span class="n">peak_idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">fs</span> <span class="o">/</span> <span class="n">peak_idx</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>


<span class="c1"># Generate a test signal with known pitch</span>
<span class="n">fs</span> <span class="o">=</span> <span class="mi">16000</span>
<span class="n">duration</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">fs</span><span class="p">)</span>

<span class="c1"># Create a signal with time-varying pitch (glissando)</span>
<span class="n">f0_start</span> <span class="o">=</span> <span class="mi">150</span>
<span class="n">f0_end</span> <span class="o">=</span> <span class="mi">300</span>
<span class="n">phase</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">f0_start</span> <span class="o">*</span> <span class="n">t</span> <span class="o">+</span> <span class="p">(</span><span class="n">f0_end</span> <span class="o">-</span> <span class="n">f0_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">t</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">duration</span><span class="p">))</span>
<span class="n">signal_test</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
    <span class="n">signal_test</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">k</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">k</span> <span class="o">*</span> <span class="n">phase</span><span class="p">)</span>
<span class="n">signal_test</span> <span class="o">=</span> <span class="n">signal_test</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">signal_test</span><span class="p">))</span>
<span class="n">signal_test</span> <span class="o">+=</span> <span class="mf">0.05</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>  <span class="c1"># Add noise</span>

<span class="c1"># Frame-by-frame pitch detection</span>
<span class="n">frame_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.04</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>  <span class="c1"># 40 ms</span>
<span class="n">hop</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mf">0.01</span> <span class="o">*</span> <span class="n">fs</span><span class="p">)</span>  <span class="c1"># 10 ms</span>
<span class="n">n_frames</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">signal_test</span><span class="p">)</span> <span class="o">-</span> <span class="n">frame_length</span><span class="p">)</span> <span class="o">//</span> <span class="n">hop</span>

<span class="n">pitches_ac</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)</span>
<span class="n">pitches_cep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)</span>
<span class="n">frame_times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_frames</span><span class="p">)</span>

<span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hanning</span><span class="p">(</span><span class="n">frame_length</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_frames</span><span class="p">):</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">hop</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="n">signal_test</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span><span class="o">+</span><span class="n">frame_length</span><span class="p">]</span> <span class="o">*</span> <span class="n">window</span>
    <span class="n">frame_times</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">frame_length</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="n">fs</span>

    <span class="n">pitches_ac</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">autocorrelation_pitch</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>
    <span class="n">pitches_cep</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">cepstrum_pitch</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">fs</span><span class="p">)</span>

<span class="c1"># True pitch trajectory</span>
<span class="n">true_pitch</span> <span class="o">=</span> <span class="n">f0_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">f0_end</span> <span class="o">-</span> <span class="n">f0_start</span><span class="p">)</span> <span class="o">*</span> <span class="n">frame_times</span> <span class="o">/</span> <span class="n">duration</span>

<span class="c1"># Plot</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">signal_test</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Test Signal (Glissando 150-300 Hz)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">frame_times</span><span class="p">,</span> <span class="n">true_pitch</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;True pitch&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">frame_times</span><span class="p">,</span> <span class="n">pitches_ac</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
             <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Autocorrelation&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">frame_times</span><span class="p">,</span> <span class="n">pitches_cep</span><span class="p">,</span> <span class="s1">&#39;bx&#39;</span><span class="p">,</span> <span class="n">markersize</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
             <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Cepstrum&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Pitch Detection Comparison&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">500</span><span class="p">])</span>

<span class="c1"># Autocorrelation and cepstrum of one frame</span>
<span class="n">frame_idx</span> <span class="o">=</span> <span class="n">n_frames</span> <span class="o">//</span> <span class="mi">2</span>
<span class="n">start</span> <span class="o">=</span> <span class="n">frame_idx</span> <span class="o">*</span> <span class="n">hop</span>
<span class="n">frame</span> <span class="o">=</span> <span class="n">signal_test</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span><span class="o">+</span><span class="n">frame_length</span><span class="p">]</span> <span class="o">*</span> <span class="n">window</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">correlate</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;full&#39;</span><span class="p">)</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

<span class="n">spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">frame_length</span><span class="p">)</span>
<span class="n">cepstrum_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span> <span class="o">+</span> <span class="mf">1e-10</span><span class="p">)))</span>

<span class="n">lag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">))</span> <span class="o">/</span> <span class="n">fs</span> <span class="o">*</span> <span class="mi">1000</span>  <span class="c1"># ms</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">lag</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="mi">80</span><span class="p">)],</span> <span class="n">r</span><span class="p">[:</span><span class="nb">int</span><span class="p">(</span><span class="n">fs</span><span class="o">/</span><span class="mi">80</span><span class="p">)],</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span>
             <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Autocorrelation&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Lag (ms)&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Normalized Autocorrelation&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Autocorrelation of Middle Frame&#39;</span><span class="p">)</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="s1">&#39;pitch_detection.png&#39;</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</code></pre></div>

<hr />
<h2 id="19">19. 연습 문제<a class="header-link" href="#19" title="Permanent link">&para;</a></h2>
<h3 id="1_1">연습 1: 오디오 이펙트 체인<a class="header-link" href="#1_1" title="Permanent link">&para;</a></h3>
<p>(a) 4개의 병렬 빗살 필터(지연 29.7, 37.1, 41.1, 43.7 ms, 이득 0.742, 0.733, 0.715, 0.697)와 2개의 직렬 전역 통과 필터(지연 5.0, 1.7 ms, 이득 0.7)를 사용하여 슈뢰더 리버브레이터를 구현하십시오. 짧은 임펄스에 적용하고 결과 임펄스 응답을 플로팅하십시오.</p>
<p>(b) 간단한 멜로디(예: 적절한 주파수의 사인파를 사용한 "반짝반짝 작은 별")를 생성하십시오. 리버브를 적용하고 들어보십시오(가능하다면 WAV 파일로 저장).</p>
<p>(c) 플랜저 이펙트를 구현하고, 시변 크기 응답을 플로팅하여 특징적인 빗살 필터 스윕을 시연하십시오.</p>
<h3 id="2_1">연습 2: 피치 검출 강인성<a class="header-link" href="#2_1" title="Permanent link">&para;</a></h3>
<p>(a) 220 Hz의 순음(pure tone)을 생성하고 자기상관과 켑스트럼 방법 모두 올바르게 검출하는지 확인하십시오.</p>
<p>(b) 고조파 내용(감소하는 진폭을 가진 1번째부터 5번째 고조파)을 추가하십시오. 피치 검출기가 여전히 기본파를 찾는지 확인하십시오.</p>
<p>(c) SNR = 20, 10, 5, 0 dB에서 잡음을 추가하십시오. 두 방법에 대해 SNR 대 피치 검출 정확도를 플로팅하십시오.</p>
<p>(d) 빠진 기본파를 가진 신호(100 Hz의 고조파 2, 3, 4만 포함)를 만드십시오. 자기상관 방법이 여전히 100 Hz를 검출할 수 있습니까? 켑스트럼은 어떻습니까?</p>
<h3 id="3-ber">연습 3: 디지털 변조 BER<a class="header-link" href="#3-ber" title="Permanent link">&para;</a></h3>
<p>(a) BPSK, QPSK, 16-QAM 변조 및 복조를 구현하십시오.</p>
<p>(b) $E_b/N_0$를 0에서 20 dB까지 AWGN 채널을 통한 전송을 시뮬레이션하십시오. 세 가지 방식 모두의 BER 곡선을 플로팅하십시오.</p>
<p>(c) 이론적 BER과 비교하십시오:
- BPSK: $P_b = Q(\sqrt{2E_b/N_0})$
- QPSK: BPSK와 동일(비트당)
- 16-QAM: $P_b \approx \frac{3}{8}Q(\sqrt{4E_b/(5N_0)})$</p>
<p>(d) 16-QAM에 그레이 코딩(Gray coding)을 구현하고 자연 이진 매핑에 비해 BER이 개선됨을 보이십시오.</p>
<h3 id="4-ofdm">연습 4: OFDM 시스템<a class="header-link" href="#4-ofdm" title="Permanent link">&para;</a></h3>
<p>(a) 64개 부반송파, 16-QAM 변조, 길이 16의 순환 전치를 가진 기본 OFDM 송신기와 수신기를 구현하십시오.</p>
<p>(b) AWGN을 포함한 다중경로 채널 $h = [1, 0, 0.5, 0, 0.2]$를 통한 전송을 시뮬레이션하십시오.</p>
<p>(c) 순환 전치가 단순한 단일 탭 등화를 가능하게 함을 보이십시오. 등화 전후의 성상도를 플로팅하십시오.</p>
<p>(d) 순환 전치를 제거하고 결과로 나타나는 ISI를 시연하십시오.</p>
<h3 id="5_1">연습 5: 레이더 파형 설계<a class="header-link" href="#5_1" title="Permanent link">&para;</a></h3>
<p>(a) 시간-대역폭 곱 10, 50, 200의 처프 펄스를 생성하십시오. 정합 필터링을 적용하고 압축된 펄스 폭과 사이드로브 레벨을 비교하십시오.</p>
<p>(b) 정합 필터에 해밍 윈도우를 적용하십시오. 메인로브 폭과 사이드로브 레벨에 어떤 영향을 미칩니까?</p>
<p>(c) 10 km와 10.03 km 거리에 두 표적이 있는 시나리오를 시뮬레이션하십시오. 각 TBP에서 표적이 분해되는지 확인하십시오.</p>
<p>(d) TBP = 50인 처프 펄스에 대해 2D 모호 함수 $|\chi(\tau, f_d)|$를 계산하고 플로팅하십시오. 거리-도플러 결합 능선을 식별하십시오.</p>
<h3 id="6-ecg">연습 6: ECG 분석 파이프라인<a class="header-link" href="#6-ecg" title="Permanent link">&para;</a></h3>
<p>(a) 심박수 75 bpm의 합성 ECG를 생성하고 다음을 추가하십시오:
- 기저선 방랑(0.2 Hz 정현파, 진폭 0.3 mV)
- 50 Hz 전원선 잡음(진폭 0.1 mV)
- 랜덤 잡음(SNR = 20 dB)</p>
<p>(b) 전체 전처리 파이프라인을 구현하십시오: 고역 통과 필터(0.5 Hz), 노치 필터(50 Hz), 대역 통과(1-40 Hz). 각 단계 후의 신호를 보이십시오.</p>
<p>(c) Pan-Tompkins QRS 검출기를 구현하십시오. 검출된 박동 수를 세고 실제 값과 비교하십시오.</p>
<p>(d) RR 간격을 추출하고 SDNN, RMSSD, pNN50을 계산하십시오. 알려진 심박 변이도와 비교하십시오.</p>
<p>(e) HRV 전력 스펙트럼을 계산하고 LF 및 HF 대역을 식별하십시오.</p>
<h3 id="7-eeg">연습 7: EEG 스펙트럼 분석<a class="header-link" href="#7-eeg" title="Permanent link">&para;</a></h3>
<p>(a) EEG 신호를 다음의 합으로 시뮬레이션하십시오:
- 알파 대역(10 Hz): 눈을 감았을 때 지배적
- 베타 대역(20 Hz): 집중 시 존재
- 배경 잡음(1/f 스펙트럼)</p>
<p>(b) 웰치 방법(2초 윈도우, 50% 오버랩)을 사용하여 전력 스펙트럼 밀도를 계산하십시오. 알파 및 베타 피크를 식별하십시오.</p>
<p>(c) "눈 뜨기/감기" 실험을 시뮬레이션하십시오: 알파 전력이 $t = 2$-4 s(눈 감음) 동안 증가하고 다른 곳에서는 감소합니다. STFT를 사용하여 시변 알파 대역 전력을 보이십시오.</p>
<p>(d) 슬라이딩 윈도우를 사용하여 시간에 따른 상대 대역 전력(알파/전체, 베타/전체)을 계산하십시오.</p>
<hr />
<h2 id="20">20. 요약<a class="header-link" href="#20" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>분야</th>
<th>핵심 기법</th>
<th>신호 처리 도구</th>
</tr>
</thead>
<tbody>
<tr>
<td>오디오</td>
<td>지연 이펙트, 리버브</td>
<td>지연 라인, 빗살/전역 통과 필터</td>
</tr>
<tr>
<td>오디오</td>
<td>피치 검출</td>
<td>자기상관, 켑스트럼</td>
</tr>
<tr>
<td>오디오</td>
<td>이퀄라이제이션</td>
<td>파라메트릭 바이쿼드 필터</td>
</tr>
<tr>
<td>오디오</td>
<td>음성 코딩</td>
<td>선형 예측(LPC)</td>
</tr>
<tr>
<td>통신</td>
<td>아날로그 변조</td>
<td>AM, FM, PM</td>
</tr>
<tr>
<td>통신</td>
<td>디지털 변조</td>
<td>PSK, QAM(I-Q 처리)</td>
</tr>
<tr>
<td>통신</td>
<td>펄스 성형</td>
<td>상승 코사인, 정합 필터</td>
</tr>
<tr>
<td>통신</td>
<td>OFDM</td>
<td>FFT/IFFT, 순환 전치</td>
</tr>
<tr>
<td>통신</td>
<td>등화</td>
<td>ZF, MMSE, 적응(LMS/RLS)</td>
</tr>
<tr>
<td>레이더</td>
<td>거리 검출</td>
<td>정합 필터</td>
</tr>
<tr>
<td>레이더</td>
<td>펄스 압축</td>
<td>처프, 정합 필터</td>
</tr>
<tr>
<td>레이더</td>
<td>파형 설계</td>
<td>모호 함수</td>
</tr>
<tr>
<td>생체의학</td>
<td>ECG 전처리</td>
<td>대역 통과, 노치 필터</td>
</tr>
<tr>
<td>생체의학</td>
<td>QRS 검출</td>
<td>Pan-Tompkins 알고리즘</td>
</tr>
<tr>
<td>생체의학</td>
<td>EEG 분석</td>
<td>PSD, 대역 전력, STFT</td>
</tr>
<tr>
<td>생체의학</td>
<td>HRV</td>
<td>시간/주파수 영역 측정값</td>
</tr>
</tbody>
</table>
<p><strong>핵심 요점</strong>:
1. 오디오 이펙트는 기본 빌딩 블록인 지연 라인, 필터, 변조기로 구성됩니다.
2. 피치 검출은 자기상관을 통한 주기성 찾기 또는 켑스트럼을 통한 스펙트럼 분석으로 귀결됩니다.
3. 디지털 변조는 비트를 I-Q 평면의 점에 매핑합니다; 고차 방식은 스펙트럼 효율을 위해 SNR을 교환합니다.
4. OFDM은 FFT를 사용하여 주파수 선택적 채널을 병렬 평탄 채널로 변환합니다.
5. 레이더 펄스 압축은 높은 에너지(긴 펄스)와 미세한 거리 해상도(넓은 대역폭) 모두를 달성합니다.
6. 모호 함수는 레이더 파형의 거리-속도 해상도를 완전히 특성화합니다.
7. ECG 처리는 신뢰할 수 있는 QRS 검출을 위해 대역 통과 필터링, 노치 필터링, Pan-Tompkins 알고리즘을 결합합니다.
8. EEG 스펙트럼 분석은 주파수 대역에 걸친 전력 분포를 통해 뇌 상태를 드러냅니다.
9. 이 레슨의 모든 응용은 레슨 1-15의 기초 위에 직접 구축됩니다.</p>
<hr />
<h2 id="21">21. 참고 문헌<a class="header-link" href="#21" title="Permanent link">&para;</a></h2>
<ol>
<li>J.O. Smith III, <em>Physical Audio Signal Processing</em>, W3K Publishing, 2010. (온라인 제공)</li>
<li>J.G. Proakis and M. Salehi, <em>Digital Communications</em>, 5th ed., McGraw-Hill, 2008.</li>
<li>M.A. Richards, <em>Fundamentals of Radar Signal Processing</em>, 2nd ed., McGraw-Hill, 2014.</li>
<li>M.I. Skolnik, <em>Introduction to Radar Systems</em>, 3rd ed., McGraw-Hill, 2001.</li>
<li>J. Pan and W.J. Tompkins, "A real-time QRS detection algorithm," <em>IEEE Trans. Biomedical Engineering</em>, vol. BME-32, no. 3, pp. 230-236, 1985.</li>
<li>R. Rangayyan, <em>Biomedical Signal Analysis</em>, 2nd ed., Wiley-IEEE Press, 2015.</li>
<li>S. Haykin and M. Moher, <em>Communication Systems</em>, 5th ed., Wiley, 2009.</li>
<li>A.V. Oppenheim and R.W. Schafer, <em>Discrete-Time Signal Processing</em>, 3rd ed., Pearson, 2010.</li>
<li>U.R. Acharya et al., "Heart rate variability: a review," <em>Medical and Biological Engineering and Computing</em>, vol. 44, pp. 1031-1051, 2006.</li>
</ol>
<hr />
<p><strong>이전</strong>: <a href="./15_Image_Signal_Processing.md">15. 영상 신호 처리</a> | <a href="./00_Overview.md">개요</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Signal_Processing/15_Image_Signal_Processing.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">15. 영상 신호 처리(Image Signal Processing)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Signal_Processing/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}