{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>레슨 2: 소프트웨어 개발 생명주기 - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Software_Engineering/">Software Engineering</a>
    <span class="separator">/</span>
    <span class="current">레슨 2: 소프트웨어 개발 생명주기</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>레슨 2: 소프트웨어 개발 생명주기</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Software_Engineering/01_What_Is_Software_Engineering.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">레슨 1: 소프트웨어 공학이란 무엇인가</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Software_Engineering/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Software_Engineering/03_Agile_and_Iterative_Development.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">레슨 3: 애자일과 반복적 개발</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#1-sdlc">1. SDLC 개요</a><ul>
<li><a href="#1-planning">단계 1: 계획(Planning)</a></li>
<li><a href="#2-requirements-engineering">단계 2: 요구사항 공학(Requirements Engineering)</a></li>
<li><a href="#3-design">단계 3: 설계(Design)</a></li>
<li><a href="#4-implementation">단계 4: 구현(Implementation, 코딩)</a></li>
<li><a href="#5-testing">단계 5: 테스트(Testing)</a></li>
<li><a href="#6-deployment">단계 6: 배포(Deployment)</a></li>
<li><a href="#7-maintenance-and-evolution">단계 7: 유지보수 및 발전(Maintenance and Evolution)</a></li>
</ul>
</li>
<li><a href="#2-waterfall-model">2. 폭포수 모델(Waterfall Model)</a><ul>
<li><a href="#_1">구조</a></li>
<li><a href="#_2">단계 게이트 기준</a></li>
<li><a href="#_3">강점</a></li>
<li><a href="#_4">약점</a></li>
<li><a href="#_5">폭포수 모델 사용 시기</a></li>
</ul>
</li>
<li><a href="#3-v-v-model">3. V-모델(V-Model, 검증 및 확인 모델)</a><ul>
<li><a href="#_6">구조</a></li>
<li><a href="#verification">왼쪽 (검증(Verification) — "제품을 올바르게 만들기")</a></li>
<li><a href="#validation">오른쪽 (확인(Validation) — "올바른 제품 만들기")</a></li>
<li><a href="#_7">폭포수 모델 대비 강점</a></li>
<li><a href="#_8">약점</a></li>
</ul>
</li>
<li><a href="#4-incremental-model">4. 점진적 모델(Incremental Model)</a><ul>
<li><a href="#_9">구조</a></li>
<li><a href="#_10">강점</a></li>
<li><a href="#_11">약점</a></li>
</ul>
</li>
<li><a href="#5-spiral-model">5. 나선형 모델(Spiral Model)</a><ul>
<li><a href="#_12">구조</a></li>
<li><a href="#_13">리스크 중심 특성</a></li>
<li><a href="#_14">강점</a></li>
<li><a href="#_15">약점</a></li>
</ul>
</li>
<li><a href="#6-radrapid-application-development">6. RAD(Rapid Application Development, 신속 응용 프로그램 개발)</a><ul>
<li><a href="#_16">핵심 원칙</a></li>
<li><a href="#rad">RAD 단계</a></li>
<li><a href="#_17">강점</a></li>
<li><a href="#_18">약점</a></li>
</ul>
</li>
<li><a href="#7-prototyping-model">7. 프로토타이핑 모델(Prototyping Model)</a><ul>
<li><a href="#_19">프로토타입 유형</a></li>
<li><a href="#_20">프로세스</a></li>
<li><a href="#_21">프로토타이핑 사용 시기</a></li>
</ul>
</li>
<li><a href="#8-sdlc">8. SDLC 모델 비교</a></li>
<li><a href="#9">9. 올바른 모델 선택</a><ul>
<li><a href="#_22">의사결정 프레임워크</a></li>
<li><a href="#_23">주요 의사결정 기준</a></li>
</ul>
</li>
<li><a href="#10">10. 실제 사례</a><ul>
<li><a href="#1-nasa-v-">사례 1: NASA 미션 소프트웨어 (V-모델)</a></li>
<li><a href="#2_1">사례 2: 전자상거래 스타트업 (애자일/점진적)</a></li>
<li><a href="#3">사례 3: 은행 핵심 시스템 교체 (나선형)</a></li>
<li><a href="#4-hr-rad">사례 4: 내부 HR 도구 (RAD)</a></li>
</ul>
</li>
<li><a href="#_24">요약</a></li>
<li><a href="#_25">연습 문제</a></li>
<li><a href="#_26">더 읽을거리</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="2">레슨 2: 소프트웨어 개발 생명주기<a class="header-link" href="#2" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./01_What_Is_Software_Engineering.md">소프트웨어 공학이란 무엇인가</a> | <strong>다음</strong>: <a href="./03_Agile_and_Iterative_Development.md">애자일과 반복적 개발</a></p>
<hr />
<p>모든 소프트웨어 시스템은 개념 정립부터 폐기에 이르기까지 예측 가능한 일련의 단계를 거칩니다. <strong>소프트웨어 개발 생명주기(Software Development Life Cycle, SDLC)</strong>는 이러한 단계, 각 단계의 활동, 생성되는 산출물, 그리고 한 단계에서 다음 단계로 이동하기 위한 기준을 정의하는 구조화된 프로세스입니다. 적절한 SDLC 모델을 선택하는 것은 프로젝트 시작 시 내리는 가장 중요한 결정 중 하나입니다.</p>
<p><strong>난이도</strong>: ⭐⭐</p>
<p><strong>선수 학습</strong>:
- <a href="./01_What_Is_Software_Engineering.md">레슨 1: 소프트웨어 공학이란 무엇인가</a>
- 소프트웨어 프로젝트에 대한 기본적인 이해</p>
<p><strong>학습 목표</strong>:
- 소프트웨어 개발 생명주기의 표준 단계를 설명한다
- 폭포수(Waterfall), V-모델(V-Model), 점진적(Incremental), 나선형(Spiral), RAD, 프로토타이핑(Prototyping) 모델을 설명한다
- 각 모델의 강점, 약점, 적합한 사용 사례를 식별한다
- 주어진 프로젝트에 적합한 모델을 선택하기 위한 의사결정 프레임워크를 적용한다
- 프로세스 모델이 리스크, 요구사항 안정성, 팀 규모와 어떻게 관련되는지 이해한다</p>
<hr />
<h2 id="1-sdlc">1. SDLC 개요<a class="header-link" href="#1-sdlc" title="Permanent link">&para;</a></h2>
<p>소프트웨어 개발 생명주기는 초기 아이디어부터 폐기까지 소프트웨어 개발을 안내하는 구조를 설명합니다. 특정 모델과 관계없이 대부분의 SDLC 프레임워크는 다음과 같은 핵심 단계의 변형을 포함합니다:</p>
<div class="highlight"><pre><span></span><code>┌─────────────────────────────────────────────────────────────────┐
│                   SDLC 핵심 단계                                 │
│                                                                 │
│  1. 계획      ──►  프로젝트는 무엇인가? 실현 가능한가?           │
│  2. 요구사항  ──►  소프트웨어는 무엇을 해야 하는가?              │
│  3. 설계      ──►  어떻게 구조화될 것인가?                       │
│  4. 구현      ──►  코드 작성                                     │
│  5. 테스트    ──►  올바르게 작동하는지 검증                       │
│  6. 배포      ──►  프로덕션 환경에 릴리스                        │
│  7. 유지보수  ──►  결함 수정, 시간 경과에 따른 기능 추가          │
└─────────────────────────────────────────────────────────────────┘
</code></pre></div>

<h3 id="1-planning">단계 1: 계획(Planning)<a class="header-link" href="#1-planning" title="Permanent link">&para;</a></h3>
<p><strong>목표</strong>: 프로젝트가 진행할 가치가 있는지, 어떻게 접근할 것인지 결정합니다.</p>
<p>활동:
- 프로젝트 범위와 목표 정의
- 이해관계자 식별
- 타당성 검토 수행 (기술적, 재정적, 법적, 운영적)
- 높은 수준에서 비용과 일정 추정
- 팀과 역할 정의
- SDLC 모델 선택</p>
<p>주요 산출물: 프로젝트 헌장, 타당성 보고서, 초기 프로젝트 계획</p>
<h3 id="2-requirements-engineering">단계 2: 요구사항 공학(Requirements Engineering)<a class="header-link" href="#2-requirements-engineering" title="Permanent link">&para;</a></h3>
<p><strong>목표</strong>: 소프트웨어가 정확히 무엇을 해야 하는지 이해하고 문서화합니다.</p>
<p>활동:
- 인터뷰, 워크숍, 관찰을 통한 요구사항 도출
- 요구사항 분석 및 우선순위 결정
- 기능적 요구사항과 비기능적 요구사항 문서화
- 이해관계자와 요구사항 검증
- 요구사항 변경 관리</p>
<p>주요 산출물: 소프트웨어 요구사항 명세서(SRS), 유스케이스, 사용자 스토리</p>
<h3 id="3-design">단계 3: 설계(Design)<a class="header-link" href="#3-design" title="Permanent link">&para;</a></h3>
<p><strong>목표</strong>: 시스템이 어떻게 구축될지 결정합니다.</p>
<p>활동:
- 아키텍처 설계 (높은 수준의 구조: 컴포넌트, 레이어, 인터페이스)
- 상세 설계 (클래스 구조, 데이터 스키마, 알고리즘)
- UI/UX 설계
- 데이터베이스 설계
- 보안 설계</p>
<p>주요 산출물: 아키텍처 문서, 상세 설계 명세서, 데이터베이스 스키마, API 계약</p>
<h3 id="4-implementation">단계 4: 구현(Implementation, 코딩)<a class="header-link" href="#4-implementation" title="Permanent link">&para;</a></h3>
<p><strong>목표</strong>: 설계를 작동하는 코드로 변환합니다.</p>
<p>활동:
- 설계 명세서에 따른 소스 코드 작성
- 코드 리뷰
- 개발자가 수행하는 단위 테스트
- 컴포넌트 통합</p>
<p>주요 산출물: 소스 코드, 빌드 산출물, 단위 테스트</p>
<h3 id="5-testing">단계 5: 테스트(Testing)<a class="header-link" href="#5-testing" title="Permanent link">&para;</a></h3>
<p><strong>목표</strong>: 소프트웨어가 요구사항을 충족하고 올바르게 작동하는지 검증합니다.</p>
<p>활동:
- 시스템 테스트 (종단 간 검증)
- 통합 테스트
- 성능 테스트, 보안 테스트
- 사용자 인수 테스트(UAT)
- 결함 보고 및 해결</p>
<p>주요 산출물: 테스트 계획, 테스트 케이스, 결함 보고서, 테스트 결과</p>
<h3 id="6-deployment">단계 6: 배포(Deployment)<a class="header-link" href="#6-deployment" title="Permanent link">&para;</a></h3>
<p><strong>목표</strong>: 소프트웨어를 의도한 환경과 사용자에게 릴리스합니다.</p>
<p>활동:
- 배포 계획 및 롤백 절차
- 프로덕션 환경 구성
- 사용자 교육 및 문서화
- 레거시 시스템에서의 전환 (해당하는 경우)</p>
<p>주요 산출물: 배포 계획, 릴리스 노트, 사용자 매뉴얼</p>
<h3 id="7-maintenance-and-evolution">단계 7: 유지보수 및 발전(Maintenance and Evolution)<a class="header-link" href="#7-maintenance-and-evolution" title="Permanent link">&para;</a></h3>
<p><strong>목표</strong>: 소프트웨어가 운영 가능한 상태를 유지하고 변화하는 요구사항을 충족하도록 발전시킵니다.</p>
<p>활동:
- 프로덕션에서 발견된 결함 수정 (교정적 유지보수)
- 새로운 환경에 적응 (적응적 유지보수)
- 새로운 기능 추가 (완전화 유지보수)
- 미래의 장애 예방 (예방적 유지보수)</p>
<p>주요 산출물: 변경 요청, 업데이트된 문서, 새 릴리스</p>
<hr />
<h2 id="2-waterfall-model">2. 폭포수 모델(Waterfall Model)<a class="header-link" href="#2-waterfall-model" title="Permanent link">&para;</a></h2>
<p>폭포수 모델은 Winston Royce가 1970년 논문 "대형 소프트웨어 시스템 개발 관리(Managing the Development of Large Software Systems)"에서 설명한 최초의 공식 SDLC 모델입니다. Royce가 실제로는 순수한 순차적 개발이 <strong>위험하다</strong>고 주장하며 반복적 접근 방식을 권장했음에도 불구하고, 순차적 해석이 수십 년간 지배적인 모델이 되었습니다.</p>
<h3 id="_1">구조<a class="header-link" href="#_1" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>     요구사항
          │
          ▼
        설계
          │
          ▼
        구현
          │
          ▼
       테스트
          │
          ▼
        배포
          │
          ▼
      유지보수
</code></pre></div>

<p>각 단계는 <strong>완전히 완료</strong>되고 공식적으로 승인된 후에야 다음 단계가 시작됩니다. 이전 단계로 돌아가는 것은 가능하지만 예외적인 경우로 취급됩니다.</p>
<h3 id="_2">단계 게이트 기준<a class="header-link" href="#_2" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>단계 게이트</th>
<th>진입 기준</th>
<th>완료 기준</th>
</tr>
</thead>
<tbody>
<tr>
<td>요구사항 → 설계</td>
<td>프로젝트 승인, 팀 구성</td>
<td>서명된 SRS 문서</td>
</tr>
<tr>
<td>설계 → 구현</td>
<td>승인된 SRS</td>
<td>서명된 설계 문서</td>
</tr>
<tr>
<td>구현 → 테스트</td>
<td>승인된 설계</td>
<td>코드 완성, 단위 테스트 통과</td>
</tr>
<tr>
<td>테스트 → 배포</td>
<td>코드 완성</td>
<td>모든 심각한 결함 해결, UAT 통과</td>
</tr>
<tr>
<td>배포 → 유지보수</td>
<td>UAT 서명</td>
<td>프로덕션 배포 완료</td>
</tr>
</tbody>
</table>
<h3 id="_3">강점<a class="header-link" href="#_3" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>명확성</strong>: 프로세스가 이해하고 관리하기 쉬움</li>
<li><strong>문서화</strong>: 각 단계에서 포괄적인 문서 생성</li>
<li><strong>단계 제어</strong>: 명확한 마일스톤으로 진행 상황 측정 가능</li>
<li><strong>안정적인 요구사항에 적합</strong>: 구축할 것이 잘 이해되고 변경 가능성이 낮은 경우, 순차적 개발이 효율적</li>
<li><strong>공급업체 계약</strong>: 외부 공급업체와의 고정 범위 계약은 폭포수 방식으로 관리하기 쉬움</li>
</ul>
<h3 id="_4">약점<a class="header-link" href="#_4" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>결함의 늦은 발견</strong>: 테스트가 늦게 수행되어 테스트 단계에서 발견된 결함을 수정하는 비용이 높음</li>
<li><strong>늦게까지 작동하는 소프트웨어 없음</strong>: 이해관계자는 테스트나 배포까지 아무것도 볼 수 없음</li>
<li><strong>변화하는 요구사항에 부적합</strong>: 프로세스 후반부의 변경은 이전 단계의 비용이 많이 드는 재작업이 필요</li>
<li><strong>완벽한 요구사항 가정</strong>: 실제로는 시작 시점에 요구사항이 완전히 알려지는 경우는 거의 없음</li>
<li><strong>통합 문제의 늦은 발견</strong>: 컴포넌트가 서로 맞지 않으면 통합 테스트 중에 발견됨</li>
</ul>
<h3 id="_5">폭포수 모델 사용 시기<a class="header-link" href="#_5" title="Permanent link">&para;</a></h3>
<ul>
<li>요구사항이 잘 정의되어 있고 안정적이며 변경 가능성이 낮은 경우</li>
<li>기술이 잘 이해되어 있는 경우 (주요 R&amp;D 없음)</li>
<li>개발 중 변경 가능성이 낮을 만큼 프로젝트가 충분히 짧은 경우</li>
<li>규제 또는 계약 요구사항으로 포괄적인 문서화가 의무화된 경우</li>
<li>고정 범위 납품물로 외부 계약업체와 협력하는 경우</li>
</ul>
<p><strong>실제 사례</strong>: 정부 기관이 법적으로 규정된 계산 규칙이 있는 급여 시스템을 구축하기 위해 공급업체와 계약을 체결합니다. 요구사항은 법령으로 정의되어 있으며 18개월 프로젝트 기간 동안 변경 가능성이 낮습니다. 폭포수 모델이 적절합니다.</p>
<hr />
<h2 id="3-v-v-model">3. V-모델(V-Model, 검증 및 확인 모델)<a class="header-link" href="#3-v-v-model" title="Permanent link">&para;</a></h2>
<p>V-모델은 각 개발 단계를 대응하는 테스트 단계에 명시적으로 매핑하여 폭포수 모델을 확장합니다. V의 왼쪽은 분해(요구사항 분해)를 나타내고, 오른쪽은 검증(Verification)과 확인(Validation)을 나타냅니다.</p>
<h3 id="_6">구조<a class="header-link" href="#_6" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>요구사항 ──────────────────────────── 인수 테스트
    │                                      │
    ▼                                      │
시스템 설계 ──────────────────── 시스템 테스트 │
    │                                │         │
    ▼                                │         │
아키텍처 설계 ──── 통합 테스트     │
    │                          │              │
    ▼                          │              │
모듈 설계 ── 단위 테스트      │              │
    │              │           │              │
    └── 코딩 ──────┘           │              │
                               │              │
        ◄── 검증(Verification) ┘──── 확인(Validation) ──►
</code></pre></div>

<h3 id="verification">왼쪽 (검증(Verification) — "제품을 올바르게 만들기")<a class="header-link" href="#verification" title="Permanent link">&para;</a></h3>
<p>각 단계는 테스트를 이끌기 위해 사용될 명세를 생성합니다:
- <strong>요구사항</strong> → 인수 테스트 기준 정의
- <strong>시스템 설계</strong> → 시스템 테스트 기준 정의
- <strong>아키텍처 설계</strong> → 통합 테스트 기준 정의
- <strong>모듈 설계</strong> → 단위 테스트 기준 정의</p>
<h3 id="validation">오른쪽 (확인(Validation) — "올바른 제품 만들기")<a class="header-link" href="#validation" title="Permanent link">&para;</a></h3>
<p>테스트는 나중에 실행되더라도 대응하는 왼쪽 단계와 <em>병렬로</em> 설계됩니다:
- <strong>단위 테스트</strong>: 모듈 설계에 대해 개별 모듈을 검증
- <strong>통합 테스트</strong>: 아키텍처 설계에 대해 모듈 상호작용을 검증
- <strong>시스템 테스트</strong>: 시스템 설계에 대해 전체 시스템을 검증
- <strong>인수 테스트</strong>: 사용자 요구사항에 대해 시스템을 확인</p>
<h3 id="_7">폭포수 모델 대비 강점<a class="header-link" href="#_7" title="Permanent link">&para;</a></h3>
<ul>
<li>테스트가 처음부터 계획되어 일급 시민으로 취급됨</li>
<li>결함을 더 낮은 수준에서 발견 가능 (시스템 테스트 전에 단위 테스트)</li>
<li>요구사항에서 테스트까지의 명확한 추적성</li>
<li>안전 필수 시스템(항공우주, 의료, 국방)에 적합</li>
</ul>
<h3 id="_8">약점<a class="header-link" href="#_8" title="Permanent link">&para;</a></h3>
<ul>
<li>여전히 대체로 순차적; 변화하는 요구사항에 대한 수용도가 제한적</li>
<li>높은 문서화 부담</li>
<li>탐색적이거나 혁신적인 프로젝트에 부적합</li>
</ul>
<p><strong>실제 사례</strong>: 의료용 주입 펌프의 임베디드 소프트웨어를 개발하려면 FDA 규정에 의해 모든 요구사항에서 특정 테스트까지의 추적성이 필요합니다. V-모델의 명시적인 검증/확인 매핑이 규제 요구사항을 충족합니다.</p>
<hr />
<h2 id="4-incremental-model">4. 점진적 모델(Incremental Model)<a class="header-link" href="#4-incremental-model" title="Permanent link">&para;</a></h2>
<p>점진적 모델은 이전 빌드에 기능을 추가하는 일련의 빌드(증분)로 시스템을 제공합니다. 요구사항은 일반적으로 사전에 정의되지만, 구현은 단계적으로 진행됩니다.</p>
<h3 id="_9">구조<a class="header-link" href="#_9" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>요구사항 ──► 사전에 모두 계획 (또는 부분적으로)
    │
    ├──► 증분 1: 핵심 기능
    │         설계 ► 코딩 ► 테스트 ► 배포
    │                                  │
    ├──► 증분 2: 추가 기능
    │         설계 ► 코딩 ► 테스트 ► 배포
    │                                  │
    ├──► 증분 3: 확장 기능
    │         설계 ► 코딩 ► 테스트 ► 배포
    │                                  │
    └──► 증분 N: 최종 기능
              설계 ► 코딩 ► 테스트 ► 배포
</code></pre></div>

<h3 id="_10">강점<a class="header-link" href="#_10" title="Permanent link">&para;</a></h3>
<ul>
<li>폭포수보다 일찍 작동하는 소프트웨어 제공</li>
<li>높은 우선순위의 기능을 더 빨리 사용 가능</li>
<li>사용자가 초기 증분에 대한 피드백 제공 가능</li>
<li>리스크 감소: 초기에 발견된 문제를 수정 가능</li>
</ul>
<h3 id="_11">약점<a class="header-link" href="#_11" title="Permanent link">&para;</a></h3>
<ul>
<li>초기에 좋은 아키텍처 구상 필요 (각 증분이 전체 설계에 맞아야 함)</li>
<li>주의하지 않으면 "패치된" 아키텍처로 이어질 수 있음</li>
<li>이후 증분의 요구사항이 잘 정의되지 않을 수 있음</li>
</ul>
<hr />
<h2 id="5-spiral-model">5. 나선형 모델(Spiral Model)<a class="header-link" href="#5-spiral-model" title="Permanent link">&para;</a></h2>
<p>Barry Boehm은 1988년 논문 "소프트웨어 개발 및 개선의 나선형 모델(A Spiral Model of Software Development and Enhancement)"에서 나선형 모델을 소개했습니다. 나선형 모델은 <strong>리스크 중심적</strong>입니다: 나선의 각 주기는 진행하기 전에 가장 중요한 리스크를 식별하고 완화하는 데 중점을 둡니다.</p>
<h3 id="_12">구조<a class="header-link" href="#_12" title="Permanent link">&para;</a></h3>
<p>나선형은 각 주기에서 반복되는 네 개의 사분면으로 구성됩니다:</p>
<div class="highlight"><pre><span></span><code>            목표, 대안, 제약 사항 결정
                    │
                    ▼
    ┌───────────────────────────────┐
    │    사분면 1: 계획             │
    │  ┌──────────────────────────┐ │
    │  │       사분면 4:          │ │
    │  │    다음 반복 계획        │◄├─── 누적 리스크 ──►
    │  │                          │ │                   │
    │  └──────────────────────────┘ │    사분면 2:      │
    └───────────────────────────────┘   리스크 분석     │
                    │                        │          │
                    ▼                        ▼          │
            대안 평가,               리스크 식별,       │
            리스크 식별 및 해결       분석, 해결        │
                                           │          │
                    ┌──────────────────────┘          │
                    ▼                                  │
            사분면 3: 개발 및 테스트                   │
            (현재 증분 설계, 코딩, 테스트)              │
                    │                                  │
                    └───────────────────────────────────┘
</code></pre></div>

<p>더 정확하게, 각 나선형 주기는 다음을 포함합니다:</p>
<ol>
<li><strong>목표 결정</strong>: 이 주기에서 무엇을 달성해야 하는가? 제약 사항은 무엇인가?</li>
<li><strong>리스크 식별 및 해결</strong>: 무엇이 잘못될 수 있는가? 불확실한 영역을 테스트하기 위한 프로토타입 구축.</li>
<li><strong>개발 및 검증</strong>: 이 주기를 위한 제품 개발 및 테스트.</li>
<li><strong>다음 주기 계획</strong>: 이해관계자와 검토하고 진행 여부 결정.</li>
</ol>
<h3 id="_13">리스크 중심 특성<a class="header-link" href="#_13" title="Permanent link">&para;</a></h3>
<p>나선형 모델은 각 반복의 중심에 리스크 분석을 두는 점에서 독특합니다. 리스크를 합리적인 비용으로 해결할 수 없다면 프로젝트가 조기에 종료될 수 있습니다 — 이것은 결함이 아니라 특징으로, 실패가 예정된 프로젝트에 추가 투자를 방지합니다.</p>
<p>초기 나선형에서 다루는 리스크 예시:
- "사용자가 이 인터페이스를 채택할지 확신할 수 없다" → 프로토타입을 구축하고 사용자와 테스트
- "이 알고리즘이 충분히 빠를지 알 수 없다" → 성능 스파이크 구축
- "공급업체의 API가 우리 요구사항을 지원하지 않을 수 있다" → 통합 개념 증명 작성</p>
<h3 id="_14">강점<a class="header-link" href="#_14" title="Permanent link">&para;</a></h3>
<ul>
<li>탁월한 리스크 관리</li>
<li>유연성: 나선형 사이에서 변화하는 요구사항 수용 가능</li>
<li>초기 프로토타이핑으로 잘못된 제품을 구축할 가능성 감소</li>
<li>크고 복잡하며 고위험 프로젝트에 적합</li>
</ul>
<h3 id="_15">약점<a class="header-link" href="#_15" title="Permanent link">&para;</a></h3>
<ul>
<li>상당한 리스크 관리 전문 지식 필요</li>
<li>비용이 높을 수 있음 (각 나선형 주기에 오버헤드 발생)</li>
<li>작고 저위험 프로젝트에 부적합</li>
<li>종료 날짜 예측 불가능</li>
</ul>
<p><strong>실제 사례</strong>: 새로운 지휘통제 시스템을 개발하는 방위 계약업체는 상당한 기술적 리스크(새로운 통신 프로토콜), 조직적 리스크(변화하는 요구사항), 일정 리스크에 직면합니다. 나선형 모델은 전체 개발에 착수하기 전에 각 리스크를 체계적으로 해결할 수 있게 합니다.</p>
<hr />
<h2 id="6-radrapid-application-development">6. RAD(Rapid Application Development, 신속 응용 프로그램 개발)<a class="header-link" href="#6-radrapid-application-development" title="Permanent link">&para;</a></h2>
<p>James Martin이 1990년대 초에 개발한 RAD는 타임박싱, 재사용, 높은 사용자 참여를 통한 매우 빠른 개발을 강조합니다. RAD는 일반적으로 60–90일 납품 주기를 목표로 합니다.</p>
<h3 id="_16">핵심 원칙<a class="header-link" href="#_16" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>타임박싱(Timeboxing)</strong>: 남은 작업량에 관계없이 고정된 기간 (일반적으로 60–90일)</li>
<li><strong>프로토타이핑</strong>: 높은 사용자 피드백을 통한 지속적인 프로토타입 개선</li>
<li><strong>SWAT 팀</strong>: 소규모의 고도로 숙련된 팀 (Skilled With Advanced Tools)</li>
<li><strong>재사용</strong>: 기존 컴포넌트, 프레임워크, 도구의 최대 활용</li>
<li><strong>지속적인 사용자 참여</strong>: 사용자가 요구사항과 UAT뿐만 아니라 개발 전반에 걸쳐 참여</li>
</ul>
<h3 id="rad">RAD 단계<a class="header-link" href="#rad" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">요구사항</span><span class="w"> </span><span class="n">계획</span><span class="w"> </span><span class="err">──►</span><span class="w"> </span><span class="n">비즈니스</span><span class="w"> </span><span class="n">목표와</span><span class="w"> </span><span class="n">제약</span><span class="w"> </span><span class="n">사항</span><span class="w"> </span><span class="n">식별</span>
<span class="mf">2.</span><span class="w"> </span><span class="n">사용자</span><span class="w"> </span><span class="n">설계</span><span class="w">   </span><span class="err">──►</span><span class="w"> </span><span class="n">사용자와의</span><span class="w"> </span><span class="n">인터랙티브</span><span class="w"> </span><span class="n">프로토타이핑</span><span class="w"> </span><span class="p">(</span><span class="n">반복적</span><span class="p">)</span>
<span class="mf">3.</span><span class="w"> </span><span class="n">구축</span><span class="w">          </span><span class="err">──►</span><span class="w"> </span><span class="n">승인된</span><span class="w"> </span><span class="n">프로토타입</span><span class="w"> </span><span class="n">기반의</span><span class="w"> </span><span class="n">신속한</span><span class="w"> </span><span class="n">코딩</span>
<span class="mf">4.</span><span class="w"> </span><span class="n">전환</span><span class="w">          </span><span class="err">──►</span><span class="w"> </span><span class="n">테스트</span><span class="p">,</span><span class="w"> </span><span class="n">배포</span><span class="p">,</span><span class="w"> </span><span class="n">사용자</span><span class="w"> </span><span class="n">교육</span>
</code></pre></div>

<h3 id="_17">강점<a class="header-link" href="#_17" title="Permanent link">&para;</a></h3>
<ul>
<li>작동하는 소프트웨어의 빠른 납품</li>
<li>높은 사용자 만족도 (높은 참여)</li>
<li>잘못된 제품을 구축할 가능성 감소</li>
</ul>
<h3 id="_18">약점<a class="header-link" href="#_18" title="Permanent link">&para;</a></h3>
<ul>
<li>고도로 숙련되고 가용한 사용자 필요 (이해관계자 시간이 주요 제약)</li>
<li>새로운 기술이나 복잡한 알고리즘이 필요한 프로젝트에 부적합</li>
<li>대규모 시스템의 확장성 문제</li>
<li>품질보다 속도를 우선시하면 성능이나 아키텍처가 낮은 시스템 생성 가능</li>
</ul>
<hr />
<h2 id="7-prototyping-model">7. 프로토타이핑 모델(Prototyping Model)<a class="header-link" href="#7-prototyping-model" title="Permanent link">&para;</a></h2>
<p>프로토타이핑 모델은 전체 개발에 착수하기 전에 요구사항을 명확히 하고 아이디어를 테스트하기 위해 작동하지만 불완전한 버전의 시스템을 구축합니다.</p>
<h3 id="_19">프로토타입 유형<a class="header-link" href="#_19" title="Permanent link">&para;</a></h3>
<p><strong>폐기형(탐색적) 프로토타이핑</strong>: 특정 질문에 답하기 위한 빠른 프로토타입을 구축한 후 폐기합니다. 프로토타입은 프로덕션 코드가 아니라 학습을 위한 도구입니다.</p>
<p><strong>진화형 프로토타이핑</strong>: 프로토타입을 최종 제품으로 점진적으로 구축합니다. 프로토타입 코드가 품질 문제를 프로덕션으로 가져올 수 있어 더 위험합니다.</p>
<h3 id="_20">프로세스<a class="header-link" href="#_20" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>┌─────────────────────────────────┐
│  1. 기본 요구사항 식별           │
└────────────┬────────────────────┘
             │
             ▼
┌─────────────────────────────────┐
│  2. 프로토타입 구축             │◄─────────────┐
└────────────┬────────────────────┘             │
             │                                  │
             ▼                                  │
┌─────────────────────────────────┐             │
│  3. 사용자 프로토타입 평가      │             │
└────────────┬────────────────────┘             │
             │                                  │
             ▼                                  │
       수용 가능? ──── 아니오 ──────────────────┘
             │
            예
             │
             ▼
┌─────────────────────────────────┐
│  4. 최종 시스템 구축            │
└─────────────────────────────────┘
</code></pre></div>

<h3 id="_21">프로토타이핑 사용 시기<a class="header-link" href="#_21" title="Permanent link">&para;</a></h3>
<ul>
<li>요구사항이 불명확하거나 진화하는 경우</li>
<li>사용자 인터페이스 설계가 주요 관심사인 경우</li>
<li>새로운 기술의 타당성 탐색</li>
<li>더 큰 프로세스 모델의 일부로 (예: 나선형의 리스크 해결 단계에서 프로토타이핑)</li>
</ul>
<hr />
<h2 id="8-sdlc">8. SDLC 모델 비교<a class="header-link" href="#8-sdlc" title="Permanent link">&para;</a></h2>
<table>
<thead>
<tr>
<th>모델</th>
<th>요구사항</th>
<th>납품</th>
<th>리스크</th>
<th>문서화</th>
<th>최적 사용 대상</th>
</tr>
</thead>
<tbody>
<tr>
<td>폭포수</td>
<td>사전에 안정적이어야 함</td>
<td>늦음 (단일 릴리스)</td>
<td>요구사항 오류 시 높음</td>
<td>포괄적</td>
<td>안정적이고 잘 이해된 프로젝트</td>
</tr>
<tr>
<td>V-모델</td>
<td>사전에 안정적이어야 함</td>
<td>늦음 (단일 릴리스)</td>
<td>중간 (더 나은 테스트)</td>
<td>매우 포괄적</td>
<td>안전 필수 시스템</td>
</tr>
<tr>
<td>점진적</td>
<td>대부분 사전에</td>
<td>단계적 릴리스</td>
<td>중간</td>
<td>보통</td>
<td>우선순위 기반 납품</td>
</tr>
<tr>
<td>나선형</td>
<td>진화적</td>
<td>나선형별 릴리스</td>
<td>낮음 (리스크 중심)</td>
<td>보통 ~ 높음</td>
<td>크고 고위험 프로젝트</td>
</tr>
<tr>
<td>RAD</td>
<td>빠르게 협상</td>
<td>매우 빠름</td>
<td>단순 프로젝트에서 낮음</td>
<td>가벼움</td>
<td>잘 이해된 비즈니스 도메인</td>
</tr>
<tr>
<td>프로토타이핑</td>
<td>초기에 불명확</td>
<td>프로토타입 승인 후</td>
<td>요구사항에서 낮음</td>
<td>가벼움</td>
<td>불명확한 요구사항, UI 중심</td>
</tr>
<tr>
<td>애자일*</td>
<td>스프린트마다 진화</td>
<td>지속적</td>
<td>낮음</td>
<td>경량</td>
<td>동적 요구사항, 집중 팀</td>
</tr>
</tbody>
</table>
<p>*애자일은 레슨 3에서 다룹니다.</p>
<hr />
<h2 id="9">9. 올바른 모델 선택<a class="header-link" href="#9" title="Permanent link">&para;</a></h2>
<p>어떤 모델도 보편적으로 최선은 아닙니다. 선택은 여러 프로젝트 요소에 따라 달라집니다:</p>
<h3 id="_22">의사결정 프레임워크<a class="header-link" href="#_22" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>프로젝트가 안전 필수적이거나 고도로 규제받는가?
    └─ 예 → 엄격한 문서화를 갖춘 V-모델 또는 폭포수
    └─ 아니오 ↓

요구사항이 잘 이해되고 안정적인가?
    └─ 예 → 폭포수 또는 점진적
    └─ 아니오 ↓

상당한 기술적 또는 비즈니스 리스크가 있는가?
    └─ 예 → 나선형
    └─ 아니오 ↓

납품 속도가 주요 관심사인가?
    └─ 예 → RAD (소규모 팀, 비즈니스 도메인)
    └─ 아니오 ↓

요구사항이 자주 변경될 것으로 예상되는가?
    └─ 예 → 애자일 (스크럼, 칸반 — 레슨 3 참조)
    └─ 아니오 → 점진적
</code></pre></div>

<h3 id="_23">주요 의사결정 기준<a class="header-link" href="#_23" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>요소</th>
<th>순차적 방식 선호 (폭포수/V)</th>
<th>반복적/애자일 방식 선호</th>
</tr>
</thead>
<tbody>
<tr>
<td>요구사항 안정성</td>
<td>안정적, 잘 정의됨</td>
<td>가변적, 불명확</td>
</tr>
<tr>
<td>팀 규모</td>
<td>크고 분산됨</td>
<td>소~중, 집중</td>
</tr>
<tr>
<td>고객 가용성</td>
<td>제한적</td>
<td>높음 (빈번한 피드백)</td>
</tr>
<tr>
<td>프로젝트 기간</td>
<td>단~중기</td>
<td>중~장기</td>
</tr>
<tr>
<td>기술 참신성</td>
<td>알려진 기술</td>
<td>최첨단 또는 불확실</td>
</tr>
<tr>
<td>규제 환경</td>
<td>높은 규제</td>
<td>낮은 규제</td>
</tr>
<tr>
<td>계약 유형</td>
<td>고정 가격, 고정 범위</td>
<td>시간 및 재료 기준</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="10">10. 실제 사례<a class="header-link" href="#10" title="Permanent link">&para;</a></h2>
<h3 id="1-nasa-v-">사례 1: NASA 미션 소프트웨어 (V-모델)<a class="header-link" href="#1-nasa-v-" title="Permanent link">&para;</a></h3>
<p>유인 미션을 위한 NASA의 비행 소프트웨어는 각 단계에서 공식 검증을 수행하는 엄격한 V-모델 프로세스를 사용합니다. 요구사항은 테스트까지 추적 가능하며, 모든 테스트는 독립적인 팀이 검토합니다. 우주에서의 결함 비용은 잠재적으로 치명적이므로 무거운 프로세스 오버헤드를 정당화합니다.</p>
<h3 id="2_1">사례 2: 전자상거래 스타트업 (애자일/점진적)<a class="header-link" href="#2_1" title="Permanent link">&para;</a></h3>
<p>온라인 마켓플레이스를 출시하는 스타트업은 시장에 빠르게 진출하고 사용자 피드백을 수집하며 효과적인 것을 기반으로 방향을 전환해야 합니다. 폭포수는 치명적일 것입니다 — 18개월 후 전체 시스템이 납품될 즈음에는 시장이 변해 있을 수 있습니다. 격주 릴리스를 통한 애자일 방식은 팀이 지속적으로 학습하고 적응할 수 있게 합니다.</p>
<h3 id="3">사례 3: 은행 핵심 시스템 교체 (나선형)<a class="header-link" href="#3" title="Permanent link">&para;</a></h3>
<p>30년 된 핵심 뱅킹 시스템을 교체하는 대형 은행은 엄청난 기술적 리스크(메인프레임 마이그레이션), 비즈니스 리스크(규제 준수), 조직적 리스크(수천 명의 직원 교육)에 직면합니다. 나선형 모델은 은행이 가장 위험한 통합을 초기에 프로토타이핑하고 규제 기관과 검증한 후, 중요한 리스크가 해결된 후에만 전체 개발로 진행할 수 있게 합니다.</p>
<h3 id="4-hr-rad">사례 4: 내부 HR 도구 (RAD)<a class="header-link" href="#4-hr-rad" title="Permanent link">&para;</a></h3>
<p>회사의 HR 부서는 직원 자격증 추적을 위한 새 도구가 필요합니다. 요구사항이 간단하고, 도메인이 잘 이해되어 있으며, 두 명의 개발자로 구성된 소규모 팀이 HR 관리자의 높은 참여로 6주 안에 납품할 수 있습니다. RAD (또는 간단한 반복적 방식)가 적절합니다.</p>
<hr />
<h2 id="_24">요약<a class="header-link" href="#_24" title="Permanent link">&para;</a></h2>
<p>소프트웨어 개발 생명주기는 소프트웨어가 구축되는 구조적 프레임워크를 제공합니다. SDLC 모델의 선택은 팀이 어떻게 구성되는지, 납품물이 언제 생성되는지, 리스크가 어떻게 관리되는지, 변경이 어떻게 처리되는지 등 프로젝트의 모든 측면을 형성합니다.</p>
<p>주요 시사점:
- <strong>폭포수</strong>는 순차적이고 문서화가 많으며, 안정적이고 잘 이해된 요구사항에 적합
- <strong>V-모델</strong>은 각 단계에서 명시적인 테스트 계획으로 폭포수를 확장; 안전 필수 시스템에 선호
- <strong>점진적</strong>은 단계적으로 소프트웨어를 납품; 구조와 더 이른 납품 간의 균형
- <strong>나선형</strong>은 리스크 중심; 각 반복은 가장 중요한 리스크를 먼저 해결
- <strong>RAD</strong>는 타임박싱과 사용자 참여를 통해 극도의 속도를 강조
- <strong>프로토타이핑</strong>은 전체 개발 전에 요구사항을 명확히 하기 위한 불완전한 시스템을 구축
- 어떤 단일 모델도 보편적으로 최선은 아니며, 선택은 요구사항 안정성, 리스크, 팀 규모, 규제 맥락에 따라 달라짐</p>
<hr />
<h2 id="_25">연습 문제<a class="header-link" href="#_25" title="Permanent link">&para;</a></h2>
<p><strong>연습 1</strong>: 시 정부가 전시 800개 교차로를 제어하는 새 교통 관리 시스템을 구축하고 있습니다. 프로젝트는 고정 예산, 안전 인증을 위한 규제 요구사항이 있으며 완성까지 3년이 주어집니다. 어떤 SDLC 모델을 추천하시겠습니까? 9절의 의사결정 기준 중 최소 세 가지를 다루어 선택을 정당화하세요.</p>
<p><strong>연습 2</strong>: 다음 프로젝트의 폭포수 타임라인을 그리세요: 회사는 직원들이 경비 보고서를 제출할 수 있는 모바일 앱이 필요합니다. 앱은 회사의 기존 SAP ERP 시스템과 통합되어야 합니다. 각 단계의 기간을 (전체 프로젝트 시간의 백분율로) 추정하고 각 단계에서 생성되는 두 가지 주요 산출물을 나열하세요.</p>
<p><strong>연습 3</strong>: 새로운 소셜 네트워킹 스타트업이 플랫폼을 구축하고 싶지만 사용자가 원하는 기능에 대한 대략적인 아이디어만 있습니다. 폭포수가 왜 좋지 않은 선택인지 설명하세요. 첫 6주 동안의 3-스프린트 점진적 계획을 설계하고, 각 증분에 포함될 기능을 명시하세요.</p>
<p><strong>연습 4</strong>: V-모델과 폭포수 모델을 비교하세요. 다섯 가지 구체적인 차이점을 나열한 표를 만드세요. 더 높은 문서화 부담에도 불구하고 V-모델을 폭포수보다 선택하는 상황은 언제인가요?</p>
<p><strong>연습 5</strong>: 나선형 모델은 리스크를 해결하기 위해 프로토타입을 사용합니다. 은행을 위한 실시간 사기 감지 시스템을 구축하는 프로젝트에서 세 가지 중요한 리스크를 식별하고, 각 리스크를 해결하기 위한 초기 나선형에서 구축할 프로토타입이나 스파이크를 설명하세요.</p>
<hr />
<h2 id="_26">더 읽을거리<a class="header-link" href="#_26" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>Winston W. Royce</strong>, "Managing the Development of Large Software Systems" (1970) — 폭포수로 알려지게 된 것을 소개한 논문</li>
<li><strong>Barry W. Boehm</strong>, "A Spiral Model of Software Development and Enhancement" (1988) — IEEE Computer, Vol. 21, No. 5</li>
<li><strong>James Martin</strong>, <em>Rapid Application Development</em> (1991) — Macmillan</li>
<li><strong>Ian Sommerville</strong>, <em>Software Engineering</em> (10th ed.) — 2장과 3장에서 프로세스 모델을 심도 있게 다룸</li>
<li><strong>Roger Pressman</strong>, <em>Software Engineering: A Practitioner's Approach</em> — 2장: 프로세스 모델</li>
<li><strong>SEI CMMI</strong>: https://cmmiinstitute.com — 모든 프로세스 모델에 걸쳐 있는 능력 성숙도 모델 통합</li>
</ul>
<hr />
<p><strong>이전</strong>: <a href="./01_What_Is_Software_Engineering.md">소프트웨어 공학이란 무엇인가</a> | <strong>다음</strong>: <a href="./03_Agile_and_Iterative_Development.md">애자일과 반복적 개발</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Software_Engineering/01_What_Is_Software_Engineering.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">레슨 1: 소프트웨어 공학이란 무엇인가</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Software_Engineering/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Software_Engineering/03_Agile_and_Iterative_Development.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">레슨 3: 애자일과 반복적 개발</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}