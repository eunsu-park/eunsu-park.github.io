{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>레슨 06: 추정과 계획 (Estimation and Planning) - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Software_Engineering/">Software Engineering</a>
    <span class="separator">/</span>
    <span class="current">레슨 06: 추정과 계획 (Estimation and Planning)</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>레슨 06: 추정과 계획 (Estimation and Planning)</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Software_Engineering/05_Software_Modeling_and_UML.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">레슨 05: 소프트웨어 모델링과 UML</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Software_Engineering/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Software_Engineering/07_Software_Quality_Assurance.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">레슨 07: 소프트웨어 품질 보증(Software Quality Assurance)</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#_1">목차</a></li>
<li><a href="#1">1. 추정이 어려운 이유</a><ul>
<li><a href="#11-cone-of-uncertainty">1.1 불확실성의 원뿔 (Cone of Uncertainty)</a></li>
<li><a href="#12">1.2 불확실성의 근본 원인</a></li>
<li><a href="#13-estimation-vs-planning">1.3 추정(Estimation) vs. 계획(Planning)</a></li>
</ul>
</li>
<li><a href="#2">2. 코드 라인 수와 그 한계</a><ul>
<li><a href="#21-loc">2.1 LOC의 활용 방식</a></li>
<li><a href="#22-loc">2.2 LOC의 한계</a></li>
</ul>
</li>
<li><a href="#3">3. 기능 점수 분석</a><ul>
<li><a href="#31">3.1 다섯 가지 기능 유형</a></li>
<li><a href="#32">3.2 복잡도 분류</a></li>
<li><a href="#33-ufp">3.3 미조정 기능 점수(UFP) 계산</a></li>
<li><a href="#34-value-adjustment-factor">3.4 가치 조정 계수 (Value Adjustment Factor)</a></li>
<li><a href="#35">3.5 기능 점수를 공수로 변환</a></li>
</ul>
</li>
<li><a href="#4-cocomo-cocomo-ii">4. COCOMO와 COCOMO II</a><ul>
<li><a href="#41-cocomo">4.1 COCOMO 기본 모델</a></li>
<li><a href="#42-cocomo-cocomo-intermediate">4.2 COCOMO 중간 모델 (COCOMO Intermediate)</a></li>
<li><a href="#43-cocomo-ii">4.3 COCOMO II</a></li>
<li><a href="#44">4.4 알고리즘 모델의 활용 시점</a></li>
</ul>
</li>
<li><a href="#5">5. 스토리 포인트와 상대적 추정</a><ul>
<li><a href="#51">5.1 상대적 추정이 효과적인 이유</a></li>
<li><a href="#52">5.2 스토리 포인트에 피보나치 수열 사용</a></li>
<li><a href="#53-velocity">5.3 속도 (Velocity)</a></li>
<li><a href="#54">5.4 스토리 포인트의 한계</a></li>
</ul>
</li>
<li><a href="#6">6. 플래닝 포커</a><ul>
<li><a href="#61">6.1 진행 방식</a></li>
<li><a href="#62">6.2 특수 카드</a></li>
<li><a href="#63">6.3 플래닝 포커가 효과적인 이유</a></li>
<li><a href="#64">6.4 원격 플래닝 포커</a></li>
</ul>
</li>
<li><a href="#7">7. 티셔츠 사이즈 추정</a></li>
<li><a href="#8-pert">8. 삼점 추정과 PERT</a><ul>
<li><a href="#81-pert">8.1 PERT 공식</a></li>
<li><a href="#82">8.2 삼점 추정 활용 시점</a></li>
</ul>
</li>
<li><a href="#9">9. 작업 분류 체계</a><ul>
<li><a href="#91-wbs">9.1 WBS 원칙</a></li>
<li><a href="#92-wbs">9.2 WBS 예시: 모바일 뱅킹 앱</a></li>
<li><a href="#93-wbs-wbs-dictionary">9.3 WBS 사전 (WBS Dictionary)</a></li>
</ul>
</li>
<li><a href="#10">10. 간트 차트와 주경로</a><ul>
<li><a href="#101-gantt-charts">10.1 간트 차트 (Gantt Charts)</a></li>
<li><a href="#102-critical-path-method-cpm">10.2 주경로 분석법 (Critical Path Method, CPM)</a></li>
<li><a href="#103">10.3 일정 단축: 충돌과 병렬 진행</a></li>
</ul>
</li>
<li><a href="#11-vs">11. 릴리스 계획 vs. 스프린트 계획</a><ul>
<li><a href="#111-release-planning">11.1 릴리스 계획 (Release Planning)</a></li>
<li><a href="#112-sprint-planning">11.2 스프린트 계획 (Sprint Planning)</a></li>
<li><a href="#113-iteration-zero-sprint-0">11.3 이터레이션 제로 (Iteration Zero, Sprint 0)</a></li>
</ul>
</li>
<li><a href="#12_1">12. 추정 정확도: 추적과 개선</a><ul>
<li><a href="#121-vs">12.1 실제 vs. 추정 추적</a></li>
<li><a href="#122">12.2 교정 기법</a></li>
<li><a href="#123">12.3 시간에 따른 추정 개선</a></li>
</ul>
</li>
<li><a href="#13">13. 일반적인 추정 함정</a><ul>
<li><a href="#131-planning-fallacy">13.1 낙관주의 편향 (계획 오류, Planning Fallacy)</a></li>
<li><a href="#132-anchoring-bias">13.2 닻 내리기 편향 (Anchoring Bias)</a></li>
<li><a href="#133-parkinsons-law">13.3 파킨슨의 법칙 (Parkinson's Law)</a></li>
<li><a href="#134-brooks-brookss-law">13.4 Brooks의 법칙 (Brooks's Law)</a></li>
<li><a href="#135-student-syndrome">13.5 학생 증후군 (Student Syndrome)</a></li>
<li><a href="#136-90-ninety-percent-syndrome">13.6 90% 증후군 (Ninety-Percent Syndrome)</a></li>
<li><a href="#137-scope-creep">13.7 범위 팽창 (Scope Creep)</a></li>
</ul>
</li>
<li><a href="#14">14. 요약</a></li>
<li><a href="#15">15. 연습 문제</a></li>
<li><a href="#16">16. 더 읽을거리</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="06-estimation-and-planning">레슨 06: 추정과 계획 (Estimation and Planning)<a class="header-link" href="#06-estimation-and-planning" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./05_Software_Modeling_and_UML.md">05. 소프트웨어 모델링과 UML</a> | <strong>다음</strong>: <a href="./07_Software_Quality_Assurance.md">07. 소프트웨어 품질 보증</a></p>
<hr />
<p>소프트웨어 팀에게 다음 프로젝트가 얼마나 걸릴지 물어보면, 대부분 낙관적인 답변을 내놓고 결국 틀리게 된다. Standish Group의 CHAOS 보고서 연구 결과에 따르면, 대다수의 소프트웨어 프로젝트가 일정과 예산을 초과한다. 이는 단순한 무능함이 아니다 — 소프트웨어는 지적 산물이고, 팀마다 특성이 다르며, 요구사항은 변하기 때문에 추정 자체가 본질적으로 어렵다. 이 레슨에서는 더 나은 추정과 현실적인 계획을 만들어내는 기법, 모델, 사고 습관을 익힌다.</p>
<p><strong>난이도</strong>: ⭐⭐⭐</p>
<p><strong>선수 학습</strong>:
- 레슨 02 — 소프트웨어 개발 생명 주기
- 레슨 03 — 애자일과 반복적 개발
- 레슨 04 — 요구사항 공학</p>
<p><strong>학습 목표</strong>:
- 소프트웨어 추정이 본질적으로 불확실한 이유를 설명하고 불확실성의 원뿔(Cone of Uncertainty)을 기술할 수 있다
- 코드 라인 수(LOC) 추정을 적용하고 그 한계를 명확히 설명할 수 있다
- 기능 점수 분석(Function Point Analysis, FPA)을 기술하고 기본 미조정 기능 점수를 산정할 수 있다
- COCOMO와 COCOMO II를 설명하고 COCOMO 모델을 사용해 기본 공수 추정치를 계산할 수 있다
- 스토리 포인트와 상대적 추정을 애자일 스프린트 계획에 적용할 수 있다
- 플래닝 포커(Planning Poker) 세션을 진행할 수 있다
- PERT 공식을 사용한 삼점 추정(Three-Point Estimation)을 적용할 수 있다
- 작업 분류 체계(Work Breakdown Structure, WBS)를 구성할 수 있다
- 간트 차트를 작성하고 주경로 분석법(Critical Path Method, CPM)으로 주경로를 파악할 수 있다
- 릴리스 계획과 스프린트 계획을 구별할 수 있다
- 일반적인 추정 편향을 인식하고 이를 상쇄하는 기법을 적용할 수 있다</p>
<hr />
<h2 id="_1">목차<a class="header-link" href="#_1" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#1-추정이-어려운-이유">추정이 어려운 이유</a></li>
<li><a href="#2-코드-라인-수와-그-한계">코드 라인 수와 그 한계</a></li>
<li><a href="#3-기능-점수-분석">기능 점수 분석</a></li>
<li><a href="#4-cocomo와-cocomo-ii">COCOMO와 COCOMO II</a></li>
<li><a href="#5-스토리-포인트와-상대적-추정">스토리 포인트와 상대적 추정</a></li>
<li><a href="#6-플래닝-포커">플래닝 포커</a></li>
<li><a href="#7-티셔츠-사이즈-추정">티셔츠 사이즈 추정</a></li>
<li><a href="#8-삼점-추정과-pert">삼점 추정과 PERT</a></li>
<li><a href="#9-작업-분류-체계">작업 분류 체계</a></li>
<li><a href="#10-간트-차트와-주경로">간트 차트와 주경로</a></li>
<li><a href="#11-릴리스-계획-vs-스프린트-계획">릴리스 계획 vs. 스프린트 계획</a></li>
<li><a href="#12-추정-정확도-추적과-개선">추정 정확도: 추적과 개선</a></li>
<li><a href="#13-일반적인-추정-함정">일반적인 추정 함정</a></li>
<li><a href="#14-요약">요약</a></li>
<li><a href="#15-연습-문제">연습 문제</a></li>
<li><a href="#16-더-읽을거리">더 읽을거리</a></li>
</ol>
<hr />
<h2 id="1">1. 추정이 어려운 이유<a class="header-link" href="#1" title="Permanent link">&para;</a></h2>
<h3 id="11-cone-of-uncertainty">1.1 불확실성의 원뿔 (Cone of Uncertainty)<a class="header-link" href="#11-cone-of-uncertainty" title="Permanent link">&para;</a></h3>
<p><strong>불확실성의 원뿔(Cone of Uncertainty)</strong>은 Barry Boehm이 공식화하고 Steve McConnell이 대중화한 개념으로, 프로젝트가 진행될수록 추정 정확도가 어떻게 향상되는지를 설명한다.</p>
<div class="highlight"><pre><span></span><code>  추정    │
  기간    │  ╲                  4배 초과
  (실제  4│   ╲
   대비)  │    ╲
         3│     ╲
          │      ╲______________
         2│              ╲      ─ ─ ─ 2배 초과
          │               ╲
        1 │────────────────╲────────────── 실제
          │                 ╲
       0.5│                  ╲_____________ 0.5배 (빠른 완료)
          │
          └──────┬────────────┬────────────┬────────
            타당성     아키텍처      기능      완료
            검토       완료         완료
            (±4배)     (±2배)       (±1.25배)
</code></pre></div>

<p>프로젝트 초기에는 추정치가 실제와 <strong>4배</strong> 이내의 범위에서 벗어날 수 있다. 아키텍처가 완성될 즈음에는 불확실성이 ±2배로 좁혀진다. 기능 구현이 완료에 가까워져야 비로소 오차가 ±25%로 줄어든다.</p>
<p>시사점:
- 요구사항이 파악되기 전에 정확한 추정치를 요구하지 말 것 — 어차피 틀린다
- 원뿔이 충분히 좁아진 시점에 맞춰 추정치를 확정할 것
- 각 단계 게이트에서 새로운 정보를 바탕으로 재추정할 것</p>
<h3 id="12">1.2 불확실성의 근본 원인<a class="header-link" href="#12" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>원인</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>요구사항의 불완전성</strong></td>
<td>범위가 불명확하면 작업량도 알 수 없음</td>
</tr>
<tr>
<td><strong>기술의 새로움</strong></td>
<td>새로운 프레임워크, 플랫폼, 언어는 특성이 불분명함</td>
</tr>
<tr>
<td><strong>팀의 낮은 친숙도</strong></td>
<td>도메인이나 도구에 낯선 팀은 과거 데이터보다 느림</td>
</tr>
<tr>
<td><strong>통합 복잡도</strong></td>
<td>외부 시스템 인터페이스에는 숨은 작업이 존재함</td>
</tr>
<tr>
<td><strong>설계 결정의 창발성</strong></td>
<td>프로젝트 중간에 이루어진 아키텍처 선택이 범위를 바꿈</td>
</tr>
<tr>
<td><strong>인적 요소</strong></td>
<td>병가, 이직, 온보딩, 회의, 컨텍스트 전환 등</td>
</tr>
</tbody>
</table>
<h3 id="13-estimation-vs-planning">1.3 추정(Estimation) vs. 계획(Planning)<a class="header-link" href="#13-estimation-vs-planning" title="Permanent link">&para;</a></h3>
<p>중요한 구분:</p>
<ul>
<li><strong>추정(Estimation)</strong>은 현재 알고 있는 지식을 바탕으로 얼마나 걸릴지 예측하는 것</li>
<li><strong>계획(Planning)</strong>은 비즈니스 제약을 고려해 언제까지 무엇을 제공할지에 대한 약속</li>
</ul>
<p>추정은 계획의 토대가 되지만, 범위·자원·일정이 조정될 때 계획은 추정과 달라질 수 있다. 위험을 명시적으로 인정하지 않은 채 계획이 솔직한 추정을 덮어쓰도록 내버려 두어서는 안 된다.</p>
<hr />
<h2 id="2">2. 코드 라인 수와 그 한계<a class="header-link" href="#2" title="Permanent link">&para;</a></h2>
<p><strong>코드 라인 수(Lines of Code, LOC)</strong> — 또는 KLOC(수천 줄)와 MLOC(수백만 줄) — 는 소프트웨어의 규모를 측정하는 가장 초기의, 그리고 가장 직관적인 지표였다.</p>
<h3 id="21-loc">2.1 LOC의 활용 방식<a class="header-link" href="#21-loc" title="Permanent link">&para;</a></h3>
<p>역사적으로 조직들은 생산성을 LOC/인월(person-month)로, 결함 밀도를 결함/KLOC로 추적했다. 유사 코드베이스의 이력 데이터가 있다면, LOC를 기반으로 비용과 일정을 산출할 수 있다:</p>
<div class="highlight"><pre><span></span><code>Effort = (LOC / Productivity Rate) × adjustment factors
</code></pre></div>

<p>예시: 팀의 과거 생산성이 1,000 LOC/인월이고 예상 규모가 50,000 LOC라면:</p>
<div class="highlight"><pre><span></span><code>Effort = 50,000 / 1,000 = 50 person-months
</code></pre></div>

<h3 id="22-loc">2.2 LOC의 한계<a class="header-link" href="#22-loc" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>문제</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>언어 의존성</strong></td>
<td>Python 100줄이 Java 400줄과 동일한 기능을 할 수 있음; LOC는 코드 분량과 작업량을 혼동함</td>
</tr>
<tr>
<td><strong>음수 생산성</strong></td>
<td>200줄을 제거하는 리팩터링은 품질을 향상시키지만 "음수 생산성"으로 계산됨</td>
</tr>
<tr>
<td><strong>설계 선행 필요</strong></td>
<td>라인 수를 세려면 무엇을 만들지 알아야 함; 초기 추정에는 순환 논리</td>
</tr>
<tr>
<td><strong>코드 비대화 유인</strong></td>
<td>LOC를 보상 기준으로 삼으면 장황하고 유지보수하기 어려운 코드를 장려함</td>
</tr>
<tr>
<td><strong>현대 개발에 부적합</strong></td>
<td>설정 파일, 코드형 인프라(IaC), 자동 생성 코드는 측정치를 왜곡함</td>
</tr>
</tbody>
</table>
<p>LOC는 알고리즘 중심의 고성능 코드(예: 과학 계산, 컴파일러 내부)처럼 코드 줄 수가 복잡도와 합리적으로 대응되는 영역에서 과거 규모 지표로는 여전히 유용하다. 일반 비즈니스 소프트웨어에는 기능 점수나 스토리 포인트가 더 적합하다.</p>
<hr />
<h2 id="3">3. 기능 점수 분석<a class="header-link" href="#3" title="Permanent link">&para;</a></h2>
<p>기능 점수 분석(Function Point Analysis, FPA)은 1979년 IBM의 Allan Albrecht이 개발했다. 시스템이 어떻게 동작하는가가 아니라 <strong>무엇을 하는가</strong>라는 사용자 관점에서 기능적 규모를 측정한다. 따라서 기능 점수는 기술에 독립적이다.</p>
<h3 id="31">3.1 다섯 가지 기능 유형<a class="header-link" href="#31" title="Permanent link">&para;</a></h3>
<p>기능 점수는 다섯 가지 기능 컴포넌트를 계산한다:</p>
<table>
<thead>
<tr>
<th>기능 유형</th>
<th>약자</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td>외부 입력 (External Input)</td>
<td>EI</td>
<td>외부로부터 시스템에 입력되는 데이터</td>
<td>주문 양식 제출</td>
</tr>
<tr>
<td>외부 출력 (External Output)</td>
<td>EO</td>
<td>시스템에서 외부로 나가는 데이터</td>
<td>청구서 생성</td>
</tr>
<tr>
<td>외부 조회 (External Inquiry)</td>
<td>EQ</td>
<td>영속 데이터 변경 없는 입출력 쌍</td>
<td>상품 검색</td>
</tr>
<tr>
<td>내부 논리 파일 (Internal Logical File)</td>
<td>ILF</td>
<td>시스템이 유지하는 논리적으로 연관된 데이터 그룹</td>
<td>주문 테이블</td>
</tr>
<tr>
<td>외부 인터페이스 파일 (External Interface File)</td>
<td>EIF</td>
<td>다른 시스템이 유지하지만 참조하는 데이터 그룹</td>
<td>제품 카탈로그 (ERP에서 제공)</td>
</tr>
</tbody>
</table>
<h3 id="32">3.2 복잡도 분류<a class="header-link" href="#32" title="Permanent link">&para;</a></h3>
<p>각 컴포넌트는 낮음, 평균, 높음의 복잡도로 평가되어 가중치를 부여받는다:</p>
<table>
<thead>
<tr>
<th>기능 유형</th>
<th>낮음</th>
<th>평균</th>
<th>높음</th>
</tr>
</thead>
<tbody>
<tr>
<td>EI</td>
<td>3</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>EO</td>
<td>4</td>
<td>5</td>
<td>7</td>
</tr>
<tr>
<td>EQ</td>
<td>3</td>
<td>4</td>
<td>6</td>
</tr>
<tr>
<td>ILF</td>
<td>7</td>
<td>10</td>
<td>15</td>
</tr>
<tr>
<td>EIF</td>
<td>5</td>
<td>7</td>
<td>10</td>
</tr>
</tbody>
</table>
<h3 id="33-ufp">3.3 미조정 기능 점수(UFP) 계산<a class="header-link" href="#33-ufp" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="nx">UFP</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Σ</span><span class="w"> </span><span class="p">(</span><span class="nx">count</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="nx">weight</span><span class="p">)</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nx">all</span><span class="w"> </span><span class="nx">function</span><span class="w"> </span><span class="nx">types</span>
</code></pre></div>

<p>예시:</p>
<table>
<thead>
<tr>
<th>유형</th>
<th>수량</th>
<th>복잡도</th>
<th>가중치</th>
<th>소계</th>
</tr>
</thead>
<tbody>
<tr>
<td>EI</td>
<td>8</td>
<td>평균</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>EO</td>
<td>5</td>
<td>평균</td>
<td>5</td>
<td>25</td>
</tr>
<tr>
<td>EQ</td>
<td>6</td>
<td>낮음</td>
<td>3</td>
<td>18</td>
</tr>
<tr>
<td>ILF</td>
<td>4</td>
<td>평균</td>
<td>10</td>
<td>40</td>
</tr>
<tr>
<td>EIF</td>
<td>2</td>
<td>낮음</td>
<td>5</td>
<td>10</td>
</tr>
<tr>
<td><strong>UFP</strong></td>
<td></td>
<td></td>
<td></td>
<td><strong>125</strong></td>
</tr>
</tbody>
</table>
<h3 id="34-value-adjustment-factor">3.4 가치 조정 계수 (Value Adjustment Factor)<a class="header-link" href="#34-value-adjustment-factor" title="Permanent link">&para;</a></h3>
<p><strong>가치 조정 계수(Value Adjustment Factor, VAF)</strong>는 0~5점으로 평가되는 14개의 일반 시스템 특성(General System Characteristics, GSC)을 기반으로 UFP를 보정한다:</p>
<div class="highlight"><pre><span></span><code>VAF = 0.65 + 0.01 × Σ(GSC scores)    [GSC 점수 합계 범위 0–70]
VAF ranges from 0.65 to 1.35
</code></pre></div>

<div class="highlight"><pre><span></span><code>Adjusted FP = UFP × VAF
</code></pre></div>

<p>ISO/IEC 20926 (IFPUG)와 ISO/IEC 19761 (COSMIC)은 표준화 기구의 기능 점수 계산 변형 방식이다.</p>
<h3 id="35">3.5 기능 점수를 공수로 변환<a class="header-link" href="#35" title="Permanent link">&para;</a></h3>
<p>기능 점수를 산정한 후, 과거 데이터나 산업 벤치마크(예: ISBSG 데이터베이스)에서 도출한 생산성 지수(FP/인월)를 적용한다:</p>
<div class="highlight"><pre><span></span><code>Effort (person-months) = Adjusted FP / Productivity Rate
</code></pre></div>

<p>산업 벤치마크: 비즈니스 애플리케이션 개발의 경우 5~15 FP/인월 (언어, 도메인, 팀에 따라 크게 다름).</p>
<hr />
<h2 id="4-cocomo-cocomo-ii">4. COCOMO와 COCOMO II<a class="header-link" href="#4-cocomo-cocomo-ii" title="Permanent link">&para;</a></h2>
<p><strong>구성적 비용 모델(Constructive Cost Model, COCOMO)</strong>은 Barry Boehm이 1981년 개발한 알고리즘 모델로, 소프트웨어 프로젝트의 예상 규모(KLOC 기준)에서 공수와 일정을 추정한다.</p>
<h3 id="41-cocomo">4.1 COCOMO 기본 모델<a class="header-link" href="#41-cocomo" title="Permanent link">&para;</a></h3>
<p>세 가지 프로젝트 모드 (원래 1981년 모델):</p>
<table>
<thead>
<tr>
<th>모드</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>유기적(Organic)</strong></td>
<td>소규모 팀, 잘 이해된 문제, 친숙한 환경</td>
<td>비즈니스 데이터 처리</td>
</tr>
<tr>
<td><strong>반분리형(Semi-detached)</strong></td>
<td>중규모 팀, 혼합 경험, 일부 새로운 요구사항</td>
<td>트랜잭션 처리 시스템</td>
</tr>
<tr>
<td><strong>내장형(Embedded)</strong></td>
<td>엄격한 하드웨어 제약, 복잡한 요구사항, 높은 신뢰성 요구</td>
<td>비행 제어 소프트웨어</td>
</tr>
</tbody>
</table>
<p><strong>공수 방정식</strong>:</p>
<div class="highlight"><pre><span></span><code>E = a × (KLOC)^b    [person-months]
</code></pre></div>

<p><strong>일정 방정식</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="n">D</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">E</span><span class="o">^</span><span class="n">d</span><span class="w">    </span><span class="o">[</span><span class="n">months</span><span class="o">]</span>
</code></pre></div>

<p><strong>상수</strong>:</p>
<table>
<thead>
<tr>
<th>모드</th>
<th>a</th>
<th>b</th>
<th>c</th>
<th>d</th>
</tr>
</thead>
<tbody>
<tr>
<td>Organic</td>
<td>2.4</td>
<td>1.05</td>
<td>2.5</td>
<td>0.38</td>
</tr>
<tr>
<td>Semi-detached</td>
<td>3.0</td>
<td>1.12</td>
<td>2.5</td>
<td>0.35</td>
</tr>
<tr>
<td>Embedded</td>
<td>3.6</td>
<td>1.20</td>
<td>2.5</td>
<td>0.32</td>
</tr>
</tbody>
</table>
<p><strong>예시</strong> (Organic, 32 KLOC):</p>
<div class="highlight"><pre><span></span><code>E = 2.4 × (32)^1.05 = 2.4 × 36.5 ≈ 87.6 person-months
D = 2.5 × (87.6)^0.38 ≈ 2.5 × 14.0 ≈ 14.0 months
Average team size = E / D = 87.6 / 14.0 ≈ 6.3 people
</code></pre></div>

<h3 id="42-cocomo-cocomo-intermediate">4.2 COCOMO 중간 모델 (COCOMO Intermediate)<a class="header-link" href="#42-cocomo-cocomo-intermediate" title="Permanent link">&para;</a></h3>
<p>중간 COCOMO는 기본 공수 추정치에 <strong>비용 동인(Cost Drivers)</strong> — 15개 요소(제품, 컴퓨터, 인력, 프로젝트 속성으로 분류) — 를 곱하며, 각 요소는 매우 낮음~매우 높음으로 평가되어 공수 배수(Effort Multiplier, EM)를 적용한다:</p>
<div class="highlight"><pre><span></span><code>E = a × (KLOC)^b × Π(EM_i)
</code></pre></div>

<p>비용 동인 예시:</p>
<table>
<thead>
<tr>
<th>동인</th>
<th>매우 낮음</th>
<th>낮음</th>
<th>보통</th>
<th>높음</th>
<th>매우 높음</th>
<th>초고</th>
</tr>
</thead>
<tbody>
<tr>
<td>요구 신뢰성 (RELY)</td>
<td>0.75</td>
<td>0.88</td>
<td>1.00</td>
<td>1.15</td>
<td>1.40</td>
<td>—</td>
</tr>
<tr>
<td>분석가 역량 (ACAP)</td>
<td>1.46</td>
<td>1.19</td>
<td>1.00</td>
<td>0.86</td>
<td>0.71</td>
<td>—</td>
</tr>
<tr>
<td>소프트웨어 도구 사용 (TOOL)</td>
<td>1.24</td>
<td>1.10</td>
<td>1.00</td>
<td>0.91</td>
<td>0.82</td>
<td>—</td>
</tr>
</tbody>
</table>
<p>높은 신뢰성 요구 + 낮은 분석가 역량 + 열악한 도구 환경이 겹치면 기본 추정치의 2~3배까지 늘어날 수 있다.</p>
<h3 id="43-cocomo-ii">4.3 COCOMO II<a class="header-link" href="#43-cocomo-ii" title="Permanent link">&para;</a></h3>
<p>COCOMO II (1995~2000)는 현대적 개발 패러다임(객체지향 설계, 프로토타이핑, COTS 재사용, 반복적 개발)에 맞게 모델을 갱신했다. 주요 개선 사항:</p>
<ul>
<li><strong>규모 지표</strong>: LOC뿐만 아니라 기능 점수(언어별 동등 SLOC로 변환) 또는 스토리 포인트도 사용</li>
<li><strong>규모 요소(Scale Factors)</strong>: 선례성, 개발 유연성, 아키텍처/위험 해소, 팀 결집력, 프로세스 성숙도의 다섯 가지 요소가 모드 분류를 대체</li>
<li><strong>세 가지 하위 모델</strong>:</li>
<li><em>응용 구성(Application Composition)</em> (초기 단계, 신속 프로토타이핑)</li>
<li><em>초기 설계(Early Design)</em> (아키텍처 완료 후)</li>
<li><em>후기 아키텍처(Post-Architecture)</em> (상세 설계 완료)</li>
</ul>
<p>COCOMO II 공수 방정식:</p>
<div class="highlight"><pre><span></span><code><span class="n">E</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="n">Size</span><span class="o">^</span><span class="n">SF</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="err">Π</span><span class="p">(</span><span class="n">EM_i</span><span class="p">)</span>

<span class="n">where</span><span class="p">:</span>
<span class="w">  </span><span class="n">A</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">2.94</span><span class="w"> </span><span class="p">(</span><span class="n">calibrated</span><span class="w"> </span><span class="n">constant</span><span class="p">)</span>
<span class="w">  </span><span class="n">SF</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mf">0.01</span><span class="w"> </span><span class="err">×</span><span class="w"> </span><span class="err">Σ</span><span class="p">(</span><span class="n">scale</span><span class="w"> </span><span class="n">factor</span><span class="w"> </span><span class="n">scores</span><span class="p">)</span><span class="w">   </span><span class="p">[</span><span class="n">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.91</span><span class="p">]</span>
<span class="w">  </span><span class="n">Scale</span><span class="w"> </span><span class="n">factor</span><span class="w"> </span><span class="n">scores</span><span class="w"> </span><span class="nb">range</span><span class="w"> </span><span class="mi">0</span><span class="err">–</span><span class="mi">5</span><span class="p">;</span><span class="w"> </span><span class="err">Σ</span><span class="w"> </span><span class="n">ranges</span><span class="w"> </span><span class="mi">0</span><span class="err">–</span><span class="mi">25</span><span class="p">;</span><span class="w"> </span><span class="n">SF</span><span class="w"> </span><span class="n">ranges</span><span class="w"> </span><span class="mf">0.91</span><span class="err">–</span><span class="mf">1.23</span>
</code></pre></div>

<p>COCOMO II는 오픈소스 USC COCOMO II 도구와 Construx Estimate, SEER-SEM 상용 도구로 구현되어 있다.</p>
<h3 id="44">4.4 알고리즘 모델의 활용 시점<a class="header-link" href="#44" title="Permanent link">&para;</a></h3>
<p>알고리즘 모델을 사용하려면:
1. 유사 프로젝트에서 도출한 과거 교정 데이터
2. 사용 전 규모 추정치
3. 비용 동인 등급의 신중한 선택</p>
<p>이 모델은 다음 상황에 가장 적합하다:
- 요구사항이 안정적인 대규모 폭포수(waterfall) 방식 프로젝트
- 비용 근거 문서화가 필요한 정부/국방 계약
- 방대한 프로젝트 이력 데이터베이스를 보유한 조직</p>
<p>소규모 팀이나 애자일 프로젝트에는 스토리 포인트 기반 추정이 보통 더 실용적이다.</p>
<hr />
<h2 id="5">5. 스토리 포인트와 상대적 추정<a class="header-link" href="#5" title="Permanent link">&para;</a></h2>
<p><strong>스토리 포인트(Story Points)</strong>는 애자일 개발에서 사용자 스토리를 구현하는 데 필요한 공수를 표현하는 상대적이고 무차원적인 단위다. 시간이나 인일(person-day)과 달리, 스토리 포인트는 특정 기간에 얽매이지 않고 공수, 복잡도, 불확실성을 함께 포착한다.</p>
<h3 id="51">5.1 상대적 추정이 효과적인 이유<a class="header-link" href="#51" title="Permanent link">&para;</a></h3>
<p>사람은 절대적 추정("이 작업은 14시간 걸릴 것이다")에는 취약하지만, 상대적 비교("스토리 B는 스토리 A보다 약 두 배 어렵다")에는 꽤 능숙하다. 상대적 추정은 이 인지적 강점을 활용한다.</p>
<h3 id="52">5.2 스토리 포인트에 피보나치 수열 사용<a class="header-link" href="#52" title="Permanent link">&para;</a></h3>
<p>대부분의 팀은 수정된 피보나치 수열을 사용한다: <strong>1, 2, 3, 5, 8, 13, 21, 40, 100</strong>.</p>
<p>큰 값 사이의 간격이 점점 커지는 것은 불확실성의 증가를 반영한다: 5와 8의 차이는 의미 있지만, 40과 45의 차이는 그렇지 않다.</p>
<p>일부 팀은 <strong>XS, S, M, L, XL</strong> (티셔츠 사이즈, §7 참조)이나 <strong>2의 거듭제곱</strong> (1, 2, 4, 8, 16)을 사용하기도 한다.</p>
<h3 id="53-velocity">5.3 속도 (Velocity)<a class="header-link" href="#53-velocity" title="Permanent link">&para;</a></h3>
<p>여러 스프린트를 완료하면 팀은 <strong>속도(Velocity)</strong>를 측정할 수 있다: 스프린트당 평균 완료 스토리 포인트 수.</p>
<div class="highlight"><pre><span></span><code><span class="nv">Velocity</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">Total</span><span class="w"> </span><span class="nv">story</span><span class="w"> </span><span class="nv">points</span><span class="w"> </span><span class="nv">completed</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">sprint</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="nv">sprint</span>
<span class="w">           </span><span class="ss">(</span><span class="nv">averaged</span><span class="w"> </span><span class="nv">over</span><span class="w"> </span><span class="nv">several</span><span class="w"> </span><span class="nv">sprints</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">stability</span><span class="ss">)</span>
</code></pre></div>

<p>속도는 <strong>릴리스 계획</strong>에 사용된다: 백로그가 N 스토리 포인트이고 팀 속도가 V 포인트/스프린트라면, 프로젝트에는 약 N/V 스프린트가 필요하다.</p>
<h3 id="54">5.4 스토리 포인트의 한계<a class="header-link" href="#54" title="Permanent link">&para;</a></h3>
<ul>
<li>포인트는 팀 상대적이다: 팀 A의 "5"는 더 경험 많은 팀 B에게는 "3"일 수 있음</li>
<li>포인트는 복잡도를 측정하지 시간을 측정하지 않는다; "스토리 포인트 1개가 몇 시간인가?"라고 묻는 이해관계자는 모델을 오해하는 것</li>
<li>추정치를 부풀려 속도를 조작할 수 있다("스토리 포인트 인플레이션"이라고 불리는 관행)</li>
<li>새로운 팀은 속도 이력이 없어 초기 스프린트로 교정해야 함</li>
</ul>
<hr />
<h2 id="6">6. 플래닝 포커<a class="header-link" href="#6" title="Permanent link">&para;</a></h2>
<p>플래닝 포커(Planning Poker)는 전문가 판단, 구조화된 토론, 델파이(Delphi) 방법을 결합해 스토리 포인트 추정치를 산출하는 합의 기반 추정 기법이다.</p>
<h3 id="61">6.1 진행 방식<a class="header-link" href="#61" title="Permanent link">&para;</a></h3>
<ol>
<li>
<p><strong>준비</strong>: 각 팀원은 피보나치 값(1, 2, 3, 5, 8, 13, 21, ?, ∞, ☕)이 적힌 카드 덱을 받는다. 제품 책임자(Product Owner)가 사용자 스토리를 읽는다.</p>
</li>
<li>
<p><strong>개별 선택</strong>: 각 추정자는 자신의 추정치를 나타내는 카드를 비공개로 선택한다. 이 시점에서는 카드를 공개하지 않는 것이 핵심이다.</p>
</li>
<li>
<p><strong>동시 공개</strong>: 셋을 세면 모든 추정자가 동시에 카드를 공개한다. 동시 공개는 닻 내리기 편향(Anchoring) — 먼저 들은 숫자가 이후 모든 추정치를 강하게 끌어당기는 현상 — 을 방지한다.</p>
</li>
<li>
<p><strong>토론</strong>: 추정치가 다르면, 가장 높게 추정한 사람과 가장 낮게 추정한 사람이 각자의 근거를 설명한다. 이 과정에서 숨겨진 복잡도, 오해된 요구사항, 다른 가정이 드러난다.</p>
</li>
<li>
<p><strong>재추정</strong>: 팀이 수렴하거나 다시 투표할 때까지 논의가 이어진다. 추정치가 피보나치 수 한 단계 이내로 모일 때까지 반복한다.</p>
</li>
<li>
<p><strong>기록</strong>: 합의된 추정치를 스토리에 기록한다.</p>
</li>
</ol>
<h3 id="62">6.2 특수 카드<a class="header-link" href="#62" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>카드</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>?</code></td>
<td>"스토리를 충분히 이해하지 못해 추정할 수 없습니다" → 토론 필요</td>
</tr>
<tr>
<td><code>∞</code></td>
<td>"이 스토리는 너무 커서 추정이 불가능합니다; 더 작게 나누어야 합니다"</td>
</tr>
<tr>
<td><code>☕</code></td>
<td>"휴식이 필요합니다"</td>
</tr>
</tbody>
</table>
<h3 id="63">6.3 플래닝 포커가 효과적인 이유<a class="header-link" href="#63" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>구조화된 토론</strong>: 가정을 명확히 표현하도록 강제함</li>
<li><strong>닻 내리기 방지</strong>: 동시 공개가 인지 편향을 차단함</li>
<li><strong>팀 헌신</strong>: 추정에 참여한 이들이 그 결과에 더 책임감을 가짐</li>
<li><strong>지식 공유</strong>: 스토리를 논의하면서 구현 지식이 표면화됨</li>
</ul>
<h3 id="64">6.4 원격 플래닝 포커<a class="header-link" href="#64" title="Permanent link">&para;</a></h3>
<p>분산 팀을 위한 도구: PlanningPoker.com, Scrum Poker Online, Jira Planning Poker 플러그인, Miro 템플릿.</p>
<hr />
<h2 id="7">7. 티셔츠 사이즈 추정<a class="header-link" href="#7" title="Permanent link">&para;</a></h2>
<p>티셔츠 사이즈 추정(T-Shirt Sizing)은 <strong>XS, S, M, L, XL</strong> (때로는 XXL)을 사용해 상대적 규모를 표현한다. 플래닝 포커보다 빠르며 다음 상황에 사용된다:</p>
<ul>
<li>스토리 포인트로 표현하기에 너무 큰 <strong>에픽과 테마</strong></li>
<li>스토리가 아직 명확하게 정의되지 않은 <strong>초기 로드맵 계획</strong></li>
<li>전체 플래닝 포커에 앞서 <strong>빠른 필터링</strong></li>
</ul>
<p>팀은 스토리 포인트와의 대응을 약속한다, 예를 들어:</p>
<table>
<thead>
<tr>
<th>티셔츠</th>
<th>스토리 포인트</th>
</tr>
</thead>
<tbody>
<tr>
<td>XS</td>
<td>1–2</td>
</tr>
<tr>
<td>S</td>
<td>3–5</td>
</tr>
<tr>
<td>M</td>
<td>8</td>
</tr>
<tr>
<td>L</td>
<td>13–21</td>
</tr>
<tr>
<td>XL</td>
<td>40+ (분리 고려)</td>
</tr>
</tbody>
</table>
<p>티셔츠 사이즈 추정은 정밀도를 희생하는 대신 속도를 얻는다. 스토리가 더 구체화되면 정제하는 <strong>1차 추정</strong>이다.</p>
<hr />
<h2 id="8-pert">8. 삼점 추정과 PERT<a class="header-link" href="#8-pert" title="Permanent link">&para;</a></h2>
<p>삼점 추정(Three-Point Estimation)은 작업 기간이 단일 숫자가 아니라 <strong>분포</strong>임을 인정한다. 세 가지 시나리오를 추정한다:</p>
<table>
<thead>
<tr>
<th>매개변수</th>
<th>기호</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>낙관적 (Optimistic)</td>
<td>O</td>
<td>모든 것이 잘 풀릴 때 (최선의 경우; ~5백분위)</td>
</tr>
<tr>
<td>최빈값 (Most Likely)</td>
<td>M</td>
<td>현실적으로 기대되는 기간</td>
</tr>
<tr>
<td>비관적 (Pessimistic)</td>
<td>P</td>
<td>일이 나쁘게 풀릴 때 (최악의 경우; ~95백분위)</td>
</tr>
</tbody>
</table>
<h3 id="81-pert">8.1 PERT 공식<a class="header-link" href="#81-pert" title="Permanent link">&para;</a></h3>
<p><strong>프로그램 평가 검토 기법(Program Evaluation and Review Technique, PERT)</strong>은 최빈값에 가장 큰 가중치를 부여한 가중 평균을 사용한다:</p>
<div class="highlight"><pre><span></span><code>Expected duration  E = (O + 4M + P) / 6
Standard deviation σ = (P - O) / 6
Variance         Var = σ²
</code></pre></div>

<p><strong>예시</strong>:</p>
<table>
<thead>
<tr>
<th>작업</th>
<th>O</th>
<th>M</th>
<th>P</th>
<th>E</th>
<th>σ</th>
</tr>
</thead>
<tbody>
<tr>
<td>스키마 설계</td>
<td>2</td>
<td>3</td>
<td>8</td>
<td>3.33</td>
<td>1.0</td>
</tr>
<tr>
<td>API 구현</td>
<td>3</td>
<td>5</td>
<td>12</td>
<td>5.5</td>
<td>1.5</td>
</tr>
<tr>
<td>테스트 작성</td>
<td>1</td>
<td>2</td>
<td>5</td>
<td>2.33</td>
<td>0.67</td>
</tr>
</tbody>
</table>
<p>순차적으로 실행되는 독립 작업들의 경우, 총 기대 기간과 총 분산은 덧셈으로 계산된다:</p>
<div class="highlight"><pre><span></span><code>E_total = Σ E_i
Var_total = Σ Var_i
σ_total = √Var_total
</code></pre></div>

<p>위 세 작업에 대해:</p>
<div class="highlight"><pre><span></span><code>E_total = 3.33 + 5.5 + 2.33 = 11.17 days
σ_total = √(1.0² + 1.5² + 0.67²) = √(1 + 2.25 + 0.45) = √3.70 ≈ 1.92 days
</code></pre></div>

<p>90% 신뢰 구간은 약 E ± 1.65σ = [11.17 ± 3.17] = [8.0, 14.3]일이다.</p>
<h3 id="82">8.2 삼점 추정 활용 시점<a class="header-link" href="#82" title="Permanent link">&para;</a></h3>
<ul>
<li>상세 프로젝트 계획에서 <strong>개별 작업 추정</strong></li>
<li>일정 불확실성을 이해관계자에게 전달해야 할 때 <strong>위험 정량화</strong></li>
<li>각 작업의 분포에서 수천 번의 무작위 샘플을 추출해 프로젝트 완료 확률 분포를 생성하는 <strong>몬테카를로 시뮬레이션</strong>과 결합</li>
</ul>
<hr />
<h2 id="9">9. 작업 분류 체계<a class="header-link" href="#9" title="Permanent link">&para;</a></h2>
<p><strong>작업 분류 체계(Work Breakdown Structure, WBS)</strong>는 전체 프로젝트 범위를 관리 가능한 작업 패키지로 계층적으로 분해한 것이다. "프로젝트가 무엇을 만들어야 하는가?"라는 질문에 답한다.</p>
<h3 id="91-wbs">9.1 WBS 원칙<a class="header-link" href="#91-wbs" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>산출물 지향</strong>: 각 노드는 활동이 아닌 산출물 또는 결과물</li>
<li><strong>100% 규칙</strong>: WBS는 프로젝트 범위의 100%를 포함해야 함 — 그 이상도, 그 이하도 아님</li>
<li><strong>상호 배타성</strong>: 동일한 작업이 두 번 계산되지 않음</li>
<li><strong>작업 패키지</strong>(리프 노드)는 가장 작은 단위로, 보통 한 보고 기간 동안 한 사람 또는 팀에 할당됨</li>
</ul>
<h3 id="92-wbs">9.2 WBS 예시: 모바일 뱅킹 앱<a class="header-link" href="#92-wbs" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">Mobile</span><span class="w"> </span><span class="n">Banking</span><span class="w"> </span><span class="n">App</span>
<span class="err">├──</span><span class="w"> </span><span class="mf">1.1</span><span class="w"> </span><span class="n">Project</span><span class="w"> </span><span class="n">Management</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.1.1</span><span class="w"> </span><span class="n">Project</span><span class="w"> </span><span class="n">Plans</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.1.2</span><span class="w"> </span><span class="n">Status</span><span class="w"> </span><span class="n">Reports</span>
<span class="err">│</span><span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="mf">1.1.3</span><span class="w"> </span><span class="n">Risk</span><span class="w"> </span><span class="n">Register</span>
<span class="err">├──</span><span class="w"> </span><span class="mf">1.2</span><span class="w"> </span><span class="n">Requirements</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.2.1</span><span class="w"> </span><span class="n">Stakeholder</span><span class="w"> </span><span class="nb">Int</span><span class="n">erviews</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.2.2</span><span class="w"> </span><span class="n">Use</span><span class="w"> </span><span class="n">Cases</span>
<span class="err">│</span><span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="mf">1.2.3</span><span class="w"> </span><span class="n">SRS</span><span class="w"> </span><span class="n">Document</span>
<span class="err">├──</span><span class="w"> </span><span class="mf">1.3</span><span class="w"> </span><span class="n">Design</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.3.1</span><span class="w"> </span><span class="n">Architecture</span><span class="w"> </span><span class="n">Document</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.3.2</span><span class="w"> </span><span class="kd">Data</span><span class="n">base</span><span class="w"> </span><span class="n">Schema</span>
<span class="err">│</span><span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="mf">1.3.3</span><span class="w"> </span><span class="n">UI</span><span class="w"> </span><span class="n">Wireframes</span>
<span class="err">├──</span><span class="w"> </span><span class="mf">1.4</span><span class="w"> </span><span class="n">Implementation</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.4.1</span><span class="w"> </span><span class="n">Authentication</span><span class="w"> </span><span class="n">Module</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.4.2</span><span class="w"> </span><span class="n">Account</span><span class="w"> </span><span class="n">Management</span><span class="w"> </span><span class="n">Module</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.4.3</span><span class="w"> </span><span class="n">Transfer</span><span class="w"> </span><span class="n">Module</span>
<span class="err">│</span><span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="mf">1.4.4</span><span class="w"> </span><span class="ow">Not</span><span class="kr">if</span><span class="n">ications</span><span class="w"> </span><span class="n">Module</span>
<span class="err">├──</span><span class="w"> </span><span class="mf">1.5</span><span class="w"> </span><span class="n">Testing</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.5.1</span><span class="w"> </span><span class="n">Unit</span><span class="w"> </span><span class="n">Tests</span>
<span class="err">│</span><span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.5.2</span><span class="w"> </span><span class="nb">Int</span><span class="n">egration</span><span class="w"> </span><span class="n">Tests</span>
<span class="err">│</span><span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="mf">1.5.3</span><span class="w"> </span><span class="n">UAT</span>
<span class="err">└──</span><span class="w"> </span><span class="mf">1.6</span><span class="w"> </span><span class="n">Deployment</span>
<span class="w">    </span><span class="err">├──</span><span class="w"> </span><span class="mf">1.6.1</span><span class="w"> </span><span class="n">Infrastructure</span><span class="w"> </span><span class="n">Setup</span>
<span class="w">    </span><span class="err">└──</span><span class="w"> </span><span class="mf">1.6.2</span><span class="w"> </span><span class="n">Production</span><span class="w"> </span><span class="n">Release</span>
</code></pre></div>

<p>WBS는 <strong>개요 번호 부여(outline numbering)</strong> 방식을 사용하여 각 작업 패키지에 고유 식별자(예: 1.4.3)를 부여하며, 이 식별자는 일정, 예산, 위험 등록부에 등장한다.</p>
<h3 id="93-wbs-wbs-dictionary">9.3 WBS 사전 (WBS Dictionary)<a class="header-link" href="#93-wbs-wbs-dictionary" title="Permanent link">&para;</a></h3>
<p>각 작업 패키지에는 다음을 포함하는 <strong>WBS 사전 항목</strong>이 있어야 한다:
- 작업 설명
- 담당자/팀
- 일정 (시작, 종료)
- 예상 비용
- 의존성
- 인수 기준</p>
<hr />
<h2 id="10">10. 간트 차트와 주경로<a class="header-link" href="#10" title="Permanent link">&para;</a></h2>
<h3 id="101-gantt-charts">10.1 간트 차트 (Gantt Charts)<a class="header-link" href="#101-gantt-charts" title="Permanent link">&para;</a></h3>
<p><strong>간트 차트(Gantt chart)</strong>는 프로젝트 작업을 시간 축에 대해 표시하는 막대 차트다. 각 작업은 수평 막대이며, 길이는 기간을, 위치는 시간 범위를 나타낸다.</p>
<div class="highlight"><pre><span></span><code>Task                   | Wk1 | Wk2 | Wk3 | Wk4 | Wk5 | Wk6 |
-----------------------|-----|-----|-----|-----|-----|-----|
Requirements           |=====|=====|     |     |     |     |
Architecture           |     |  ===|=====|     |     |     |
Database Design        |     |     |=====|     |     |     |
Backend Development    |     |     |     |=====|=====|     |
Frontend Development   |     |     |  ===|=====|=====|     |
Testing                |     |     |     |     |=====|=====|
Deployment             |     |     |     |     |     |  ===|
</code></pre></div>

<p>현대 프로젝트 관리 도구(Microsoft Project, Jira Plans, Asana, Linear)는 작업 의존성과 추정치로부터 간트 차트를 자동으로 생성한다.</p>
<h3 id="102-critical-path-method-cpm">10.2 주경로 분석법 (Critical Path Method, CPM)<a class="header-link" href="#102-critical-path-method-cpm" title="Permanent link">&para;</a></h3>
<p><strong>주경로(Critical Path)</strong>는 프로젝트 시작부터 끝까지 종속 작업들로 이어진 가장 긴 경로다. 주경로 위의 어떤 지연도 <strong>프로젝트를 직접 지연</strong>시킨다. 주경로에 없는 작업들은 <strong>여유(Float, Slack)</strong>를 가진다 — 프로젝트 종료일에 영향을 주지 않고 지연될 수 있다.</p>
<p><strong>전진 계산(Forward pass)</strong> — 최조 시작일(ES)과 최조 완료일(EF) 계산:</p>
<div class="highlight"><pre><span></span><code>ES(task) = max(EF of all predecessors)
EF(task) = ES(task) + duration
</code></pre></div>

<p><strong>후진 계산(Backward pass)</strong> — 최지 시작일(LS)과 최지 완료일(LF) 계산:</p>
<div class="highlight"><pre><span></span><code>LF(task) = min(LS of all successors)
LS(task) = LF(task) - duration
</code></pre></div>

<p><strong>여유(Float, Slack)</strong>:</p>
<div class="highlight"><pre><span></span><code>Float = LS - ES = LF - EF
</code></pre></div>

<p>여유가 0인 작업은 주경로 위에 있다.</p>
<p><strong>네트워크 예시</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="w">        </span>┌─────┐<span class="w">        </span>┌─────┐
<span class="w">  </span>●────►│<span class="w"> </span><span class="nv">A</span>:<span class="mi">3</span><span class="w"> </span>│───────►│<span class="w"> </span><span class="nv">C</span>:<span class="mi">4</span><span class="w"> </span>│──────►●
<span class="w">        </span>└─────┘<span class="w">        </span>└─────┘<span class="w">    </span><span class="ss">(</span><span class="nv">project</span><span class="w"> </span><span class="k">end</span><span class="ss">)</span>
<span class="w">           </span>│<span class="w">                          </span>▲
<span class="w">           </span>│<span class="w">           </span>┌─────┐<span class="w">        </span>│
<span class="w">           </span>└──────────►│<span class="w"> </span><span class="nv">B</span>:<span class="mi">6</span><span class="w"> </span>│────────┘
<span class="w">                       </span>└─────┘

<span class="nv">Tasks</span>:<span class="w"> </span><span class="nv">A</span><span class="w"> </span><span class="ss">(</span><span class="mi">3</span><span class="w"> </span><span class="nv">days</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="ss">(</span><span class="mi">6</span><span class="w"> </span><span class="nv">days</span><span class="ss">)</span>,<span class="w"> </span><span class="nv">C</span><span class="w"> </span><span class="ss">(</span><span class="mi">4</span><span class="w"> </span><span class="nv">days</span>,<span class="w"> </span><span class="nv">depends</span><span class="w"> </span><span class="nv">on</span><span class="w"> </span><span class="nv">A</span><span class="ss">)</span>
<span class="nv">Path</span><span class="w"> </span><span class="mi">1</span>:<span class="w"> </span><span class="nv">A</span><span class="w"> </span>→<span class="w"> </span><span class="nv">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="nv">days</span>
<span class="nv">Path</span><span class="w"> </span><span class="mi">2</span>:<span class="w"> </span><span class="nv">A</span><span class="w"> </span>→<span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">6</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="nv">days</span><span class="w">  </span>←<span class="w"> </span><span class="nv">Critical</span><span class="w"> </span><span class="nv">Path</span>
<span class="nv">Float</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="nv">C</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="nv">days</span>
</code></pre></div>

<h3 id="103">10.3 일정 단축: 충돌과 병렬 진행<a class="header-link" href="#103" title="Permanent link">&para;</a></h3>
<p>주경로가 너무 길 때:
- <strong>충돌(Crashing)</strong>: 주경로 작업에 자원을 추가해 기간을 단축 (비용이 들고, Brooks의 법칙으로 수익 체감 — §13 참조)
- <strong>패스트 트래킹(Fast-tracking)</strong>: 주경로 작업을 순차적이 아닌 병렬로 실행 (재작업 위험 증가)</p>
<hr />
<h2 id="11-vs">11. 릴리스 계획 vs. 스프린트 계획<a class="header-link" href="#11-vs" title="Permanent link">&para;</a></h2>
<h3 id="111-release-planning">11.1 릴리스 계획 (Release Planning)<a class="header-link" href="#111-release-planning" title="Permanent link">&para;</a></h3>
<p><strong>릴리스 계획(Release planning)</strong>은 특정 날짜까지 어떤 기능을 제공할지(또는 특정 기능들이 언제 준비될지)를 결정한다. 여러 스프린트에 걸쳐 <strong>에픽/스토리 수준</strong>에서 운영된다.</p>
<p>프로세스:
1. 백로그를 우선순위(비즈니스 가치, 위험, 의존성)로 정렬
2. 팀 속도 결정 (과거 스프린트 이력이나 초기 교정 스프린트 기반)
3. 계산: 스프린트 수 = 총 스토리 포인트 / 속도
4. 스토리를 릴리스에 할당하며, 범위가 용량에 맞는 지점에 <strong>릴리스 경계선</strong> 설정</p>
<div class="highlight"><pre><span></span><code> Sprint   | Stories         | Points | Cumulative | Release
----------|-----------------|--------|------------|--------
   1      | Login, Profile  |   18   |    18      |
   2      | Search, Filter  |   21   |    39      |  v1.0
   3      | Checkout, Cart  |   25   |    64      |
   4      | Payment, Review |   20   |    84      |  v1.1
   5      | Admin Panel     |   22   |   106      |
   6      | Reporting       |   18   |   124      |  v1.2
</code></pre></div>

<h3 id="112-sprint-planning">11.2 스프린트 계획 (Sprint Planning)<a class="header-link" href="#112-sprint-planning" title="Permanent link">&para;</a></h3>
<p><strong>스프린트 계획(Sprint planning)</strong>은 각 스프린트 초에 팀이 백로그에서 스토리를 선택하고 스프린트 내에 완료할 것을 약속하는 의식이다. 며칠에서 일주일 단위로 <strong>스토리/작업 수준</strong>에서 운영된다.</p>
<p>두 부분으로 구성:
1. <strong>무엇을?</strong> — 제품 책임자가 최우선 백로그 항목을 제시하고, 팀이 속도에 맞는 스토리를 선택
2. <strong>어떻게?</strong> — 팀이 선택한 스토리를 엔지니어링 작업(시간 기준)으로 분해하고, 기술적 접근법과 의존성을 파악</p>
<p>결과: <strong>스프린트 백로그(Sprint Backlog)</strong> — 이번 스프린트에서 완료할 스토리와 작업의 집합.</p>
<h3 id="113-iteration-zero-sprint-0">11.3 이터레이션 제로 (Iteration Zero, Sprint 0)<a class="header-link" href="#113-iteration-zero-sprint-0" title="Permanent link">&para;</a></h3>
<p>애자일 프로젝트의 첫 번째 스프린트는 종종 다음을 위한 "스프린트 0"이다:
- 개발 환경과 CI/CD 파이프라인 구축
- 코딩 표준 및 브랜치 전략 수립
- 초기 아키텍처 스파이크(spike) 수행
- 샘플 백로그 스토리로 플래닝 포커를 실행해 속도 교정</p>
<p>이 스프린트는 사용자 대상 기능을 제공하지 않지만, 이후 모든 스프린트가 효과적으로 작동하도록 기반을 마련한다.</p>
<hr />
<h2 id="12_1">12. 추정 정확도: 추적과 개선<a class="header-link" href="#12_1" title="Permanent link">&para;</a></h2>
<h3 id="121-vs">12.1 실제 vs. 추정 추적<a class="header-link" href="#121-vs" title="Permanent link">&para;</a></h3>
<p>매 스프린트:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Pseudo-code for tracking estimation accuracy</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sprint_report</span><span class="p">(</span><span class="n">sprint</span><span class="p">):</span>
    <span class="n">accuracy_per_story</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">story</span> <span class="ow">in</span> <span class="n">sprint</span><span class="o">.</span><span class="n">completed_stories</span><span class="p">:</span>
        <span class="c1"># For hour-based tasks</span>
        <span class="n">accuracy</span> <span class="o">=</span> <span class="n">story</span><span class="o">.</span><span class="n">actual_hours</span> <span class="o">/</span> <span class="n">story</span><span class="o">.</span><span class="n">estimated_hours</span>
        <span class="n">accuracy_per_story</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">accuracy</span><span class="p">)</span>

    <span class="n">avg_accuracy</span> <span class="o">=</span> <span class="n">mean</span><span class="p">(</span><span class="n">accuracy_per_story</span><span class="p">)</span>
    <span class="c1"># accuracy &gt; 1.0: over-ran; &lt; 1.0: finished early</span>
    <span class="k">return</span> <span class="n">avg_accuracy</span>
</code></pre></div>

<p>팀이 추적해야 할 항목:
- <strong>속도 추세</strong> (안정적인가, 향상되고 있는가, 하락하고 있는가?)
- <strong>정확도 비율</strong> (스토리 규모별 실제/추정) — 8포인트 스토리가 일관되게 과소평가되는 경향이 자주 있음
- <strong>이월률(Spillover rate)</strong> (완료하지 못한 스토리 비율)</p>
<h3 id="122">12.2 교정 기법<a class="header-link" href="#122" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>기법</th>
<th>설명</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>과거 유추(Historical analogy)</strong></td>
<td>새 스토리를 비슷한 복잡도의 이전 완료 스토리와 비교</td>
</tr>
<tr>
<td><strong>분해(Decomposition)</strong></td>
<td>큰 스토리를 작업으로 분해하고, 작업을 추정한 후 합산</td>
</tr>
<tr>
<td><strong>참조 스토리(Reference stories)</strong></td>
<td>각 크기 포인트에서 교정 기준점 역할을 하는 "참조 스토리" 유지</td>
</tr>
<tr>
<td><strong>와이드밴드 델파이(Wideband Delphi)</strong></td>
<td>구조화된 전문가 합의 (플래닝 포커가 근사하는 공식 방법)</td>
</tr>
</tbody>
</table>
<h3 id="123">12.3 시간에 따른 추정 개선<a class="header-link" href="#123" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>추정에 집중한 회고 진행</strong>: "어떤 스토리를 가장 많이 잘못 추정했는가? 왜?"</li>
<li><strong>참조 스토리 갱신</strong>: 팀의 역량이 성장할수록 "5"의 의미를 재교정</li>
<li><strong>추정 체크리스트 유지</strong>: 자주 누락되는 작업(코드 리뷰 시간, 문서화, 배포 검증)</li>
<li><strong>추정 편향 추적</strong>: 팀이 지속적으로 20% 과소평가한다면, 행동이 바뀔 때까지 1.2 보정 계수 적용</li>
</ol>
<hr />
<h2 id="13">13. 일반적인 추정 함정<a class="header-link" href="#13" title="Permanent link">&para;</a></h2>
<h3 id="131-planning-fallacy">13.1 낙관주의 편향 (계획 오류, Planning Fallacy)<a class="header-link" href="#131-planning-fallacy" title="Permanent link">&para;</a></h3>
<p>사람들은 미래 행동의 시간, 비용, 위험을 체계적으로 과소평가한다. Daniel Kahneman은 이를 <strong>계획 오류(Planning Fallacy)</strong>라고 명명했다: 개인들은 과거 실적과 위험을 무시한 채 최선의 시나리오로 작업을 완료한다고 예측한다.</p>
<p>대응책: <strong>참조 계층 예측(Reference class forecasting)</strong> — 현재 프로젝트를 추정하기 전에 유사한 프로젝트가 실제로 얼마나 걸렸는지 살펴본다.</p>
<h3 id="132-anchoring-bias">13.2 닻 내리기 편향 (Anchoring Bias)<a class="header-link" href="#132-anchoring-bias" title="Permanent link">&para;</a></h3>
<p>추정 논의에서 처음 언급된 숫자가 인지적 닻이 된다. 관리자가 "이건 한 주 정도 걸릴 것 같아요"라고 말하면, 이후 모든 추정치는 그 숫자 쪽으로 끌린다.</p>
<p>대응책: <strong>동시 공개</strong> (플래닝 포커)와 원하는 기간에 대한 논의가 시작되기 전에 추정치를 먼저 제시하도록 요구하기.</p>
<h3 id="133-parkinsons-law">13.3 파킨슨의 법칙 (Parkinson's Law)<a class="header-link" href="#133-parkinsons-law" title="Permanent link">&para;</a></h3>
<p><em>"업무는 완료하기 위해 주어진 시간을 채운다."</em> 작업에 2주가 주어지면, 3일이면 할 수 있더라도 2주가 걸린다.</p>
<p>대응책: 명시적으로 짧은 기간을 설정한 <strong>타임박싱(Timeboxing)</strong>과 일일 스탠드업. 애자일 스프린트는 자연스럽게 타임박싱을 적용한다.</p>
<h3 id="134-brooks-brookss-law">13.4 Brooks의 법칙 (Brooks's Law)<a class="header-link" href="#134-brooks-brookss-law" title="Permanent link">&para;</a></h3>
<p><em>"지연된 소프트웨어 프로젝트에 인력을 추가하면 더 늦어진다."</em> (Fred Brooks, <em>The Mythical Man-Month</em>) 새 팀원은 온보딩이 필요하고, 커뮤니케이션 오버헤드를 증가시키며, 통합 문제를 일으키는 방식으로 작업을 분담한다.</p>
<p>대응책: 팀 구성을 미리 계획하고, 마지막 순간에 인력을 추가하지 않는다. 불가피하다면, 비핵심 업무에 배치한다.</p>
<h3 id="135-student-syndrome">13.5 학생 증후군 (Student Syndrome)<a class="header-link" href="#135-student-syndrome" title="Permanent link">&para;</a></h3>
<p>사람들은 마지막 순간까지 작업 시작을 미루다가 서두르게 되어 품질 문제와 이월이 발생한다.</p>
<p>대응책: 일일 스탠드업으로 진행 상황을 가시화하고; 완료의 정의(Definition of Done) 기준으로 조기 종료를 방지한다.</p>
<h3 id="136-90-ninety-percent-syndrome">13.6 90% 증후군 (Ninety-Percent Syndrome)<a class="header-link" href="#136-90-ninety-percent-syndrome" title="Permanent link">&para;</a></h3>
<p>"90% 완료"로 보고된 작업이 오랫동안 "90% 완료" 상태에 머무르는 경향이 있다. 마지막 10%에 가장 어렵고 불확실한 작업이 들어있다.</p>
<p>대응책: 작업 패키지에 이진 완료 추적(완료/미완료)을 사용한다. 완료 비율이 아닌 <strong>남은 작업량</strong>을 보고한다.</p>
<h3 id="137-scope-creep">13.7 범위 팽창 (Scope Creep)<a class="header-link" href="#137-scope-creep" title="Permanent link">&para;</a></h3>
<p>일정, 예산, 자원의 조정 없이 프로젝트 범위가 통제되지 않고 확장되는 것.</p>
<p>대응책: 공식 변경 관리(레슨 04 참조); MoSCoW 우선순위 결정; 스프린트 수준의 범위 약속.</p>
<hr />
<h2 id="14">14. 요약<a class="header-link" href="#14" title="Permanent link">&para;</a></h2>
<p>추정은 의도적인 연습, 교정 데이터, 구조화된 기법을 통해 향상되는 기술이다.</p>
<table>
<thead>
<tr>
<th>기법</th>
<th>최적 활용 상황</th>
<th>핵심 공식</th>
</tr>
</thead>
<tbody>
<tr>
<td>LOC</td>
<td>알고리즘 중심, 고성능 코드</td>
<td><code>Effort = LOC / productivity</code></td>
</tr>
<tr>
<td>기능 점수 (Function Points)</td>
<td>기술 독립적 규모 측정</td>
<td><code>UFP = Σ(count × weight)</code></td>
</tr>
<tr>
<td>COCOMO</td>
<td>대규모 폭포수 프로젝트</td>
<td><code>E = a × KLOC^b × Π(EM)</code></td>
</tr>
<tr>
<td>스토리 포인트 (Story Points)</td>
<td>애자일 스프린트</td>
<td>상대적; 속도로 교정</td>
</tr>
<tr>
<td>플래닝 포커 (Planning Poker)</td>
<td>팀 합의 추정</td>
<td>동시 공개 + 토론</td>
</tr>
<tr>
<td>티셔츠 사이즈 (T-shirt sizing)</td>
<td>에픽, 초기 로드맵</td>
<td>XS/S/M/L/XL</td>
</tr>
<tr>
<td>삼점 추정/PERT</td>
<td>작업 수준 불확실성</td>
<td><code>E = (O + 4M + P) / 6</code></td>
</tr>
<tr>
<td>WBS</td>
<td>범위 분해</td>
<td>100% 규칙; 개요 번호 부여</td>
</tr>
<tr>
<td>주경로 (Critical Path)</td>
<td>일정 최적화</td>
<td>Float = LS − ES</td>
</tr>
</tbody>
</table>
<p>핵심 원칙:
- 불확실성을 인정하고 소통하라; 불확실성의 원뿔을 사용해 기대치를 설정하라
- 애자일 팀에는 <strong>상대적 추정</strong>(스토리 포인트)을 선호하라; 절대 시간 추정보다 빠르고 정확하다
- 추정치에 대해 실제 결과를 <strong>철저히 추적</strong>하라; 그 데이터가 미래 추정 개선의 토대다
- 닻 내리기 편향, 낙관주의 편향, 관리 압박으로부터 추정치를 보호하라</p>
<hr />
<h2 id="15">15. 연습 문제<a class="header-link" href="#15" title="Permanent link">&para;</a></h2>
<p><strong>연습 1: PERT 추정</strong></p>
<p>소프트웨어 팀이 새 기능을 위해 세 가지 작업을 파악했다:</p>
<table>
<thead>
<tr>
<th>작업</th>
<th>낙관적</th>
<th>최빈값</th>
<th>비관적</th>
</tr>
</thead>
<tbody>
<tr>
<td>데이터베이스 마이그레이션</td>
<td>1일</td>
<td>2일</td>
<td>6일</td>
</tr>
<tr>
<td>API 구현</td>
<td>3일</td>
<td>5일</td>
<td>10일</td>
</tr>
<tr>
<td>프론트엔드 통합</td>
<td>2일</td>
<td>4일</td>
<td>9일</td>
</tr>
</tbody>
</table>
<p>작업들이 순차적(각 작업이 이전 작업에 의존)이라고 가정한다.</p>
<p>a. 각 작업의 PERT 기대 기간과 표준 편차를 계산하라.
b. 총 기대 프로젝트 기간과 표준 편차를 계산하라.
c. 프로젝트 완료일에 대한 90% 신뢰 구간을 계산하라.
d. 프로젝트 관리자가 "13일에 완료하겠습니다"라고 말한다. 이는 어느 정도의 성공 확률을 나타내는가? (힌트: Z-점수를 계산하라.)</p>
<hr />
<p><strong>연습 2: 기능 점수 계산</strong></p>
<p>온라인 설문 애플리케이션에 다음 컴포넌트가 있다:</p>
<ul>
<li>설문 생성 양식 (입력: 질문 + 최대 10개 선택지) — 평균 EI</li>
<li>투표 양식 (입력: 설문 ID + 선택지) — 낮음 EI</li>
<li>결과 보기 페이지 (출력: 선택지별 투표 막대 차트) — 평균 EO</li>
<li>키워드로 설문 검색 (입출력 쌍, 데이터 변경 없음) — 낮음 EQ</li>
<li>설문 테이블 (시스템이 유지) — 평균 ILF</li>
<li>사용자 테이블 (시스템이 유지) — 낮음 ILF</li>
<li>인증 서비스 (외부 시스템, 참조만 하고 유지하지 않음) — 낮음 EIF</li>
</ul>
<p>미조정 기능 점수(UFP)를 계산하라. 팀의 과거 생산성이 8 FP/인월이라면, 공수를 인월로 추정하라.</p>
<hr />
<p><strong>연습 3: 주경로</strong></p>
<p>다음 프로젝트 네트워크가 주어진다 (작업: 기간, 선행 작업):</p>
<table>
<thead>
<tr>
<th>작업</th>
<th>기간</th>
<th>선행 작업</th>
</tr>
</thead>
<tbody>
<tr>
<td>A</td>
<td>4일</td>
<td>—</td>
</tr>
<tr>
<td>B</td>
<td>6일</td>
<td>—</td>
</tr>
<tr>
<td>C</td>
<td>3일</td>
<td>A</td>
</tr>
<tr>
<td>D</td>
<td>5일</td>
<td>A, B</td>
</tr>
<tr>
<td>E</td>
<td>4일</td>
<td>C, D</td>
</tr>
<tr>
<td>F</td>
<td>2일</td>
<td>D</td>
</tr>
<tr>
<td>G</td>
<td>3일</td>
<td>E, F</td>
</tr>
</tbody>
</table>
<p>a. 네트워크 다이어그램을 그려라.
b. 전진/후진 계산을 수행해 각 작업의 ES, EF, LS, LF, 여유(Float)를 계산하라.
c. 주경로와 프로젝트 기간을 파악하라.
d. 작업 D가 2일 지연되면 새로운 프로젝트 기간은 얼마인가?</p>
<hr />
<p><strong>연습 4: 릴리스 계획</strong></p>
<p>제품 백로그에 240 스토리 포인트가 있다. 팀의 지난 4번의 스프린트 측정 속도는: 28, 32, 30, 26 포인트/스프린트 (2주 스프린트)이다.</p>
<p>a. 팀의 평균 속도를 계산하라.
b. 백로그를 완료하는 데 필요한 스프린트 수와 달력 기준 개월 수를 추정하라.
c. 제품 책임자가 우선순위 순으로 처음 100 스토리 포인트를 v1.0으로 릴리스하길 원한다. 몇 번의 스프린트가 필요한가?
d. 시니어 엔지니어 한 명이 한 스프린트 동안 휴가를 떠나 해당 스프린트 속도가 20% 감소한다. v1.0 릴리스 날짜에 어떤 영향을 미치는가?</p>
<hr />
<p><strong>연습 5: 추정 함정</strong></p>
<p>아래 각 시나리오에서 발생하고 있는 추정 함정을 파악하고 완화 방안을 제안하라:</p>
<p>a. 프로젝트 관리자가 팀이 추정을 하기도 전에 킥오프 회의에서 6개월 기한을 발표한다. 이후 모든 추정치가 6개월 근처로 모인다.
b. 팀이 어려운 데이터베이스 마이그레이션 작업을 3주 연속으로 "95% 완료"로 보고한다.
c. 개발자 한 명이 10일 스프린트의 9일째에야 대규모 기능 코딩을 시작한다.
d. 슬리핑하는 일정을 맞추기 위해 관리자가 남은 2주에 개발자 3명을 추가로 프로젝트에 투입한다.
e. 팀이 최선의 시나리오("모든 것이 순조롭다면")를 기반으로 기능을 추정하며, 통합 테스트에서 반복적으로 차단 버그가 발견된 과거 스프린트를 무시한다.</p>
<hr />
<h2 id="16">16. 더 읽을거리<a class="header-link" href="#16" title="Permanent link">&para;</a></h2>
<ul>
<li>McConnell, S. — <em>Software Estimation: Demystifying the Black Art</em> (Microsoft Press, 2006) — 이 주제에서 가장 실용적이고 읽기 쉬운 책</li>
<li>Boehm, B. — <em>Software Engineering Economics</em> (Prentice-Hall, 1981) — 원래 COCOMO; 기초 문헌</li>
<li>Boehm, B. et al. — <em>Software Cost Estimation with COCOMO II</em> (Prentice-Hall, 2000) — COCOMO II 전체 내용</li>
<li>Brooks, F. — <em>The Mythical Man-Month</em> (Addison-Wesley, 1975; 기념판 1995) — 필독서; Brooks의 법칙, 외과 팀 모델, 개념적 무결성</li>
<li>Kahneman, D. — <em>Thinking, Fast and Slow</em> (Farrar, Straus and Giroux, 2011) — 계획 오류와 닻 내리기를 포함한 인지 편향</li>
<li>Cohn, M. — <em>Agile Estimating and Planning</em> (Prentice-Hall, 2005) — 스토리 포인트, 플래닝 포커, 속도 기반 릴리스 계획</li>
<li>IFPUG — <em>IFPUG Function Point Counting Practices Manual</em> (Release 4.3.1) — 권위 있는 FPA 참고 문헌</li>
<li>PMI — <em>A Guide to the Project Management Body of Knowledge (PMBOK Guide)</em> — WBS, CPM, 획득 가치 관리</li>
</ul>
<hr />
<p><strong>이전</strong>: <a href="./05_Software_Modeling_and_UML.md">05. 소프트웨어 모델링과 UML</a> | <strong>다음</strong>: <a href="./07_Software_Quality_Assurance.md">07. 소프트웨어 품질 보증</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Software_Engineering/05_Software_Modeling_and_UML.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">레슨 05: 소프트웨어 모델링과 UML</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Software_Engineering/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Software_Engineering/07_Software_Quality_Assurance.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">레슨 07: 소프트웨어 품질 보증(Software Quality Assurance)</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}