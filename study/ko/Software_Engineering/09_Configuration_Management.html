{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>레슨 09: 형상 관리(Configuration Management) - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Software_Engineering/">Software Engineering</a>
    <span class="separator">/</span>
    <span class="current">레슨 09: 형상 관리(Configuration Management)</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>레슨 09: 형상 관리(Configuration Management)</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Software_Engineering/08_Verification_and_Validation.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">레슨 08: 검증과 확인 (Verification and Validation)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Software_Engineering/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Software_Engineering/10_Project_Management.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">레슨 10: 소프트웨어 프로젝트 관리(Software Project Management)</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#_1">목차</a></li>
<li><a href="#1">1. 소프트웨어 형상 관리란?</a><ul>
<li><a href="#11">1.1 정의</a></li>
<li><a href="#12-scm">1.2 SCM의 네 가지 핵심 기능</a></li>
<li><a href="#13-scm-devops">1.3 SCM과 DevOps</a></li>
</ul>
</li>
<li><a href="#2">2. 형상 항목과 기준선</a><ul>
<li><a href="#21-configuration-item">2.1 형상 항목(Configuration Item)</a></li>
<li><a href="#22-ci">2.2 CI 명명 및 식별</a></li>
<li><a href="#23-baseline">2.3 기준선(Baseline)</a></li>
</ul>
</li>
<li><a href="#3">3. 버전 관리 개념</a><ul>
<li><a href="#31">3.1 브랜치 전략</a><ul>
<li><a href="#gitflow">Gitflow</a></li>
<li><a href="#trunk-based-development-tbd">트렁크 기반 개발(Trunk-Based Development, TBD)</a></li>
<li><a href="#_2">전략 선택</a></li>
</ul>
</li>
<li><a href="#32">3.2 태깅과 릴리스 브랜치</a></li>
</ul>
</li>
<li><a href="#4">4. 빌드 관리</a><ul>
<li><a href="#41">4.1 좋은 빌드 시스템의 특성</a></li>
<li><a href="#42">4.2 빌드 스크립트와 도구</a></li>
<li><a href="#43-reproducible-build">4.3 재현 가능한 빌드(Reproducible Build)</a></li>
<li><a href="#44-artifact-repository">4.4 아티팩트 저장소(Artifact Repository)</a></li>
</ul>
</li>
<li><a href="#5">5. 릴리스 관리</a><ul>
<li><a href="#51-semantic-versioning-semver">5.1 시맨틱 버저닝(Semantic Versioning, SemVer)</a></li>
<li><a href="#52-release-notes">5.2 릴리스 노트(Release Notes)</a></li>
<li><a href="#53">5.3 릴리스 프로세스</a></li>
</ul>
</li>
<li><a href="#6">6. 변경 관리</a><ul>
<li><a href="#61">6.1 변경 요청 프로세스</a></li>
<li><a href="#62-change-control-board-ccb">6.2 변경 통제 위원회(Change Control Board, CCB)</a></li>
<li><a href="#63-emergency-change">6.3 긴급 변경(Emergency Change)</a></li>
<li><a href="#64-impact-analysis">6.4 영향 분석(Impact Analysis)</a></li>
</ul>
</li>
<li><a href="#7-configuration-auditing">7. 형상 감사(Configuration Auditing)</a><ul>
<li><a href="#71-functional-configuration-audit-fca">7.1 기능 형상 감사(Functional Configuration Audit, FCA)</a></li>
<li><a href="#72-physical-configuration-audit-pca">7.2 물리 형상 감사(Physical Configuration Audit, PCA)</a></li>
<li><a href="#73-software-bill-of-materials-sbom">7.3 소프트웨어 부품 명세서(Software Bill of Materials, SBOM)</a></li>
</ul>
</li>
<li><a href="#8">8. 환경 관리</a><ul>
<li><a href="#81">8.1 표준 환경</a></li>
<li><a href="#82-infrastructure-as-code-iac">8.2 코드형 인프라(Infrastructure as Code, IaC)</a></li>
<li><a href="#83-secrets">8.3 설정 파일과 시크릿(Secrets)</a></li>
</ul>
</li>
<li><a href="#9">9. 의존성 관리</a><ul>
<li><a href="#91-lockfile">9.1 잠금 파일(Lockfile)</a></li>
<li><a href="#92-version-pinning">9.2 버전 고정(Version Pinning)</a></li>
<li><a href="#93">9.3 의존성 취약점 스캔</a></li>
<li><a href="#94">9.4 의존성 업데이트 전략</a></li>
</ul>
</li>
<li><a href="#10">10. 도구 개요</a><ul>
<li><a href="#101-scm">10.1 SCM 기능별 도구</a></li>
<li><a href="#102-scm">10.2 완전한 SCM 툴체인 예시</a></li>
</ul>
</li>
<li><a href="#11_1">11. 요약</a></li>
<li><a href="#12">12. 연습 문제</a></li>
<li><a href="#13">13. 더 읽을거리</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="09-configuration-management">레슨 09: 형상 관리(Configuration Management)<a class="header-link" href="#09-configuration-management" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./08_Verification_and_Validation.md">08. 검증과 확인</a> | <strong>다음</strong>: <a href="./10_Project_Management.md">10. 프로젝트 관리</a></p>
<hr />
<p>소프트웨어 시스템은 결코 완성되지 않습니다 — 지속적으로 변경되고, 확장되며, 다양한 환경에 배포됩니다. 이러한 변경을 규율 있게 관리하지 않으면, 프로젝트는 혼돈에 빠집니다: 팀원들이 서로의 작업을 덮어쓰고, 운영 환경에서 아무도 재현할 수 없는 버전이 실행되며, 핫픽스 하나가 찾는 데 석 달이 걸리는 회귀 버그를 유발합니다. 소프트웨어 형상 관리(Software Configuration Management, SCM)는 이를 방지하는 규율입니다. 모든 산출물에 정확한 식별자를 부여하고, 변경 방식을 통제하며, 언제든 시스템의 특정 버전을 재현 가능하게 만듭니다.</p>
<p><strong>난이도</strong>: ⭐⭐⭐</p>
<p><strong>선수 학습</strong>:
- 버전 관리(Git 토픽 권장)에 대한 기본 이해
- 소프트웨어 개발 생명주기 이해 (레슨 02)
- 일반 프로그래밍 경험</p>
<p><strong>학습 목표</strong>:
- 소프트웨어 형상 관리(SCM)를 정의하고 소프트웨어 공학에서의 역할을 설명한다
- 형상 항목(Configuration Item)을 식별·분류하고 기준선(Baseline)을 수립한다
- 버전 관리를 위한 브랜치 전략을 설명하고 비교한다
- 빌드 관리와 재현 가능한 빌드의 특성을 설명한다
- 시맨틱 버저닝(Semantic Versioning)을 적용하고 릴리스 프로세스를 설계한다
- 공식적인 변경 관리 프로세스의 단계를 구별한다
- 환경 관리와 코드형 인프라(Infrastructure as Code)와의 관계를 설명한다
- 잠금 파일(Lockfile), 버전 고정(Pinning), 취약점 스캔을 활용하여 의존성을 안전하게 관리한다</p>
<hr />
<h2 id="_1">목차<a class="header-link" href="#_1" title="Permanent link">&para;</a></h2>
<ol>
<li><a href="#1-소프트웨어-형상-관리란">소프트웨어 형상 관리란?</a></li>
<li><a href="#2-형상-항목과-기준선">형상 항목과 기준선</a></li>
<li><a href="#3-버전-관리-개념">버전 관리 개념</a></li>
<li><a href="#4-빌드-관리">빌드 관리</a></li>
<li><a href="#5-릴리스-관리">릴리스 관리</a></li>
<li><a href="#6-변경-관리">변경 관리</a></li>
<li><a href="#7-형상-감사">형상 감사</a></li>
<li><a href="#8-환경-관리">환경 관리</a></li>
<li><a href="#9-의존성-관리">의존성 관리</a></li>
<li><a href="#10-도구-개요">도구 개요</a></li>
<li><a href="#11-요약">요약</a></li>
<li><a href="#12-연습-문제">연습 문제</a></li>
<li><a href="#13-더-읽을거리">더 읽을거리</a></li>
</ol>
<hr />
<h2 id="1">1. 소프트웨어 형상 관리란?<a class="header-link" href="#1" title="Permanent link">&para;</a></h2>
<h3 id="11">1.1 정의<a class="header-link" href="#11" title="Permanent link">&para;</a></h3>
<p><strong>소프트웨어 형상 관리(Software Configuration Management, SCM)</strong>는 요구사항 문서부터 운영 바이너리까지, 소프트웨어 개발 과정에서 생산되는 모든 산출물에 대한 변경을 식별, 추적, 통제하는 규율입니다.</p>
<p>IEEE는 이를 다음과 같이 정의합니다:</p>
<blockquote>
<p>"형상 항목의 기능적·물리적 특성을 식별하고 문서화하며, 해당 특성에 대한 변경을 통제하고, 변경 처리 및 구현 상태를 기록·보고하며, 명시된 요구사항과의 준수 여부를 검증하기 위해 기술적·관리적 지도와 감시를 적용하는 규율."</p>
</blockquote>
<p>다소 관료적으로 들릴 수 있지만, SCM은 실제로 시급한 문제들을 해결합니다:</p>
<table>
<thead>
<tr>
<th>SCM 없이 발생하는 문제</th>
<th>SCM 해결책</th>
</tr>
</thead>
<tbody>
<tr>
<td>"운영 환경에 어떤 버전이 배포되어 있는가?"</td>
<td>기준선(Baseline)과 릴리스 태깅</td>
</tr>
<tr>
<td>"누가 빌드를 망쳤고 어떻게 된 건가?"</td>
<td>버전 관리 이력 + CI/CD 로그</td>
</tr>
<tr>
<td>"지난 달 릴리스를 재현할 수 없다"</td>
<td>잠긴 의존성, VCS의 빌드 스크립트</td>
</tr>
<tr>
<td>"두 개발자가 같은 파일을 편집했다"</td>
<td>브랜치 전략과 병합 워크플로우</td>
</tr>
<tr>
<td>"모듈 A의 변경이 모듈 B를 망가뜨렸다"</td>
<td>변경 관리 + 영향 분석</td>
</tr>
<tr>
<td>"개발 환경이 운영 환경과 다르게 동작한다"</td>
<td>환경 관리 / 코드형 인프라(IaC)</td>
</tr>
</tbody>
</table>
<h3 id="12-scm">1.2 SCM의 네 가지 핵심 기능<a class="header-link" href="#12-scm" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>┌─────────────────────────────────────────────────────────────────┐
│  소프트웨어 형상 관리(Software Configuration Management)         │
│                                                                 │
│  ┌──────────────────┐    ┌──────────────────┐                  │
│  │  식별(Identification)│    │  통제(Control)   │                  │
│  │                  │    │                  │                  │
│  │ 모든 산출물에    │    │ 변경을 체계적으로│                  │
│  │ 이름 부여 및 추적│    │ 관리            │                  │
│  └──────────────────┘    └──────────────────┘                  │
│                                                                 │
│  ┌──────────────────┐    ┌──────────────────┐                  │
│  │  회계(Accounting) │    │  감사(Auditing)   │                  │
│  │                  │    │                  │                  │
│  │ 모든 CI의 상태   │    │ 산출물이 기준선  │                  │
│  │ 기록; 변경 이력  │    │ 과 일치하는지    │                  │
│  │ 보고            │    │ 검증; 프로세스 확인│                  │
│  └──────────────────┘    └──────────────────┘                  │
└─────────────────────────────────────────────────────────────────┘
</code></pre></div>

<h3 id="13-scm-devops">1.3 SCM과 DevOps<a class="header-link" href="#13-scm-devops" title="Permanent link">&para;</a></h3>
<p>SCM은 DevOps보다 수십 년 앞서 등장했습니다 (1950년대 방위 계약에서 유래). DevOps는 SCM의 원칙을 채택하고 자동화합니다:</p>
<table>
<thead>
<tr>
<th>SCM 개념</th>
<th>DevOps/현대적 실천</th>
</tr>
</thead>
<tbody>
<tr>
<td>형상 식별(Configuration identification)</td>
<td>Git 커밋과 태그; Docker 이미지 다이제스트</td>
</tr>
<tr>
<td>버전 관리(Version control)</td>
<td>Git, GitHub/GitLab</td>
</tr>
<tr>
<td>변경 통제(Change control)</td>
<td>풀 리퀘스트(Pull Request), 코드 리뷰</td>
</tr>
<tr>
<td>빌드 관리(Build management)</td>
<td>CI 파이프라인 (GitHub Actions, Jenkins)</td>
</tr>
<tr>
<td>릴리스 관리(Release management)</td>
<td>CD 파이프라인, GitOps</td>
</tr>
<tr>
<td>환경 관리(Environment management)</td>
<td>코드형 인프라(Terraform, Ansible)</td>
</tr>
<tr>
<td>감사(Auditing)</td>
<td>감사 로그, SBOM (소프트웨어 부품 명세서)</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="2">2. 형상 항목과 기준선<a class="header-link" href="#2" title="Permanent link">&para;</a></h2>
<h3 id="21-configuration-item">2.1 형상 항목(Configuration Item)<a class="header-link" href="#21-configuration-item" title="Permanent link">&para;</a></h3>
<p><strong>형상 항목(Configuration Item, CI)</strong>은 형상 통제 대상에 포함되는 모든 산출물 — 고유한 식별자가 부여되고 변경이 추적되는 것 — 입니다. CI는 소스 코드만을 의미하지 않습니다.</p>
<table>
<thead>
<tr>
<th>범주</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>소스 코드</strong></td>
<td>애플리케이션 코드, 스크립트, 테스트 코드, 데이터베이스 마이그레이션</td>
</tr>
<tr>
<td><strong>빌드 산출물</strong></td>
<td>컴파일된 바이너리, 컨테이너 이미지, 패키지</td>
</tr>
<tr>
<td><strong>문서</strong></td>
<td>요구사항, 설계 문서, 사용자 매뉴얼, API 명세</td>
</tr>
<tr>
<td><strong>테스트 산출물</strong></td>
<td>테스트 계획, 테스트 케이스, 테스트 데이터, 테스트 스크립트</td>
</tr>
<tr>
<td><strong>설정 파일</strong></td>
<td><code>application.yaml</code>, <code>.env.example</code>, nginx 설정, Kubernetes 매니페스트</td>
</tr>
<tr>
<td><strong>서드파티 컴포넌트</strong></td>
<td>벤더 라이브러리, 라이선스 파일</td>
</tr>
<tr>
<td><strong>인프라 코드</strong></td>
<td>Terraform <code>.tf</code> 파일, Ansible 플레이북, Dockerfile</td>
</tr>
<tr>
<td><strong>프로젝트 관리</strong></td>
<td>프로젝트 계획, 위험 관리 대장, 릴리스 노트</td>
</tr>
</tbody>
</table>
<p><strong>CI 선정 기준</strong>: 다음 조건을 만족하면 CI로 지정해야 합니다:
- 변경을 추적하고 감사해야 하는 경우
- 동시에 여러 버전이 존재하는 경우
- 해당 산출물의 무결성이 시스템 무결성에 영향을 미치는 경우
- 이전 상태로 되돌릴 필요가 있을 수 있는 경우</p>
<h3 id="22-ci">2.2 CI 명명 및 식별<a class="header-link" href="#22-ci" title="Permanent link">&para;</a></h3>
<p>모든 CI에는 다음을 포함하는 고유 식별자가 필요합니다:
- <strong>이름(Name)</strong>: 설명적이고 명명 규칙과 일관된 이름
- <strong>유형(Type)</strong>: 소스, 문서, 테스트 산출물 등
- <strong>버전(Version)</strong>: 개정판을 구별하는 번호 또는 해시
- <strong>변형(Variant)</strong>: 선택적, 플랫폼별 버전용 (예: <code>linux-amd64</code>, <code>macos-arm64</code>)</p>
<div class="highlight"><pre><span></span><code><span class="err">명명</span><span class="w"> </span><span class="err">체계</span><span class="w"> </span><span class="err">예시</span><span class="p">:</span>
<span class="w">  </span><span class="p">{</span><span class="n">project</span><span class="p">}</span><span class="o">-</span><span class="p">{</span><span class="n">component</span><span class="p">}</span><span class="o">-</span><span class="p">{</span><span class="n">version</span><span class="p">}</span><span class="o">-</span><span class="p">{</span><span class="n">variant</span><span class="p">}</span><span class="o">.</span><span class="p">{</span><span class="n">ext</span><span class="p">}</span>

<span class="w">  </span><span class="n">myapp</span><span class="o">-</span><span class="n">api</span><span class="o">-</span><span class="mf">1.4</span><span class="o">.</span><span class="mi">2</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">amd64</span><span class="o">.</span><span class="n">tar</span><span class="o">.</span><span class="n">gz</span>
<span class="w">  </span><span class="n">myapp</span><span class="o">-</span><span class="n">api</span><span class="o">-</span><span class="mf">1.4</span><span class="o">.</span><span class="mi">2</span><span class="o">-</span><span class="n">windows</span><span class="o">-</span><span class="n">amd64</span><span class="o">.</span><span class="n">zip</span>
<span class="w">  </span><span class="n">myapp</span><span class="o">-</span><span class="n">docs</span><span class="o">-</span><span class="mf">1.4</span><span class="o">.</span><span class="mf">2.</span><span class="n">pdf</span>
</code></pre></div>

<h3 id="23-baseline">2.3 기준선(Baseline)<a class="header-link" href="#23-baseline" title="Permanent link">&para;</a></h3>
<p><strong>기준선(Baseline)</strong>은 하나 이상의 CI에 대해 공식적으로 검토·합의된 스냅샷으로, 이후 개발의 고정된 참조점 역할을 합니다. 특정 시점의 "공식 버전"입니다.</p>
<table>
<thead>
<tr>
<th>기준선 유형</th>
<th>수립 시점</th>
<th>내용</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>기능 기준선(Functional Baseline)</strong></td>
<td>시스템 요구사항 검토 후</td>
<td>승인된 요구사항 명세</td>
</tr>
<tr>
<td><strong>할당 기준선(Allocated Baseline)</strong></td>
<td>예비 설계 검토 후</td>
<td>승인된 아키텍처 및 고수준 설계</td>
</tr>
<tr>
<td><strong>제품 기준선(Product Baseline)</strong></td>
<td>최종 인수 테스트 후</td>
<td>릴리스를 위한 전체 소스 코드, 문서, 테스트</td>
</tr>
<tr>
<td><strong>운영 기준선(Operational Baseline)</strong></td>
<td>운영 중</td>
<td>모든 패치를 포함한 배포 구성</td>
</tr>
</tbody>
</table>
<p>현대적 실천에서 기준선은 메인 브랜치의 Git 태그에 해당합니다:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># v1.4.2 제품 기준선 수립</span>
git<span class="w"> </span>tag<span class="w"> </span>-a<span class="w"> </span>v1.4.2<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Product baseline: Q1 2024 release</span>

<span class="s2">Approved by: Product team 2024-03-28</span>
<span class="s2">Change control ticket: CCB-2024-031</span>
<span class="s2">Includes: api-service, worker-service, migrations 001-047&quot;</span>

git<span class="w"> </span>push<span class="w"> </span>origin<span class="w"> </span>v1.4.2
</code></pre></div>

<hr />
<h2 id="3">3. 버전 관리 개념<a class="header-link" href="#3" title="Permanent link">&para;</a></h2>
<p>버전 관리 시스템(VCS)은 SCM의 기술적 근간입니다. 이 절은 전략에 초점을 맞추며, 세부 기술은 Git 토픽에서 다룹니다.</p>
<h3 id="31">3.1 브랜치 전략<a class="header-link" href="#31" title="Permanent link">&para;</a></h3>
<p>브랜치 전략은 팀이 동시 개발과 릴리스를 관리하기 위해 브랜치를 사용하는 방법을 정의합니다.</p>
<h4 id="gitflow">Gitflow<a class="header-link" href="#gitflow" title="Permanent link">&para;</a></h4>
<p>정기적 릴리스(월별/분기별)를 하는 팀에 적합합니다.</p>
<div class="highlight"><pre><span></span><code>main          ─────────────●──────────────────●─────────
                          ↑ v1.0              ↑ v2.0
develop       ──────●──────────────●──────────────────●──
                    ↑              ↑
feature/login ──────●              │
                                   │
feature/pay   ────────────────────●│
                                    │
release/2.0   ───────────────────────●────────●──────────
                                    (test)   (merge)
hotfix/2.0.1  ─────────────────────────────────────●─────
</code></pre></div>

<p><strong>브랜치 구성</strong>:
- <code>main</code>: 운영 준비된 코드만 포함; 항상 릴리스 가능
- <code>develop</code>: 통합 브랜치; 최신 개발 변경사항
- <code>feature/*</code>: 개별 기능, develop에서 분기
- <code>release/*</code>: 릴리스 준비 (버그 수정만, 신기능 없음)
- <code>hotfix/*</code>: 긴급 운영 수정, main에서 분기</p>
<h4 id="trunk-based-development-tbd">트렁크 기반 개발(Trunk-Based Development, TBD)<a class="header-link" href="#trunk-based-development-tbd" title="Permanent link">&para;</a></h4>
<p>지속적 배포(매일 또는 더 자주 릴리스)를 하는 팀에 적합합니다.</p>
<div class="highlight"><pre><span></span><code>main (trunk)  ──●──●──●──●──●──●──●──●──●──●──●──●──
               ↑  ↑     ↑           ↑
             feat1 feat2 feat3     feat4
              (단기 브랜치, 1~2일 이내)
</code></pre></div>

<p>모든 개발자가 최소 하루에 한 번 main에 통합합니다. 기능 플래그(Feature Flag)가 운영 환경에서 무엇을 활성화할지 제어하여, 배포와 릴리스를 분리합니다.</p>
<h4 id="_2">전략 선택<a class="header-link" href="#_2" title="Permanent link">&para;</a></h4>
<table>
<thead>
<tr>
<th>요소</th>
<th>Gitflow</th>
<th>트렁크 기반 개발</th>
</tr>
</thead>
<tbody>
<tr>
<td>릴리스 주기</td>
<td>정기적 (주/월 단위)</td>
<td>지속적 (매일)</td>
</tr>
<tr>
<td>팀 규모</td>
<td>모든 규모</td>
<td>소규모·훈련된 팀에 더 적합</td>
</tr>
<tr>
<td>테스트 자동화</td>
<td>중간 수준 허용</td>
<td>강력한 자동화 테스트 필수</td>
</tr>
<tr>
<td>기능 플래그 필요 여부</td>
<td>불필요</td>
<td>필요</td>
</tr>
<tr>
<td>장기 브랜치</td>
<td>있음 (기능 브랜치)</td>
<td>없음 (2일 미만)</td>
</tr>
</tbody>
</table>
<h3 id="32">3.2 태깅과 릴리스 브랜치<a class="header-link" href="#32" title="Permanent link">&para;</a></h3>
<p>태그는 특정 커밋을 중요한 것으로 표시합니다. 모든 릴리스에는 태그를 붙여야 합니다.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 어노테이션 태그 (릴리스에 권장 — 메타데이터 포함)</span>
git<span class="w"> </span>tag<span class="w"> </span>-a<span class="w"> </span>v1.4.2<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Release v1.4.2 - Q1 2024&quot;</span>

<span class="c1"># 버전 순으로 태그 목록 표시</span>
git<span class="w"> </span>tag<span class="w"> </span>--sort<span class="o">=</span>version:refname

<span class="c1"># 이전 버전에 긴급 패치를 위한 릴리스 브랜치 생성</span>
git<span class="w"> </span>checkout<span class="w"> </span>-b<span class="w"> </span>release/1.3<span class="w"> </span>v1.3.0
git<span class="w"> </span>cherry-pick<span class="w"> </span>abc1234<span class="w">  </span><span class="c1"># 핫픽스 적용</span>
git<span class="w"> </span>tag<span class="w"> </span>-a<span class="w"> </span>v1.3.1<span class="w"> </span>-m<span class="w"> </span><span class="s2">&quot;Hotfix v1.3.1&quot;</span>
</code></pre></div>

<hr />
<h2 id="4">4. 빌드 관리<a class="header-link" href="#4" title="Permanent link">&para;</a></h2>
<p><strong>빌드(Build)</strong>는 소스 코드와 리소스를 배포 가능한 산출물로 변환하는 프로세스입니다. 빌드 관리는 이 프로세스가 신뢰할 수 있고, 재현 가능하며, 자동화되도록 보장합니다.</p>
<h3 id="41">4.1 좋은 빌드 시스템의 특성<a class="header-link" href="#41" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>특성</th>
<th>설명</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>재현 가능(Reproducible)</strong></td>
<td>동일한 입력은 항상 동일한 출력을 생성</td>
<td>잠긴 의존성; 무작위 요소 없음</td>
</tr>
<tr>
<td><strong>자동화(Automated)</strong></td>
<td>수동 단계 불필요</td>
<td>CI 파이프라인이 모든 커밋에서 빌드 실행</td>
</tr>
<tr>
<td><strong>빠름(Fast)</strong></td>
<td>증분 빌드 — 변경된 것만 재빌드</td>
<td>Make, Gradle 증분 컴파일</td>
</tr>
<tr>
<td><strong>멱등성(Idempotent)</strong></td>
<td>빌드를 두 번 실행해도 동일한 결과</td>
<td>빌드 자체에 부작용 없음</td>
</tr>
<tr>
<td><strong>문서화(Documented)</strong></td>
<td>빌드 프로세스가 구전이 아닌 코드로 정의됨</td>
<td>VCS의 <code>Makefile</code>, <code>build.gradle</code>, <code>pyproject.toml</code></td>
</tr>
<tr>
<td><strong>검증(Verified)</strong></td>
<td>빌드에 품질 게이트 포함</td>
<td>파이프라인의 테스트, 린팅, 보안 스캔</td>
</tr>
</tbody>
</table>
<h3 id="42">4.2 빌드 스크립트와 도구<a class="header-link" href="#42" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="c"># Makefile: 폴리글랏 프로젝트의 공통 빌드 자동화</span>
<span class="nf">.PHONY</span><span class="o">:</span><span class="w"> </span><span class="n">all</span> <span class="n">clean</span> <span class="n">test</span> <span class="n">lint</span> <span class="n">build</span> <span class="n">docker</span>

<span class="c"># 기본 타겟</span>
<span class="nf">all</span><span class="o">:</span><span class="w"> </span><span class="n">lint</span> <span class="n">test</span> <span class="n">build</span>

<span class="c"># 의존성 설치</span>
<span class="nf">deps</span><span class="o">:</span>
<span class="w">    </span>pip<span class="w"> </span>install<span class="w"> </span>-r<span class="w"> </span>requirements.txt
<span class="w">    </span>pip<span class="w"> </span>install<span class="w"> </span>-r<span class="w"> </span>requirements-dev.txt

<span class="c"># 린터 실행</span>
<span class="nf">lint</span><span class="o">:</span>
<span class="w">    </span>flake8<span class="w"> </span>src/<span class="w"> </span>--max-line-length<span class="o">=</span><span class="m">100</span>
<span class="w">    </span>mypy<span class="w"> </span>src/

<span class="c"># 커버리지와 함께 테스트 실행</span>
<span class="nf">test</span><span class="o">:</span>
<span class="w">    </span>pytest<span class="w"> </span>tests/<span class="w"> </span>-v<span class="w"> </span>--cov<span class="o">=</span>src<span class="w"> </span>--cov-fail-under<span class="o">=</span><span class="m">85</span>

<span class="c"># 운영 산출물 빌드</span>
<span class="nf">build</span><span class="o">:</span>
<span class="w">    </span>python<span class="w"> </span>-m<span class="w"> </span>build<span class="w"> </span>--wheel
<span class="w">    </span>@echo<span class="w"> </span><span class="s2">&quot;Build artifact: dist/&quot;</span>

<span class="c"># git SHA를 태그로 사용하여 Docker 이미지 빌드</span>
<span class="nf">docker</span><span class="o">:</span>
<span class="w">    </span>docker<span class="w"> </span>build<span class="w"> </span><span class="se">\</span>
<span class="w">      </span>--build-arg<span class="w"> </span><span class="nv">GIT_SHA</span><span class="o">=</span><span class="k">$(</span>shell<span class="w"> </span>git<span class="w"> </span>rev-parse<span class="w"> </span>--short<span class="w"> </span>HEAD<span class="k">)</span><span class="w"> </span><span class="se">\</span>
<span class="w">      </span>--build-arg<span class="w"> </span><span class="nv">BUILD_DATE</span><span class="o">=</span><span class="k">$(</span>shell<span class="w"> </span>date<span class="w"> </span>-u<span class="w"> </span>+%Y-%m-%dT%H:%M:%SZ<span class="k">)</span><span class="w"> </span><span class="se">\</span>
<span class="w">      </span>-t<span class="w"> </span>myapp:<span class="k">$(</span>shell<span class="w"> </span>git<span class="w"> </span>rev-parse<span class="w"> </span>--short<span class="w"> </span>HEAD<span class="k">)</span><span class="w"> </span><span class="se">\</span>
<span class="w">      </span>-t<span class="w"> </span>myapp:latest<span class="w"> </span><span class="se">\</span>
<span class="w">      </span>.

<span class="c"># 생성된 산출물 정리</span>
<span class="nf">clean</span><span class="o">:</span>
<span class="w">    </span>rm<span class="w"> </span>-rf<span class="w"> </span>dist/<span class="w"> </span>build/<span class="w"> </span>*.egg-info<span class="w"> </span>.coverage<span class="w"> </span>htmlcov/<span class="w"> </span>.mypy_cache/
<span class="w">    </span>find<span class="w"> </span>.<span class="w"> </span>-name<span class="w"> </span><span class="s2">&quot;*.pyc&quot;</span><span class="w"> </span>-delete
<span class="w">    </span>find<span class="w"> </span>.<span class="w"> </span>-name<span class="w"> </span><span class="s2">&quot;__pycache__&quot;</span><span class="w"> </span>-delete
</code></pre></div>

<h3 id="43-reproducible-build">4.3 재현 가능한 빌드(Reproducible Build)<a class="header-link" href="#43-reproducible-build" title="Permanent link">&para;</a></h3>
<p><strong>재현 가능한 빌드</strong>는 동일한 소스를 입력받으면 비트 단위로 동일한 출력을 생성합니다. 이를 통해:
- 배포된 바이너리가 공개된 소스 코드에 해당하는지 검증 가능
- 공급망 공격(빌드 환경 변조) 탐지 가능
- 빌드 산출물의 신뢰할 수 있는 캐싱 가능</p>
<div class="highlight"><pre><span></span><code><span class="c"># 재현성을 위해 설계된 Dockerfile</span>
<span class="c"># 1. 기본 이미지를 태그가 아닌 특정 다이제스트로 고정</span>
<span class="k">FROM</span><span class="w"> </span><span class="s">python:3.12.3-slim@sha256:a1e3204e39b5f3e2c3f74bc7fdf14e2ae1dfba9ab8bb1cde0f3a5b1c5e2c2d3f</span>

<span class="c"># 2. 파일 메타데이터의 고정된 타임스탬프 설정</span>
<span class="k">ARG</span><span class="w"> </span><span class="nv">SOURCE_DATE_EPOCH</span><span class="o">=</span><span class="m">1711670400</span>

<span class="c"># 3. 모든 시스템 패키지 고정</span>
<span class="k">RUN</span><span class="w"> </span>apt-get<span class="w"> </span>update<span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span>apt-get<span class="w"> </span>install<span class="w"> </span>-y<span class="w"> </span>--no-install-recommends<span class="w"> </span><span class="se">\</span>
<span class="w">    </span><span class="nv">libpq5</span><span class="o">=</span><span class="m">15</span>.6-0+deb12u1<span class="w"> </span><span class="se">\</span>
<span class="w">    </span><span class="o">&amp;&amp;</span><span class="w"> </span>rm<span class="w"> </span>-rf<span class="w"> </span>/var/lib/apt/lists/*

<span class="k">WORKDIR</span><span class="w"> </span><span class="s">/app</span>

<span class="c"># 4. 잠금 파일(lockfile)에서 설치 (requirements.txt만 사용하지 않음)</span>
<span class="k">COPY</span><span class="w"> </span>requirements.lock<span class="w"> </span>.
<span class="k">RUN</span><span class="w"> </span>pip<span class="w"> </span>install<span class="w"> </span>--no-cache-dir<span class="w"> </span>-r<span class="w"> </span>requirements.lock

<span class="k">COPY</span><span class="w"> </span>src/<span class="w"> </span>./src/

<span class="c"># 5. 출처(provenance) 메타데이터 포함</span>
<span class="k">ARG</span><span class="w"> </span>GIT_SHA
<span class="k">ARG</span><span class="w"> </span>BUILD_DATE
<span class="k">LABEL</span><span class="w"> </span>org.opencontainers.image.revision<span class="o">=</span><span class="nv">$GIT_SHA</span><span class="w"> </span><span class="se">\</span>
<span class="w">      </span>org.opencontainers.image.created<span class="o">=</span><span class="nv">$BUILD_DATE</span><span class="w"> </span><span class="se">\</span>
<span class="w">      </span>org.opencontainers.image.source<span class="o">=</span><span class="s2">&quot;https://github.com/org/myapp&quot;</span>

<span class="k">CMD</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;python&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;-m&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;myapp&quot;</span><span class="p">]</span>
</code></pre></div>

<h3 id="44-artifact-repository">4.4 아티팩트 저장소(Artifact Repository)<a class="header-link" href="#44-artifact-repository" title="Permanent link">&para;</a></h3>
<p>빌드 산출물은 <strong>아티팩트 저장소</strong> — 바이너리, 패키지, 컨테이너 이미지를 위한 버전 관리되고 검색 가능한 저장소 — 에 보관해야 합니다.</p>
<table>
<thead>
<tr>
<th>아티팩트 유형</th>
<th>저장소</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python 패키지</td>
<td>PyPI, Artifactory, AWS CodeArtifact</td>
</tr>
<tr>
<td>Java/JVM 패키지</td>
<td>Maven Central, Nexus</td>
</tr>
<tr>
<td>Docker 이미지</td>
<td>Docker Hub, ECR, GCR, GHCR</td>
</tr>
<tr>
<td>Helm 차트</td>
<td>Helm repo, OCI 레지스트리</td>
</tr>
<tr>
<td>일반 바이너리</td>
<td>Artifactory, S3 (버전 관리 활성화)</td>
</tr>
</tbody>
</table>
<p>배포 시 소스에서 빌드하지 마십시오. 한 번 빌드하고, 산출물을 저장하고, 산출물을 배포하십시오.</p>
<hr />
<h2 id="5">5. 릴리스 관리<a class="header-link" href="#5" title="Permanent link">&para;</a></h2>
<p>릴리스 관리는 소프트웨어 버전이 패키징되고, 버전이 지정되며, 사용자에게 전달되는 방식을 관장합니다.</p>
<h3 id="51-semantic-versioning-semver">5.1 시맨틱 버저닝(Semantic Versioning, SemVer)<a class="header-link" href="#51-semantic-versioning-semver" title="Permanent link">&para;</a></h3>
<p>시맨틱 버저닝(semver.org)은 버전 번호의 범용적인 문법을 제공합니다:</p>
<div class="highlight"><pre><span></span><code>MAJOR.MINOR.PATCH[-PRERELEASE][+BUILD]

예시:
  1.0.0          초기 안정 릴리스
  1.0.1          패치: 하위 호환 버그 수정
  1.1.0          마이너: 하위 호환 신기능 추가
  2.0.0          메이저: 호환성을 깨는 변경 (API 비호환)
  2.1.0-alpha.1  프리릴리스: 불안정, 운영 사용 불가
  2.1.0-rc.1     릴리스 후보: 기능 완성, 최종 테스트 단계
  1.0.0+build.42 빌드 메타데이터: 정보 제공용, 우선순위 비교에서 무시
</code></pre></div>

<p><strong>버전 우선순위 규칙</strong>:</p>
<div class="highlight"><pre><span></span><code><span class="mf">1.0.0</span><span class="o">-</span><span class="n">alpha</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1.0.0</span><span class="o">-</span><span class="n">alpha</span><span class="mf">.1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1.0.0</span><span class="o">-</span><span class="n">beta</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1.0.0</span><span class="o">-</span><span class="n">rc</span><span class="mf">.1</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mf">1.0.0</span>
</code></pre></div>

<p><strong>증가 시점</strong>:
- <strong>PATCH</strong>: 공개 API를 변경하지 않고 버그를 수정할 때
- <strong>MINOR</strong>: 하위 호환 방식으로 기능을 추가할 때
- <strong>MAJOR</strong>: 비호환 API 변경을 할 때</p>
<p>라이브러리의 경우, 엄격한 SemVer는 하위 소비자를 보호합니다. 애플리케이션(라이브러리가 아닌)의 경우, MAJOR 버전은 종종 제품 세대나 연간 릴리스를 추적합니다.</p>
<h3 id="52-release-notes">5.2 릴리스 노트(Release Notes)<a class="header-link" href="#52-release-notes" title="Permanent link">&para;</a></h3>
<p>릴리스 노트는 변경사항을 사용자에게 전달합니다. 좋은 릴리스 노트는 다음 질문에 답합니다:
- 무엇이 변경되었는가?
- 나(사용자)에게 왜 중요한가?
- 내가 무언가를 해야 하는가?</p>
<div class="highlight"><pre><span></span><code><span class="gh"># Release Notes: v2.3.0 (2024-03-28)</span>

<span class="gu">## What&#39;s New</span>

<span class="k">-</span><span class="w"> </span><span class="gs">**Bulk export**</span>: export up to 10,000 records to CSV in one operation (#1847)
<span class="k">-</span><span class="w"> </span><span class="gs">**Dark mode**</span>: full dark mode support across all screens (#2103)
<span class="k">-</span><span class="w"> </span><span class="gs">**API rate limiting**</span>: new <span class="sb">`X-RateLimit-*`</span> response headers (#2251)

<span class="gu">## Bug Fixes</span>

<span class="k">-</span><span class="w"> </span>Fixed: session expired users were redirected to blank page (#2289)
<span class="k">-</span><span class="w"> </span>Fixed: decimal amounts rounded incorrectly for JPY and KRW (#2301)

<span class="gu">## Breaking Changes</span>

<span class="k">-</span><span class="w"> </span><span class="gs">**API**</span>: <span class="sb">`GET /users`</span> no longer returns the <span class="sb">`password_hash`</span> field.
  Update any clients that read this field. (#2275)

<span class="gu">## Deprecations</span>

<span class="k">-</span><span class="w"> </span><span class="sb">`POST /api/v1/auth/login`</span> is deprecated. Use <span class="sb">`POST /api/v2/auth/login`</span>.
  v1 will be removed in v3.0.0 (Q3 2024).

<span class="gu">## Upgrade Notes</span>

Run the following migration before upgrading:
</code></pre></div>

<p>python manage.py migrate --run-syncdb</p>
<div class="highlight"><pre><span></span><code>## Known Issues

- Safari 16.x: dark mode toggle may require a page refresh.
  Workaround: use the keyboard shortcut Cmd+Shift+D.
</code></pre></div>

<h3 id="53">5.3 릴리스 프로세스<a class="header-link" href="#53" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>기능 동결(Feature freeze)
      │
      ▼
릴리스 브랜치 생성 (release/2.3)
      │
      ▼
릴리스 브랜치에서 회귀 테스트
      │
      ├── 버그 발견? → 릴리스 브랜치에서 수정 → main으로 cherry-pick
      │
      ▼
릴리스 후보 (v2.3.0-rc.1)
      │
      ▼
스테이징 배포 + 인수 테스트
      │
      ├── 문제 발견? → rc 번호 증가 (v2.3.0-rc.2)
      │
      ▼
운영 배포 (단계적/블루-그린)
      │
      ▼
커밋 태깅: v2.3.0
      │
      ▼
릴리스 브랜치를 main에 병합
      │
      ▼
릴리스 노트 게시 + 이해관계자 통보
</code></pre></div>

<hr />
<h2 id="6">6. 변경 관리<a class="header-link" href="#6" title="Permanent link">&para;</a></h2>
<p>변경 관리는 기준선이 설정된 CI에 대한 모든 수정이 통제된 프로세스를 따르도록 보장합니다. 시스템 무결성을 훼손하는 임의적인 변경을 방지합니다.</p>
<h3 id="61">6.1 변경 요청 프로세스<a class="header-link" href="#61" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code><span class="mf">1.</span><span class="w"> </span><span class="n">개시</span><span class="p">(</span><span class="n">INITIATION</span><span class="p">)</span>
<span class="w">   </span><span class="n">누구나</span><span class="w"> </span><span class="n">변경</span><span class="w"> </span><span class="n">요청</span><span class="p">(</span><span class="n">CR</span><span class="p">)</span><span class="w"> </span><span class="n">또는</span><span class="w"> </span><span class="n">변경</span><span class="w"> </span><span class="n">요구서</span><span class="p">(</span><span class="n">RFC</span><span class="p">)</span><span class="n">를</span><span class="w"> </span><span class="n">제출할</span><span class="w"> </span><span class="n">수</span><span class="w"> </span><span class="n">있음</span>
<span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="n">CR</span><span class="w"> </span><span class="n">포함</span><span class="w"> </span><span class="n">내용</span><span class="p">:</span><span class="w"> </span><span class="n">설명</span><span class="p">,</span><span class="w"> </span><span class="n">정당성</span><span class="p">,</span><span class="w"> </span><span class="n">영향</span><span class="w"> </span><span class="n">받는</span><span class="w"> </span><span class="n">컴포넌트</span><span class="p">,</span><span class="w"> </span><span class="n">긴급도</span>

<span class="mf">2.</span><span class="w"> </span><span class="n">영향</span><span class="w"> </span><span class="n">분석</span><span class="p">(</span><span class="n">IMPACT</span><span class="w"> </span><span class="n">ANALYSIS</span><span class="p">)</span>
<span class="w">   </span><span class="n">기술팀이</span><span class="w"> </span><span class="n">평가</span><span class="p">:</span>
<span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">어떤</span><span class="w"> </span><span class="n">CI가</span><span class="w"> </span><span class="n">영향을</span><span class="w"> </span><span class="n">받는가</span><span class="err">?</span>
<span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">구현</span><span class="w"> </span><span class="n">노력</span><span class="o">/</span><span class="n">비용은</span><span class="w"> </span><span class="n">얼마인가</span><span class="err">?</span>
<span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">위험은</span><span class="w"> </span><span class="n">무엇인가</span><span class="err">?</span>
<span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="n">하지</span><span class="w"> </span><span class="n">않을</span><span class="w"> </span><span class="n">경우의</span><span class="w"> </span><span class="n">위험은</span><span class="w"> </span><span class="n">무엇인가</span><span class="err">?</span>

<span class="mf">3.</span><span class="w"> </span><span class="n">검토</span><span class="w"> </span><span class="n">및</span><span class="w"> </span><span class="n">승인</span><span class="p">(</span><span class="n">REVIEW</span><span class="w"> </span><span class="ow">AND</span><span class="w"> </span><span class="n">APPROVAL</span><span class="p">)</span>
<span class="w">   </span><span class="n">변경</span><span class="w"> </span><span class="n">통제</span><span class="w"> </span><span class="n">위원회</span><span class="p">(</span><span class="n">CCB</span><span class="p">)</span><span class="n">가</span><span class="w"> </span><span class="n">검토</span><span class="p">:</span>
<span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">승인</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">일정</span><span class="w"> </span><span class="n">계획</span><span class="w"> </span><span class="n">및</span><span class="w"> </span><span class="n">담당자</span><span class="w"> </span><span class="n">지정</span>
<span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">연기</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">조건부로</span><span class="w"> </span><span class="n">백로그에</span><span class="w"> </span><span class="n">추가</span>
<span class="w">   </span><span class="err">├──</span><span class="w"> </span><span class="n">거부</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="n">사유</span><span class="w"> </span><span class="n">문서화</span>
<span class="w">   </span><span class="err">└──</span><span class="w"> </span><span class="n">추가</span><span class="w"> </span><span class="n">정보</span><span class="w"> </span><span class="n">요청으로</span><span class="w"> </span><span class="n">반려</span>

<span class="mf">4.</span><span class="w"> </span><span class="n">구현</span><span class="p">(</span><span class="n">IMPLEMENTATION</span><span class="p">)</span>
<span class="w">   </span><span class="n">개발자가</span><span class="w"> </span><span class="n">통제된</span><span class="w"> </span><span class="n">브랜치에서</span><span class="w"> </span><span class="n">변경</span><span class="w"> </span><span class="n">사항을</span><span class="w"> </span><span class="n">구현</span>

<span class="mf">5.</span><span class="w"> </span><span class="n">검증</span><span class="p">(</span><span class="n">VERIFICATION</span><span class="p">)</span>
<span class="w">   </span><span class="n">테스트로</span><span class="w"> </span><span class="n">변경</span><span class="w"> </span><span class="n">사항이</span><span class="w"> </span><span class="n">작동하고</span><span class="w"> </span><span class="n">회귀가</span><span class="w"> </span><span class="n">없음을</span><span class="w"> </span><span class="n">확인</span>

<span class="mf">6.</span><span class="w"> </span><span class="n">릴리스</span><span class="p">(</span><span class="n">RELEASE</span><span class="p">)</span>
<span class="w">   </span><span class="n">변경</span><span class="w"> </span><span class="n">사항이</span><span class="w"> </span><span class="n">배포되고</span><span class="w"> </span><span class="n">CR이</span><span class="w"> </span><span class="n">종료됨</span>
<span class="w">   </span><span class="n">변경</span><span class="w"> </span><span class="n">로그가</span><span class="w"> </span><span class="n">업데이트됨</span>
</code></pre></div>

<h3 id="62-change-control-board-ccb">6.2 변경 통제 위원회(Change Control Board, CCB)<a class="header-link" href="#62-change-control-board-ccb" title="Permanent link">&para;</a></h3>
<p>CCB(변경 자문 위원회(Change Advisory Board, CAB)라고도 함)는 변경에 대한 의사결정 기구입니다. 구성은 조직 규모에 따라 다릅니다:</p>
<table>
<thead>
<tr>
<th>조직 규모</th>
<th>CCB 구성원</th>
<th>회의 주기</th>
</tr>
</thead>
<tbody>
<tr>
<td>소규모 스타트업</td>
<td>기술 리드 + PM</td>
<td>비동기 (Slack/GitHub)</td>
</tr>
<tr>
<td>중간 규모 회사</td>
<td>엔지니어링 매니저, QA 리드, PM, 운영</td>
<td>주간</td>
</tr>
<tr>
<td>대기업</td>
<td>CTO, 엔지니어링/QA/운영 VP, 보안</td>
<td>격주; P1 긴급 위원회</td>
</tr>
<tr>
<td>규제 산업 (금융, 의료)</td>
<td>위 + 컴플라이언스 담당자, 법무</td>
<td>공식적, 문서화</td>
</tr>
</tbody>
</table>
<p>애자일(Agile) 팀에서는 CCB 기능이 별도 기구 대신 스프린트 계획과 풀 리퀘스트 리뷰에 내재화되는 경우가 많습니다.</p>
<h3 id="63-emergency-change">6.3 긴급 변경(Emergency Change)<a class="header-link" href="#63-emergency-change" title="Permanent link">&para;</a></h3>
<p>중요한 운영 장애의 경우, 일반 CCB 주기는 너무 느립니다. <strong>긴급 변경 프로세스</strong>를 통해 다음이 허용됩니다:
1. 신속 승인 (전체 CCB 대신 승인자 2명)
2. 몇 시간 이내 구현 및 배포
3. <strong>사후 문서화</strong>: 변경 후(사전이 아닌) 문서 작성 완료
4. 48~72시간 이내 의무적 사후 검토</p>
<div class="highlight"><pre><span></span><code>긴급 변경 트리거:
  운영 장애 | 보안 침해 | 데이터 손상 위험

신속 승인 (다음 중 2인): 기술 리드, 엔지니어링 매니저, 온콜 SRE

배포 전 롤백 계획 필수

72시간 이내 사후 조치:
  - 근본 원인 분석(RCA)
  - 전체 CCB 방식의 문서화
  - 교훈(Lessons learned)
</code></pre></div>

<h3 id="64-impact-analysis">6.4 영향 분석(Impact Analysis)<a class="header-link" href="#64-impact-analysis" title="Permanent link">&para;</a></h3>
<p>변경을 승인하기 전에, CCB는 그것이 무엇에 영향을 미치는지 이해해야 합니다:</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 단순화된 의존성 그래프 영향 분석</span>
<span class="k">def</span><span class="w"> </span><span class="nf">find_impacted_modules</span><span class="p">(</span><span class="n">changed_module</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">dependency_graph</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">set</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    BFS from changed module to find all modules that depend on it.</span>
<span class="sd">    dependency_graph[A] = [B, C] means A depends on B and C.</span>
<span class="sd">    We want to find all modules that (transitively) depend on changed_module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Reverse the graph: who depends on me?</span>
    <span class="n">reverse_graph</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">module</span><span class="p">,</span> <span class="n">deps</span> <span class="ow">in</span> <span class="n">dependency_graph</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">dep</span> <span class="ow">in</span> <span class="n">deps</span><span class="p">:</span>
            <span class="n">reverse_graph</span><span class="o">.</span><span class="n">setdefault</span><span class="p">(</span><span class="n">dep</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>

    <span class="n">impacted</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[</span><span class="n">changed_module</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">queue</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">dependent</span> <span class="ow">in</span> <span class="n">reverse_graph</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="p">[]):</span>
            <span class="k">if</span> <span class="n">dependent</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">impacted</span><span class="p">:</span>
                <span class="n">impacted</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">dependent</span><span class="p">)</span>
                <span class="n">queue</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dependent</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">impacted</span>

<span class="c1"># Example</span>
<span class="n">graph</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;checkout&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;cart&quot;</span><span class="p">,</span> <span class="s2">&quot;payment&quot;</span><span class="p">,</span> <span class="s2">&quot;inventory&quot;</span><span class="p">],</span>
    <span class="s2">&quot;order_history&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;checkout&quot;</span><span class="p">],</span>
    <span class="s2">&quot;admin_dashboard&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;checkout&quot;</span><span class="p">,</span> <span class="s2">&quot;order_history&quot;</span><span class="p">],</span>
    <span class="s2">&quot;notification_service&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;checkout&quot;</span><span class="p">],</span>
<span class="p">}</span>
<span class="nb">print</span><span class="p">(</span><span class="n">find_impacted_modules</span><span class="p">(</span><span class="s2">&quot;payment&quot;</span><span class="p">,</span> <span class="n">graph</span><span class="p">))</span>
<span class="c1"># {&#39;checkout&#39;, &#39;order_history&#39;, &#39;admin_dashboard&#39;, &#39;notification_service&#39;}</span>
</code></pre></div>

<hr />
<h2 id="7-configuration-auditing">7. 형상 감사(Configuration Auditing)<a class="header-link" href="#7-configuration-auditing" title="Permanent link">&para;</a></h2>
<p>형상 감사는 빌드되고 배포된 것이 승인되고 문서화된 것과 일치하는지 검증합니다. 두 가지 유형이 있습니다:</p>
<h3 id="71-functional-configuration-audit-fca">7.1 기능 형상 감사(Functional Configuration Audit, FCA)<a class="header-link" href="#71-functional-configuration-audit-fca" title="Permanent link">&para;</a></h3>
<p>CI의 실제 성능이 요구사항과 일치하는지 검증합니다. "이 빌드가 해야 할 모든 것을 하는가?"라는 질문에 답합니다.</p>
<p><strong>체크리스트</strong>:
- 계획된 모든 기능이 존재하고 작동함
- 이전 감사에서 발견된 모든 결함이 해결됨
- 테스트 결과가 품질 완료 기준을 충족함
- 릴리스 노트가 변경된 내용을 정확하게 설명함</p>
<h3 id="72-physical-configuration-audit-pca">7.2 물리 형상 감사(Physical Configuration Audit, PCA)<a class="header-link" href="#72-physical-configuration-audit-pca" title="Permanent link">&para;</a></h3>
<p>CI가 물리적으로 문서화된 설명과 일치하는지 검증합니다. "릴리스하려는 것이 정확히 승인되고 테스트된 것인가?"라는 질문에 답합니다.</p>
<p><strong>체크리스트</strong>:
- 코드의 버전 번호가 빌드 산출물의 버전 번호와 일치함
- 빌드 매니페스트에 나열된 모든 파일이 존재함
- 산출물의 체크섬이 기록된 값과 일치함
- 승인되지 않은 파일이 포함되지 않음
- 산출물의 의존성이 승인된 의존성 목록과 일치함</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 체크섬으로 산출물 무결성 검증</span>
sha256sum<span class="w"> </span>myapp-2.3.0-linux-amd64.tar.gz<span class="w"> </span>&gt;<span class="w"> </span>myapp-2.3.0.sha256
cat<span class="w"> </span>myapp-2.3.0.sha256
<span class="c1"># 7a3b9c1d... myapp-2.3.0-linux-amd64.tar.gz</span>

<span class="c1"># 검증 (수신자 또는 감사자가 수행)</span>
sha256sum<span class="w"> </span>--check<span class="w"> </span>myapp-2.3.0.sha256
<span class="c1"># myapp-2.3.0-linux-amd64.tar.gz: OK</span>
</code></pre></div>

<h3 id="73-software-bill-of-materials-sbom">7.3 소프트웨어 부품 명세서(Software Bill of Materials, SBOM)<a class="header-link" href="#73-software-bill-of-materials-sbom" title="Permanent link">&para;</a></h3>
<p>SBOM은 소프트웨어 산출물의 모든 컴포넌트 — 자체 개발 코드, 오픈소스 의존성, 그리고 그 라이선스 — 에 대한 완전한 목록입니다. 다음을 위해 필요합니다:
- 공급망 보안 (행정명령 14028, 2021)
- 라이선스 컴플라이언스
- 취약점 대응 (CVE가 공개될 때 보유 항목 파악)</p>
<div class="highlight"><pre><span></span><code><span class="c1"># syft를 사용하여 SPDX 형식으로 SBOM 생성</span>
syft<span class="w"> </span>myapp:2.3.0<span class="w"> </span>-o<span class="w"> </span>spdx-json<span class="w"> </span>&gt;<span class="w"> </span>myapp-2.3.0.sbom.json

<span class="c1"># Python 프로젝트용 SBOM 생성</span>
pip<span class="w"> </span>install<span class="w"> </span>cyclonedx-bom
cyclonedx-py<span class="w"> </span>--poetry<span class="w"> </span>-o<span class="w"> </span>sbom.json
</code></pre></div>

<hr />
<h2 id="8">8. 환경 관리<a class="header-link" href="#8" title="Permanent link">&para;</a></h2>
<p>소프트웨어는 각기 다른 목적을 위한 여러 환경에서 실행됩니다. 이러한 환경을 일관되게 관리하는 것은 신뢰할 수 있는 배포를 위해 필수적입니다.</p>
<h3 id="81">8.1 표준 환경<a class="header-link" href="#81" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>개발자 워크스테이션
        │
        │ (커밋 + PR)
        ▼
CI 환경 (임시 — 빌드마다 생성, 완료 후 삭제)
        │
        │ (main으로 병합)
        ▼
개발/통합 환경(Development / Integration Environment)
        │
        │ (예정된 승격)
        ▼
스테이징/사전 운영 환경(Staging / Pre-production Environment)
        │
        │ (승인 게이트)
        ▼
운영 환경(Production Environment)
</code></pre></div>

<table>
<thead>
<tr>
<th>환경</th>
<th>목적</th>
<th>접근 주체</th>
<th>데이터</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CI</strong></td>
<td>자동화된 빌드 및 테스트</td>
<td>CI 시스템</td>
<td>합성 테스트 데이터</td>
</tr>
<tr>
<td><strong>개발</strong></td>
<td>통합 테스트; 데모</td>
<td>개발자, QA</td>
<td>익명화 또는 합성 데이터</td>
</tr>
<tr>
<td><strong>스테이징</strong></td>
<td>릴리스 전 검증</td>
<td>QA, PM, 이해관계자</td>
<td>운영 스냅샷 (익명화)</td>
</tr>
<tr>
<td><strong>운영</strong></td>
<td>최종 사용자 서비스</td>
<td>최종 사용자</td>
<td>실제 데이터</td>
</tr>
</tbody>
</table>
<p><strong>환경 드리프트(Environment drift)</strong> — 스테이징이 운영과 다르게 동작하는 현상 — 은 "내 컴퓨터에서는 됐는데" 문제의 가장 흔한 원인 중 하나입니다. 코드형 인프라(IaC)가 이를 해결합니다.</p>
<h3 id="82-infrastructure-as-code-iac">8.2 코드형 인프라(Infrastructure as Code, IaC)<a class="header-link" href="#82-infrastructure-as-code-iac" title="Permanent link">&para;</a></h3>
<p>IaC는 인프라(서버, 데이터베이스, 네트워크, 로드 밸런서)를 버전 관리에 저장된 선언적 설정 파일로 정의합니다. 동일한 코드가 모든 환경을 프로비저닝하여 일관성을 보장합니다.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Terraform: 웹 애플리케이션 스택 프로비저닝</span>
<span class="c1"># environments/staging/main.tf와 environments/prod/main.tf는</span>
<span class="c1"># 동일한 모듈을 공유 — 입력값만 다름</span>

<span class="kr">module</span><span class="w"> </span><span class="nv">&quot;web_app&quot;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="na">source</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;../../modules/web_app&quot;</span>

<span class="c1">  # 환경별 값 (terraform.tfvars에서 설정)</span>
<span class="w">  </span><span class="na">environment</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nv">var.environment</span><span class="c1">     # &quot;staging&quot; 또는 &quot;prod&quot;</span>
<span class="w">  </span><span class="na">instance_type</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nv">var.instance_type</span><span class="c1">   # &quot;t3.small&quot; vs &quot;t3.large&quot;</span>
<span class="w">  </span><span class="na">min_instances</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nv">var.min_instances</span><span class="c1">   # 1 vs 3</span>
<span class="w">  </span><span class="na">max_instances</span><span class="w">   </span><span class="o">=</span><span class="w"> </span><span class="nv">var.max_instances</span><span class="c1">   # 2 vs 10</span>
<span class="w">  </span><span class="na">db_instance</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="nv">var.db_instance</span><span class="c1">     # &quot;db.t3.micro&quot; vs &quot;db.r6g.large&quot;</span>
<span class="w">  </span><span class="na">enable_backups</span><span class="w">  </span><span class="o">=</span><span class="w"> </span><span class="nv">var.enable_backups</span><span class="c1">  # false vs true</span>
<span class="w">  </span><span class="na">alert_endpoints</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">var.alert_endpoints</span><span class="c1"> # 개발팀 vs 운영팀 + PagerDuty</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1"># Ansible: 애플리케이션 서버 일관성 있게 구성</span>
<span class="nn">---</span>
<span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Configure web application servers</span>
<span class="w">  </span><span class="nt">hosts</span><span class="p">:</span><span class="w"> </span><span class="s">&quot;{{</span><span class="nv"> </span><span class="s">target_env</span><span class="nv"> </span><span class="s">}}_web&quot;</span><span class="w">  </span><span class="c1"># staging_web 또는 prod_web</span>
<span class="w">  </span><span class="nt">become</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
<span class="w">  </span><span class="nt">vars_files</span><span class="p">:</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="s">&quot;vars/{{</span><span class="nv"> </span><span class="s">target_env</span><span class="nv"> </span><span class="s">}}.yml&quot;</span><span class="w">  </span><span class="c1"># 환경별 변수</span>

<span class="w">  </span><span class="nt">roles</span><span class="p">:</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">common</span><span class="w">          </span><span class="c1"># OS 기준: NTP, 로깅, 보안 패치</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">nginx</span><span class="w">           </span><span class="c1"># 웹 서버, TLS 종료</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">app_deploy</span><span class="w">      </span><span class="c1"># 아티팩트 저장소에서 애플리케이션 산출물 배포</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">monitoring</span><span class="w">      </span><span class="c1"># Prometheus 노드 익스포터 설치</span>

<span class="w">  </span><span class="nt">tasks</span><span class="p">:</span>
<span class="w">    </span><span class="p p-Indicator">-</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">Ensure application is running</span>
<span class="w">      </span><span class="nt">systemd</span><span class="p">:</span>
<span class="w">        </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">myapp</span>
<span class="w">        </span><span class="nt">state</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">started</span>
<span class="w">        </span><span class="nt">enabled</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">true</span>
</code></pre></div>

<h3 id="83-secrets">8.3 설정 파일과 시크릿(Secrets)<a class="header-link" href="#83-secrets" title="Permanent link">&para;</a></h3>
<p>애플리케이션 설정은 환경마다 다릅니다 (데이터베이스 URL, API 키, 기능 플래그). 세 가지 계층:</p>
<div class="highlight"><pre><span></span><code>계층 1: 민감하지 않은 환경별 설정
  → VCS의 환경별 설정 파일에 저장
  → 예: application-staging.yaml, application-prod.yaml

계층 2: 민감한 설정 (자격 증명, API 키)
  → 절대 VCS에 저장하지 말 것
  → 시크릿 관리 시스템(Vault, AWS Secrets Manager, GCP Secret Manager)에 저장
  → 런타임에 환경 변수 또는 마운트된 시크릿으로 주입

계층 3: 기능 플래그(Feature Flag)
  → 기능 플래그 서비스(LaunchDarkly, Unleash, Flagsmith)에 저장
  → 재배포 없이 변경 가능
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1"># .env.example (VCS에 커밋 — 필요한 변수를 보여주되 값은 없음)</span>
<span class="nv">DATABASE_URL</span><span class="o">=</span>postgresql://user:password@host:5432/dbname
<span class="nv">REDIS_URL</span><span class="o">=</span>redis://localhost:6379
<span class="nv">STRIPE_API_KEY</span><span class="o">=</span>sk_...
<span class="nv">JWT_SECRET</span><span class="o">=</span>...
<span class="nv">LOG_LEVEL</span><span class="o">=</span>INFO
<span class="nv">FEATURE_FLAG_NEW_UI</span><span class="o">=</span><span class="nb">false</span>

<span class="c1"># .env (커밋하지 않음 — 각 환경이 실제 값을 채움)</span>
<span class="c1"># 배포 시 시크릿 매니저에서 가져옴:</span>
<span class="c1">#   aws secretsmanager get-secret-value --secret-id prod/myapp</span>
</code></pre></div>

<hr />
<h2 id="9">9. 의존성 관리<a class="header-link" href="#9" title="Permanent link">&para;</a></h2>
<p>현대 소프트웨어는 수백 또는 수천 개의 서드파티 라이브러리로 구축됩니다. 이러한 의존성을 안전하게 관리하는 것은 SCM의 중요한 책임입니다.</p>
<h3 id="91-lockfile">9.1 잠금 파일(Lockfile)<a class="header-link" href="#91-lockfile" title="Permanent link">&para;</a></h3>
<p><strong>잠금 파일(Lockfile)</strong>은 특정 시점에 해결된 모든 의존성(전이적 의존성 포함)의 정확한 버전을 기록합니다. 모든 개발자와 모든 CI 빌드가 정확히 동일한 버전을 사용하도록 보장합니다.</p>
<div class="highlight"><pre><span></span><code>요구사항 파일 (의도 기술)            잠금 파일 (실제 기록)
──────────────────────────────────      ─────────────────────────────
requests&gt;=2.28.0                        requests==2.31.0
flask&gt;=3.0.0                            flask==3.0.2
                                        werkzeug==3.0.1
                                        click==8.1.7
                                        jinja2==3.1.3
                                        markupsafe==2.1.5
                                        ...47개의 추가 전이적 의존성
</code></pre></div>

<table>
<thead>
<tr>
<th>생태계</th>
<th>요구사항 파일</th>
<th>잠금 파일</th>
</tr>
</thead>
<tbody>
<tr>
<td>Python (pip)</td>
<td><code>requirements.txt</code></td>
<td><code>requirements.lock</code> (pip-compile)</td>
</tr>
<tr>
<td>Python (Poetry)</td>
<td><code>pyproject.toml</code></td>
<td><code>poetry.lock</code></td>
</tr>
<tr>
<td>Node.js (npm)</td>
<td><code>package.json</code></td>
<td><code>package-lock.json</code></td>
</tr>
<tr>
<td>Node.js (Yarn)</td>
<td><code>package.json</code></td>
<td><code>yarn.lock</code></td>
</tr>
<tr>
<td>Ruby</td>
<td><code>Gemfile</code></td>
<td><code>Gemfile.lock</code></td>
</tr>
<tr>
<td>Go</td>
<td><code>go.mod</code></td>
<td><code>go.sum</code></td>
</tr>
<tr>
<td>Rust</td>
<td><code>Cargo.toml</code></td>
<td><code>Cargo.lock</code></td>
</tr>
</tbody>
</table>
<p><strong>규칙</strong>: 애플리케이션의 잠금 파일은 항상 커밋하십시오. 라이브러리의 경우 잠금 파일 커밋은 선택적입니다 (하위 소비자가 자체적으로 해결).</p>
<h3 id="92-version-pinning">9.2 버전 고정(Version Pinning)<a class="header-link" href="#92-version-pinning" title="Permanent link">&para;</a></h3>
<p><strong>버전 고정(Pinning)</strong>은 범위 대신 정확한 버전을 지정합니다. 다음의 경우에 중요합니다:
- 운영 배포 (예측 가능성)
- 보안 스캔 (CVE 데이터베이스에서 특정 버전을 명확하게 확인 가능)</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 미고정 (운영 환경에 위험)</span>
<span class="n">requests</span><span class="o">&gt;=</span><span class="mf">2.28.0</span>
<span class="n">flask</span><span class="o">~=</span><span class="mf">3.0</span>

<span class="c1"># 고정 (운영 환경에 안전)</span>
<span class="n">requests</span><span class="o">==</span><span class="mf">2.31.0</span>
<span class="n">flask</span><span class="o">==</span><span class="mf">3.0.2</span>
</code></pre></div>

<p>버전 고정 전략: <code>requirements.txt</code>가 아닌 잠금 파일에서 고정합니다. 이렇게 하면 라이브러리 호환성을 위한 의도(범위)와 재현성을 위한 보장(정확한 버전) 모두를 얻을 수 있습니다.</p>
<h3 id="93">9.3 의존성 취약점 스캔<a class="header-link" href="#93" title="Permanent link">&para;</a></h3>
<p>버전이 고정되고 잠금 파일이 있더라도, 잠금 파일이 생성된 후 CVE가 공개되면 의존성이 취약해질 수 있습니다.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># Python: pip-audit이 OSV 및 PyPA 어드바이저리 데이터베이스 대상 스캔</span>
pip<span class="w"> </span>install<span class="w"> </span>pip-audit
pip-audit<span class="w"> </span>-r<span class="w"> </span>requirements.lock

<span class="c1"># 출력:</span>
<span class="c1"># Found 2 known vulnerabilities in 1 package</span>
<span class="c1"># Name      Version  ID                    Fix Versions</span>
<span class="c1"># ──────────────────────────────────────────────────────</span>
<span class="c1"># cryptography 38.0.1  GHSA-jfh8-c2jp-jvq8  39.0.1</span>
<span class="c1"># cryptography 38.0.1  GHSA-w7pp-m8wf-vj6r  39.0.1</span>

<span class="c1"># Node.js: npm audit</span>
npm<span class="w"> </span>audit<span class="w"> </span>--audit-level<span class="o">=</span>high

<span class="c1"># Docker 이미지 스캔</span>
docker<span class="w"> </span>scout<span class="w"> </span>cves<span class="w"> </span>myapp:2.3.0
</code></pre></div>

<p>취약점 스캔을 CI 파이프라인에 통합하십시오 — 운영 의존성의 고심각도 취약점 발견 시 빌드를 실패시킵니다.</p>
<h3 id="94">9.4 의존성 업데이트 전략<a class="header-link" href="#94" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>전략</th>
<th>설명</th>
<th>위험도</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>수동 업데이트</strong></td>
<td>개발자가 업데이트 시기 결정</td>
<td>자주 구식이 됨; 누적 위험 높음</td>
</tr>
<tr>
<td><strong>자동 PR</strong> (Dependabot, Renovate)</td>
<td>봇이 각 업데이트에 PR 오픈</td>
<td>PR이 많음; 좋은 테스트가 있으면 관리 가능</td>
</tr>
<tr>
<td><strong>정기적 업데이트</strong></td>
<td>스프린트마다 의존성 업데이트에 시간 할당</td>
<td>균형 잡힌; 예측 가능한 작업량</td>
</tr>
<tr>
<td><strong>LTS 유지</strong></td>
<td>장기 지원(Long-Term Support) 버전만 사용</td>
<td>보수적; 기능을 놓치지만 안정적</td>
</tr>
</tbody>
</table>
<p>권장 사항: Dependabot 또는 Renovate를 사용하여 패치 업데이트는 자동 병합(테스트 통과 시), 마이너 및 메이저 업데이트는 수동 검토합니다.</p>
<hr />
<h2 id="10">10. 도구 개요<a class="header-link" href="#10" title="Permanent link">&para;</a></h2>
<h3 id="101-scm">10.1 SCM 기능별 도구<a class="header-link" href="#101-scm" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>기능</th>
<th>도구</th>
<th>사용 사례</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>버전 관리</strong></td>
<td>Git</td>
<td>범용 소스 관리</td>
</tr>
<tr>
<td><strong>코드 호스팅/리뷰</strong></td>
<td>GitHub, GitLab, Bitbucket</td>
<td>PR 워크플로우, 코드 리뷰, CODEOWNERS</td>
</tr>
<tr>
<td><strong>CI/CD</strong></td>
<td>GitHub Actions, Jenkins, GitLab CI, CircleCI</td>
<td>자동화된 빌드, 테스트, 배포 파이프라인</td>
</tr>
<tr>
<td><strong>아티팩트 저장</strong></td>
<td>JFrog Artifactory, Nexus, AWS ECR, GitHub Packages</td>
<td>버전 관리된 바이너리 저장</td>
</tr>
<tr>
<td><strong>IaC 프로비저닝</strong></td>
<td>Terraform, Pulumi</td>
<td>코드형 클라우드 인프라</td>
</tr>
<tr>
<td><strong>설정 관리</strong></td>
<td>Ansible, Chef, Puppet</td>
<td>코드형 서버 설정</td>
</tr>
<tr>
<td><strong>컨테이너 오케스트레이션</strong></td>
<td>Kubernetes, Docker Compose</td>
<td>환경 일관성</td>
</tr>
<tr>
<td><strong>시크릿 관리</strong></td>
<td>HashiCorp Vault, AWS Secrets Manager</td>
<td>안전한 자격 증명 저장</td>
</tr>
<tr>
<td><strong>의존성 관리</strong></td>
<td>pip-tools, Poetry, Dependabot, Renovate</td>
<td>잠금 파일, 자동 업데이트</td>
</tr>
<tr>
<td><strong>취약점 스캔</strong></td>
<td>Snyk, Dependabot, Trivy, pip-audit</td>
<td>의존성 및 이미지의 CVE 탐지</td>
</tr>
<tr>
<td><strong>SBOM 생성</strong></td>
<td>syft, CycloneDX</td>
<td>소프트웨어 부품 명세서</td>
</tr>
<tr>
<td><strong>기능 플래그</strong></td>
<td>LaunchDarkly, Unleash</td>
<td>배포와 릴리스 분리</td>
</tr>
</tbody>
</table>
<h3 id="102-scm">10.2 완전한 SCM 툴체인 예시<a class="header-link" href="#102-scm" title="Permanent link">&para;</a></h3>
<div class="highlight"><pre><span></span><code>개발자가 코드 커밋 (Git)
           │
           ▼
풀 리퀘스트 오픈 (GitHub)
  └── 코드 리뷰 (CODEOWNERS가 필수 리뷰어 지정)
  └── 상태 체크 통과 필수:
        ├── 린팅 (GitHub Actions)
        ├── 단위 테스트 + 커버리지 (GitHub Actions)
        ├── 보안 스캔: Semgrep (GitHub Actions)
        └── 의존성 취약점 확인: Dependabot 알림
           │
           ▼ (PR이 main에 병합)
           │
CI 파이프라인 (GitHub Actions)
  ├── Docker 이미지 빌드
  ├── 통합 테스트 실행
  ├── ECR에 이미지 푸시 (git SHA로 태깅)
  └── SBOM 생성 (syft)
           │
           ▼
CD 파이프라인: 스테이징에 배포
  ├── Terraform apply (IaC 변경 시)
  ├── Ansible 플레이북 (서버 설정)
  └── Kubernetes 롤링 업데이트
           │
           ▼
수동 승인 게이트
           │
           ▼
CD 파이프라인: 운영에 배포 (블루/그린)
  ├── 기존 버전 옆에 새 버전 배포
  ├── 트래픽 전환: 10% → 50% → 100% (30분에 걸쳐)
  └── 오류율이 임계값 초과 시 자동 롤백
           │
           ▼
릴리스 태깅: v2.3.0 (Git 태그)
릴리스 노트 게시 (GitHub Release)
아티팩트 저장소에 SBOM 보관
</code></pre></div>

<hr />
<h2 id="11_1">11. 요약<a class="header-link" href="#11_1" title="Permanent link">&para;</a></h2>
<p>소프트웨어 형상 관리는 대규모 소프트웨어 개발을 다룰 수 있게 만드는 기반입니다. 이것 없이는 시스템이 신뢰할 수 없게 되고, 릴리스가 예측 불가능해지며, 팀은 무언가를 안전하게 변경할 수 있다는 확신을 잃습니다.</p>
<p>핵심 요점:</p>
<ul>
<li><strong>형상 항목(Configuration Item)</strong>은 추적이 필요한 모든 산출물 — 소스 코드, 문서, 설정 파일, 인프라 코드, 빌드 산출물 — 입니다. 모든 CI는 고유한 식별자와 버전을 가집니다.</li>
<li><strong>기준선(Baseline)</strong>은 참조점 역할을 하는 공식적으로 승인된 스냅샷입니다. 현대적 실천에서 메인 브랜치의 Git 태그에 해당합니다.</li>
<li><strong>브랜치 전략</strong> — 정기적 릴리스를 위한 Gitflow, 지속적 배포를 위한 트렁크 기반 개발 — 은 동시 변경 관리를 위한 워크플로우 구조를 제공합니다.</li>
<li><strong>빌드 관리</strong>는 버전 관리된 빌드 스크립트를 통한 자동화되고 재현 가능한 빌드를 의미합니다. 한 번 빌드하고, 산출물을 저장하고, 산출물을 배포합니다.</li>
<li><strong>시맨틱 버저닝(Semantic Versioning)</strong>은 버전 번호에 정확한 의미를 부여합니다. MAJOR.MINOR.PATCH는 소비자에게 호환성 보장을 알립니다.</li>
<li><strong>변경 관리</strong>는 수정에 규율을 가져옵니다: 모든 변경은 요청되고, 영향이 분석되고, 승인되고, 구현되고, 검증되고, 종료됩니다.</li>
<li><strong>IaC를 사용한 환경 관리</strong>는 개발, 스테이징, 운영 환경이 일관되고 재현 가능하도록 보장합니다 — "스테이징에서는 됐는데 운영에서는 안 된다"는 문제를 제거합니다.</li>
<li><strong>의존성 관리</strong>는 재현성을 위한 잠금 파일, 예측 가능성을 위한 버전 고정, 그리고 보안 문제를 신속하게 발견하기 위한 자동화된 취약점 스캔이 필요합니다.</li>
</ul>
<hr />
<h2 id="12">12. 연습 문제<a class="header-link" href="#12" title="Permanent link">&para;</a></h2>
<p><strong>연습 문제 1 — 형상 항목 식별</strong></p>
<p>다음과 같은 새로운 마이크로서비스에 대해 SCM을 설정하고 있습니다:
- Python FastAPI 애플리케이션
- PostgreSQL과 Redis 사용
- Terraform을 사용하여 AWS에 배포
- React 프론트엔드 동반
- OpenAPI 형식의 API 문서</p>
<p>(a) 이 시스템에 대해 유형별로 분류하여 최소 15개의 형상 항목을 나열하십시오.
(b) CI가 아닌(버전 관리되어서는 안 되는) 세 가지 산출물을 식별하고 이유를 설명하십시오.
(c) SCM 식별 요구사항을 충족하는 Docker 이미지 태그 명명 체계를 설계하십시오.</p>
<p><strong>연습 문제 2 — 브랜치 전략</strong></p>
<p>8명의 개발자로 구성된 팀이 이커머스 플랫폼을 개발하고 있습니다. 현재는 격주로 릴리스하지만, 6개월 이내에 일일 릴리스로 전환하고자 합니다.</p>
<p>(a) 현재 2주 릴리스 주기에 적합한 브랜치 전략을 권장하십시오. 주요 브랜치를 보여주는 간단한 다이어그램을 그리십시오.
(b) 트렁크 기반 개발로의 전환 계획을 설명하십시오. 전환 전에 팀이 갖추어야 할 것은 무엇입니까?
(c) 다음 릴리스 작업이 진행 중인 동안 2주 전 릴리스에 대한 핫픽스가 필요합니다. 단계별로 정확한 Git 워크플로우를 설명하십시오.</p>
<p><strong>연습 문제 3 — 의존성 분석</strong></p>
<p>Python 웹 애플리케이션의 <code>pyproject.toml</code>이 다음을 지정합니다:</p>
<div class="highlight"><pre><span></span><code><span class="k">[tool.poetry.dependencies]</span>
<span class="n">python</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;^3.11&quot;</span>
<span class="n">django</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;&gt;=4.2,&lt;5.0&quot;</span>
<span class="n">celery</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;^5.3&quot;</span>
<span class="n">redis</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;&gt;=4.6&quot;</span>
<span class="n">boto3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;*&quot;</span>
</code></pre></div>

<p>(a) boto3에 <code>*</code> (임의 버전)를 사용하는 것의 위험은 무엇입니까?
(b) <code>django = "4.2.8"</code> 대신 <code>django = "&gt;=4.2,&lt;5.0"</code>를 사용합니다. 이 접근 방식의 장점과 단점은 무엇입니까?
(c) 다음을 수행하는 Dependabot 설정(<code>dependabot.yml</code>)을 작성하십시오: 주간으로 업데이트 확인, 모든 패치 업데이트를 그룹화, 메이저 버전 업데이트에 대해 <code>@security-team</code>의 검토 요구.</p>
<p><strong>연습 문제 4 — 변경 통제</strong></p>
<p>운영 시스템이 금융 거래를 처리합니다. 한 개발자가 레거시 MD5 기반 세션 토큰을 암호학적으로 안전한 랜덤 토큰(256비트, base64 인코딩)으로 교체하는 변경을 제안합니다. 예상 구현 시간: 4시간.</p>
<p>(a) 영향 분석을 포함하여 이 변경에 대한 완전한 변경 요청 문서를 작성하십시오.
(b) 변경 통제 위원회가 이 변경을 승인하기 전에 물어야 할 질문은 무엇입니까?
(c) 이 변경이 운영 환경에 배포되기 전에 통과해야 하는 검증 단계를 설계하십시오.</p>
<p><strong>연습 문제 5 — 릴리스 관리</strong></p>
<p>SaaS 제품이 버전 <code>2.7.3</code>에 있습니다. 다음 각 변경에 대해 적절한 다음 버전 번호를 결정하고 이유를 설명하십시오:</p>
<p>(a) 회의 알림의 시간대 처리를 수정하는 버그 수정.
(b) 사용자가 프로필에서 토글할 수 있는 새로운 "다크 모드" 설정.
(c) REST API의 <code>/users</code> 엔드포인트가 이제 JSON 응답에서 <code>id</code> 대신 <code>user_id</code>를 반환합니다.
(d) API 변경 없이 UI에 일본어와 한국어 지원 추가.
(e) 12개월 전에 제거 예고된 deprecated SOAP API 엔드포인트 제거.</p>
<hr />
<h2 id="13">13. 더 읽을거리<a class="header-link" href="#13" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>도서</strong>:</li>
<li><em>Continuous Delivery</em> — Jez Humble and David Farley. 빌드, 테스트, 배포 파이프라인을 포함한 자동화된 소프트웨어 배포의 결정판 가이드.</li>
<li><em>The Phoenix Project</em> — Gene Kim, Kevin Behr, George Spafford. 설득력 있는 스토리를 통해 DevOps와 변경 관리 개념을 보여주는 소설.</li>
<li><em>Software Configuration Management Patterns</em> — Steve Berczuk and Brad Appleton. 애자일 팀을 위한 SCM 실용 패턴.</li>
<li>
<p><em>Infrastructure as Code</em> (2nd ed.) — Kief Morris. 코드로 인프라를 관리하기 위한 종합 가이드.</p>
</li>
<li>
<p><strong>표준</strong>:</p>
</li>
<li>IEEE Std 828-2012 — 시스템 및 소프트웨어 공학의 형상 관리를 위한 IEEE 표준</li>
<li>NIST SP 800-128 — 정보 시스템의 보안 중심 형상 관리 가이드</li>
<li>
<p>Semantic Versioning 2.0.0 — https://semver.org/</p>
</li>
<li>
<p><strong>도구 문서</strong>:</p>
</li>
<li>Git Reference — https://git-scm.com/doc</li>
<li>Terraform Documentation — https://developer.hashicorp.com/terraform/docs</li>
<li>Ansible Documentation — https://docs.ansible.com/</li>
<li>Dependabot Documentation — https://docs.github.com/en/code-security/dependabot</li>
<li>
<p>Syft (SBOM generator) — https://github.com/anchore/syft</p>
</li>
<li>
<p><strong>아티클 및 명세서</strong>:</p>
</li>
<li>"Gitflow Workflow" — Atlassian Bitbucket 가이드</li>
<li>"Trunk Based Development" — https://trunkbaseddevelopment.com/</li>
<li>Reproducible Builds — https://reproducible-builds.org/</li>
<li>NTIA Software Bill of Materials — https://www.ntia.gov/sbom</li>
</ul>
<hr />
<p><strong>이전</strong>: <a href="./08_Verification_and_Validation.md">08. 검증과 확인</a> | <strong>다음</strong>: <a href="./10_Project_Management.md">10. 프로젝트 관리</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Software_Engineering/08_Verification_and_Validation.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">레슨 08: 검증과 확인 (Verification and Validation)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Software_Engineering/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Software_Engineering/10_Project_Management.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">레슨 10: 소프트웨어 프로젝트 관리(Software Project Management)</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}