{% raw %}
<!DOCTYPE html>
<html lang="ko" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>레슨 13: DevOps와 CI/CD - Study Materials</title>
    <link rel="stylesheet" href="/study/static/css/style.css">
    <link rel="stylesheet" href="/study/static/css/highlight.css">
    <!-- KaTeX for LaTeX math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {
            delimiters: [
                {left: '$$', right: '$$', display: true},
                {left: '$', right: '$', display: false}
            ],
            throwOnError: false
        });"></script>
    
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <a href="/study/ko/" class="logo">Study Materials</a>
                <button class="sidebar-toggle" id="sidebar-toggle" aria-label="Toggle sidebar">
                    <span></span>
                </button>
            </div>

            <nav class="sidebar-nav">
                <a href="/study/ko/" class="nav-item ">
                    <span class="nav-icon">🏠</span>
                    <span class="nav-text">Home</span>
                </a>
                <a href="/study/examples/" class="nav-item ">
                    <span class="nav-icon">💻</span>
                    <span class="nav-text">Examples</span>
                </a>
            </nav>

            <div class="sidebar-search">
                <form action="/study/ko/search.html" method="get" id="search-form">
                    <input type="search" name="q" placeholder="Search..." id="search-sidebar-input">
                </form>
            </div>

            <!-- Language Selector -->
            <div class="sidebar-lang">
                <select id="lang-select" class="lang-selector" onchange="switchLanguage(this.value)">
                    
                    <option value="en" >
                        English
                    </option>
                    
                    <option value="ko" selected>
                        한국어
                    </option>
                    
                </select>
            </div>

            <div class="sidebar-footer">
                <button class="theme-toggle" id="theme-toggle" aria-label="Toggle theme">
                    <span class="theme-icon light">☀️</span>
                    <span class="theme-icon dark">🌙</span>
                </button>
            </div>
        </aside>

        <!-- Main Content -->
        <main class="main-content">
            <header class="main-header">
                <button class="menu-toggle" id="menu-toggle" aria-label="Open menu">
                    <span></span>
                </button>
                
<nav class="breadcrumb">
    <a href="/study/ko/">Topics</a>
    <span class="separator">/</span>
    <a href="/study/ko/Software_Engineering/">Software Engineering</a>
    <span class="separator">/</span>
    <span class="current">레슨 13: DevOps와 CI/CD</span>
</nav>

            </header>

            <div class="content">
                
<article class="lesson-article">
    <header class="lesson-header">
        <h1>레슨 13: DevOps와 CI/CD</h1>
    </header>

    
<div class="lesson-toolbar lesson-toolbar--top">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Software_Engineering/12_Process_Improvement.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">레슨 12: 소프트웨어 프로세스 개선(Software Process Improvement)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Software_Engineering/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Software_Engineering/14_Technical_Documentation.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">레슨 14: 기술 문서화(Technical Documentation)</span>
        </a>
        
    </div>
</div>


    
    <nav class="toc" id="toc">
        <h2>Table of Contents</h2>
        <div class="toc">
<ul>
<li><a href="#1-devops">1. DevOps란 무엇인가?</a><ul>
<li><a href="#devops-vs">DevOps vs. 전통적 운영</a></li>
<li><a href="#devops-vs-sre">DevOps vs. SRE</a></li>
</ul>
</li>
<li><a href="#2-calms">2. CALMS 프레임워크</a><ul>
<li><a href="#c-culture">C — 문화(Culture)</a></li>
<li><a href="#a-automation">A — 자동화(Automation)</a></li>
<li><a href="#l-lean">L — 린(Lean)</a></li>
<li><a href="#m-measurement">M — 측정(Measurement)</a></li>
<li><a href="#s-sharing">S — 공유(Sharing)</a></li>
</ul>
</li>
<li><a href="#3-continuous-integration">3. 지속적 통합(Continuous Integration)</a><ul>
<li><a href="#ci">CI가 해결하는 문제</a></li>
<li><a href="#ci_1">CI 원칙</a></li>
<li><a href="#ci_2">CI 파이프라인 단계</a></li>
<li><a href="#ci_3">CI의 테스트 피라미드</a></li>
</ul>
</li>
<li><a href="#4-continuous-delivery-vs-continuous-deployment">4. 지속적 납품(Continuous Delivery) vs. 지속적 배포(Continuous Deployment)</a><ul>
<li><a href="#continuous-delivery">지속적 납품(Continuous Delivery)</a></li>
<li><a href="#continuous-deployment">지속적 배포(Continuous Deployment)</a></li>
</ul>
</li>
<li><a href="#5">5. 배포 전략</a><ul>
<li><a href="#rolling-deployment">롤링 배포(Rolling Deployment)</a></li>
<li><a href="#-blue-green-deployment">블루-그린 배포(Blue-Green Deployment)</a></li>
<li><a href="#canary-deployment">카나리 배포(Canary Deployment)</a></li>
<li><a href="#feature-flags">피처 플래그(Feature Flags)</a></li>
</ul>
</li>
<li><a href="#6-infrastructure-as-code">6. 코드로서의 인프라(Infrastructure as Code)</a><ul>
<li><a href="#_1">핵심 원칙</a></li>
<li><a href="#iac">IaC 범주</a></li>
</ul>
</li>
<li><a href="#7-observability">7. 모니터링과 관찰 가능성(Observability)</a><ul>
<li><a href="#_2">세 가지 기둥</a><ul>
<li><a href="#metrics">메트릭(Metrics)</a></li>
<li><a href="#logs">로그(Logs)</a></li>
<li><a href="#traces">트레이스(Traces)</a></li>
</ul>
</li>
<li><a href="#_3">경보 원칙</a></li>
</ul>
</li>
<li><a href="#8-incident-management">8. 사고 관리(Incident Management)</a><ul>
<li><a href="#_4">온콜 실천</a></li>
<li><a href="#blameless-postmortems">무결점 사후 검토(Blameless Postmortems)</a></li>
</ul>
</li>
<li><a href="#9-dora">9. DORA 메트릭</a><ul>
<li><a href="#4-dora">4가지 DORA 메트릭</a></li>
<li><a href="#_5">메트릭이 드러내는 것</a></li>
<li><a href="#dora">DORA 메트릭 사용</a></li>
</ul>
</li>
<li><a href="#10-devops">10. DevOps 성숙도 모델</a></li>
<li><a href="#11-devops">11. DevOps의 문화적 측면</a><ul>
<li><a href="#_6">사일로 허물기</a></li>
<li><a href="#_7">공유 책임</a></li>
<li><a href="#_8">실패에서 배우기</a></li>
</ul>
</li>
<li><a href="#_9">요약</a></li>
<li><a href="#_10">연습 문제</a></li>
<li><a href="#_11">더 읽을거리</a></li>
</ul>
</div>

    </nav>
    

    <div class="lesson-content markdown-body">
        <h1 id="13-devops-cicd">레슨 13: DevOps와 CI/CD<a class="header-link" href="#13-devops-cicd" title="Permanent link">&para;</a></h1>
<p><strong>이전</strong>: <a href="./12_Process_Improvement.md">프로세스 개선</a> | <strong>다음</strong>: <a href="./14_Technical_Documentation.md">기술 문서화</a></p>
<hr />
<p>DevOps는 지난 10년간 소프트웨어 팀이 소프트웨어를 구축하고 납품하는 방식을 변화시켰다. 그러나 DevOps는 도구도, 제품도, 직함도 아니다 — 소프트웨어 개발과 IT 운영 사이의 전통적인 장벽을 허무는 <strong>문화와 실천의 집합</strong>이다. 이 레슨에서는 DevOps의 진정한 의미, 지속적 통합(Continuous Integration)과 지속적 납품(Continuous Delivery) 뒤에 있는 원칙, 그리고 성숙한 엔지니어링 조직이 납품 프로세스의 속도와 신뢰성을 어떻게 측정하고 개선하는지 탐구한다.</p>
<p><strong>난이도</strong>: ⭐⭐⭐</p>
<p><strong>선수 학습</strong>:
- <a href="./09_Configuration_Management.md">형상 관리</a> — 브랜칭 전략, 버전 관리 워크플로우
- <a href="./12_Process_Improvement.md">프로세스 개선</a> — 메트릭, 회고, 개선 사이클
- 빌드 시스템과 자동화 테스트 개념에 대한 기본 이해</p>
<p><strong>학습 목표</strong>:
- DevOps가 무엇인지 설명하고 전통적인 운영 및 SRE와 구별한다
- CALMS 프레임워크와 문화가 DevOps의 기반인 이유를 설명한다
- 의미 있는 단계와 품질 게이트가 있는 CI 파이프라인을 설계한다
- 지속적 납품(Continuous Delivery)과 지속적 배포(Continuous Deployment)를 구별한다
- 배포 전략을 비교한다: 롤링, 블루-그린, 카나리, 피처 플래그
- 관찰 가능성의 세 가지 기둥과 그 중요성을 설명한다
- DORA의 4가지 메트릭을 정의하고 팀 건강에 대해 무엇을 드러내는지 해석한다
- 무결점 사후 검토(blameless postmortems)와 심리적 안전이 학습을 가능하게 하는 이유를 설명한다</p>
<hr />
<h2 id="1-devops">1. DevOps란 무엇인가?<a class="header-link" href="#1-devops" title="Permanent link">&para;</a></h2>
<p>DevOps는 2008–2009년경 개발 팀과 운영 팀 사이의 만성적인 기능 장애에 대한 좌절에서 탄생했다. 개발자들은 새로운 기능을 빠르게 출시하도록 유인을 받았고, 운영 팀은 운영 환경을 안정적으로 유지하도록 유인을 받았다. 이 상반된 유인이 장벽을 만들었다 — 기능들은 배포를 기다리며 쌓였고, 사고들은 "나쁜 코드" 또는 "운영 실수"로 탓해졌으며, 아무도 전체 납품 파이프라인을 소유하지 않았다.</p>
<p><strong>DevOps는 개발 및 운영 엔지니어가 설계 및 개발부터 배포 및 운영 지원까지 전체 서비스 생명주기에 걸쳐 함께 작업하는 실천이다</strong> — 린 제조와 시스템 사고의 원칙을 소프트웨어 납품에 적용하면서.</p>
<p>이 용어는 Patrick Debois와 Andrew Shafer에 의해 대중화되었으며, "State of DevOps" 연구(2013년 Puppet Labs에서 시작, 이후 DORA가 계속)는 DevOps 실천이 상당히 더 나은 조직 성과와 상관관계가 있다는 첫 번째 엄격한 증거를 제공했다.</p>
<h3 id="devops-vs">DevOps vs. 전통적 운영<a class="header-link" href="#devops-vs" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>차원</th>
<th>전통적 방식</th>
<th>DevOps</th>
</tr>
</thead>
<tbody>
<tr>
<td>팀 구조</td>
<td>개발과 운영이 별도의 사일로</td>
<td>공유 책임, 교차 기능 팀</td>
</tr>
<tr>
<td>배포</td>
<td>대량 배치, 드물고, 고위험</td>
<td>소규모, 자주, 점진적</td>
</tr>
<tr>
<td>변경 승인</td>
<td>변경 자문 위원회, 수 주의 리드 타임</td>
<td>자동화된 게이트, 수 분에서 수 시간</td>
</tr>
<tr>
<td>사고 대응</td>
<td>비난 찾기, 에스컬레이션</td>
<td>무결점 사후 검토, 공유 온콜</td>
</tr>
<tr>
<td>피드백 루프</td>
<td>릴리스 후 버그 발견, 느린 피드백</td>
<td>모니터링, 경보, 빠른 복구</td>
</tr>
<tr>
<td>지식</td>
<td>운영이 운영 환경을 "소유"; 개발은 접근 없음</td>
<td>개발자가 자신의 서비스를 이해하고 운영할 수 있음</td>
</tr>
</tbody>
</table>
<h3 id="devops-vs-sre">DevOps vs. SRE<a class="header-link" href="#devops-vs-sre" title="Permanent link">&para;</a></h3>
<p>사이트 신뢰성 엔지니어링(SRE, Site Reliability Engineering)은 구글의 DevOps 원칙 구현이다. DevOps가 <em>철학</em>을 설명한다면, SRE는 <em>직무 기능과 실천의 집합</em>을 설명한다.</p>
<p>SRE는 구체적인 메커니즘을 도입한다:
- <strong>서비스 수준 목표(SLO, Service Level Objectives)</strong>: 정량화된 신뢰성 목표 (예: 99.9% 가용성)
- <strong>오류 예산(Error budgets)</strong>: 허용 가능한 다운타임 — 소진되면 신뢰성이 개선될 때까지 기능 작업 중단
- <strong>수고 감소(Toil reduction)</strong>: SRE는 반복적인 수동 작업을 자동화로 제거해야 함
- <strong>사후 검토(Postmortems)</strong>: 사고로부터의 구조화된 학습</p>
<p>관계: "SRE는 소프트웨어 엔지니어에게 운영 기능을 설계하도록 요청했을 때 얻는 것이다." DevOps는 더 넓은 문화적 운동이고, SRE는 이를 구현하는 하나의 엄격한 방법이다.</p>
<hr />
<h2 id="2-calms">2. CALMS 프레임워크<a class="header-link" href="#2-calms" title="Permanent link">&para;</a></h2>
<p>CALMS는 DevOps를 이해하기 위해 가장 널리 사용되는 프레임워크다. 각 글자는 조직 역량의 한 차원을 나타낸다.</p>
<h3 id="c-culture">C — 문화(Culture)<a class="header-link" href="#c-culture" title="Permanent link">&para;</a></h3>
<p>문화는 기반이다. 이것 없이는 어떤 도구도 실패한다. DevOps 문화는:
- <strong>공유 소유권(Shared ownership)</strong>: 개발자와 운영 모두 신뢰성과 배포 성공을 소유한다
- <strong>비난 없는 환경(Blame-free environment)</strong>: 실패는 사람을 처벌하는 것이 아니라 시스템을 개선할 기회다
- <strong>투명성(Transparency)</strong>: 메트릭, 사고, 결정이 팀 전체에 가시적이다
- <strong>고객 집중(Customer focus)</strong>: 궁극적인 척도는 사용자에게 전달된 가치다</p>
<p>문화적 전환이 가장 어렵다. 리더십의 지원, 신뢰 구축, 그리고 종종 조직 개편이 필요하다. 많은 "DevOps 전환"이 도구 선택이 아니라 기저의 문화가 바뀌지 않았기 때문에 실패한다.</p>
<h3 id="a-automation">A — 자동화(Automation)<a class="header-link" href="#a-automation" title="Permanent link">&para;</a></h3>
<p>자동화는 납품 파이프라인에서 수동적이고 오류가 발생하기 쉬운 단계를 제거한다:
- 코드 빌드 및 컴파일
- 모든 수준에서의 테스트 실행
- 인프라 프로비저닝
- 모든 환경에 배포
- 형상 관리
- 보안 스캔</p>
<p>자동화의 목표는 단순히 속도가 아니라 <strong>일관성</strong>과 <strong>재현성</strong>이다. 90%의 시간에만 작동하는 수동 프로세스는 신뢰성 문제다.</p>
<h3 id="l-lean">L — 린(Lean)<a class="header-link" href="#l-lean" title="Permanent link">&para;</a></h3>
<p>제조업의 린 원칙이 소프트웨어 납품에 직접 적용된다:
- <strong>낭비 제거(Eliminate waste)</strong>: 불필요한 승인 단계, 환경 대기, 수동 인계
- <strong>피드백 증폭(Amplify feedback)</strong>: 문제를 빠르게 가시화하여 수정할 수 있도록
- <strong>소규모 배치(Small batch sizes)</strong>: 위험을 줄이고 피드백을 가속화하기 위해 더 자주 더 작은 변경 배포
- <strong>흐름(Flow)</strong>: 개별 단계가 아닌 전체 시스템의 처리량 최적화</p>
<p>린에서의 핵심 통찰: 배포 후 발견된 결함은 코드 검토에서 잡힌 것보다 수정하는 데 10배, 좋은 설계로 예방한 것보다 100배 더 비용이 든다.</p>
<h3 id="m-measurement">M — 측정(Measurement)<a class="header-link" href="#m-measurement" title="Permanent link">&para;</a></h3>
<p>측정할 수 없는 것은 개선할 수 없다. DevOps 팀은 모든 것을 계측한다:
- 배포 빈도와 리드 타임
- 시스템 건강: 오류율, 지연, 포화
- 파이프라인 건강: 빌드 성공률, 테스트 커버리지 추세
- 비즈니스 결과: 전환율, 사용자 참여</p>
<p>측정에는 도구(모니터링, APM, 로깅)가 필요하지만, 더 중요한 것은 데이터를 기반으로 결정을 내리고 실패 데이터를 숨기지 않고 배우는 문화다.</p>
<h3 id="s-sharing">S — 공유(Sharing)<a class="header-link" href="#s-sharing" title="Permanent link">&para;</a></h3>
<p>지식 사일로는 DevOps의 적이다. 공유란:
- 전체 조직에 공개된 사후 검토
- 모든 사람이 접근 가능한 런북(runbook)과 플레이북(playbook)
- 시스템이 특정 방식으로 구축된 <em>이유</em>를 설명하는 아키텍처 결정 기록(Architecture Decision Records)
- 내부 기술 강연, 실천 공동체, 멘토링
- 가능하면 오픈 소스에 기여</p>
<hr />
<h2 id="3-continuous-integration">3. 지속적 통합(Continuous Integration)<a class="header-link" href="#3-continuous-integration" title="Permanent link">&para;</a></h2>
<p>지속적 통합(CI, Continuous Integration)은 코드 변경을 자주 — 이상적으로는 하루에 여러 번 — 공유 저장소에 통합하고, 자동화된 빌드 및 테스트 스위트로 각 통합을 검증하는 실천이다.</p>
<h3 id="ci">CI가 해결하는 문제<a class="header-link" href="#ci" title="Permanent link">&para;</a></h3>
<p>CI 이전에는 팀이 수 주 또는 수 개월 동안 별도의 브랜치에서 작업한 다음 릴리스 전에 모든 것을 합치려는 시도가 일반적이었다. 결과는 <strong>통합 지옥(integration hell)</strong>이었다: 대규모 충돌, 깨진 테스트, 며칠간의 디버깅. Martin Fowler와 Kent Beck은 이 문제를 직접 해결하기 위해 익스트림 프로그래밍(Extreme Programming)의 일환으로 CI를 대중화했다.</p>
<h3 id="ci_1">CI 원칙<a class="header-link" href="#ci_1" title="Permanent link">&para;</a></h3>
<ol>
<li><strong>단일 소스 저장소 유지</strong>: 모든 코드가 하나의 메인 브랜치에 있거나 자주 병합됨</li>
<li><strong>빌드 자동화</strong>: 누구든 코드를 체크아웃하고 단일 명령으로 빌드할 수 있어야 함</li>
<li><strong>빌드를 자체 테스트로</strong>: 빌드가 테스트를 실행하고, 빌드 통과는 코드가 올바름을 의미함</li>
<li><strong>모든 커밋이 빌드를 트리거</strong>: 파이프라인이 모든 푸시에서 자동으로 실행됨</li>
<li><strong>깨진 빌드 즉시 수정</strong>: 깨진 메인 브랜치는 최우선 순위 — "나중에 고칠게"가 아님</li>
<li><strong>빌드를 빠르게 유지</strong>: 45분이 걸리는 CI 파이프라인은 나쁜 피드백을 제공 — 핵심 파이프라인은 10분 미만 목표</li>
<li><strong>운영과 유사한 환경에서 테스트</strong>: 테스트와 운영 환경 간의 차이가 위험을 도입함</li>
<li><strong>결과를 가시적으로</strong>: 빌드 상태를 보여주는 대시보드는 팀 건강 지표임</li>
</ol>
<h3 id="ci_2">CI 파이프라인 단계<a class="header-link" href="#ci_2" title="Permanent link">&para;</a></h3>
<p>일반적인 CI 파이프라인은 증가하는 깊이와 비용의 단계를 거친다:</p>
<div class="highlight"><pre><span></span><code><span class="k">[커밋(Commit)]</span>
<span class="w">   </span><span class="na">│</span>
<span class="w">   </span><span class="na">▼</span>
<span class="na">[체크아웃 &amp; 컴파일]          ~30초</span>
<span class="w">   </span><span class="na">│  구문 오류, 누락된 의존성</span>
<span class="w">   </span><span class="na">▼</span>
<span class="na">[단위 테스트(Unit Tests)]    ~2–5분</span>
<span class="w">   </span><span class="na">│  빠르고, 격리되고, 높은 커버리지</span>
<span class="w">   </span><span class="na">▼</span>
<span class="na">[정적 분석 &amp; 린팅]           ~1–2분</span>
<span class="w">   </span><span class="na">│  코드 스타일, 복잡도, 보안 패턴 (SAST)</span>
<span class="w">   </span><span class="na">▼</span>
<span class="na">[통합 테스트(Integration Tests)] ~5–10분</span>
<span class="w">   </span><span class="na">│  컴포넌트 경계 간 테스트, 데이터베이스 상호작용</span>
<span class="w">   </span><span class="na">▼</span>
<span class="na">[아티팩트 빌드(Build Artifact)] ~1–3분</span>
<span class="w">   </span><span class="na">│  Docker 이미지, JAR, 바이너리, 패키지</span>
<span class="w">   </span><span class="na">▼</span>
<span class="na">[보안 스캔(Security Scanning)] ~2–5분</span>
<span class="w">   </span><span class="na">│  의존성 취약점 (SCA), 컨테이너 이미지 스캔</span>
<span class="w">   </span><span class="na">▼</span>
<span class="na">[통과(PASS)] → 아티팩트를 레지스트리에 저장</span>
<span class="na">[실패(FAIL)] → 빌드 차단, 개발자에게 알림</span>
</code></pre></div>

<p><strong>품질 게이트(Quality gates)</strong>: 각 단계가 게이트 역할을 한다. 단계 실패는 파이프라인을 중단시키고 깨진 아티팩트가 진행되는 것을 막는다. 이 "빠른 실패(fail fast)" 원칙이 필수적이다 — 문제가 일찍 잡힐수록 수정하는 데 비용이 덜 든다.</p>
<h3 id="ci_3">CI의 테스트 피라미드<a class="header-link" href="#ci_3" title="Permanent link">&para;</a></h3>
<p>테스트 피라미드(Mike Cohn)는 어떤 유형의 테스트를 언제 실행할지 안내한다:</p>
<div class="highlight"><pre><span></span><code>        /\
       /  \
      / E2E \         적고, 느리고, 불안정 — 덜 자주 실행
     /--------\
    / Integration\    적당량 — 모든 커밋에서 실행
   /--------------\
  /   Unit Tests   \  많고, 빠르고, 신뢰할 수 있음 — 모든 커밋에서 실행
 /------------------\
</code></pre></div>

<p>단위 테스트가 피라미드를 지배해야 한다. 밀리초 단위로 실행되고, 외부 의존성이 없으며, 정확한 피드백을 제공한다. 느린 통합 테스트가 너무 많은 파이프라인은 피드백에 너무 오래 걸리기 때문에 무시된다.</p>
<hr />
<h2 id="4-continuous-delivery-vs-continuous-deployment">4. 지속적 납품(Continuous Delivery) vs. 지속적 배포(Continuous Deployment)<a class="header-link" href="#4-continuous-delivery-vs-continuous-deployment" title="Permanent link">&para;</a></h2>
<p>이 용어들은 관련이 있지만 구별되며, 그 구별이 중요하다.</p>
<h3 id="continuous-delivery">지속적 납품(Continuous Delivery)<a class="header-link" href="#continuous-delivery" title="Permanent link">&para;</a></h3>
<p><strong>정의</strong>: 모든 성공적인 빌드는 언제든지 운영 환경에 배포될 <em>수 있는</em> 아티팩트를 생성한다. 운영 환경으로의 배포는 <em>수동 결정</em>이다.</p>
<p>지속적 납품은 다음을 보장한다:
- 소프트웨어는 항상 배포 가능한 상태
- 배포는 저위험의 일상적인 작업
- 비즈니스가 릴리스를 <em>언제</em> 할지 선택할 수 있음 (릴리스가 기술적으로 가능한지만이 아닌)</p>
<p>"기술적으로 릴리스 가능"과 "릴리스하기 위한 비즈니스 결정"의 이 분리는 강력하다. 팀은 사용자에게 준비가 되지 않은 기능을 완성하고, 코드를 메인에 병합된 상태로 유지하다가, 마케팅 팀이 준비되면 릴리스할 수 있다.</p>
<h3 id="continuous-deployment">지속적 배포(Continuous Deployment)<a class="header-link" href="#continuous-deployment" title="Permanent link">&para;</a></h3>
<p><strong>정의</strong>: 모든 성공적인 빌드가 인간의 승인 없이 <em>자동으로</em> 운영 환경에 배포된다.</p>
<p>지속적 배포는 다음을 필요로 한다:
- 매우 높은 테스트 커버리지와 파이프라인 신뢰
- 배포 후 문제를 잡기 위한 강력한 모니터링 및 경보
- 빠른 롤백 능력 (자동화 또는 원클릭)
- 코드 배포에서 기능 가시성을 분리하는 피처 플래그</p>
<table>
<thead>
<tr>
<th></th>
<th>지속적 납품(Continuous Delivery)</th>
<th>지속적 배포(Continuous Deployment)</th>
</tr>
</thead>
<tbody>
<tr>
<td>운영 환경으로의 배포</td>
<td>수동 트리거</td>
<td>자동</td>
</tr>
<tr>
<td>인간 승인 단계</td>
<td>예 (마지막에)</td>
<td>아니오</td>
</tr>
<tr>
<td>위험 허용</td>
<td>중간</td>
<td>높은 신뢰 필요</td>
</tr>
<tr>
<td>일반적 사용 사례</td>
<td>엔터프라이즈, 규제 산업</td>
<td>고속 웹 서비스</td>
</tr>
<tr>
<td>예시</td>
<td>Netflix (주로), 은행</td>
<td>Flickr (2009년 하루 10+ 배포), 많은 SaaS 기업</td>
</tr>
</tbody>
</table>
<p>대부분의 조직은 지속적 납품을 실천한다; 지속적 배포는 성숙한 CI와 강력한 모니터링 문화를 가진 팀에 적합하다.</p>
<hr />
<h2 id="5">5. 배포 전략<a class="header-link" href="#5" title="Permanent link">&para;</a></h2>
<p>변경을 어떻게 릴리스하느냐는 릴리스하느냐 만큼이나 중요하다. 다른 전략들은 위험을 다르게 관리한다.</p>
<h3 id="rolling-deployment">롤링 배포(Rolling Deployment)<a class="header-link" href="#rolling-deployment" title="Permanent link">&para;</a></h3>
<p>인스턴스를 하나씩 (또는 소규모 배치로) 업데이트한다. 어느 시점에서나 일부 인스턴스는 이전 버전을, 일부는 새 버전을 실행한다.</p>
<div class="highlight"><pre><span></span><code><span class="nl">이전</span><span class="p">:</span><span class="w">    </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span>
<span class="mi">1</span><span class="nl">단계</span><span class="p">:</span><span class="w">   </span><span class="o">[</span><span class="n">v2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span>
<span class="mi">2</span><span class="nl">단계</span><span class="p">:</span><span class="w">   </span><span class="o">[</span><span class="n">v2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span>
<span class="mi">3</span><span class="nl">단계</span><span class="p">:</span><span class="w">   </span><span class="o">[</span><span class="n">v2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v1</span><span class="o">]</span>
<span class="p">...</span>
<span class="nl">이후</span><span class="p">:</span><span class="w">    </span><span class="o">[</span><span class="n">v2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v2</span><span class="o">]</span><span class="w"> </span><span class="o">[</span><span class="n">v2</span><span class="o">]</span>
</code></pre></div>

<p><strong>장점</strong>: 점진적 출시, 추가 인프라 불필요, 일시 중지 용이.
<strong>단점</strong>: 동시에 운영 환경에 혼합 버전 존재 (하위 호환성 필요), 다른 전략보다 느림.</p>
<h3 id="-blue-green-deployment">블루-그린 배포(Blue-Green Deployment)<a class="header-link" href="#-blue-green-deployment" title="Permanent link">&para;</a></h3>
<p>두 개의 동일한 운영 환경을 유지한다. 모든 트래픽을 "블루"(현재)로 라우팅한다. "그린"(유휴)에 배포한다. 트래픽을 한 번에 전환한다.</p>
<div class="highlight"><pre><span></span><code>         [로드 밸런서]
              │
     ┌────────┴────────┐
     ▼                 ▼
  [블루: v1]       [그린: v2]
  ← 트래픽            유휴

  (전환 후)

  [블루: v1]       [그린: v2]
    유휴            ← 트래픽
</code></pre></div>

<p><strong>장점</strong>: 즉각적인 롤백 (블루로 다시 전환), 혼합 버전 없음.
<strong>단점</strong>: 두 배의 인프라 필요, 데이터베이스 스키마 변경이 까다로움.</p>
<h3 id="canary-deployment">카나리 배포(Canary Deployment)<a class="header-link" href="#canary-deployment" title="Permanent link">&para;</a></h3>
<p>트래픽의 소규모 비율을 새 버전으로 라우팅하고, 관찰하다가 점진적으로 증가시킨다.</p>
<div class="highlight"><pre><span></span><code><span class="k">[로드 밸런서]</span>
<span class="w">      </span><span class="na">│</span>
<span class="w">  </span><span class="na">┌───┴──────────────┐</span>
<span class="w">  </span><span class="na">▼ (5%)             ▼ (95%)</span>
<span class="k">[v2: 카나리]      [v1: 안정]</span>
</code></pre></div>

<p><strong>장점</strong>: 실제 운영 트래픽이 제한된 노출로 새 버전을 검증; 전체 출시 전에 통계적 신뢰성.
<strong>단점</strong>: 트래픽 라우팅 능력 필요, 낮은 트래픽 볼륨에서 문제를 감지할 만큼 모니터링이 정밀해야 함.</p>
<h3 id="feature-flags">피처 플래그(Feature Flags)<a class="header-link" href="#feature-flags" title="Permanent link">&para;</a></h3>
<p>피처 플래그(피처 토글, 피처 게이트라고도 함)는 <em>코드 배포</em>와 <em>기능 가시성</em>을 분리한다. 코드가 비활성화 상태로 운영 환경에 출시되고, 기능은 설정을 통해 특정 사용자, 비율, 또는 지역에 대해 활성화된다.</p>
<div class="highlight"><pre><span></span><code><span class="c1"># 예시: 서버 측 피처 플래그 확인 (의사 코드)</span>
<span class="k">if</span> <span class="n">feature_flags</span><span class="o">.</span><span class="n">is_enabled</span><span class="p">(</span><span class="s2">&quot;new_checkout_flow&quot;</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="n">current_user</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">render_new_checkout</span><span class="p">()</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">render_old_checkout</span><span class="p">()</span>
</code></pre></div>

<p>피처 플래그를 통해:
- <strong>A/B 테스트</strong>: 비즈니스 메트릭을 위한 두 버전 비교
- <strong>점진적 출시</strong>: 1% → 10% → 50% → 100%로 활성화
- <strong>킬 스위치</strong>: 배포 없이 문제 있는 기능을 즉시 비활성화
- <strong>베타 프로그램</strong>: 동의한 사용자에게만 활성화</p>
<p>피처 플래그는 신중하게 관리해야 한다: 전체 출시 후 정리되지 않으면 오래된 플래그들이 기술 부채로 쌓인다.</p>
<hr />
<h2 id="6-infrastructure-as-code">6. 코드로서의 인프라(Infrastructure as Code)<a class="header-link" href="#6-infrastructure-as-code" title="Permanent link">&para;</a></h2>
<p>코드로서의 인프라(IaC, Infrastructure as Code)는 수동 프로세스나 대화형 도구가 아닌 기계가 읽을 수 있는 설정 파일을 통해 인프라를 관리하고 프로비저닝하는 실천이다.</p>
<h3 id="_1">핵심 원칙<a class="header-link" href="#_1" title="Permanent link">&para;</a></h3>
<p><strong>멱등성(Idempotency)</strong>: 같은 설정을 여러 번 적용해도 같은 결과가 나온다. 프로비저닝 스크립트를 두 번 실행해도 중복 리소스가 생성되어서는 안 된다.</p>
<p><strong>버전 관리</strong>: 인프라 설정은 애플리케이션 코드와 같은 저장소에 존재한다. 변경은 검토되고, 테스트되고, 감사된다.</p>
<p><strong>선언적 vs. 명령적</strong>:
- <em>선언적(Declarative)</em>: 원하는 최종 상태를 기술; 도구가 거기에 도달하는 방법을 파악 (Terraform, CloudFormation, Kubernetes 매니페스트)
- <em>명령적(Imperative)</em>: 수행할 단계를 기술 (Ansible 플레이북, 셸 스크립트)</p>
<p>현대 IaC는 상태와 멱등성에 대해 추론하기 더 쉽기 때문에 선언적 방향으로 경향이 있다.</p>
<p><strong>인프라 테스트</strong>: IaC 설정은 애플리케이션 코드와 마찬가지로 테스트해야 한다 — 모듈 단위 테스트, 테스트 환경에서 실제 인프라를 프로비저닝하는 통합 테스트, 그리고 코드형 정책(policy-as-code) 확인 (예: "S3 버킷은 공개 읽기 불가").</p>
<h3 id="iac">IaC 범주<a class="header-link" href="#iac" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>범주</th>
<th>목적</th>
<th>예시</th>
</tr>
</thead>
<tbody>
<tr>
<td>프로비저닝(Provisioning)</td>
<td>인프라 리소스 생성</td>
<td>Terraform, Pulumi, CloudFormation</td>
</tr>
<tr>
<td>형상 관리(Configuration management)</td>
<td>기존 서버에서 소프트웨어 구성</td>
<td>Ansible, Chef, Puppet</td>
</tr>
<tr>
<td>컨테이너 오케스트레이션(Container orchestration)</td>
<td>컨테이너 워크로드 관리</td>
<td>Kubernetes, Nomad</td>
</tr>
<tr>
<td>이미지 빌드(Image building)</td>
<td>재사용 가능한 머신 이미지 생성</td>
<td>Packer, Docker</td>
</tr>
<tr>
<td>코드형 정책(Policy as code)</td>
<td>컴플라이언스 규칙 시행</td>
<td>OPA, Sentinel, Checkov</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="7-observability">7. 모니터링과 관찰 가능성(Observability)<a class="header-link" href="#7-observability" title="Permanent link">&para;</a></h2>
<p>소프트웨어가 배포되면, 올바르게 작동하고 있는지 알아야 한다. <strong>관찰 가능성(Observability)</strong>은 외부 출력에서 시스템의 내부 상태를 추론할 수 있는 정도다.</p>
<h3 id="_2">세 가지 기둥<a class="header-link" href="#_2" title="Permanent link">&para;</a></h3>
<h4 id="metrics">메트릭(Metrics)<a class="header-link" href="#metrics" title="Permanent link">&para;</a></h4>
<p>메트릭은 시간에 따라 샘플링된 숫자 측정값이다. 저장 비용이 저렴하고, 집계하기 쉽고, 경보에 적합하다.</p>
<p>범주 (리소스용 USE 방법, 서비스용 RED 방법):
- <strong>활용률(Utilization)</strong>: 리소스가 얼마나 바쁜가? (CPU %, 메모리 %)
- <strong>포화(Saturation)</strong>: 얼마나 많은 작업이 대기 중인가? (요청 큐 깊이)
- <strong>오류(Errors)</strong>: 오류율은 얼마인가? (HTTP 5xx 비율)
- <strong>속도(Rate)</strong>: 초당 요청 수는?
- <strong>지속 시간(Duration)</strong>: 요청에 얼마나 걸리는가? (p50, p95, p99 지연)</p>
<h4 id="logs">로그(Logs)<a class="header-link" href="#logs" title="Permanent link">&para;</a></h4>
<p>로그는 개별 이벤트의 타임스탬프 기록이다. 메트릭이 제공할 수 없는 세부 사항을 제공한다 — 정확한 오류 메시지, 요청 ID, 영향받은 사용자.</p>
<p>좋은 로깅 실천:
- <strong>구조화된 로깅(Structured logging)</strong>: 로그를 기계가 파싱할 수 있도록 자유 텍스트가 아닌 JSON으로 출력
- <strong>상관 ID(Correlation IDs)</strong>: 모든 요청에 고유 ID; 해당 요청의 모든 로그 줄에 이를 포함
- <strong>로그 레벨(Log levels)</strong>: DEBUG, INFO, WARN, ERROR — 레벨을 일관성 있게 사용; 모든 것을 ERROR로 로깅하지 않음
- <strong>민감한 데이터 로깅 금지</strong>: 비밀번호, 토큰, 개인정보(PII)는 절대 로그에 나타나면 안 됨</p>
<h4 id="traces">트레이스(Traces)<a class="header-link" href="#traces" title="Permanent link">&para;</a></h4>
<p>분산 트레이싱(Distributed tracing)은 요청이 여러 서비스를 통해 흐르는 것을 추적한다. 각 서비스는 <em>스팬(span)</em> (시작 시간, 종료 시간, 서비스 이름, 작업 이름)을 기록하고, 스팬들은 같은 트레이스 ID로 연결된다.</p>
<p>트레이스는 답한다: "이 요청이 왜 느렸는가? 어느 서비스가 병목이었는가?"</p>
<h3 id="_3">경보 원칙<a class="header-link" href="#_3" title="Permanent link">&para;</a></h3>
<p>모든 문제가 즉각적인 인간 대응을 필요로 하지는 않는다. 좋은 경보:
- <strong>증상에 경보, 원인이 아닌</strong>: "오류율 &gt; 1%"보다 "CPU &gt; 80%" (높은 CPU가 사용자에게 영향을 주지 않을 수도 있음)
- <strong>SLO 소모율에 임계값 설정</strong>: 지속 가능한 속도보다 빠르게 오류 예산을 소모할 때 경보
- <strong>노이즈 최소화</strong>: 경보 피로는 엔지니어가 경보를 무시하게 만든다 — 새벽 3시에 누군가를 깨우는 모든 경보는 실행 가능해야 함
- <strong>런북 링크 포함</strong>: 모든 경보는 진단 및 해결 방법을 설명하는 런북에 링크해야 함</p>
<hr />
<h2 id="8-incident-management">8. 사고 관리(Incident Management)<a class="header-link" href="#8-incident-management" title="Permanent link">&para;</a></h2>
<p>잘 설계된 시스템도 실패한다. 조직이 사고에 어떻게 대응하고 배우느냐가 신뢰성 문화를 정의한다.</p>
<h3 id="_4">온콜 실천<a class="header-link" href="#_4" title="Permanent link">&para;</a></h3>
<ul>
<li><strong>순환(Rotation)</strong>: 팀원들 사이에서 온콜 부담을 공평하게 분배</li>
<li><strong>에스컬레이션 경로(Escalation paths)</strong>: 사고를 해결할 수 없을 때 누구에게 연락할지 알 수 있도록 명확한 에스컬레이션 체인 정의</li>
<li><strong>런북(Runbooks)</strong>: 알려진 장애 모드에 대한 미리 작성된 절차 — 온콜 엔지니어가 기본 진단을 즉흥적으로 해야 하지 않음</li>
<li><strong>사고 심각도 수준(Incident severity levels)</strong>: 심각도 기준 정의 (예: SEV1 = 완전 중단, SEV2 = 서비스 저하) 그래야 대응이 비례적임</li>
</ul>
<h3 id="blameless-postmortems">무결점 사후 검토(Blameless Postmortems)<a class="header-link" href="#blameless-postmortems" title="Permanent link">&para;</a></h3>
<p>사후 검토(postmortem)는 무슨 일이 있었는지, 왜, 재발 방지를 위해 무엇을 할 것인지를 기록하는 문서다. "무결점(blameless)" 수식어가 중요하다: 목표는 개인 처벌이 아닌 체계적 개선이다.</p>
<p><strong>왜 무결점인가?</strong>
사람들이 처벌을 두려워할 때, 정보를 숨긴다. 무결점 문화는 조직이 사고를 사람 문제가 아닌 시스템 문제로 다루기 때문에 엔지니어들이 — 자신의 실수를 포함하여 — 무슨 일이 있었는지 솔직하게 보고한다는 것을 의미한다. 이 투명성만이 실제로 개선하는 유일한 방법이다.</p>
<p><strong>표준 사후 검토 구조</strong>:</p>
<div class="highlight"><pre><span></span><code>사고 요약
  - 날짜, 기간, 심각도, 영향받은 시스템

타임라인
  - 이벤트의 시간순 순서 (UTC 타임스탬프)
  - 탐지, 에스컬레이션, 완화, 해결 포함

근본 원인 분석
  - 트리거 원인은 무엇이었는가?
  - 기여 요인은 무엇이었는가?
  - &quot;5 Why&quot; 또는 결함 트리 분석 사용

영향
  - 영향받은 사용자, 수익 영향, SLO 소모

행동 항목
  - 각 항목: 설명, 담당자, 기한, 우선순위
  - 즉각적 완화 vs. 장기적 수정 구별

얻은 교훈
  - 잘된 것은? (탐지, 대응)
  - 개선할 수 있는 것은?
  - 우리를 놀라게 한 것은?
</code></pre></div>

<p>사후 검토의 행동 항목은 추적되고 완료되어야 한다. 개선 목록을 만들었지만 아무것도 변하지 않는 사후 검토는 아예 없는 것보다 나쁘다 — 조직이 실제로 개선에 관심이 없다는 신호를 보낸다.</p>
<hr />
<h2 id="9-dora">9. DORA 메트릭<a class="header-link" href="#9-dora" title="Permanent link">&para;</a></h2>
<p>Dr. Nicole Forsgren, Jez Humble, Gene Kim이 이끄는 DevOps Research and Assessment(DORA) 프로그램은 소프트웨어 납품 성과에 대한 가장 큰 지속적인 과학적 연구다. 이 연구는 고성과 엔지니어링 조직과 저성과 조직을 구별하는 4가지 핵심 메트릭을 파악한다.</p>
<h3 id="4-dora">4가지 DORA 메트릭<a class="header-link" href="#4-dora" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>메트릭</th>
<th>정의</th>
<th>엘리트 수행자</th>
<th>저성과 수행자</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>배포 빈도(Deployment Frequency)</strong></td>
<td>운영 환경에 코드가 배포되는 빈도</td>
<td>하루 여러 번</td>
<td>월 1회 미만</td>
</tr>
<tr>
<td><strong>변경 리드 타임(Lead Time for Changes)</strong></td>
<td>코드 커밋에서 운영 환경에서 실행까지의 시간</td>
<td>1시간 미만</td>
<td>1–6개월</td>
</tr>
<tr>
<td><strong>변경 실패율(Change Failure Rate)</strong></td>
<td>운영 사고를 일으키는 배포의 비율</td>
<td>0–15%</td>
<td>46–60%</td>
</tr>
<tr>
<td><strong>서비스 복구 시간(Time to Restore, MTTR)</strong></td>
<td>운영 장애에서 복구하는 시간</td>
<td>1시간 미만</td>
<td>1주 – 1개월</td>
</tr>
</tbody>
</table>
<h3 id="_5">메트릭이 드러내는 것<a class="header-link" href="#_5" title="Permanent link">&para;</a></h3>
<p><strong>배포 빈도와 리드 타임</strong>은 <em>처리량(throughput)</em>을 측정한다 — 아이디어에서 운영까지 가치가 얼마나 빠르게 흐르는가.</p>
<p><strong>변경 실패율과 MTTR</strong>은 <em>안정성(stability)</em>을 측정한다 — 시스템이 얼마나 신뢰할 수 있고 얼마나 빠르게 복구되는가.</p>
<p>DORA 연구의 반직관적 발견: 높은 처리량과 높은 안정성은 <strong>상관관계가 있으며</strong> 트레이드오프가 아니다. 엘리트 팀은 더 자주 배포하며 <em>동시에</em> 실패가 적다. 이는 잦은 소규모 변경이 본질적으로 드문 대규모 변경보다 위험이 적고, 빠른 피드백 루프가 문제를 더 일찍 잡기 때문이다.</p>
<h3 id="dora">DORA 메트릭 사용<a class="header-link" href="#dora" title="Permanent link">&para;</a></h3>
<ul>
<li>성과 평가가 아닌 <strong>진단 신호</strong>로 사용한다. 배포 빈도를 개별 엔지니어를 순위 매기는 데 사용하지 않는다.</li>
<li>절대값보다 시간에 따른 추세가 더 유용하다. 팀이 개선되고 있는가?</li>
<li>DORA 메트릭은 지연 지표 — 결과를 반영한다. 이를 개선하려면 선행 실천에 집중한다 (CI, 테스트 커버리지, 배포 자동화, 관찰 가능성).</li>
</ul>
<hr />
<h2 id="10-devops">10. DevOps 성숙도 모델<a class="header-link" href="#10-devops" title="Permanent link">&para;</a></h2>
<p>조직은 DevOps를 점진적으로 채택한다. 성숙도 모델은 팀이 현재 어디에 있고 다음에 무엇을 해야 하는지 이해하는 데 도움을 준다.</p>
<table>
<thead>
<tr>
<th>레벨</th>
<th>명칭</th>
<th>특징</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>초기(Initial)</td>
<td>수동 배포, 제한된 자동화, 사일로 팀, 사고는 위기</td>
</tr>
<tr>
<td>2</td>
<td>개발 중(Developing)</td>
<td>기본 CI 파이프라인, 자동화 테스트, 일부 공유 소유권, 사후 검토 발생</td>
</tr>
<tr>
<td>3</td>
<td>정의됨(Defined)</td>
<td>지속적 납품, IaC, SLO 있는 모니터링, 무결점 사후 검토, 주간+ 배포 빈도</td>
</tr>
<tr>
<td>4</td>
<td>관리됨(Managed)</td>
<td>지속적 배포, 완전한 관찰 가능성, DORA 메트릭 추적, 오류 예산 사용</td>
</tr>
<tr>
<td>5</td>
<td>최적화(Optimizing)</td>
<td>실험 문화, 카오스 엔지니어링, 엘리트 DORA 메트릭, 실천을 산업에 환원</td>
</tr>
</tbody>
</table>
<p>대부분의 조직은 레벨 2–3에 있다. 레벨 3에서 4로 이동하는 것은 일반적으로 추가 도구보다 문화적 변화가 더 필요하다.</p>
<hr />
<h2 id="11-devops">11. DevOps의 문화적 측면<a class="header-link" href="#11-devops" title="Permanent link">&para;</a></h2>
<p>DevOps에서 기술은 쉬운 부분이다. 문화가 어려운 부분이다.</p>
<h3 id="_6">사일로 허물기<a class="header-link" href="#_6" title="Permanent link">&para;</a></h3>
<p>전통적인 조직은 개발자, QA, 보안, 운영을 서로 다른 관리자, 서로 다른 유인, 서로 다른 어휘를 가진 별도 부서로 분리한다. DevOps는 이 그룹들이 공유된 결과를 향해 통합된 팀으로 작업하도록 요구한다.</p>
<p>사일로를 허물기 위해서는:
- <strong>공유 목표(Shared goals)</strong>: 통합된 팀은 충돌하는 별도 부서 목표가 아닌 하나의 OKR 세트를 가짐
- <strong>내재된 전문성(Embedded expertise)</strong>: 보안과 운영 전문성이 별도 승인 대기열이 아닌 제품 팀 내에 존재
- <strong>직무 교환 및 섀도잉(Job rotation and shadowing)</strong>: 개발자가 온콜 시간을 보내고; 운영 엔지니어가 CI 파이프라인 개발에 기여
- <strong>공유 도구(Shared tools)</strong>: 공통 관찰 가능성 플랫폼, 공통 배포 플랫폼</p>
<h3 id="_7">공유 책임<a class="header-link" href="#_7" title="Permanent link">&para;</a></h3>
<p>"당신이 만들면, 당신이 실행한다(You build it, you run it)" — Amazon CTO Werner Vogels, 2006. 서비스를 구축하는 팀이 운영 환경에서 서비스를 운영할 책임이 있다. 이는 개발자가 운영 가능성에 관심을 갖도록 강제한다: 계측, 우아한 저하(graceful degradation), 런북, 경보.</p>
<p>공유 책임은 모든 개발자가 24/7 온콜이라는 의미가 아니다. 이것이 의미하는 바:
- 개발자가 자신의 서비스에 대한 온콜 순환에 참여
- 엔지니어가 운영 가능한 시스템을 설계 (기능적일 뿐만 아니라)
- 신뢰성은 사후 생각이 아닌 기능</p>
<h3 id="_8">실패에서 배우기<a class="header-link" href="#_8" title="Permanent link">&para;</a></h3>
<p>고성과 DevOps 조직은 모든 실패를 배움의 기회로 다룬다. 이는 심리적 안전 — 처벌 두려움 없이 발언하고, 실수를 인정하고, 질문할 수 있다는 믿음 — 을 필요로 한다.</p>
<p>리더는 다음을 통해 심리적 안전을 가능하게 한다:
- 직접 무결점 사후 검토를 수행하고 행동을 모델링
- 엔지니어가 문제를 조기에 탐지하고 보고할 때 축하
- 사고 데이터를 개인 성과 평가에 절대 사용하지 않음
- 공개적으로 자신의 실수를 인정</p>
<hr />
<h2 id="_9">요약<a class="header-link" href="#_9" title="Permanent link">&para;</a></h2>
<p>DevOps는 소프트웨어 개발과 운영 사이의 간격을 메워 빠르고 신뢰할 수 있는 소프트웨어 납품을 가능하게 하는 문화와 실천의 집합이다 — 도구가 아니다.</p>
<p>핵심 개념:
- <strong>CALMS</strong> (문화, 자동화, 린, 측정, 공유)는 DevOps 성숙도의 차원을 설명함
- <strong>CI</strong>는 모든 코드 변경이 자동화된 빌드 및 테스트 파이프라인으로 검증됨을 보장; 깨진 빌드는 즉시 수정
- <strong>지속적 납품</strong>은 소프트웨어가 항상 배포 가능함을 의미; <strong>지속적 배포</strong>는 자동으로 배포됨을 의미
- <strong>배포 전략</strong> (롤링, 블루-그린, 카나리, 피처 플래그)은 릴리스 중 위험을 관리
- <strong>IaC</strong>는 인프라 설정을 애플리케이션 코드와 같은 규율로 다룸
- <strong>관찰 가능성</strong> (메트릭, 로그, 트레이스)은 운영 시스템을 이해하는 데 필요한 가시성을 제공
- <strong>무결점 사후 검토</strong>는 개인을 처벌하지 않고 실패를 배움의 기회로 전환
- <strong>DORA 메트릭</strong>은 엔지니어링 성과에 대한 증거 기반 척도를 제공; 높은 처리량과 높은 안정성은 상관관계가 있으며 트레이드오프가 아님</p>
<hr />
<h2 id="_10">연습 문제<a class="header-link" href="#_10" title="Permanent link">&para;</a></h2>
<ol>
<li>
<p><strong>파이프라인 설계</strong>: 데이터베이스 백엔드가 있는 웹 애플리케이션을 위한 CI/CD 파이프라인을 스케치하라. 모든 단계, 각 단계에서 확인하는 것, 대략 소요 시간, 해당 단계에서의 실패 기준을 나열하라. 단계 순서를 정당화하라.</p>
</li>
<li>
<p><strong>배포 전략 선택</strong>: 팀이 99.99% 가동 시간 SLO를 가진 결제 처리 서비스를 운영하고 있다. 데이터베이스 스키마를 변경하는 새 버전을 배포해야 한다. 어떤 배포 전략을 권장하겠는가, 그 이유는? 스키마 변경이 어떤 복잡성을 도입하는가?</p>
</li>
<li>
<p><strong>DORA 평가</strong>: 팀이 월 1회 운영 환경에 배포하고, 커밋에서 운영까지 3주가 걸리고, 30% 변경 실패율을 가지며, 사고에서 복구하는 데 평균 2일이 걸린다. DORA 성숙도 범주를 사용하여 이 팀을 분류하라. 개선을 위해 어느 메트릭을 먼저 목표로 삼겠는가, 그리고 어떤 구체적인 실천을 권장하겠는가?</p>
</li>
<li>
<p><strong>사후 검토 작성</strong>: 트래픽 급증 후 데이터베이스 연결 풀이 소진되어 전자상거래 사이트가 블랙 프라이데이에 45분 중단을 경험했다. 사후 검토 개요를 작성하라: 타임라인(그럴듯한 세부 사항 작성), "5 Why"를 사용한 근본 원인 분석, 영향 추정, 그리고 담당자와 우선순위가 있는 최소 4개의 행동 항목.</p>
</li>
<li>
<p><strong>무결점 문화 분석</strong>: 팀 리드가 말한다: "우리의 사후 검토는 항상 실수를 한 사람을 파악한다. 우리는 책임이 필요하다." 책임과 비난의 차이를 설명하고, 무결점 사후 검토가 왜 실제로 더 나은 결과를 이끄는지 설명하는 답변을 작성하라. 심리적 안전과 사람들이 처벌을 두려워할 때 정보 흐름에 무슨 일이 일어나는지를 참조하라.</p>
</li>
</ol>
<hr />
<h2 id="_11">더 읽을거리<a class="header-link" href="#_11" title="Permanent link">&para;</a></h2>
<ul>
<li><strong>도서</strong>:</li>
<li><em>The Phoenix Project</em> — Gene Kim, Kevin Behr, George Spafford (DevOps 원칙에 대한 소설 스타일 소개)</li>
<li><em>Accelerate: The Science of Lean Software and DevOps</em> — Nicole Forsgren, Jez Humble, Gene Kim (DORA 메트릭 뒤의 연구)</li>
<li><em>The DevOps Handbook</em> — Gene Kim, Jez Humble, Patrick Debois, John Willis (포괄적인 실천 가이드)</li>
<li>
<p><em>Site Reliability Engineering</em> — Google (sre.google에서 무료 온라인) — SRE 실천 상세</p>
</li>
<li>
<p><strong>연구 및 보고서</strong>:</p>
</li>
<li>DORA State of DevOps Report (연간, dora.dev) — 엔지니어링 성과 벤치마크 데이터</li>
<li>
<p>"Psychological Safety and Learning Behavior in Work Teams" — Amy Edmondson, ASQ 1999</p>
</li>
<li>
<p><strong>아티클</strong>:</p>
</li>
<li>"Continuous Delivery" — Martin Fowler (martinfowler.com/bliki/ContinuousDelivery.html)</li>
<li>"Feature Toggles" — Pete Hodgson (martinfowler.com)</li>
<li>"CALMS: A DevOps Framework" — Atlassian 문서</li>
<li>"Blameless PostMortems and a Just Culture" — John Allspaw, Etsy Engineering Blog</li>
</ul>
<hr />
<p><strong>이전</strong>: <a href="./12_Process_Improvement.md">프로세스 개선</a> | <strong>다음</strong>: <a href="./14_Technical_Documentation.md">기술 문서화</a></p>
    </div>

    
<div class="lesson-toolbar lesson-toolbar--bottom">
    <div class="toolbar-nav toolbar-nav--prev">
        
        <a href="/study/ko/Software_Engineering/12_Process_Improvement.html" class="nav-prev">
            <span class="nav-label">Previous</span>
            <span class="nav-title">레슨 12: 소프트웨어 프로세스 개선(Software Process Improvement)</span>
        </a>
        
    </div>
    <div class="toolbar-actions">
        <button class="btn btn-copy-link" data-action="copy-link" title="Copy link">
            <span class="icon">🔗</span>
            <span class="text">Copy link</span>
        </button>
        <a href="/study/ko/Software_Engineering/" class="btn btn-topic-link" title="Back to topic list">
            <span class="icon">📋</span>
            <span class="text">Topic list</span>
        </a>
    </div>
    <div class="toolbar-nav toolbar-nav--next">
        
        <a href="/study/ko/Software_Engineering/14_Technical_Documentation.html" class="nav-next">
            <span class="nav-label">Next</span>
            <span class="nav-title">레슨 14: 기술 문서화(Technical Documentation)</span>
        </a>
        
    </div>
</div>


    <div class="toolbar-keyboard-hint">
        <kbd>&larr;</kbd> <kbd>&rarr;</kbd> to navigate between lessons
    </div>
</article>

<!-- Scroll to top floating button -->
<button class="scroll-to-top" id="scroll-to-top" title="Scroll to top" aria-label="Scroll to top">↑</button>

            </div>
        </main>
    </div>

    <script src="/study/static/js/app.js"></script>
    <script>
        function switchLanguage(newLang) {
            const path = window.location.pathname;
            const base = '/study';
            const currentLang = 'ko';
            const newPath = path.replace(base + '/' + currentLang + '/', base + '/' + newLang + '/');
            window.location.href = newPath + window.location.search;
        }
    </script>
    
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Copy link - independent feedback per button
        document.querySelectorAll('[data-action="copy-link"]').forEach(function(btn) {
            btn.addEventListener('click', function() {
                navigator.clipboard.writeText(window.location.href);
                var textEl = this.querySelector('.text');
                var originalText = textEl.textContent;
                textEl.textContent = 'Copied!';
                setTimeout(function() { textEl.textContent = originalText; }, 2000);
            });
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('.lesson-content pre').forEach(function(pre) {
            var copyBtn = document.createElement('button');
            copyBtn.className = 'code-copy-btn';
            copyBtn.textContent = 'Copy';
            copyBtn.addEventListener('click', function() {
                var code = pre.querySelector('code');
                var text = code ? code.textContent : pre.textContent;
                navigator.clipboard.writeText(text);
                copyBtn.textContent = 'Copied!';
                setTimeout(function() { copyBtn.textContent = 'Copy'; }, 2000);
            });
            pre.style.position = 'relative';
            pre.appendChild(copyBtn);
        });

        // Scroll to top button
        var scrollBtn = document.getElementById('scroll-to-top');
        window.addEventListener('scroll', function() {
            scrollBtn.classList.toggle('visible', window.scrollY > 300);
        });
        scrollBtn.addEventListener('click', function() {
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Keyboard shortcuts: left/right arrows for lesson navigation
        document.addEventListener('keydown', function(e) {
            var tag = document.activeElement.tagName;
            if (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT') return;

            if (e.key === 'ArrowLeft') {
                var prevLink = document.querySelector('.nav-prev');
                if (prevLink) prevLink.click();
            } else if (e.key === 'ArrowRight') {
                var nextLink = document.querySelector('.nav-next');
                if (nextLink) nextLink.click();
            }
        });
    });
</script>

</body>
</html>
{% endraw %}