{"documents": [{"id": "Algorithm/00_Overview", "title": "알고리즘 학습 가이드", "topic": "Algorithm", "topic_display": "Algorithm", "body": "이 폴더는 알고리즘과 자료구조를 체계적으로 학습하기 위한 자료를 담고 있습니다. 복잡도 분석부터 고급 알고리즘까지 단계별로 학습할 수 있으며, 코딩 인터뷰와 알고리즘 대회 준비에 도움이 됩니다. 대상 독자: 프로그래밍 기초를 아는 개발자, 코딩 테스트 준비자 --- --- - 프로그래밍 기초 (변수, 제어문, 함수) - 기본 자료구조 (배열, 리스트) - C, C++, 또는 Python 중 하나 이상의 언어 --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01ComplexityAnalysis.md | ⭐ | Big O, 시간/공간 복잡도, 분석 기법 | | 02ArraysandStrings.md | ⭐ | 2포인터, 슬라이딩 윈도우, 프리픽스 합 | | 03StacksandQueues.md | ⭐ | 괄호 검사, 후위표기법, 모노토닉 스택 | | 04HashTables.md | ⭐⭐ | 해시 함수, 충돌 해결, 해시맵/셋...", "url": "/study/ko/Algorithm/00_Overview.html"}, {"id": "Algorithm/01_Complexity_Analysis", "title": "복잡도 분석 (Complexity Analysis)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "알고리즘의 효율성을 측정하는 방법을 학습합니다. Big O 표기법을 이해하고 코드의 시간/공간 복잡도를 분석하는 능력은 알고리즘 학습의 기초입니다. --- 1. 왜 복잡도 분석이 필요한가? 2. Big O 표기법 3. 시간 복잡도 4. 공간 복잡도 5. 복잡도 분석 예제 6. 실전 분석 팁 7. 연습 문제 --- --- --- --- --- --- --- 다음 코드의 시간 복잡도를 구하세요. <details> <summary>정답 보기</summary> O(log²n) - 바깥 반복: i가 n에서 1까지 절반씩 감소 → log n번 - 안쪽 반복: j가 1에서 n까지 2배씩 증가 → log n번 - 총: log n × log n = O(log²n) </details> n = 1000일 때, 연산 횟수를 비교하세요. <details> <summary>정답 보기</summary> </details> <details> <summary>정답 보기</summary> O(n) 점화식:...", "url": "/study/ko/Algorithm/01_Complexity_Analysis.html"}, {"id": "Algorithm/02_Arrays_and_Strings", "title": "배열과 문자열 (Arrays and Strings)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "배열과 문자열은 가장 기본적인 자료구조입니다. 이 레슨에서는 배열/문자열 문제에서 자주 사용되는 핵심 테크닉인 2포인터, 슬라이딩 윈도우, 프리픽스 합을 학습합니다. --- 1. 배열 기초 2. 2포인터 기법 3. 슬라이딩 윈도우 4. 프리픽스 합 5. 문자열 처리 6. 빈도수 카운팅 7. 연습 문제 --- --- 문제: 정렬된 배열에서 두 수의 합이 target인 쌍 찾기 문제: 정렬된 배열에서 중복 제거 (In-place) --- 문제: 크기 k인 연속 부분 배열의 최대 합 문제: 합이 target 이상인 최소 길이 부분 배열 문제: 중복 없는 최장 부분 문자열 --- --- --- --- 배열을 오른쪽으로 k칸 회전하세요. <details> <summary>힌트</summary> 세 번의 뒤집기로 O(1) 공간으로 해결 가능: 1. 전체 뒤집기 2. 앞 k개 뒤집기 3. 나머지 뒤집기 </details> <details> <summary>정답 코드</summary>...", "url": "/study/ko/Algorithm/02_Arrays_and_Strings.html"}, {"id": "Algorithm/03_Stacks_and_Queues", "title": "스택과 큐 활용 (Stack and Queue Applications)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "스택(Stack)과 큐(Queue)는 기본적인 자료구조이지만, 다양한 알고리즘 문제에서 핵심적인 역할을 합니다. 이 레슨에서는 괄호 검사, 후위 표기법, 모노토닉 스택 등 실전에서 자주 사용되는 패턴을 학습합니다. --- 1. 스택과 큐 기초 2. 괄호 유효성 검사 3. 후위 표기법 4. 모노토닉 스택 5. 큐와 BFS 6. 덱(Deque) 활용 7. 연습 문제 --- --- 주어진 문자열의 괄호가 올바르게 짝지어졌는지 확인합니다. --- --- --- --- --- push, pop, top과 함께 O(1)에 최솟값을 반환하는 스택을 구현하세요. <details> <summary>힌트</summary> 두 개의 스택을 사용하거나, 각 원소와 함께 그 시점의 최솟값을 저장 </details> <details> <summary>정답 코드</summary> </details> 두 개의 큐를 사용하여 스택을 구현하세요. <details> <summary>힌트</summary> push할...", "url": "/study/ko/Algorithm/03_Stacks_and_Queues.html"}, {"id": "Algorithm/04_Hash_Tables", "title": "해시 테이블 (Hash Table)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "해시 테이블은 키-값 쌍을 저장하는 자료구조로, 평균 O(1) 시간에 삽입, 삭제, 검색이 가능합니다. 코딩 인터뷰에서 가장 많이 사용되는 자료구조 중 하나입니다. --- 1. 해시 테이블 개념 2. 해시 함수 3. 충돌 해결 4. 직접 구현 5. 언어별 사용법 6. 활용 문제 7. 연습 문제 --- --- --- --- --- --- --- | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐ | Two Sum | LeetCode | 기본 해시맵 | | ⭐ | Valid Anagram | LeetCode | 빈도수 | | ⭐⭐ | Group Anagrams | LeetCode | 키 설계 | | ⭐⭐ | 숫자 카드 2 | 백준 | 빈도수 | | ⭐⭐ | Subarray Sum Equals K | LeetCode | 프리픽스 합 | | ⭐⭐⭐ | Longest Consecutive Sequence | LeetCode |...", "url": "/study/ko/Algorithm/04_Hash_Tables.html"}, {"id": "Algorithm/05_Sorting_Algorithms", "title": "정렬 알고리즘 (Sorting Algorithms)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "정렬은 데이터를 특정 순서로 배열하는 기본적이면서도 중요한 알고리즘입니다. 다양한 정렬 알고리즘의 원리, 구현, 시간/공간 복잡도를 학습합니다. --- 1. 정렬 알고리즘 비교 2. 버블 정렬 3. 선택 정렬 4. 삽입 정렬 5. 병합 정렬 6. 퀵 정렬 7. 힙 정렬 8. 계수 정렬 9. 정렬 알고리즘 선택 10. 연습 문제 --- --- --- --- --- --- --- --- --- --- 정렬을 사용하지 않고 K번째로 큰 원소를 O(n) 평균 시간에 찾으세요. <details> <summary>힌트</summary> Quick Select 알고리즘: 퀵 정렬의 파티셔닝을 활용 </details> <details> <summary>정답 코드</summary> </details> 0, 1, 2로만 구성된 배열을 한 번의 순회로 정렬하세요. <details> <summary>정답 코드</summary> </details> | 난이도 | 문제 | 플랫폼 | 유형 |...", "url": "/study/ko/Algorithm/05_Sorting_Algorithms.html"}, {"id": "Algorithm/06_Searching_Algorithms", "title": "탐색 알고리즘 (Search Algorithms)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "탐색은 데이터에서 원하는 값을 찾는 기본적인 연산입니다. 이 레슨에서는 선형 탐색, 이진 탐색, 파라메트릭 서치, 해시 탐색 등 다양한 탐색 기법을 학습합니다. --- 1. 탐색 알고리즘 비교 2. 선형 탐색 3. 이진 탐색 4. 이진 탐색 변형 5. 파라메트릭 서치 6. 해시 탐색 7. 연습 문제 --- --- --- --- --- --- --- 정수 x의 제곱근을 정수로 반환하세요 (내림). <details> <summary>힌트</summary> mid mid <= x인 최대 mid 찾기 (이진 탐색) </details> <details> <summary>정답 코드</summary> </details> 피크 원소: 이웃한 원소들보다 큰 원소 <details> <summary>힌트</summary> 이진 탐색으로 O(log n)에 해결 가능 - mid > mid+1이면 왼쪽에 피크 존재 - mid < mid+1이면 오른쪽에 피크 존재 </details> <details>...", "url": "/study/ko/Algorithm/06_Searching_Algorithms.html"}, {"id": "Algorithm/07_Divide_and_Conquer", "title": "분할 정복 (Divide and Conquer)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "분할 정복은 큰 문제를 작은 부분 문제로 나누고, 각각을 해결한 후 결합하는 알고리즘 설계 기법입니다. --- 1. 분할 정복 개념 2. 병합 정렬 3. 퀵 정렬 4. 이진 탐색 5. 거듭제곱 6. 연습 문제 --- --- --- --- --- --- i < j이고 arr[i] > arr[j]인 쌍의 개수 <details> <summary>힌트</summary> 병합 정렬 과정에서 카운트 </details> <details> <summary>정답 코드</summary> </details> | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐⭐ | 행렬 제곱 | 백준 | 행렬 거듭제곱 | | ⭐⭐ | 피보나치 수 6 | 백준 | 행렬 거듭제곱 | | ⭐⭐ | K번째 수 | 백준 | Quick Select | | ⭐⭐⭐ | 버블 소트 | 백준 | 역순 쌍 | | ⭐⭐⭐ | 가장 가까운 두 점 | 백준 | 분할 정복 | ---...", "url": "/study/ko/Algorithm/07_Divide_and_Conquer.html"}, {"id": "Algorithm/08_Backtracking", "title": "백트래킹 (Backtracking)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "백트래킹은 해를 찾는 도중 막히면 되돌아가서 다시 해를 찾는 기법입니다. 가지치기(pruning)를 통해 불필요한 탐색을 줄입니다. --- 1. 백트래킹 개념 2. 순열과 조합 3. N-Queens 4. 부분집합 5. 스도쿠 6. 연습 문제 --- --- --- --- --- --- 중복 문자가 있을 때 중복 없이 순열 생성 <details> <summary>정답 코드</summary> </details> | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐⭐ | N과 M | 백준 | 순열 | | ⭐⭐ | N-Queens | 백준 | N-Queens | | ⭐⭐ | Subsets | LeetCode | 부분집합 | | ⭐⭐⭐ | Sudoku Solver | LeetCode | 스도쿠 | | ⭐⭐⭐ | Combination Sum | LeetCode | 조합 | --- --- - 09Treesand_BST.md - 트리,...", "url": "/study/ko/Algorithm/08_Backtracking.html"}, {"id": "Algorithm/09_Trees_and_BST", "title": "트리와 이진 탐색 트리 (Tree and BST)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "트리는 계층적 구조를 나타내는 비선형 자료구조입니다. 이진 탐색 트리(BST)는 효율적인 탐색, 삽입, 삭제를 지원합니다. --- 1. 트리 기본 개념 2. 트리 순회 3. 이진 탐색 트리 4. BST 연산 5. 균형 트리 개념 6. 연습 문제 --- --- --- --- --- --- BST에서 두 노드의 최소 공통 조상 찾기 <details> <summary>정답 코드</summary> </details> | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐ | 트리 순회 | 백준 | 순회 | | ⭐⭐ | Validate BST | LeetCode | BST | | ⭐⭐ | Binary Tree Inorder | LeetCode | 순회 | | ⭐⭐ | 이진 검색 트리 | 백준 | BST | | ⭐⭐⭐ | LCA | LeetCode | LCA | --- - 10HeapsandPriorityQueues.md - 힙,...", "url": "/study/ko/Algorithm/09_Trees_and_BST.html"}, {"id": "Algorithm/10_Heaps_and_Priority_Queues", "title": "힙과 우선순위 큐 (Heap and Priority Queue)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "힙은 완전 이진 트리 기반의 자료구조로, 최댓값/최솟값을 O(1)에 접근하고 O(log n)에 삽입/삭제할 수 있습니다. --- 1. 힙 개념 2. 힙 연산 3. 힙 정렬 4. 우선순위 큐 5. 활용 문제 6. 연습 문제 --- --- --- --- --- --- | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐⭐ | 최대 힙 | 백준 | 힙 기초 | | ⭐⭐ | Kth Largest | LeetCode | K번째 | | ⭐⭐ | 가운데를 말해요 | 백준 | 중앙값 | | ⭐⭐⭐ | Merge K Sorted Lists | LeetCode | 병합 | | ⭐⭐⭐ | Top K Frequent | LeetCode | 빈도 | --- --- - 11_Trie.md - 트라이 --- - Heap Visualization - Introduction to Algorithms (CLRS) - Chapter 6", "url": "/study/ko/Algorithm/10_Heaps_and_Priority_Queues.html"}, {"id": "Algorithm/11_Trie", "title": "트라이 (Trie)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "트라이(Trie)는 문자열을 효율적으로 저장하고 검색하는 트리 자료구조입니다. 접두사 트리(Prefix Tree)라고도 불리며, 자동완성, 사전 검색 등에 활용됩니다. --- 1. 트라이 개념 2. 기본 구현 3. 트라이 연산 4. XOR 트라이 5. 활용 문제 6. 연습 문제 --- --- --- --- --- --- | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐⭐ | Implement Trie | LeetCode | 기본 구현 | | ⭐⭐⭐ | 전화번호 목록 | 백준 | 접두사 | | ⭐⭐⭐ | Design Search Autocomplete | LeetCode | 자동완성 | | ⭐⭐⭐ | Add and Search Word | LeetCode | 와일드카드 | | ⭐⭐⭐⭐ | Maximum XOR of Two Numbers | LeetCode | XOR 트라이 | | ⭐⭐⭐⭐ | 문자열 집합 | 백준 | 검색...", "url": "/study/ko/Algorithm/11_Trie.html"}, {"id": "Algorithm/12_Graph_Basics", "title": "그래프 기초 (Graph Basics)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "그래프는 정점(vertex)과 간선(edge)으로 이루어진 자료구조로, 네트워크, 관계, 경로 등을 표현하는 데 사용됩니다. 이 레슨에서는 그래프의 기본 개념과 DFS, BFS 탐색을 학습합니다. --- 1. 그래프 기본 개념 2. 그래프 표현 3. 깊이 우선 탐색 (DFS) 4. 너비 우선 탐색 (BFS) 5. DFS vs BFS 6. 그래프 응용 7. 연습 문제 --- --- --- --- --- --- --- 두 정점 사이에 경로가 존재하는지 확인하세요. <details> <summary>정답 코드</summary> </details> 두 정점 사이의 모든 경로를 찾으세요. <details> <summary>정답 코드</summary> </details> | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐ | DFS와 BFS | 백준 | 기본 탐색 | | ⭐ | 연결 요소의 개수 | 백준 | 연결 요소 | | ⭐⭐ |...", "url": "/study/ko/Algorithm/12_Graph_Basics.html"}, {"id": "Algorithm/13_Topological_Sort", "title": "위상 정렬 (Topological Sort)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "위상 정렬은 방향 비순환 그래프(DAG)의 정점들을 선형으로 정렬하는 알고리즘입니다. 모든 간선 (u, v)에 대해 u가 v보다 먼저 나타나도록 정렬합니다. --- 1. 위상 정렬 개념 2. Kahn 알고리즘 (BFS) 3. DFS 기반 위상 정렬 4. 사이클 탐지 5. 활용 문제 6. 연습 문제 --- --- --- --- --- --- | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐⭐ | 줄 세우기 | 백준 | 기본 위상정렬 | | ⭐⭐ | Course Schedule | LeetCode | 사이클 탐지 | | ⭐⭐ | Course Schedule II | LeetCode | 위상정렬 순서 | | ⭐⭐⭐ | 작업 | 백준 | 최소 시간 | | ⭐⭐⭐ | 게임 개발 | 백준 | 작업 스케줄링 | | ⭐⭐⭐ | 문제집 | 백준 | 사전 순 위상정렬 | | ⭐⭐⭐⭐ | Alien Dictionary | LeetCode |...", "url": "/study/ko/Algorithm/13_Topological_Sort.html"}, {"id": "Algorithm/14_Shortest_Path", "title": "최단 경로 (Shortest Path)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "가중치가 있는 그래프에서 두 정점 사이의 최단 경로를 찾는 알고리즘을 학습합니다. Dijkstra, Bellman-Ford, Floyd-Warshall 알고리즘을 다룹니다. --- 1. 최단 경로 알고리즘 비교 2. 다익스트라 (Dijkstra) 3. 벨만-포드 (Bellman-Ford) 4. 플로이드-워셜 (Floyd-Warshall) 5. 0-1 BFS 6. 연습 문제 --- --- --- --- --- --- 시작 도시에서 정확히 K 거리인 모든 도시를 찾으세요. <details> <summary>정답 코드</summary> </details> 음수 사이클이 존재하는지 확인하세요. <details> <summary>정답 코드</summary> </details> | 난이도 | 문제 | 플랫폼 | 알고리즘 | |--------|------|--------|----------| | ⭐⭐ | 최단경로 | 백준 | Dijkstra | | ⭐⭐ | Network Delay Time |...", "url": "/study/ko/Algorithm/14_Shortest_Path.html"}, {"id": "Algorithm/15_Minimum_Spanning_Tree", "title": "최소 신장 트리 (Minimum Spanning Tree)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "최소 신장 트리(MST)는 그래프의 모든 정점을 연결하면서 간선 가중치 합이 최소인 트리입니다. Kruskal과 Prim 알고리즘, 그리고 Union-Find 자료구조를 학습합니다. --- 1. MST 개념 2. Union-Find 3. 크루스칼 (Kruskal) 4. 프림 (Prim) 5. 알고리즘 비교 6. 연습 문제 --- --- --- --- --- --- 주어진 그래프의 MST 가중치 합을 구하세요. <details> <summary>정답 코드</summary> </details> N개 마을을 2개 그룹으로 나누고, 각 그룹을 최소 비용으로 연결하세요. <details> <summary>힌트</summary> MST를 구한 후 가장 큰 간선 하나를 제거하면 2개 그룹이 됨 </details> <details> <summary>정답 코드</summary> </details> | 난이도 | 문제 | 플랫폼 | 알고리즘 |...", "url": "/study/ko/Algorithm/15_Minimum_Spanning_Tree.html"}, {"id": "Algorithm/16_LCA_and_Tree_Queries", "title": "26. LCA와 트리쿼리 (LCA and Tree Queries)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "- 최소 공통 조상(LCA)의 개념 이해 - Binary Lifting 기법 구현 - Sparse Table 활용 - 오일러 투어와 세그먼트 트리 결합 - 다양한 트리 쿼리 문제 해결 트리에서 두 노드 u, v의 최소 공통 조상(Lowest Common Ancestor)은 u와 v의 공통 조상 중 가장 깊은(낮은) 노드입니다. --- - 전처리: O(N) - 쿼리: O(N) - 최악의 경우 트리 높이만큼 --- 각 노드에서 2^k번째 조상을 미리 계산해두면, 2의 거듭제곱 점프로 빠르게 올라갈 수 있습니다. - 전처리: O(N log N) - 쿼리: O(log N) - 공간: O(N log N) --- 1. DFS로 오일러 투어 수행 (방문 순서 기록) 2. LCA(u, v) = 오일러 투어에서 u~v 구간의 최소 깊이 노드 3. Sparse Table로 O(1) RMQ - 전처리: O(N log N) - 쿼리: O(1) - 공간: O(N log N) --- u에서 v까지의 경로에...", "url": "/study/ko/Algorithm/16_LCA_and_Tree_Queries.html"}, {"id": "Algorithm/17_Strongly_Connected_Components", "title": "24. 강한 연결 요소 (Strongly Connected Components)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "- 강한 연결 요소(SCC)의 개념 이해 - Tarjan 알고리즘 구현 - Kosaraju 알고리즘 구현 - 2-SAT 문제 해결 - 응축 그래프(DAG) 활용 방향 그래프에서 강한 연결 요소(SCC)란 모든 정점 쌍 (u, v)에 대해 u→v, v→u 경로가 모두 존재하는 최대 부분 그래프입니다. 1. 최대성: SCC에 정점을 추가하면 더 이상 강하게 연결되지 않음 2. 분할성: 모든 정점은 정확히 하나의 SCC에 속함 3. DAG 구조: SCC들을 하나의 노드로 보면 DAG(비순환 방향 그래프)가 됨 --- 1. 원본 그래프에서 DFS로 종료 순서 기록 2. 역방향 그래프에서 종료 순서의 역순으로 DFS 3. 각 DFS 트리가 하나의 SCC - 시간: O(V + E) - DFS 2번 - 공간: O(V + E) - 역방향 그래프 저장 --- 단일 DFS로 SCC를 찾는 알고리즘. 발견 시간과 low-link 값을 사용합니다. - 발견 시간 (disc): 노드를 처음 방문한 시점...", "url": "/study/ko/Algorithm/17_Strongly_Connected_Components.html"}, {"id": "Algorithm/18_Dynamic_Programming", "title": "동적 프로그래밍 (Dynamic Programming)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "동적 프로그래밍(DP)은 복잡한 문제를 간단한 하위 문제로 나누어 해결하는 알고리즘 설계 기법입니다. 중복되는 하위 문제의 결과를 저장하여 효율성을 높입니다. --- 1. DP 개념 2. 메모이제이션 vs 타뷸레이션 3. 기초 DP 문제 4. 1D DP 5. 2D DP 6. 문자열 DP 7. 연습 문제 --- --- --- --- --- --- --- | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐ | Climbing Stairs | LeetCode | 기초 | | ⭐ | 피보나치 함수 | 백준 | 기초 | | ⭐⭐ | Coin Change | LeetCode | 동전 | | ⭐⭐ | LCS | 백준 | 문자열 | | ⭐⭐ | 0/1 Knapsack | 백준 | 배낭 | | ⭐⭐⭐ | LIS | 백준 | LIS | | ⭐⭐⭐ | Edit Distance | LeetCode | 문자열 | --- --- -...", "url": "/study/ko/Algorithm/18_Dynamic_Programming.html"}, {"id": "Algorithm/19_Greedy_Algorithms", "title": "탐욕 알고리즘 (Greedy Algorithm)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "탐욕 알고리즘은 매 단계에서 현재 상황에서 가장 좋은 선택을 하는 방법입니다. 항상 최적해를 보장하지는 않지만, 특정 문제에서는 효율적으로 최적해를 찾을 수 있습니다. --- 1. 탐욕 알고리즘 개념 2. 탐욕 선택 속성 3. 대표 문제 4. 탐욕 vs DP 5. 연습 문제 --- --- --- --- --- 원형 경로의 주유소들, 시작점을 찾으세요. <details> <summary>정답 코드</summary> </details> | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐ | 거스름돈 | 백준 | 동전 | | ⭐⭐ | 회의실 배정 | 백준 | 활동 선택 | | ⭐⭐ | Jump Game | LeetCode | 점프 | | ⭐⭐ | Gas Station | LeetCode | 순환 | | ⭐⭐⭐ | Jump Game II | LeetCode | 최소 점프 | | ⭐⭐⭐ | Non-overlapping...", "url": "/study/ko/Algorithm/19_Greedy_Algorithms.html"}, {"id": "Algorithm/20_Bitmask_DP", "title": "비트마스크 DP (Bitmask Dynamic Programming)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "비트마스크 DP는 집합의 상태를 비트로 표현하여 DP를 수행하는 기법입니다. n이 작을 때(n ≤ 20) 부분집합 문제를 효율적으로 해결할 수 있습니다. --- 1. 비트 연산 기초 2. 부분집합 표현 3. 비트마스크 DP 패턴 4. 외판원 문제 (TSP) 5. 활용 문제 6. 연습 문제 --- --- --- --- --- --- | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐⭐⭐ | 외판원 순회 | 백준 | TSP | | ⭐⭐⭐ | 발전소 | 백준 | 비트마스크 DP | | ⭐⭐⭐ | Shortest Hamilton Path | CF | 해밀턴 경로 | | ⭐⭐⭐ | Partition Equal Subset Sum | LeetCode | 부분집합 | | ⭐⭐⭐⭐ | 스티커 | 백준 | 비트마스크 DP | | ⭐⭐⭐⭐ | Can I Win | LeetCode | 게임 이론 | --- --- --- -...", "url": "/study/ko/Algorithm/20_Bitmask_DP.html"}, {"id": "Algorithm/21_Math_and_Number_Theory", "title": "수학과 정수론 (Mathematics and Number Theory)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "알고리즘 문제에서 자주 등장하는 수학적 개념들을 다룹니다. 모듈러 연산, 최대공약수, 소수, 조합론, 행렬 거듭제곱 등이 포함됩니다. --- 1. 모듈러 연산 2. 최대공약수와 최소공배수 3. 소수 4. 조합론 5. 행렬 거듭제곱 6. 기타 수학 7. 연습 문제 --- --- --- --- --- --- --- | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐⭐ | 이항 계수 1 | 백준 | 조합 기초 | | ⭐⭐ | 최대공약수와 최소공배수 | 백준 | GCD/LCM | | ⭐⭐ | 소수 찾기 | 백준 | 소수 판별 | | ⭐⭐⭐ | 이항 계수 3 | 백준 | 모듈러 역원 | | ⭐⭐⭐ | 피보나치 수 6 | 백준 | 행렬 거듭제곱 | | ⭐⭐⭐ | 골드바흐의 추측 | 백준 | 에라토스테네스 | | ⭐⭐⭐⭐ | 이항 계수 4 | 백준 | 뤼카 정리 | --- --- - 22StringAlgorithms.md - 문자열...", "url": "/study/ko/Algorithm/21_Math_and_Number_Theory.html"}, {"id": "Algorithm/22_String_Algorithms", "title": "문자열 알고리즘 (String Algorithms)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "문자열 패턴 매칭 알고리즘은 텍스트에서 특정 패턴을 효율적으로 찾는 방법입니다. 브루트포스 O(nm)에서 KMP/Z-알고리즘 O(n+m)까지 다양한 기법을 다룹니다. --- 1. 브루트포스 매칭 2. KMP 알고리즘 3. Rabin-Karp 알고리즘 4. Z-알고리즘 5. 문자열 해시 6. 활용 문제 7. 연습 문제 --- --- --- --- --- --- --- | 난이도 | 문제 | 플랫폼 | 알고리즘 | |--------|------|--------|----------| | ⭐⭐ | 찾기 | 백준 | KMP | | ⭐⭐ | Implement strStr() | LeetCode | KMP | | ⭐⭐ | Repeated String Match | LeetCode | KMP/Rabin-Karp | | ⭐⭐⭐ | 부분 문자열 | 백준 | KMP | | ⭐⭐⭐ | Longest Happy Prefix | LeetCode | KMP 실패함수 | | ⭐⭐⭐ | Shortest...", "url": "/study/ko/Algorithm/22_String_Algorithms.html"}, {"id": "Algorithm/23_Segment_Tree", "title": "세그먼트 트리 (Segment Tree)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "세그먼트 트리는 구간 쿼리와 점 업데이트를 O(log n)에 처리하는 자료구조입니다. 구간 합, 최솟값, 최댓값 등 다양한 쿼리에 활용됩니다. --- 1. 세그먼트 트리 개념 2. 기본 구현 3. 구간 합 쿼리 4. 구간 최솟값/최댓값 5. Lazy Propagation 6. 활용 문제 7. 연습 문제 --- --- --- --- --- --- --- | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐⭐⭐ | 구간 합 구하기 | 백준 | 기본 | | ⭐⭐⭐ | 최솟값 | 백준 | 최소 쿼리 | | ⭐⭐⭐ | Range Sum Query - Mutable | LeetCode | 기본 | | ⭐⭐⭐⭐ | 구간 합 구하기 2 | 백준 | Lazy | | ⭐⭐⭐⭐ | 수열과 쿼리 17 | 백준 | 최소 쿼리 | | ⭐⭐⭐⭐⭐ | Count of Smaller Numbers After Self | LeetCode | 응용 | ---...", "url": "/study/ko/Algorithm/23_Segment_Tree.html"}, {"id": "Algorithm/24_Fenwick_Tree", "title": "펜윅 트리 (Fenwick Tree / Binary Indexed Tree)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "펜윅 트리(BIT: Binary Indexed Tree)는 구간 합 쿼리와 점 업데이트를 O(log n)에 처리하는 자료구조입니다. 세그먼트 트리보다 구현이 간단하고 메모리 효율적입니다. --- 1. 펜윅 트리 개념 2. 기본 구현 3. 연산 4. 응용 5. 2D 펜윅 트리 6. 연습 문제 --- --- --- --- --- --- | 난이도 | 문제 | 플랫폼 | 유형 | |--------|------|--------|------| | ⭐⭐⭐ | 구간 합 구하기 | 백준 | 기본 | | ⭐⭐⭐ | Range Sum Query - Mutable | LeetCode | 기본 | | ⭐⭐⭐ | 버블 소트 | 백준 | 역순 쌍 | | ⭐⭐⭐⭐ | Count of Smaller Numbers | LeetCode | 역순 쌍 | | ⭐⭐⭐⭐ | 직사각형 합 | 백준 | 2D BIT | --- --- - 25NetworkFlow.md - 네트워크 플로우 --- - Fenwick Tree -...", "url": "/study/ko/Algorithm/24_Fenwick_Tree.html"}, {"id": "Algorithm/25_Network_Flow", "title": "25. 네트워크 플로우 (Network Flow)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "- 최대 유량 문제의 개념 이해 - Ford-Fulkerson 알고리즘 구현 - Edmonds-Karp 알고리즘 구현 - 이분 매칭 문제 해결 - 최소 컷 정리 활용 유량 네트워크는 다음으로 구성됩니다: - 방향 그래프 G = (V, E) - 용량 함수 c(u, v): 간선이 수용할 수 있는 최대 유량 - 소스(source) s: 유량의 시작점 - 싱크(sink) t: 유량의 도착점 1. 용량 제한: 0 ≤ f(u,v) ≤ c(u,v) 2. 유량 보존: 소스/싱크 제외, 들어오는 유량 = 나가는 유량 3. 반대칭성: f(u,v) = -f(v,u) 소스에서 싱크로 보낼 수 있는 최대 유량 찾기 --- 1. 증가 경로(Augmenting Path) 찾기: 소스→싱크로 추가 유량을 보낼 수 있는 경로 2. 경로를 따라 유량 증가 3. 더 이상 증가 경로가 없을 때까지 반복 - O(E × maxflow): DFS 기반 (정수 용량일 때) - 비합리적 용량이면 수렴하지 않을 수 있음 ---...", "url": "/study/ko/Algorithm/25_Network_Flow.html"}, {"id": "Algorithm/26_Computational_Geometry", "title": "27. 기하 알고리즘 (Computational Geometry)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "- CCW(Counter Clockwise) 알고리즘 이해 - 선분 교차 판정 구현 - 볼록 껍질(Convex Hull) 알고리즘 - 다각형 넓이 계산 - 가장 가까운 두 점 문제 --- 세 점 A, B, C의 방향 관계 판별 --- 두 선분 AB와 CD가 교차하는지 판별 --- 주어진 점들을 모두 포함하는 가장 작은 볼록 다각형 --- --- --- --- --- --- | 알고리즘 | 시간 복잡도 | |---------|------------| | CCW | O(1) | | 선분 교차 | O(1) | | Graham Scan | O(n log n) | | Andrew's Monotone Chain | O(n log n) | | 다각형 넓이 | O(n) | | 점 in 다각형 | O(n) / O(log n) (볼록) | | 가장 가까운 두 점 | O(n log n) | | 가장 먼 두 점 | O(n log n) | --- --- | 난이도 | 문제 유형 | 핵심 개념 |...", "url": "/study/ko/Algorithm/26_Computational_Geometry.html"}, {"id": "Algorithm/27_Game_Theory", "title": "28. 게임 이론 (Game Theory)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "- 조합 게임 이론의 기본 개념 이해 - 승리 상태와 패배 상태 분석 - 님 게임(Nim Game) 해결 - 스프라그-그런디 정리 활용 - 미니맥스 알고리즘 구현 --- - 여러 더미의 돌이 있음 - 각 턴에 한 더미에서 1개 이상의 돌을 가져감 - 마지막 돌을 가져가는 사람이 승리 XOR Sum = 0이면 패배, ≠ 0이면 승리 마지막 돌을 가져가는 사람이 패배하는 버전 --- 모든 조합 게임 상태에는 Grundy number가 있고, 이는 해당 상태와 동등한 님 더미의 크기입니다. --- 두 플레이어가 최적으로 플레이할 때의 결과를 계산 --- --- --- Nimber는 덧셈(XOR) 외에 곱셈도 정의됩니다. --- | 알고리즘 | 시간 복잡도 | 비고 | |---------|------------|------| | 님 게임 | O(n) | n = 더미 수 | | Grundy 계산 | O(상태 수 × 분기 수) | 메모이제이션 필수 | | 미니맥스 | O(b^d) | b =...", "url": "/study/ko/Algorithm/27_Game_Theory.html"}, {"id": "Algorithm/28_Advanced_DP_Optimization", "title": "29. 고급 DP 최적화 (Advanced DP Optimization)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "- Convex Hull Trick (CHT) 이해와 구현 - 분할 정복 최적화 (D&C Optimization) - Knuth 최적화 적용 - 각 최적화 기법의 적용 조건 판별 - 대표 문제 유형 파악 --- 점화식이 다음 형태일 때: 각 j에 대해 직선 를 정의하면, 는 에서 이 직선들의 최솟값(또는 최댓값)입니다. 기울기나 쿼리 순서가 정렬되지 않은 경우 --- --- --- --- | 기법 | 시간 복잡도 | 적용 조건 | |------|------------|----------| | 기본 DP | O(N²) 또는 O(N³) | - | | CHT (정렬) | O(N) | cost = a[j] b[i] | | CHT (일반) | O(N log N) | cost = a[j] b[i] | | Li Chao Tree | O(N log N) | cost = a[j] * b[i] | | D&C 최적화 | O(KN log N) | opt 단조성 | | Knuth 최적화 | O(N²) |...", "url": "/study/ko/Algorithm/28_Advanced_DP_Optimization.html"}, {"id": "Algorithm/29_Problem_Solving", "title": "실전 문제 풀이 (Problem Solving in Practice)", "topic": "Algorithm", "topic_display": "Algorithm", "body": "코딩 테스트와 알고리즘 대회를 위한 실전 문제 풀이 전략과 유형별 접근법을 다룹니다. --- 1. 문제 풀이 프로세스 2. 유형 판별법 3. 난이도별 전략 4. 유형별 핵심 문제 5. 시간 관리 전략 6. 코딩 인터뷰 팁 --- --- --- --- --- --- --- | 난이도 | 문제 | 유형 | |--------|------|------| | 실버 | 수 찾기 (1920) | 이분탐색 | | 실버 | DFS와 BFS (1260) | 그래프 탐색 | | 골드 | 최단경로 (1753) | 다익스트라 | | 골드 | LCS (9251) | DP | | 골드 | N-Queen (9663) | 백트래킹 | | 플래 | 최솟값 찾기 (11003) | 모노톤 덱 | | 난이도 | 문제 | 유형 | |--------|------|------| | Easy | Two Sum | 해시맵 | | Easy | Valid Parentheses | 스택 | | Medium | 3Sum | 투포인터...", "url": "/study/ko/Algorithm/29_Problem_Solving.html"}, {"id": "CPP/00_Overview", "title": "C++ 학습 가이드", "topic": "CPP", "topic_display": "CPP", "body": "이 폴더는 C++ 프로그래밍을 처음부터 체계적으로 학습하기 위한 자료를 담고 있습니다. 기초 문법부터 모던 C++까지 단계별로 학습할 수 있습니다. 대상 독자: 프로그래밍 입문자 ~ 중급자 --- --- - 기본적인 컴퓨터 사용법 - 터미널/명령 프롬프트 사용 경험 (권장) --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01EnvironmentSetup.md | ⭐ | 개발 환경, Hello World | | 02VariablesandTypes.md | ⭐ | 기본 타입, 상수, 형변환 | | 03OperatorsandControlFlow.md | ⭐ | 연산자, if/switch, 반복문 | | 04Functions.md | ⭐⭐ | 함수 정의, 오버로딩, 기본값 | | 05ArraysandStrings.md | ⭐⭐ | 배열, C문자열, string | | 06PointersandReferences.md | ⭐⭐ |...", "url": "/study/ko/CPP/00_Overview.html"}, {"id": "CPP/01_Environment_Setup", "title": "환경설정과 첫 프로그램", "topic": "CPP", "topic_display": "CPP", "body": "C++는 Bjarne Stroustrup이 1979년에 C 언어를 확장하여 개발한 범용 프로그래밍 언어입니다. | 특징 | 설명 | |------|------| | 객체지향 | 클래스, 상속, 다형성 지원 | | 고성능 | 하드웨어에 가까운 저수준 제어 | | 멀티패러다임 | 절차적, 객체지향, 함수형 프로그래밍 | | 호환성 | C 코드와 대부분 호환 | | STL | 강력한 표준 템플릿 라이브러리 | --- 방법 1: MinGW-w64 (권장) 1. MSYS2 설치 2. MSYS2 터미널에서 실행: 3. 환경 변수 PATH에 추가: 방법 2: Visual Studio 1. Visual Studio Community 설치 2. \"C++를 사용한 데스크톱 개발\" 워크로드 선택 --- 파일을 생성합니다: 출력: | 옵션 | 설명 | |------|------| | | 출력 파일 이름 지정 | | | C++ 표준 버전 지정 | | | 모든 경고 활성화 | | | 추가 경고 활성화 |...", "url": "/study/ko/CPP/01_Environment_Setup.html"}, {"id": "CPP/02_Variables_and_Types", "title": "변수와 자료형", "topic": "CPP", "topic_display": "CPP", "body": "변수는 데이터를 저장하는 메모리 공간에 붙인 이름입니다. --- | 타입 | 크기 | 범위 | |------|------|------| | | 2바이트 | -32,768 ~ 32,767 | | | 4바이트 | 약 -21억 ~ 21억 | | | 4/8바이트 | 시스템에 따라 다름 | | | 8바이트 | 약 -922경 ~ 922경 | | 타입 | 크기 | 정밀도 | |------|------|--------| | | 4바이트 | 약 7자리 | | | 8바이트 | 약 15자리 | | | 8~16바이트 | 시스템에 따라 다름 | 출력: | 시퀀스 | 의미 | |--------|------| | | 줄바꿈 | | | 탭 | | | 백슬래시 | | | 큰따옴표 | | | 작은따옴표 | --- --- | 구분 | const | constexpr | |------|-------|-----------| | 초기화 시점 | 런타임 가능 | 컴파일 타임 필수 | | 배열 크기 | 일부 컴파일러만 |...", "url": "/study/ko/CPP/02_Variables_and_Types.html"}, {"id": "CPP/03_Operators_and_Control_Flow", "title": "연산자와 제어문", "topic": "CPP", "topic_display": "CPP", "body": "| 연산자 | 의미 | 예시 | |--------|------|------| | | 덧셈 | | | | 뺄셈 | | | | 곱셈 | | | | 나눗셈 | | | | 나머지 | | --- --- | 연산자 | 의미 | 예시 | |--------|------|------| | | 같다 | | | | 다르다 | | | | 작다 | | | | 크다 | | | | 작거나 같다 | | | | 크거나 같다 | | --- | 연산자 | 의미 | 예시 | |--------|------|------| | | AND (그리고) | | | | OR (또는) | | | | NOT (부정) | | --- | 연산자 | 의미 | 예시 | |--------|------|------| | | AND | | | | OR | | | | XOR | | | | NOT | | | | 왼쪽 시프트 | | | | 오른쪽 시프트 | | --- --- --- --- 출력: --- --- 최소 한 번은 실행됩니다. --- 루프를...", "url": "/study/ko/CPP/03_Operators_and_Control_Flow.html"}, {"id": "CPP/04_Functions", "title": "함수", "topic": "CPP", "topic_display": "CPP", "body": "함수는 특정 작업을 수행하는 코드 블록입니다. --- --- | 상황 | 권장 방식 | |------|----------| | 작은 타입 (int, double) 읽기 | 값 전달 | | 큰 타입 읽기 | | | 수정 필요 | | | nullptr 허용 필요 | | --- --- --- 같은 이름, 다른 매개변수를 가진 여러 함수를 정의할 수 있습니다. --- 짧은 함수의 호출 오버헤드를 줄입니다. - 함수 본문이 짧을 때 (1~2줄) - 자주 호출되는 함수 - 컴파일러가 최종 결정 (inline은 힌트) --- 자기 자신을 호출하는 함수입니다. --- 함수를 변수처럼 저장하고 전달할 수 있습니다. --- C++11부터 익명 함수를 만들 수 있습니다. --- 실행: 출력: --- --- | 개념 | 설명 | |------|------| | 함수 선언 | 함수의 시그니처 (프로토타입) | | 함수 정의 | 함수의 본문 | | 값 전달 | 복사본 전달, 원본 변경 안 됨 | | 참조...", "url": "/study/ko/CPP/04_Functions.html"}, {"id": "CPP/05_Arrays_and_Strings", "title": "배열과 문자열", "topic": "CPP", "topic_display": "CPP", "body": "배열은 같은 타입의 여러 값을 연속된 메모리에 저장합니다. --- --- 크기가 고정된 안전한 배열입니다. | 특징 | C 배열 | std::array | |------|--------|------------| | 크기 확인 | sizeof 계산 | .size() | | 범위 검사 | 없음 | .at() | | 복사 | 불가 | 가능 | | 함수 전달 | 포인터로 변환 | 값/참조 전달 가능 | --- 문자 배열로 문자열을 표현합니다. --- C++의 문자열 클래스입니다. --- --- --- --- 문자열을 복사 없이 참조합니다. --- --- | 종류 | 특징 | |------|------| | C 배열 | 고정 크기, 경계 검사 없음 | | | 고정 크기, 안전함 | | C 문자열 | null 종료, 수동 관리 | | | 동적 크기, 자동 관리 | | | 읽기 전용 참조 | | std::string 메서드 | 설명 | |-------------------|------| | ,...", "url": "/study/ko/CPP/05_Arrays_and_Strings.html"}, {"id": "CPP/06_Pointers_and_References", "title": "포인터와 참조", "topic": "CPP", "topic_display": "CPP", "body": "포인터는 메모리 주소를 저장하는 변수입니다. | 연산자 | 이름 | 설명 | |--------|------|------| | | 주소 연산자 | 변수의 주소 반환 | | | 역참조 연산자 | 포인터가 가리키는 값 | --- --- --- 배열 이름은 첫 번째 요소의 주소입니다. --- 참조자는 변수의 별명입니다. --- | 특징 | 포인터 | 참조 | |------|--------|------| | 초기화 | 나중에 가능 | 선언 시 필수 | | null | nullptr 가능 | 불가 | | 대상 변경 | 가능 | 불가 | | 역참조 | 필요 | 자동 | | 주소 연산 | 가능 | 제한적 | --- --- --- --- 어떤 타입이든 가리킬 수 있는 포인터입니다. --- C++11부터 자동 메모리 관리를 제공합니다. --- --- | 개념 | 설명 | |------|------| | | 변수의 주소 | | | 역참조 (값 접근) | | | null 포인터 | | | 동적 메모리...", "url": "/study/ko/CPP/06_Pointers_and_References.html"}, {"id": "CPP/07_Classes_Basics", "title": "클래스 기초", "topic": "CPP", "topic_display": "CPP", "body": "클래스는 데이터와 함수를 하나로 묶은 사용자 정의 타입입니다. --- | 지정자 | 클래스 내부 | 파생 클래스 | 외부 | |--------|------------|------------|------| | | O | O | O | | | O | O | X | | | O | X | X | --- 객체가 생성될 때 자동으로 호출되는 특별한 함수입니다. 1. const 멤버 초기화 2. 참조 멤버 초기화 3. 부모 클래스 생성자 호출 4. 성능 (불필요한 기본 생성 방지) --- 객체가 소멸될 때 자동으로 호출됩니다. 출력: --- 현재 객체를 가리키는 포인터입니다. --- 객체를 수정하지 않는 함수입니다. --- --- C++에서 와 의 유일한 차이는 기본 접근 지정자입니다. --- --- --- --- | 개념 | 설명 | |------|------| | | 사용자 정의 타입 | | | 어디서든 접근 가능 | | | 클래스 내부에서만 접근 | | | 클래스와 파생 클래스에서 접근...", "url": "/study/ko/CPP/07_Classes_Basics.html"}, {"id": "CPP/08_Classes_Advanced", "title": "클래스 심화", "topic": "CPP", "topic_display": "CPP", "body": "클래스에 대해 연산자의 동작을 정의할 수 있습니다. --- 객체를 복사할 때 호출됩니다. --- 이미 존재하는 객체에 다른 객체를 대입할 때 호출됩니다. --- 임시 객체의 리소스를 \"이동\"하여 불필요한 복사를 방지합니다. 리소스를 관리하는 클래스는 5가지를 모두 정의해야 합니다: 1. 소멸자 2. 복사 생성자 3. 복사 대입 연산자 4. 이동 생성자 5. 이동 대입 연산자 --- 클래스의 모든 객체가 공유하는 멤버입니다. --- 클래스의 private 멤버에 접근할 수 있는 외부 함수나 클래스입니다. --- 암시적 형변환을 방지합니다. --- --- | 개념 | 설명 | |------|------| | 연산자 오버로딩 | 클래스에 연산자 정의 | | 복사 생성자 | | | 복사 대입 | | | 이동 생성자 | | | 이동 대입 | | | | 클래스 공유 멤버 | | | private 접근 허용 | | | 암시적 변환 방지 | ---...", "url": "/study/ko/CPP/08_Classes_Advanced.html"}, {"id": "CPP/09_Inheritance_and_Polymorphism", "title": "상속과 다형성", "topic": "CPP", "topic_display": "CPP", "body": "상속은 기존 클래스(부모)의 속성과 메서드를 새 클래스(자식)가 물려받는 것입니다. --- | 부모 멤버 | public 상속 | protected 상속 | private 상속 | |----------|------------|----------------|--------------| | public | public | protected | private | | protected | protected | protected | private | | private | 접근 불가 | 접근 불가 | 접근 불가 | --- 출력: --- 자식 클래스에서 부모의 함수를 재정의합니다. --- 런타임에 적절한 함수를 호출합니다 (동적 바인딩). --- 기반 클래스의 소멸자는 반드시 virtual이어야 합니다. 출력: --- --- 여러 부모 클래스를 상속받을 수 있습니다. --- 순수 가상 함수만 있는 클래스입니다. --- --- | 개념 | 설명 | |------|------| | | 상속 | |...", "url": "/study/ko/CPP/09_Inheritance_and_Polymorphism.html"}, {"id": "CPP/10_STL_Containers", "title": "STL 컨테이너", "topic": "CPP", "topic_display": "CPP", "body": "STL(Standard Template Library)은 C++ 표준 라이브러리의 핵심으로, 자료구조와 알고리즘을 제공합니다. | 구성요소 | 설명 | |---------|------| | 컨테이너 | 데이터를 저장하는 자료구조 | | 반복자 | 컨테이너 요소 순회 | | 알고리즘 | 정렬, 검색 등 범용 함수 | | 함수 객체 | 함수처럼 동작하는 객체 | --- 동적 크기 배열입니다. 가장 많이 사용됩니다. --- 고정 크기 배열입니다. --- 양쪽 끝에서 삽입/삭제가 빠른 컨테이너입니다. --- 이중 연결 리스트입니다. --- 정렬된 고유 요소의 집합입니다. 중복을 허용하는 set입니다. --- 키-값 쌍의 정렬된 컨테이너입니다. --- 해시 테이블 기반으로 평균 O(1) 접근이 가능합니다. | 특징 | set | unorderedset | |------|-----|---------------| | 내부 구조 | 레드-블랙 트리 | 해시 테이블 | | 정렬 | 정렬됨 | 정렬...", "url": "/study/ko/CPP/10_STL_Containers.html"}, {"id": "CPP/11_STL_Algorithms_Iterators", "title": "STL 알고리즘과 반복자", "topic": "CPP", "topic_display": "CPP", "body": "반복자는 컨테이너의 요소를 가리키는 포인터 같은 객체입니다. | 종류 | 설명 | 예시 컨테이너 | |------|------|--------------| | 입력 반복자 | 읽기만 가능, 한 방향 | istreamiterator | | 출력 반복자 | 쓰기만 가능, 한 방향 | ostreamiterator | | 순방향 반복자 | 읽기/쓰기, 한 방향 | forwardlist | | 양방향 반복자 | 읽기/쓰기, 양방향 | list, set, map | | 임의 접근 반복자 | 모든 연산, 임의 접근 | vector, deque, array | --- 익명 함수를 간결하게 정의합니다. --- 헤더를 포함해야 합니다. --- 정렬된 범위에서만 사용합니다. --- --- --- 헤더를 포함합니다. --- 정렬된 범위에서만 작동합니다. --- --- --- | 알고리즘 | 용도 | |---------|------| | , | 검색 | | , | 개수 세기 | | , | 정렬 | | |...", "url": "/study/ko/CPP/11_STL_Algorithms_Iterators.html"}, {"id": "CPP/12_Templates", "title": "템플릿", "topic": "CPP", "topic_display": "CPP", "body": "템플릿은 타입에 독립적인 일반화된 코드를 작성하는 C++의 강력한 기능입니다. --- --- --- --- --- SFINAE (Substitution Failure Is Not An Error): 템플릿 인자 대체 실패는 에러가 아닙니다. --- --- --- --- --- | 개념 | 설명 | |------|------| | 함수 템플릿 | 타입에 독립적인 함수 | | 클래스 템플릿 | 타입에 독립적인 클래스 | | 템플릿 특수화 | 특정 타입에 대한 특별 구현 | | 부분 특수화 | 일부 조건에 대한 특수화 | | 가변 인자 템플릿 | 임의 개수의 인자 처리 | | SFINAE | 대체 실패는 에러 아님 | | Concepts (C++20) | 템플릿 제약 조건 | | 비타입 매개변수 | 값을 템플릿 인자로 | --- 임의 개수의 인자에서 최소값과 최대값을 반환하는 함수 템플릿을 작성하세요. Stack 예제를 참고하여 Queue 클래스 템플릿을 작성하세요. 다양한 타입을...", "url": "/study/ko/CPP/12_Templates.html"}, {"id": "CPP/13_Exceptions_and_File_IO", "title": "예외 처리와 파일 입출력", "topic": "CPP", "topic_display": "CPP", "body": "예외(Exception)는 프로그램 실행 중 발생하는 비정상적인 상황입니다. C++은 try-catch 구문으로 예외를 처리합니다. --- 출력: 출력: --- --- 출력: --- | 수준 | 설명 | |------|------| | No-throw | 예외를 절대 던지지 않음 | | Strong | 예외 발생 시 원래 상태로 복원 | | Basic | 예외 발생 후에도 유효한 상태 유지 | | No guarantee | 예외 발생 시 상태 불명 | 출력: --- | 클래스 | 용도 | |--------|------| | | 파일 읽기 | | | 파일 쓰기 | | | 읽기/쓰기 | | 모드 | 설명 | |------|------| | | 읽기 | | | 쓰기 | | | 끝에 추가 | | | 파일 끝에서 시작 | | | 기존 내용 삭제 | | | 바이너리 모드 | --- --- --- --- --- --- --- | 개념 | 설명 | |------|------| | | 예외 처리...", "url": "/study/ko/CPP/13_Exceptions_and_File_IO.html"}, {"id": "CPP/14_Smart_Pointers_Memory", "title": "스마트 포인터와 메모리 관리", "topic": "CPP", "topic_display": "CPP", "body": "C++에서 수동 메모리 관리는 여러 문제를 일으킬 수 있습니다. | 문제 | 설명 | |------|------| | 메모리 누수 | delete를 호출하지 않음 | | 이중 해제 | 같은 메모리를 두 번 해제 | | 댕글링 포인터 | 해제된 메모리 접근 | | 예외 안전성 | 예외 발생 시 메모리 누수 | --- 자원 획득은 초기화다: 객체 생성 시 자원 획득, 소멸 시 자동 해제. 출력: --- 단독 소유권을 가지는 스마트 포인터입니다. 하나의 만 객체를 소유할 수 있습니다. --- 공유 소유권을 가지는 스마트 포인터입니다. 여러 이 같은 객체를 공유할 수 있습니다. --- 의 순환 참조 문제를 해결합니다. 참조 카운트를 증가시키지 않습니다. --- 클래스 내부에서 자신의 을 안전하게 얻습니다. 주의사항: --- | 상황 | 선택 | |------|------| | 하나의 소유자 | | | 여러 소유자 | | | 순환 참조 방지 | | | 캐시, 옵저버 | | | 팩토리 함수...", "url": "/study/ko/CPP/14_Smart_Pointers_Memory.html"}, {"id": "CPP/15_Modern_CPP", "title": "모던 C++ (C++11/14/17/20)", "topic": "CPP", "topic_display": "CPP", "body": "--- --- --- --- --- --- | 버전 | 주요 기능 | |------|-----------| | C++11 | auto, 람다, 이동 시맨틱, 스마트 포인터, nullptr, constexpr | | C++14 | 제네릭 람다, 변수 템플릿, 반환 타입 추론 | | C++17 | 구조적 바인딩, if constexpr, optional, variant, filesystem | | C++20 | Concepts, Ranges, 삼중 비교, 모듈, 코루틴, std::format | --- 기존 C++98/03 스타일 코드를 C++17 이상으로 리팩토링하세요. 와 을 사용하여 타입 안전한 설정 관리 시스템을 구현하세요. C++20 Ranges를 활용하여 데이터 처리 파이프라인을 구현하세요. --- C++ 입문부터 모던 C++까지의 학습을 완료했습니다! 1. 기초 복습: 01~06 (변수, 함수, 포인터) 2. OOP 복습: 07~09 (클래스, 상속) 3. STL 복습:...", "url": "/study/ko/CPP/15_Modern_CPP.html"}, {"id": "CPP/16_Multithreading_Concurrency", "title": "멀티스레딩과 동시성", "topic": "CPP", "topic_display": "CPP", "body": "현대 프로세서의 멀티코어 성능을 활용하려면 멀티스레딩 프로그래밍이 필수입니다. C++11부터 표준 라이브러리에 스레딩 지원이 추가되었으며, 이 장에서는 std::thread, 동기화 기법, 그리고 비동기 프로그래밍을 학습합니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 함수, 람다, 스마트 포인터 --- 1. 스레드 기초 2. 뮤텍스와 락 3. 조건 변수 4. 원자적 연산 5. 비동기 프로그래밍 6. 스레드 풀 7. 일반적인 문제와 해결 --- --- --- --- | 메모리 순서 | 설명 | |-------------|------| | | 원자성만 보장, 순서 보장 없음 | | | 이 연산 이전의 읽기/쓰기가 재정렬되지 않음 | | | 이 연산 이후의 읽기/쓰기가 재정렬되지 않음 | | | acquire + release | | | 순차적 일관성 (기본값, 가장 강함) | --- --- --- --- 벡터의 합을 여러 스레드로 병렬 계산하세요. <details> <summary>정답...", "url": "/study/ko/CPP/16_Multithreading_Concurrency.html"}, {"id": "CPP/17_CPP20_Advanced", "title": "C++20 심화", "topic": "CPP", "topic_display": "CPP", "body": "C++20은 C++11 이후 가장 큰 변화를 가져온 표준입니다. Concepts, Ranges, Coroutines, Modules 등 혁신적인 기능들이 추가되었습니다. 이 장에서는 C++20의 핵심 기능들을 학습합니다. 난이도: ⭐⭐⭐⭐⭐ 선수 지식: 템플릿, 람다, 스마트 포인터 --- 1. Concepts 2. Ranges 3. Coroutines 4. Modules 5. 기타 C++20 기능 6. C++23 미리보기 --- 템플릿 매개변수에 대한 제약 조건을 정의하는 기능입니다. 이전의 SFINAE보다 훨씬 가독성이 좋습니다. --- 컨테이너와 알고리즘을 더 우아하게 다루는 라이브러리입니다. 파이프라인 스타일의 연산을 지원합니다. 뷰는 지연 평가되며, 원본 데이터를 복사하지 않습니다. --- 실행을 일시 중단하고 나중에 재개할 수 있는 함수입니다. --- 헤더 파일의 단점을 해결하는 새로운 코드 구성 방식입니다. | 기존 헤더 | 모듈 |...", "url": "/study/ko/CPP/17_CPP20_Advanced.html"}, {"id": "CPP/18_Design_Patterns", "title": "18. C++ 디자인 패턴", "topic": "CPP", "topic_display": "CPP", "body": "- GoF 디자인 패턴의 핵심 패턴 이해 - 모던 C++를 활용한 패턴 구현 - CRTP, PIMPL 등 C++ 특화 이디엄 습득 - 패턴 선택 기준과 적용 사례 학습 1. 디자인 패턴 개요 2. 생성 패턴 3. 구조 패턴 4. 행동 패턴 5. C++ 특화 이디엄 6. 연습 문제 --- 디자인 패턴은 소프트웨어 설계에서 자주 발생하는 문제에 대한 재사용 가능한 해결책입니다. --- 인스턴스가 하나만 존재하도록 보장합니다. 객체 생성을 서브클래스에 위임합니다. 복잡한 객체를 단계별로 생성합니다. --- 호환되지 않는 인터페이스를 연결합니다. 객체에 동적으로 기능을 추가합니다. 복잡한 서브시스템에 단순한 인터페이스를 제공합니다. --- 객체 상태 변화를 다른 객체에 통지합니다. 알고리즘을 캡슐화하여 교체 가능하게 만듭니다. 요청을 객체로 캡슐화합니다. 알고리즘의 골격을 정의하고 일부 단계를 서브클래스에서 구현합니다. --- 정적 다형성을 구현하는 기법입니다. 구현을 헤더에서 숨기는...", "url": "/study/ko/CPP/18_Design_Patterns.html"}, {"id": "CPP/19_Project_Student_Management", "title": "19. 프로젝트: 학생 관리 시스템", "topic": "CPP", "topic_display": "CPP", "body": "- 실제 애플리케이션에서 STL 컨테이너(vector, map, set) 적용하기 - 캡슐화와 데이터 검증을 활용한 클래스 설계하기 - 직렬화(serialization)와 역직렬화(deserialization)를 사용한 파일 I/O 구현하기 - 견고한 에러 관리를 위한 예외 처리 사용하기 - 자동 메모리 관리를 위한 스마트 포인터 활용하기 - 메뉴 기반 CLI 인터페이스 구축하기 - 모던 C++ 모범 사례 연습하기 1. 프로젝트 개요 2. 요구사항 3. 클래스 설계 4. Student 클래스 5. Database 클래스 6. 파일 I/O 및 직렬화 7. 예외 처리 8. 메뉴 인터페이스 9. 전체 구현 10. 테스트 및 사용법 --- 사용자가 다음을 수행할 수 있는 학생 관리 시스템을 구축합니다: - 학생 레코드 추가, 제거, 업데이트 - 이름, ID 또는 GPA로 학생 검색 및 필터링 - 통계 계산(평균 GPA, 상위 학생) - 파일에 데이터 저장/로드 - 에러를 우아하게 처리...", "url": "/study/ko/CPP/19_Project_Student_Management.html"}, {"id": "C_Programming/00_Overview", "title": "C 프로그래밍 학습 가이드", "topic": "C_Programming", "topic_display": "C Programming", "body": "이 폴더는 C 프로그래밍을 체계적으로 학습하기 위한 자료를 담고 있습니다. 기초 문법부터 임베디드 시스템까지, 실습 프로젝트를 통해 단계별로 학습할 수 있습니다. 대상 독자: 프로그래밍 입문자 ~ 중급자 --- --- - 기본적인 컴퓨터 사용법 - 터미널/명령줄 사용 경험 (권장) - 텍스트 에디터 또는 IDE 사용법 --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01EnvironmentSetup.md | ⭐ | 개발 환경 구축, 컴파일러 설치 | | 02CBasicsReview.md | ⭐ | 변수, 자료형, 연산자, 제어문, 함수 | | 03ProjectCalculator.md | ⭐ | 함수, switch-case, scanf | | 04ProjectNumberGuessing.md | ⭐ | 반복문, 랜덤, 조건문 | | 05ProjectAddressBook.md | ⭐⭐ | 구조체, 배열, 파일 I/O | |...", "url": "/study/ko/C_Programming/00_Overview.html"}, {"id": "C_Programming/01_Environment_Setup", "title": "C 언어 환경 설정", "topic": "C_Programming", "topic_display": "C Programming", "body": "| 구성 요소 | 설명 | |-----------|------| | 컴파일러 | C 코드를 실행 파일로 변환 (GCC, Clang) | | 텍스트 에디터/IDE | 코드 작성 (VS Code, Vim 등) | | 터미널 | 컴파일 및 실행 | --- Xcode Command Line Tools에 Clang이 포함되어 있습니다. 방법 1: MinGW-w64 (권장) 1. MSYS2 다운로드 및 설치 2. MSYS2 터미널에서: 3. 환경 변수 PATH에 추가: 방법 2: WSL (Windows Subsystem for Linux) --- 1. C/C++ (Microsoft) - 필수 - 문법 강조, IntelliSense, 디버깅 2. Code Runner (선택) - 단축키로 빠른 실행 : (macOS) 또는 (Windows)로 빌드 --- : --- 프로젝트가 커지면 Makefile로 빌드를 자동화합니다. --- : --- --- 모든 단계가 성공하면 환경 설정 완료입니다!...", "url": "/study/ko/C_Programming/01_Environment_Setup.html"}, {"id": "C_Programming/02_C_Basics_Review", "title": "C 언어 기초 빠른 복습", "topic": "C_Programming", "topic_display": "C Programming", "body": "> 다른 프로그래밍 언어 경험이 있는 분을 위한 C 핵심 문법 정리 | 특징 | Python/JS | C | |------|-----------|---| | 메모리 관리 | 자동 (GC) | 수동 (malloc/free) | | 타입 시스템 | 동적 타입 | 정적 타입 | | 실행 방식 | 인터프리터 | 컴파일 | | 추상화 수준 | 높음 | 낮음 (하드웨어 가까움) | - 시스템 프로그래밍 (OS, 드라이버) - 임베디드 시스템 - 성능이 중요한 애플리케이션 - 다른 언어의 기반 이해 (Python, Ruby는 C로 작성) --- C의 특징: - 세미콜론 필수 - 중괄호 로 블록 구분 - 명시적인 main 함수 - 헤더 파일 include 필요 --- | 지정자 | 타입 | 예시 | |--------|------|------| | | int | | | | unsigned int | | | | long | | | | float/double | | | | char | | | |...", "url": "/study/ko/C_Programming/02_C_Basics_Review.html"}, {"id": "C_Programming/03_Project_Calculator", "title": "프로젝트 1: 사칙연산 계산기", "topic": "C_Programming", "topic_display": "C Programming", "body": "이 프로젝트를 통해 배우는 내용: - 사용자 입력 받기 () - 조건 분기 () - 함수 정의와 호출 - 에러 처리 --- --- --- --- --- --- | 개념 | 설명 | |------|------| | | 형식에 맞게 입력 받기 | | | 값에 따른 분기 처리 | | 함수 분리 | 코드 구조화, 재사용성 | | 포인터 매개변수 | 함수에서 값 변경하기 | | 에러 처리 | 반환값으로 성공/실패 표시 | --- 1. 제곱근 연산 추가: 연산자 추가 (힌트: , ) 2. 계산 이력 저장: 최근 10개 계산 결과를 배열에 저장하고 출력하는 기능 추가 3. 괄호 지원: 같은 수식 처리 (어려움 주의!) --- 04ProjectNumber_Guessing.md → 게임을 만들어봅시다!", "url": "/study/ko/C_Programming/03_Project_Calculator.html"}, {"id": "C_Programming/04_Project_Number_Guessing", "title": "프로젝트 2: 숫자 맞추기 게임", "topic": "C_Programming", "topic_display": "C Programming", "body": "이 프로젝트를 통해 배우는 내용: - 난수 생성 (, , ) - 반복문 (, ) - 조건문 활용 - 게임 로직 구현 --- --- --- --- 1. 시도 횟수 제한 2. 입력 검증 3. 재시작 기능 4. 난이도 선택 --- - 최고 기록 저장 (세션 내) - 통계 표시 - 더 나은 UI --- --- | 개념 | 설명 | |------|------| | | 의사 난수 생성 | | | 시드 초기화 | | | 무한 루프 | | | 루프 탈출 | | | 다음 반복으로 | | 구조체 | 관련 데이터 묶기 | --- 1. 이진 탐색 AI: 컴퓨터가 플레이어의 숫자를 맞추는 모드 추가 - 힌트: 항상 범위의 중간값 선택 2. 멀티플레이어: 두 플레이어가 번갈아 추측하는 모드 3. 파일 저장: 최고 기록을 파일로 저장하고 불러오기 --- 05ProjectAddress_Book.md → 구조체와 파일 I/O를 배워봅시다!", "url": "/study/ko/C_Programming/04_Project_Number_Guessing.html"}, {"id": "C_Programming/05_Project_Address_Book", "title": "프로젝트 3: 주소록 프로그램", "topic": "C_Programming", "topic_display": "C Programming", "body": "이 프로젝트를 통해 배우는 내용: - 구조체 정의와 활용 - 구조체 배열 - 파일 입출력 (fopen, fwrite, fread, fprintf, fscanf) - CRUD 기능 구현 (Create, Read, Update, Delete) --- --- --- --- | 모드 | 설명 | |------|------| | | 읽기 (파일 없으면 실패) | | | 쓰기 (파일 덮어씀) | | | 추가 (파일 끝에 추가) | | | 바이너리 읽기 | | | 바이너리 쓰기 | --- --- --- --- | 개념 | 설명 | |------|------| | | 구조체 타입 정의 | | , | 문자열 복사, 검색 | | , | 파일 열기/닫기 | | , | 바이너리 읽기/쓰기 | | , | 텍스트 읽기/쓰기 | | 구조체 포인터 | 연산자로 멤버 접근 | --- 1. 정렬 기능: 이름순, ID순 정렬 기능 추가 2. CSV 내보내기: 연락처를 CSV 파일로 내보내기 3. 그룹 기능:...", "url": "/study/ko/C_Programming/05_Project_Address_Book.html"}, {"id": "C_Programming/06_Project_Dynamic_Array", "title": "프로젝트 4: 동적 배열 (Dynamic Array)", "topic": "C_Programming", "topic_display": "C Programming", "body": "이 프로젝트를 통해 배우는 내용: - 동적 메모리 할당 (, , , ) - 메모리 누수 방지 - 크기가 자동으로 늘어나는 배열 구현 - Python의 리스트, JavaScript의 배열과 유사한 자료구조 --- --- --- --- --- 어떤 타입이든 저장할 수 있는 버전: --- --- --- | 함수 | 설명 | |------|------| | | size 바이트 메모리 할당 | | | n개 요소, 0으로 초기화 | | | 크기 변경 | | | 메모리 해제 | | | n 바이트 복사 | 1. 할당 후 NULL 체크 필수 2. 사용 후 free() 필수 3. free 후 NULL 할당 권장 (dangling pointer 방지) 4. 이중 free 금지 --- 1. dafind: 값을 검색하여 인덱스 반환 2. dareverse: 배열 뒤집기 3. dasort: 정렬 기능 추가 (qsort 활용) 4. 문자열 동적 배열: 배열 구현 ---...", "url": "/study/ko/C_Programming/06_Project_Dynamic_Array.html"}, {"id": "C_Programming/07_Project_Linked_List", "title": "프로젝트 5: 연결 리스트 (Linked List)", "topic": "C_Programming", "topic_display": "C Programming", "body": "이 프로젝트를 통해 배우는 내용: - 포인터의 실전 활용 - 자기 참조 구조체 - 노드 기반 자료구조 - 삽입/삭제 연산의 이해 --- | 연산 | 배열 | 연결 리스트 | |------|------|-------------| | 인덱스 접근 | O(1) ✓ | O(n) | | 맨 앞 삽입/삭제 | O(n) | O(1) ✓ | | 맨 뒤 삽입/삭제 | O(1) | O(n) 또는 O(1) | | 중간 삽입/삭제 | O(n) | O(1) | | 메모리 효율 | 좋음 | 포인터 오버헤드 | : tail 포인터가 있는 경우 : 위치를 알고 있는 경우 --- --- --- --- 앞뒤로 이동 가능한 연결 리스트: --- --- --- | 개념 | 설명 | |------|------| | 자기 참조 구조체 | | | 노드 순회 | | | 포인터 조작 | 삽입/삭제 시 연결 변경 | | 동적 메모리 | 각 노드 malloc/free | | 종류 | 특징 | |------|------| | 단일...", "url": "/study/ko/C_Programming/07_Project_Linked_List.html"}, {"id": "C_Programming/08_Project_File_Encryption", "title": "프로젝트 6: 파일 암호화 도구", "topic": "C_Programming", "topic_display": "C Programming", "body": "이 프로젝트를 통해 배우는 내용: - 비트 연산 (AND, OR, XOR, NOT, shift) - 파일 바이트 단위 처리 - 명령줄 인자 처리 (argc, argv) - 간단한 암호화 원리 --- - (자기 자신과 XOR = 0) - (0과 XOR = 자신) - (두 번 XOR = 원본) --- | A | B | AND | OR | XOR | |---|---|-----|----|----| | 0 | 0 | 0 | 0 | 0 | | 0 | 1 | 0 | 1 | 1 | | 1 | 0 | 0 | 1 | 1 | | 1 | 1 | 1 | 1 | 0 | --- --- --- --- --- --- | 개념 | 설명 | |------|------| | (XOR) | 비트 XOR 연산 | | (AND) | 비트 AND 연산 | | (OR) | 비트 OR 연산 | | (NOT) | 비트 반전 | | , | 비트 시프트 | | , | 바이트 단위 파일 I/O | | , | 명령줄 인자 | --- >...", "url": "/study/ko/C_Programming/08_Project_File_Encryption.html"}, {"id": "C_Programming/09_Project_Stack_Queue", "title": "프로젝트 7: 스택과 큐", "topic": "C_Programming", "topic_display": "C Programming", "body": "이 프로젝트를 통해 배우는 내용: - 스택(Stack)과 큐(Queue) 자료구조 - LIFO와 FIFO 개념 - 배열/연결 리스트 기반 구현 - 실전 활용: 괄호 검사, 후위 표기법 계산 --- | 연산 | 설명 | 시간 복잡도 | |------|------|-------------| | | 맨 위에 추가 | O(1) | | | 맨 위 제거 후 반환 | O(1) | | | 맨 위 값 확인 | O(1) | | | 비어있는지 확인 | O(1) | --- --- --- --- | 연산 | 설명 | 시간 복잡도 | |------|------|-------------| | | 뒤에 추가 | O(1) | | | 앞에서 제거 | O(1) | | | 앞의 값 확인 | O(1) | | | 비어있는지 확인 | O(1) | --- --- --- --- --- | 자료구조 | 특성 | 활용 | |---------|------|------| | 스택 | LIFO | 괄호 검사, 함수 호출, Undo |...", "url": "/study/ko/C_Programming/09_Project_Stack_Queue.html"}, {"id": "C_Programming/10_Project_Hash_Table", "title": "프로젝트 8: 해시 테이블", "topic": "C_Programming", "topic_display": "C Programming", "body": "이 프로젝트를 통해 배우는 내용: - 해시 함수의 원리 - 해시 테이블 구조 - 충돌 처리 (체이닝, 오픈 어드레싱) - 실전 활용: 간단한 사전 프로그램 --- 키(Key)를 해시 함수로 변환하여 인덱스를 생성하고, 해당 위치에 값(Value)을 저장합니다. | 연산 | 평균 | 최악 | |------|------|------| | 삽입 | O(1) | O(n) | | 검색 | O(1) | O(n) | | 삭제 | O(1) | O(n) | 최악의 경우: 모든 키가 같은 인덱스로 충돌할 때 --- 1. 결정적: 같은 입력 → 항상 같은 출력 2. 균일 분포: 출력이 고르게 분포 3. 빠른 계산: O(1) 시간 --- 충돌 시 같은 인덱스에 연결 리스트로 저장합니다. --- 충돌 시 다른 빈 슬롯을 찾아 저장합니다. --- --- --- | 개념 | 설명 | |------|------| | 해시 함수 | 키를 인덱스로 변환 | | 충돌 | 다른 키가 같은 인덱스 | | 체이닝 |...", "url": "/study/ko/C_Programming/10_Project_Hash_Table.html"}, {"id": "C_Programming/11_Project_Snake_Game", "title": "프로젝트 10: 터미널 뱀 게임", "topic": "C_Programming", "topic_display": "C Programming", "body": "터미널에서 동작하는 클래식 뱀 게임을 만들어봅니다. - 터미널 제어 (ANSI escape codes) - 비동기 키보드 입력 처리 - 게임 루프 구현 - 타이머와 프레임 관리 - 구조체와 포인터 - 동적 메모리 관리 - 연결 리스트 (뱀 몸통 표현) --- 터미널에서 그래픽을 표현하기 위해 ANSI escape codes를 사용합니다. --- 게임에서는 키 입력을 기다리지 않고 계속 실행되어야 합니다. --- --- --- --- ncurses 라이브러리를 사용하면 더 깔끔한 코드가 가능합니다. --- P 키를 누르면 게임이 일시정지되도록 구현하세요. 가끔 나타나는 특별 아이템을 추가하세요: - 골든 사과: 30점 - 스피드 다운: 일시적으로 속도 감소 - 투명화: 잠시 자기 몸 통과 가능 WASD와 방향키로 각각 조작하는 2인 모드를 구현하세요. 자동으로 음식을 찾아가는 AI 뱀을 추가하세요. - 힌트: BFS 또는 간단한 휴리스틱 사용 --- | 개념 | 설명 |...", "url": "/study/ko/C_Programming/11_Project_Snake_Game.html"}, {"id": "C_Programming/12_Project_Mini_Shell", "title": "프로젝트 11: 미니 쉘", "topic": "C_Programming", "topic_display": "C Programming", "body": "간단한 명령어 쉘을 직접 구현해봅니다. - 프로세스 생성 (fork) - 프로그램 실행 (exec 계열) - 파이프와 리다이렉션 - 시그널 처리 기초 - 문자열 처리 - 파일 I/O - 포인터와 동적 메모리 --- 쉘의 기본 동작: 읽기 → 파싱 → 실행 → 반복 --- 일부 명령어는 외부 프로그램이 아닌 쉘 자체에서 처리해야 합니다. --- , , 연산자를 처리합니다. 테스트: --- 연산자로 명령어를 연결합니다. 테스트: --- --- --- 형태로 여러 명령어를 순차 실행하도록 구현하세요. - : cmd1 성공시에만 cmd2 실행 - : cmd1 실패시에만 cmd2 실행 에서 \"hello world\"를 하나의 인자로 처리하세요. readline 라이브러리를 사용하여 탭 자동완성을 구현하세요. --- | 함수 | 설명 | |------|------| | | 프로세스 복제 | | | 프로그램 실행 | | | 자식 프로세스 대기 | | | 파이프 생성 | | | 파일 디스크립터...", "url": "/study/ko/C_Programming/12_Project_Mini_Shell.html"}, {"id": "C_Programming/13_Project_Multithreading", "title": "프로젝트 12: 멀티스레드 프로그래밍", "topic": "C_Programming", "topic_display": "C Programming", "body": "pthread 라이브러리를 사용한 멀티스레드 프로그래밍을 배웁니다. - 스레드 생성과 관리 - 뮤텍스를 이용한 동기화 - 조건 변수 사용 - 생산자-소비자 패턴 구현 - 포인터 - 구조체 - 함수 포인터 --- --- 여러 스레드가 동시에 공유 데이터에 접근하면 문제가 발생합니다. 실행 결과: --- 뮤텍스로 공유 자원에 대한 접근을 동기화합니다. --- 특정 조건이 만족될 때까지 스레드를 대기시킵니다. --- 가장 중요한 동기화 패턴 중 하나입니다. --- 실제 서버 프로그램에서 많이 사용하는 패턴입니다. --- 읽기는 동시에, 쓰기는 배타적으로 허용합니다. --- --- 5명의 철학자가 원탁에 앉아 있고, 젓가락 5개가 있습니다. - 철학자는 생각하거나 식사합니다 - 식사하려면 양쪽 젓가락이 필요합니다 - 데드락 없이 구현하세요 N개의 스레드가 모두 도착할 때까지 대기하는 장벽을 구현하세요. 뮤텍스와 조건 변수를 사용하여 카운팅 세마포어를 구현하세요. N×N 행렬 곱셈을 여러...", "url": "/study/ko/C_Programming/13_Project_Multithreading.html"}, {"id": "C_Programming/14_Embedded_Basics", "title": "임베디드 프로그래밍 기초", "topic": "C_Programming", "topic_display": "C Programming", "body": "임베디드 시스템의 개념을 이해하고 Arduino 개발 환경을 설정합니다. - 임베디드 시스템 개념 이해 - 마이크로컨트롤러(MCU) 이해 - Arduino 개발 환경 구축 - 첫 프로그램 작성 및 실행 - C 언어 기본 문법 - 함수와 변수 --- 임베디드 시스템(Embedded System)은 특정 기능을 수행하도록 설계된 컴퓨터 시스템입니다. | 분야 | 예시 | |------|------| | 가전제품 | 세탁기, 냉장고, 에어컨, 전자레인지 | | 자동차 | ECU, ABS, 에어백, 내비게이션 | | 의료기기 | 혈압계, 체온계, MRI, 인슐린 펌프 | | 통신 | 공유기, 스마트폰, 셋톱박스 | | 산업 | 공장 자동화, 로봇, PLC | | IoT | 스마트홈, 웨어러블, 센서 | --- | 메모리 | 특징 | 용도 | |--------|------|------| | Flash | 비휘발성, 읽기 빠름, 쓰기 느림 | 프로그램 코드 저장 | | SRAM | 휘발성,...", "url": "/study/ko/C_Programming/14_Embedded_Basics.html"}, {"id": "C_Programming/15_Bit_Operations", "title": "비트 연산 심화", "topic": "C_Programming", "topic_display": "C Programming", "body": "임베디드 프로그래밍의 핵심인 비트 단위 조작을 완벽하게 익힙니다. - 비트 연산자 완벽 이해 - 비트 마스킹 기법 습득 - 레지스터 제어 개념 이해 - volatile 키워드 이해 - C 언어 기본 문법 - 2진수, 16진수 표현 --- --- --- 동작 원리: 동작 원리: --- 여러 상태를 하나의 변수로 관리합니다. --- 레지스터는 MCU 내부의 특수한 메모리 위치로, 하드웨어를 제어합니다. --- 컴파일러는 가 루프 안에서 변경되지 않는다고 판단하여 최적화할 수 있습니다: --- --- 8비트 값에서 비트 2~5 (4비트)를 추출하는 함수를 작성하세요. 주어진 숫자가 2의 거듭제곱인지 확인하는 함수를 비트 연산으로 작성하세요. 8비트 값의 1인 비트 개수가 홀수면 1, 짝수면 0을 반환하는 함수를 작성하세요. 4개의 LED로 0~15 값을 2진수로 표시하고, 버튼을 누를 때마다 값이 1씩 증가하도록 만드세요. --- | 연산 | 코드 | 설명 |...", "url": "/study/ko/C_Programming/15_Bit_Operations.html"}, {"id": "C_Programming/16_Project_GPIO_Control", "title": "프로젝트 15: GPIO 제어", "topic": "C_Programming", "topic_display": "C Programming", "body": "GPIO(General Purpose Input/Output)로 LED와 버튼을 제어합니다. - GPIO 입출력 개념 이해 - LED 제어 (디지털 출력) - 버튼 읽기 (디지털 입력) - 풀업/풀다운 저항 이해 - 디바운싱 기법 습득 - Arduino 기본 구조 (setup, loop) - 비트 연산 기초 --- GPIO (General Purpose Input/Output)는 MCU의 범용 디지털 핀으로, 프로그램에서 자유롭게 입력 또는 출력으로 설정할 수 있습니다. --- Wokwi (https://wokwi.com)에서 다음과 같이 회로를 구성합니다: 1. Arduino Uno 추가 2. LED 추가 (부품 목록에서 검색) 3. 저항 추가 (330Ω) 4. 연결: - 핀 9 → 저항 → LED 양극(+, 긴 다리) - LED 음극(-, 짧은 다리) → GND --- --- 물리적 버튼을 누르면 접점이 여러 번 튀어 노이즈가 발생합니다. --- 2개의 버튼으로 4개의 LED를...", "url": "/study/ko/C_Programming/16_Project_GPIO_Control.html"}, {"id": "C_Programming/17_Project_Serial_Communication", "title": "프로젝트 16: 시리얼 통신", "topic": "C_Programming", "topic_display": "C Programming", "body": "UART 시리얼 통신을 이용한 PC와의 양방향 데이터 교환을 배웁니다. - UART 통신 원리 이해 - 시리얼 데이터 송수신 - 문자열 파싱 - 명령어 인터프리터 구현 - 디버깅 기법 - Arduino 기본 구조 - 문자열 처리 - GPIO 제어 --- UART (Universal Asynchronous Receiver/Transmitter)는 가장 기본적인 시리얼 통신 방식입니다. --- --- --- --- --- --- --- --- 시리얼로 \"LOG START\"를 입력하면 1초마다 가상의 온도 데이터를 출력하고, \"LOG STOP\"으로 중지하세요. 시리얼로 LED 패턴 시퀀스를 입력받아 순차 실행하세요. 예: \"SEQ 1,3,5,15,0\" → 각 패턴 500ms씩 실행 괄호와 여러 연산자를 지원하는 계산기로 확장하세요. PC에서 바이트 시퀀스를 보내면 해석하여 LED를 제어하는 바이너리 프로토콜을 구현하세요. --- | 함수 | 설명 | |------|------| | |...", "url": "/study/ko/C_Programming/17_Project_Serial_Communication.html"}, {"id": "C_Programming/18_Debugging_Memory_Analysis", "title": "디버깅과 메모리 분석", "topic": "C_Programming", "topic_display": "C Programming", "body": "효과적인 디버깅은 프로그래머의 핵심 역량입니다. 이 장에서는 GDB 디버거, Valgrind 메모리 분석 도구, 그리고 AddressSanitizer를 사용하여 버그를 찾고 메모리 문제를 해결하는 방법을 학습합니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 포인터, 동적 메모리 할당 --- 1. 디버깅 기초 2. GDB 디버거 3. Valgrind 메모리 분석 4. AddressSanitizer 5. 일반적인 메모리 버그 6. 디버깅 전략 --- 디버깅을 위해서는 플래그로 컴파일해야 합니다. 가장 기본적인 디버깅 방법입니다. 전제 조건 검증에 사용합니다. > 참고: 릴리스 빌드에서 assert를 비활성화하려면 플래그 사용 --- | 명령어 | 단축키 | 설명 | |--------|--------|------| | | | 프로그램 실행 | | | | 실행 계속 | | | | 다음 줄 (함수 안으로 들어가지 않음) | | | | 다음 줄 (함수 안으로 들어감) | | | | 현재 함수 끝까지...", "url": "/study/ko/C_Programming/18_Debugging_Memory_Analysis.html"}, {"id": "C_Programming/19_Advanced_Embedded_Protocols", "title": "고급 임베디드 프로토콜", "topic": "C_Programming", "topic_display": "C Programming", "body": "이 장에서는 임베디드 시스템에서 자주 사용되는 통신 프로토콜과 하드웨어 제어 기법을 학습합니다. PWM, I2C, SPI, ADC 등 실제 센서와 액추에이터를 제어하는 데 필요한 핵심 기술을 다룹니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 임베디드 기초, 비트 연산, 포인터 --- 1. PWM (Pulse Width Modulation) 2. 타이머와 인터럽트 3. I2C 통신 4. SPI 통신 5. ADC (Analog to Digital Converter) 6. 실전 프로젝트 --- PWM은 디지털 신호의 ON/OFF 비율을 조절하여 아날로그와 유사한 효과를 내는 기술입니다. | 용어 | 설명 | |------|------| | 주기 (Period) | 한 사이클의 전체 시간 | | 듀티 사이클 | HIGH 상태의 비율 (%) | | 주파수 | 초당 사이클 수 (Hz) | --- --- I2C는 2선식 동기 통신 프로토콜입니다. | 특징 | 설명 | |------|------| | 선...", "url": "/study/ko/C_Programming/19_Advanced_Embedded_Protocols.html"}, {"id": "C_Programming/20_Advanced_Pointers", "title": "C 언어 포인터 심화", "topic": "C_Programming", "topic_display": "C Programming", "body": "- 포인터의 동작 원리를 깊이 이해한다 - 다양한 포인터 활용 패턴을 익힌다 - 포인터 관련 흔한 실수를 피하는 방법을 배운다 난이도: ⭐⭐⭐ (중급) --- 컴퓨터 메모리는 바이트 단위로 주소가 부여된 연속적인 공간입니다. 어떤 타입이든 가리킬 수 있는 범용 포인터입니다. void 포인터 용도: - 반환 타입 - 범용 함수 작성 (예: , ) --- 포인터에 1을 더하면 가리키는 타입의 크기만큼 주소가 증가합니다. 두 포인터 사이의 요소 개수를 반환합니다. --- 배열 이름은 대부분의 상황에서 첫 번째 요소의 주소로 변환됩니다. 예외 상황: 는 의 문법적 설탕(syntactic sugar)입니다. 선언 읽는 법: --- --- --- --- 오른쪽에서 왼쪽으로 읽으세요: --- --- --- 해제된 메모리를 가리키는 포인터입니다. Valgrind 출력 예시: 1. 포인터 출력하기 2. assert 사용하기 3. AddressSanitizer 사용 (GCC/Clang) ---...", "url": "/study/ko/C_Programming/20_Advanced_Pointers.html"}, {"id": "C_Programming/21_Network_Programming", "title": "C 네트워크 프로그래밍", "topic": "C_Programming", "topic_display": "C Programming", "body": "- TCP와 UDP를 위한 소켓 API(Socket API) 기초 이해 - 클라이언트-서버 통신 패턴(Client-Server Communication Pattern) 구현 - 동시 연결을 위한 select/poll을 사용한 I/O 다중화(I/O Multiplexing) 학습 - 네트워크 바이트 순서(Network Byte Order)와 주소 변환 처리 난이도: ⭐⭐⭐⭐ (고급) --- 1. 소켓 기초 2. TCP 통신 3. UDP 통신 4. I/O 다중화 5. 실용적인 패턴 6. 연습 문제 7. 참고 자료 --- 소켓(Socket)은 네트워크 통신의 종단점(endpoint)입니다. IP 주소와 포트 번호를 결합하여 특정 머신의 특정 프로세스를 식별합니다. 네트워크 프로토콜은 빅 엔디안(big-endian, 네트워크 바이트 순서)을 사용하지만, 대부분의 최신 CPU는 리틀 엔디안(little-endian)을 사용합니다. --- TCP는 스트림 프로토콜입니다. 와 는 요청한 것보다...", "url": "/study/ko/C_Programming/21_Network_Programming.html"}, {"id": "C_Programming/22_IPC_and_Signals", "title": "프로세스 간 통신과 시그널", "topic": "C_Programming", "topic_display": "C Programming", "body": "- IPC 메커니즘 이해하기: 파이프(Pipe), FIFO, 공유 메모리(Shared Memory), 메시지 큐(Message Queue) - 강력한 프로세스 제어를 위한 sigaction을 사용한 시그널(Signal) 처리 마스터하기 - 생산자-소비자(Producer-Consumer) 및 부모-자식 간 협력을 위한 IPC 패턴 적용하기 난이도: ⭐⭐⭐⭐ (고급) --- 1. 파이프 2. 명명된 파이프 (FIFO) 3. 공유 메모리 4. POSIX 메시지 큐 5. 시그널 6. 연습 문제 7. 참고 자료 --- 파이프는 관련된 프로세스(부모-자식) 간에 단방향 데이터 흐름을 제공합니다. --- FIFO는 파일 시스템 엔트리를 통해 관련 없는 프로세스 간 통신을 가능하게 합니다. --- 공유 메모리는 프로세스 간에 데이터를 복사할 필요가 없기 때문에 가장 빠른 IPC 메커니즘입니다. --- 메시지 큐는 우선순위를 지원하는 구조화된 메시지 전달을 제공합니다. --- 시그널은 프로세스에...", "url": "/study/ko/C_Programming/22_IPC_and_Signals.html"}, {"id": "Cloud_Computing/00_Overview", "title": "클라우드 컴퓨팅 학습 가이드 (AWS & GCP)", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "이 폴더는 AWS(Amazon Web Services)와 GCP(Google Cloud Platform)를 병렬 비교하며 학습할 수 있는 클라우드 컴퓨팅 자료를 담고 있습니다. 두 플랫폼의 핵심 서비스를 대응시켜 설명하므로, 한 플랫폼을 익히면 다른 플랫폼으로 쉽게 전환할 수 있습니다. 대상 독자: 클라우드 입문자 ~ 중급자 (실무 기초) --- | 파일명 | 주제 | 난이도 | AWS 서비스 | GCP 서비스 | |--------|------|--------|-----------|-----------| | 01CloudComputingOverview.md | 클라우드 개요, IaaS/PaaS/SaaS | ⭐ | - | - | | 02AWSGCPAccountSetup.md | 계정 생성, 콘솔 탐색, MFA | ⭐ | Console | Console | | 03RegionsAvailabilityZones.md | 리전, 가용 영역, 글로벌 인프라 | ⭐⭐ | Regions/AZs...", "url": "/study/ko/Cloud_Computing/00_Overview.html"}, {"id": "Cloud_Computing/01_Cloud_Computing_Overview", "title": "클라우드 컴퓨팅 개요", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "클라우드 컴퓨팅은 인터넷을 통해 IT 리소스(서버, 스토리지, 네트워크, 데이터베이스 등)를 온디맨드로 제공하는 서비스 모델입니다. | 구분 | 온프레미스 (전통) | 클라우드 | |------|------------------|----------| | 초기 비용 | 높음 (하드웨어 구매) | 낮음 (사용량 기반) | | 확장성 | 수주~수개월 | 수분~수시간 | | 유지보수 | 직접 관리 | 제공자가 관리 | | 위험 | 미사용 리소스 낭비 | 필요한 만큼만 사용 | | 책임 | 모든 계층 직접 관리 | 공동 책임 모델 | 미국 국립표준기술연구소(NIST)가 정의한 클라우드 컴퓨팅의 핵심 특성: 1. On-demand Self-service (온디맨드 셀프서비스) - 사용자가 직접 리소스를 프로비저닝 - 사람의 개입 없이 자동화된 배포 2. Broad Network Access (광범위한 네트워크 접근) - 표준 메커니즘으로 네트워크를 통해 접근 - 다양한 클라이언트 플랫폼 지원...", "url": "/study/ko/Cloud_Computing/01_Cloud_Computing_Overview.html"}, {"id": "Cloud_Computing/02_AWS_GCP_Account_Setup", "title": "AWS & GCP 계정 설정", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "1. AWS 가입 페이지 접속 - https://aws.amazon.com/ 에서 \"Create an AWS Account\" 클릭 2. 계정 정보 입력 - 이메일 주소 (Root 계정용) - AWS 계정 이름 - 비밀번호 3. 연락처 정보 - 계정 유형: 개인(Personal) 또는 비즈니스(Business) - 이름, 주소, 전화번호 4. 결제 정보 - 신용카드 등록 (무료 티어 사용 시에도 필수) - $1 인증 결제 후 환불됨 5. 본인 확인 - SMS 또는 음성 통화로 PIN 확인 6. 지원 플랜 선택 - Basic Support (무료) 선택 권장 Root 계정은 모든 권한을 가지므로 반드시 보안 강화가 필요합니다. Console에서 MFA 활성화: 1. AWS Console → 우측 상단 계정명 → \"Security credentials\" 2. \"Multi-factor authentication (MFA)\" 섹션 3. \"Activate MFA\" 클릭 4. MFA 디바이스...", "url": "/study/ko/Cloud_Computing/02_AWS_GCP_Account_Setup.html"}, {"id": "Cloud_Computing/03_Regions_Availability_Zones", "title": "리전과 가용 영역", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "클라우드 제공자는 전 세계에 분산된 데이터센터를 통해 서비스를 제공합니다. | 개념 | AWS | GCP | |------|-----|-----| | 지리적 영역 | Region | Region | | 독립 데이터센터 | Availability Zone (AZ) | Zone | | 로컬 서비스 | Local Zones, Wavelength | - | | CDN 엣지 | Edge Locations | Edge PoPs | | 프라이빗 연결 | Direct Connect | Cloud Interconnect | --- 리전은 지리적으로 분리된 클라우드 인프라 영역입니다. 특징: - 각 리전은 독립적으로 운영 - 리전 간 데이터 복제는 명시적 설정 필요 - 대부분의 서비스는 리전 단위로 제공 | 리전 코드 | 위치 | 한국에서 권장 | |----------|------|--------------| | ap-northeast-2 | 서울 | ✅ 가장 권장 | | ap-northeast-1...", "url": "/study/ko/Cloud_Computing/03_Regions_Availability_Zones.html"}, {"id": "Cloud_Computing/04_Virtual_Machines", "title": "가상 머신 (EC2 / Compute Engine)", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "가상 머신(VM)은 클라우드에서 가장 기본적인 컴퓨팅 리소스입니다. | 항목 | AWS EC2 | GCP Compute Engine | |------|---------|-------------------| | 서비스명 | Elastic Compute Cloud | Compute Engine | | 인스턴스 단위 | Instance | Instance | | 이미지 | AMI | Image | | 인스턴스 유형 | Instance Types | Machine Types | | 시작 스크립트 | User Data | Startup Script | | 메타데이터 | Instance Metadata | Metadata Server | --- 명명 규칙: 예: , , | 패밀리 | 용도 | 예시 | |--------|------|------| | t | 범용 (버스터블) | t3.micro, t3.small | | m | 범용 (균형) | m5.large, m6i.xlarge | | c |...", "url": "/study/ko/Cloud_Computing/04_Virtual_Machines.html"}, {"id": "Cloud_Computing/05_Serverless_Functions", "title": "서버리스 함수 (Lambda / Cloud Functions)", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "서버리스는 서버 관리 없이 코드를 실행하는 컴퓨팅 모델입니다. 특징: - 서버 프로비저닝/관리 불필요 - 자동 확장 - 사용한 만큼만 과금 (실행 시간 + 요청 수) - 이벤트 기반 실행 | 항목 | AWS Lambda | GCP Cloud Functions | |------|-----------|-------------------| | 런타임 | Node.js, Python, Java, Go, Ruby, .NET, Custom | Node.js, Python, Go, Java, Ruby, PHP, .NET | | 메모리 | 128MB ~ 10GB | 128MB ~ 32GB | | 최대 실행 시간 | 15분 | 9분 (1세대) / 60분 (2세대) | | 동시 실행 | 1000 (기본, 증가 가능) | 무제한 (기본) | | 트리거 | API Gateway, S3, DynamoDB, SNS 등 | HTTP, Pub/Sub, Cloud Storage 등 | | 컨테이너 지원 | 지원...", "url": "/study/ko/Cloud_Computing/05_Serverless_Functions.html"}, {"id": "Cloud_Computing/06_Container_Services", "title": "컨테이너 서비스 (ECS/EKS/Fargate vs GKE/Cloud Run)", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "| 항목 | AWS | GCP | |------|-----|-----| | 컨테이너 레지스트리 | ECR | Artifact Registry | | 컨테이너 오케스트레이션 | ECS | - | | Kubernetes 관리형 | EKS | GKE | | 서버리스 컨테이너 | Fargate | Cloud Run | | App Platform | App Runner | Cloud Run | --- --- ECS Service Connect는 별도의 프록시나 서비스 메시 설정 없이 서비스 간 통신을 위한 내장 서비스 메시 기능을 제공합니다. 주요 장점: - 내장 서비스 디스커버리 (AWS Cloud Map 통합) - 서비스 간 자동 로드 밸런싱 - 추가 에이전트 없이 트래픽 메트릭 및 관측성(Observability) 제공 - 외부 서비스 메시(Istio, Consul) 불필요 ECS Exec을 사용하면 실행 중인 컨테이너에 대화형 셸로 접근하여 디버깅할 수 있습니다. > 참고: ECS...", "url": "/study/ko/Cloud_Computing/06_Container_Services.html"}, {"id": "Cloud_Computing/07_Object_Storage", "title": "객체 스토리지 (S3 / Cloud Storage)", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "객체 스토리지는 데이터를 객체 단위로 저장하는 스토리지 아키텍처입니다. 객체 구성요소: - 데이터: 실제 파일 내용 - 메타데이터: 파일 정보 (생성일, 크기, 커스텀 속성) - 고유 식별자: 객체를 찾기 위한 키 | 항목 | AWS S3 | GCP Cloud Storage | |------|--------|------------------| | 서비스명 | Simple Storage Service | Cloud Storage | | 컨테이너 단위 | Bucket | Bucket | | 최대 객체 크기 | 5TB | 5TB | | 멀티파트 업로드 | 지원 (5MB-5GB 파트) | 지원 (복합 업로드) | | 버전 관리 | Versioning | Object Versioning | | 수명 주기 | Lifecycle Rules | Lifecycle Management | | 암호화 | SSE-S3, SSE-KMS, SSE-C | Google-managed, CMEK, CSEK |...", "url": "/study/ko/Cloud_Computing/07_Object_Storage.html"}, {"id": "Cloud_Computing/08_Block_and_File_Storage", "title": "블록 및 파일 스토리지 (EBS/EFS vs Persistent Disk/Filestore)", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "| 유형 | 특징 | 사용 사례 | AWS | GCP | |------|------|----------|-----|-----| | 블록 | 저수준 디스크 접근 | DB, OS 부팅 디스크 | EBS | Persistent Disk | | 파일 | 공유 파일시스템 | 공유 스토리지, CMS | EFS | Filestore | | 객체 | HTTP 기반, 무제한 | 백업, 미디어, 로그 | S3 | Cloud Storage | | 기능 | AWS | GCP | |------|-----|-----| | 블록 스토리지 | EBS (Elastic Block Store) | Persistent Disk (PD) | | 공유 파일 스토리지 | EFS (Elastic File System) | Filestore | | 로컬 SSD | Instance Store | Local SSD | --- EBS 볼륨 유형: | 유형 | 용도 | IOPS | 처리량 | 비용 |...", "url": "/study/ko/Cloud_Computing/08_Block_and_File_Storage.html"}, {"id": "Cloud_Computing/09_Virtual_Private_Cloud", "title": "VPC (Virtual Private Cloud)", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "VPC는 클라우드 내에서 논리적으로 격리된 가상 네트워크입니다. 핵심 개념: - 자체 IP 주소 범위 정의 - 서브넷으로 분할 - 라우팅 테이블로 트래픽 제어 - 보안 그룹/방화벽으로 접근 통제 | 항목 | AWS VPC | GCP VPC | |------|---------|---------| | 범위 | 리전 단위 | 글로벌 | | 서브넷 범위 | 가용 영역 (AZ) | 리전 | | 기본 VPC | 리전당 1개 | 프로젝트당 1개 (default) | | 피어링 | 리전 간 가능 | 글로벌 자동 | | IP 범위 | 생성 시 고정 | 서브넷 추가 가능 | --- | 유형 | 인터넷 접근 | 용도 | |------|-----------|------| | 퍼블릭 | 직접 가능 | 웹 서버, Bastion | | 프라이빗 | NAT 통해서만 | 애플리케이션, DB | --- GCP는 별도의 인터넷 게이트웨이 없이 외부 IP가 있으면 인터넷 접근이 가능합니다. --- 프라이빗 서브넷의...", "url": "/study/ko/Cloud_Computing/09_Virtual_Private_Cloud.html"}, {"id": "Cloud_Computing/10_Load_Balancing_CDN", "title": "로드밸런싱 & CDN", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "로드밸런서는 들어오는 트래픽을 여러 서버에 분산시키는 서비스입니다. 장점: - 고가용성 (장애 서버 자동 제외) - 확장성 (서버 추가/제거 용이) - 성능 향상 (부하 분산) - 보안 (DDoS 완화, SSL 오프로딩) | 항목 | AWS | GCP | |------|-----|-----| | L7 (HTTP/HTTPS) | ALB | HTTP(S) Load Balancing | | L4 (TCP/UDP) | NLB | TCP/UDP Load Balancing | | 클래식 | CLB (레거시) | - | | 내부 | Internal ALB/NLB | Internal Load Balancing | | 글로벌 | Global Accelerator | Global Load Balancing | --- | 유형 | 계층 | 사용 사례 | 특징 | |------|------|----------|------| | ALB | L7 | 웹 앱, 마이크로서비스 | 경로/호스트 라우팅, 웹소켓...", "url": "/study/ko/Cloud_Computing/10_Load_Balancing_CDN.html"}, {"id": "Cloud_Computing/11_Managed_Relational_DB", "title": "관리형 관계형 데이터베이스 (RDS / Cloud SQL)", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "| 작업 | 자체 관리 (EC2) | 관리형 (RDS/Cloud SQL) | |------|----------------|----------------------| | 하드웨어 프로비저닝 | 사용자 | 제공자 | | OS 패치 | 사용자 | 제공자 | | DB 설치/설정 | 사용자 | 제공자 | | 백업 | 사용자 | 자동 | | 고가용성 | 사용자 | 옵션 제공 | | 스케일링 | 수동 | 버튼 클릭 | | 모니터링 | 설정 필요 | 기본 제공 | | 항목 | AWS | GCP | |------|-----|-----| | 관리형 RDB | RDS | Cloud SQL | | 고성능 DB | Aurora | Cloud Spanner, AlloyDB | | 지원 엔진 | MySQL, PostgreSQL, MariaDB, Oracle, SQL Server | MySQL, PostgreSQL, SQL Server | --- --- --- 보안 그룹 설정: 애플리케이션에서 연결: 연결...", "url": "/study/ko/Cloud_Computing/11_Managed_Relational_DB.html"}, {"id": "Cloud_Computing/12_NoSQL_Databases", "title": "NoSQL 데이터베이스", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "| 항목 | RDBMS | NoSQL | |------|-------|-------| | 스키마 | 엄격한 스키마 | 유연한 스키마 | | 확장성 | 수직 확장 | 수평 확장 | | 트랜잭션 | ACID | BASE (일부 ACID) | | 쿼리 | SQL | 다양한 API | | 사용 사례 | 트랜잭션, 복잡한 관계 | 대용량, 유연한 데이터 | | 유형 | AWS | GCP | |------|-----|-----| | Key-Value / Document | DynamoDB | Firestore | | Wide Column | - | Bigtable | | In-Memory Cache | ElastiCache | Memorystore | | Document (MongoDB) | DocumentDB | MongoDB Atlas (마켓플레이스) | --- 특징: - 완전 관리형 Key-Value / Document DB - 밀리초 지연 시간 - 무한 확장 - 서버리스 (온디맨드...", "url": "/study/ko/Cloud_Computing/12_NoSQL_Databases.html"}, {"id": "Cloud_Computing/13_Identity_Access_Management", "title": "IAM (Identity and Access Management)", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "IAM은 클라우드 리소스에 대한 접근을 안전하게 제어하는 서비스입니다. 핵심 질문: - 누가 (Who): 사용자, 그룹, 역할 - 무엇을 (What): 리소스 - 어떻게 (How): 권한 (허용/거부) | 항목 | AWS IAM | GCP IAM | |------|---------|---------| | 범위 | 계정 수준 | 조직/프로젝트 수준 | | 정책 부착 | 사용자/그룹/역할에 | 리소스에 | | 역할 | 역할을 맡음 (AssumeRole) | 역할 바인딩 | | 서비스 계정 | 역할 + 인스턴스 프로파일 | 서비스 계정 | --- 정책 구조: EC2 인스턴스 역할: 교차 계정 역할: --- | 유형 | 설명 | 예시 | |------|------|------| | 기본 역할 | 넓은 권한 | Owner, Editor, Viewer | | 사전정의 역할 | 서비스별 세분화 | roles/storage.admin | | 커스텀 역할 | 사용자 정의 |...", "url": "/study/ko/Cloud_Computing/13_Identity_Access_Management.html"}, {"id": "Cloud_Computing/14_Security_Services", "title": "보안 서비스", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "| 기능 | AWS | GCP | |------|-----|-----| | 네트워크 방화벽 | Security Groups, NACL | Firewall Rules | | WAF | AWS WAF | Cloud Armor | | DDoS | AWS Shield | Cloud Armor | | 키 관리 | KMS | Cloud KMS | | 비밀 관리 | Secrets Manager | Secret Manager | | 취약점 스캐닝 | Inspector | Security Command Center | | 위협 탐지 | GuardDuty | Security Command Center | --- --- 일반 규칙: - AWSManagedRulesCommonRuleSet: OWASP Top 10 - AWSManagedRulesSQLiRuleSet: SQL 인젝션 - AWSManagedRulesKnownBadInputsRuleSet: 악성 입력 -...", "url": "/study/ko/Cloud_Computing/14_Security_Services.html"}, {"id": "Cloud_Computing/15_CLI_and_SDK", "title": "CLI & SDK", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "| 항목 | AWS CLI | gcloud CLI | |------|---------|------------| | 설치 패키지 | awscli | google-cloud-sdk | | 구성 명령 | aws configure | gcloud init | | 프로필 | --profile | --configuration | | 출력 형식 | json, text, table, yaml | json, text, yaml, csv | --- ~/.aws/credentials: ~/.aws/config: --- --- 설치: 기본 사용: 서비스별 예시: 설치: 기본 사용: 서비스별 예시: --- AWS - 미사용 EBS 볼륨 삭제: GCP - 오래된 스냅샷 삭제: AWS Lambda 배포: AWS 인스턴스 상태 확인: --- boto3 Paginator: Python: --- --- - 16InfrastructureasCode.md - Terraform -...", "url": "/study/ko/Cloud_Computing/15_CLI_and_SDK.html"}, {"id": "Cloud_Computing/16_Infrastructure_as_Code", "title": "Infrastructure as Code (Terraform)", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "IaC는 인프라를 코드로 정의하고 관리하는 방식입니다. 장점: - 버전 관리 (Git) - 재현 가능성 - 자동화 - 문서화 - 협업 | 도구 | 유형 | 언어 | 멀티 클라우드 | |------|------|------|-------------| | Terraform | 선언적 | HCL | ✅ | | CloudFormation | 선언적 | JSON/YAML | AWS만 | | Deployment Manager | 선언적 | YAML/Jinja | GCP만 | | Pulumi | 선언적 | Python/TS 등 | ✅ | | Ansible | 절차적 | YAML | ✅ | --- --- --- --- AWS S3 백엔드: GCP Cloud Storage 백엔드: --- --- --- --- --- - 17MonitoringLogging_Cost.md - 모니터링 - Docker/ - Kubernetes IaC --- - Terraform Documentation -...", "url": "/study/ko/Cloud_Computing/16_Infrastructure_as_Code.html"}, {"id": "Cloud_Computing/17_Monitoring_Logging_Cost", "title": "모니터링, 로깅 & 비용 관리", "topic": "Cloud_Computing", "topic_display": "Cloud Computing", "body": "- 시스템 가용성 확보 - 성능 문제 조기 발견 - 용량 계획 - 비용 최적화 - 보안 이상 탐지 | 기능 | AWS | GCP | |------|-----|-----| | 메트릭 모니터링 | CloudWatch | Cloud Monitoring | | 로그 수집 | CloudWatch Logs | Cloud Logging | | 추적 | X-Ray | Cloud Trace | | 대시보드 | CloudWatch Dashboards | Cloud Monitoring Dashboards | | 알림 | CloudWatch Alarms + SNS | Alerting Policies | | 비용 관리 | Cost Explorer, Budgets | Billing, Budgets | --- 주요 메트릭: | 서비스 | 메트릭 | 설명 | |--------|--------|------| | EC2 | CPUUtilization | CPU 사용률 | | EC2 | NetworkIn/Out |...", "url": "/study/ko/Cloud_Computing/17_Monitoring_Logging_Cost.html"}, {"id": "Compiler_Design/00_Overview", "title": "컴파일러 설계(Compiler Design)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "컴파일러 설계는 컴퓨터 과학의 핵심 분야 중 하나로, 사람이 읽을 수 있는 프로그래밍 언어와 기계가 실행할 수 있는 코드 사이의 간극을 잇습니다. 컴파일러는 고수준 언어로 작성된 소스 코드를 — 전형적으로 기계 코드, 바이트코드, 또는 다른 프로그래밍 언어로 — 일련의 명확히 정의된 단계를 거쳐 하위 수준의 표현으로 변환합니다. 이 토픽은 컴파일의 전체 파이프라인을 다룹니다: 원시 문자(raw character)를 토큰(token)으로 스캔하는 것부터 시작해, 토큰을 구조화된 표현으로 파싱하고, 의미를 분석하고, 중간 코드(intermediate code)를 생성하고, 이를 최적화하고, 최종적으로 목적 코드를 생성하는 것까지 다룹니다. 이 과정에서 형식 언어 이론(formal language theory), 알고리즘 설계, 그래프 이론, 컴퓨터 아키텍처와의 깊은 연관성을 발견하게 될 것입니다. 컴파일러 설계를 이해하는 것은 컴파일러를 직접 만들기 위해서뿐만 아니라 다음과 같은...", "url": "/study/ko/Compiler_Design/00_Overview.html"}, {"id": "Compiler_Design/01_Introduction_to_Compilers", "title": "레슨 1: 컴파일러 입문(Introduction to Compilers)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 완료하면 다음을 수행할 수 있습니다: 1. 컴파일러의 정의 및 인터프리터와의 차이점 설명 2. FORTRAN부터 현대 시스템까지 컴파일러의 역사적 발전 추적 3. 컴파일 과정의 각 단계 식별 및 설명 4. 프론트엔드(front-end)와 백엔드(back-end)의 구분 설명 5. 단일 패스(single-pass) vs. 다중 패스(multi-pass) 컴파일 전략 이해 6. 부트스트래핑(bootstrapping)과 크로스 컴파일(cross-compilation) 설명 7. T-다이어그램(tombstone diagram) 읽기 및 작성 8. 간단한 프로그램의 모든 컴파일 단계 추적 --- 컴파일러(compiler)는 한 언어(소스 언어(source language))로 작성된 소스 코드를 다른 언어(목적 언어(target language))로 변환하면서, 변환 과정에서 감지된 오류를 보고하는 프로그램입니다. $$\\text{Compiler}: \\text{Source...", "url": "/study/ko/Compiler_Design/01_Introduction_to_Compilers.html"}, {"id": "Compiler_Design/02_Lexical_Analysis", "title": "레슨 2: 어휘 분석(Lexical Analysis)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 완료하면 다음을 할 수 있습니다: 1. 컴파일 파이프라인에서 렉서(Lexer, 스캐너)의 역할을 설명할 수 있다 2. 토큰(Token), 어휘소(Lexeme), 패턴(Pattern)의 차이를 구분할 수 있다 3. 정규 표현식(Regular Expression)을 형식적으로 정의하고 토큰 패턴 명세에 활용할 수 있다 4. 톰슨 구성법(Thompson's Construction)을 적용하여 정규 표현식을 NFA로 변환할 수 있다 5. 부분집합 구성법(Subset Construction)을 적용하여 NFA를 DFA로 변환할 수 있다 6. 홉크로프트 알고리즘(Hopcroft's Algorithm)을 적용하여 DFA를 최소화할 수 있다 7. 최장 일치 규칙(Longest Match Rule)을 구현하고 토큰 우선순위를 처리할 수 있다 8. 간단한 프로그래밍 언어용 완전한 렉서를 Python으로 구현할 수 있다 --- 렉서(Lexer)는 스캐너(Scanner) 또는...", "url": "/study/ko/Compiler_Design/02_Lexical_Analysis.html"}, {"id": "Compiler_Design/03_Finite_Automata", "title": "레슨 3: 유한 오토마톤(Finite Automata)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 완료하면 다음을 할 수 있습니다: 1. DFA, NFA, $\\epsilon$-NFA의 형식적 정의를 제시할 수 있다 2. 부분집합 구성법(Subset Construction)을 통해 NFA와 DFA의 동치 관계를 증명할 수 있다 3. 부분집합 구성 알고리즘을 단계별로 적용할 수 있다 4. 홉크로프트 알고리즘(Hopcroft's Algorithm)으로 DFA를 최소화하고 마이힐-네로드 정리(Myhill-Nerode Theorem)를 이해할 수 있다 5. 정규 언어의 펌핑 보조 정리(Pumping Lemma)를 기술하고 적용할 수 있다 6. 정규 언어의 한계(유한 오토마톤이 인식할 수 없는 것)를 파악할 수 있다 7. 렉서 생성을 위한 실용 도구(Lex, Flex, re2c)를 사용할 수 있다 8. Python으로 NFA 시뮬레이션, 부분집합 구성, DFA 최소화를 구현할 수 있다 --- 결정적 유한 오토마톤(Deterministic Finite Automaton,...", "url": "/study/ko/Compiler_Design/03_Finite_Automata.html"}, {"id": "Compiler_Design/04_Context_Free_Grammars", "title": "레슨 4: 문맥 자유 문법", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 완료하면 다음을 할 수 있습니다: 1. 문맥 자유 문법(Context-Free Grammar, CFG)의 형식적 정의를 제시할 수 있다 2. BNF 및 EBNF 표기법을 사용하여 문법을 작성할 수 있다 3. 주어진 문자열에 대한 최좌단(leftmost) 및 최우단(rightmost) 유도를 구성할 수 있다 4. 파스 트리(parse tree)를 구성하고 유도와의 관계를 이해할 수 있다 5. 문법의 모호성(ambiguity)을 식별하고 해소할 수 있다 6. 문법을 촘스키 정규형(Chomsky Normal Form, CNF) 및 그라이바흐 정규형(Greibach Normal Form, GNF)으로 변환할 수 있다 7. CYK 파싱 알고리즘을 적용할 수 있다 8. CFG와 푸시다운 오토마타(pushdown automata)의 연관성을 이해할 수 있다 9. 문맥 자유 언어에 대한 펌핑 보조 정리(pumping lemma)를 적용할 수 있다 10. Python으로 문법 조작 및...", "url": "/study/ko/Compiler_Design/04_Context_Free_Grammars.html"}, {"id": "Compiler_Design/05_Top_Down_Parsing", "title": "레슨 5: 하향식 파싱(Top-Down Parsing)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 완료하면 다음을 할 수 있습니다: 1. 이해: 하향식 파싱의 원리와 파스 트리를 루트에서 아래로 구성하는 방법 2. 계산: 임의의 문맥 자유 문법에 대한 FIRST 및 FOLLOW 집합 계산 3. 구성: LL(1) 파싱 테이블을 구성하고 LL(1) 문법 식별 4. 구현: 소규모 언어에 대한 재귀 하강 파서(recursive descent parser) 직접 구현 5. 구현: 구성된 파싱 테이블에서 테이블 구동 LL(1) 파서 구현 6. 제거: 좌재귀(left recursion)를 제거하고 좌인수분해(left factoring)를 적용하여 문법을 LL(1) 호환으로 만들기 7. 해소: LL(1) 충돌 해소 및 오류 복구 전략 적용 8. 설명: LL(k)와 ALL() 파싱이 LL(1)을 넘어 제공하는 확장 기능 설명 --- 하향식 파싱(top-down parsing)은 루트(시작 기호)에서 파스 트리를 구성하여 잎(단말 기호) 방향으로 내려가는 파싱 전략입니다. 각 단계에서...", "url": "/study/ko/Compiler_Design/05_Top_Down_Parsing.html"}, {"id": "Compiler_Design/06_Bottom_Up_Parsing", "title": "레슨 6: 상향식 파싱(Bottom-Up Parsing)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 완료하면 다음을 수행할 수 있습니다: 1. 이해: 시프트-리듀스 파싱(Shift-Reduce Parsing)의 원리와 잎(리프)에서 위로 파스 트리를 구성하는 방법 2. 정의: 핸들(Handle)이 무엇인지 설명하고 리듀스 결정을 유도하는 방식 설명 3. 구성: LR(0) 아이템 집합과 해당 오토마톤(Automaton) 구성 4. 구축: SLR(1), 정규 LR(1), LALR(1) 파싱 테이블 구축 5. 비교: 각 LR 변형의 장단점 비교 6. 활용: 파서 생성기 도구(Yacc, Bison, PLY) 효과적으로 사용 7. 해결: 우선순위(Precedence)와 결합성(Associativity)을 이용한 시프트-리듀스/리듀스-리듀스 충돌 해결 8. 구현: LR 파서에서의 오류 복구(Error Recovery) 전략 구현 --- 상향식 파싱은 잎(리프) (터미널 심볼)에서 루트(시작 심볼)까지 파스 트리를 구성합니다. 센텐셜 폼(Sentential Form)의 부분 문자열...", "url": "/study/ko/Compiler_Design/06_Bottom_Up_Parsing.html"}, {"id": "Compiler_Design/07_Abstract_Syntax_Trees", "title": "레슨 7: 추상 구문 트리(Abstract Syntax Trees)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 완료하면 다음을 수행할 수 있습니다: 1. 구분: 구체적 구문 트리(Concrete Syntax Tree, CST)와 추상 구문 트리(Abstract Syntax Tree, AST)의 차이 구분 2. 설계: 대수적 데이터 타입(Algebraic Data Types)과 Python 데이터클래스(Dataclasses)를 사용한 AST 노드 타입 설계 3. 구현: AST 순회(Traversal)와 변환(Transformation)을 위한 방문자 패턴(Visitor Pattern) 구현 4. 적용: 다양한 트리 순회 전략 적용 (전위 순회(Pre-Order), 후위 순회(Post-Order), 중위 순회(In-Order)) 5. 구축: AST로부터 소스 코드를 재구성하는 프리티 프린터(Pretty Printer) 구축 6. 수행: 상수 폴딩(Constant Folding)과 디슈가링(Desugaring) 같은 AST 변환 수행 7. 추적: 오류 보고를 위해 AST 노드에 소스...", "url": "/study/ko/Compiler_Design/07_Abstract_Syntax_Trees.html"}, {"id": "Compiler_Design/08_Semantic_Analysis", "title": "레슨 8: 의미 분석(Semantic Analysis)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 완료하면 다음을 할 수 있습니다: 1. 컴파일 파이프라인에서 의미 분석(semantic analysis)의 역할을 설명할 수 있다 2. S-속성(S-attributed) 문법과 L-속성(L-attributed) 문법을 사용하는 구문 지향 번역(syntax-directed translation)을 구별할 수 있다 3. 해시 테이블을 사용하여 적절한 스코프 관리(scope management)가 있는 심벌 테이블(symbol table)을 구현할 수 있다 4. 정적/동적, 강/약 타입 시스템(type system)을 설명할 수 있다 5. 표현식, 문장, 함수에 대한 타입 검사(type checking) 규칙을 구현할 수 있다 6. 힌들리-밀너(Hindley-Milner) 타입 추론(type inference)의 기초를 이해할 수 있다 7. 타입 호환성(type compatibility), 강제 변환(coercion), 오버로딩 해결(overloading...", "url": "/study/ko/Compiler_Design/08_Semantic_Analysis.html"}, {"id": "Compiler_Design/09_Intermediate_Representations", "title": "레슨 9: 중간 표현(Intermediate Representations)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 완료하면 다음을 할 수 있습니다: 1. 현대 컴파일러 설계에서 중간 표현(intermediate representations, IRs)이 왜 필수적인지 설명할 수 있다 2. 고수준, 중간 수준, 저수준 IR의 차이와 그 트레이드오프를 구별할 수 있다 3. 추상 구문 트리(abstract syntax tree)로부터 3-주소 코드(three-address code, TAC)를 생성할 수 있다 4. 제어 흐름 그래프(control flow graphs, CFGs)를 구성하고 기본 블록(basic blocks)을 식별할 수 있다 5. 코드를 정적 단일 대입(Static Single Assignment, SSA) 형식으로 변환하고 파이 함수(phi functions)를 설명할 수 있다 6. Python으로 TAC 생성기와 CFG 빌더를 구현할 수 있다 7. DAG 표현과 최적화에서의 역할을 설명할 수 있다 --- 컴파일러는 고수준 언어로 작성된 소스 코드를 특정 대상 아키텍처의...", "url": "/study/ko/Compiler_Design/09_Intermediate_Representations.html"}, {"id": "Compiler_Design/10_Runtime_Environments", "title": "레슨 10: 런타임 환경(Runtime Environments)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 마치면 다음을 할 수 있습니다: 1. 실행 중인 프로그램의 표준 메모리 레이아웃(코드, 정적, 스택, 힙)을 설명할 수 있다 2. 활성화 레코드(Activation Records)(스택 프레임)와 그 내용을 설명할 수 있다 3. 호출 규약(Calling Conventions)(cdecl, stdcall, System V AMD64 ABI)과 그 함의를 비교할 수 있다 4. 값에 의한 전달, 참조에 의한 전달, 이름에 의한 전달 등 매개변수 전달 메커니즘을 구현할 수 있다 5. 액세스 링크(Access Links)와 디스플레이(Displays)를 사용하여 중첩 함수를 처리할 수 있다 6. 정적 스코핑(Static Scoping)과 동적 스코핑(Dynamic Scoping)의 차이 및 런타임 구현을 구별할 수 있다 7. 힙 관리 전략(자유 리스트(Free Lists), 버디 시스템(Buddy System), 가비지 컬렉션(Garbage Collection))을 설명할 수...", "url": "/study/ko/Compiler_Design/10_Runtime_Environments.html"}, {"id": "Compiler_Design/11_Code_Generation", "title": "레슨 11: 코드 생성(Code Generation)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 완료하면 다음을 할 수 있습니다: 1. 설명하기: 코드 생성에 사용되는 목표 기계 모델(target machine model) 2. 설명하기: 트리 패턴 매칭(tree pattern matching) 및 타일링(tiling)을 통한 명령어 선택(instruction selection) 3. 구현하기: 명령어 선택을 위한 최대 한입 알고리즘(Maximal Munch algorithm) 4. 적용하기: 레지스터 할당(register allocation) 기법: 그래프 색칠(graph coloring) 및 선형 스캔(linear scan) 5. 이해하기: 명령어 스케줄링(instruction scheduling): 리스트 스케줄링(list scheduling), 소프트웨어 파이프라이닝(software pipelining) 개요 6. 수행하기: 생성된 코드에 대한 핍홀 최적화(peephole optimization) 7. 생성하기: 식, 제어 흐름, 함수 호출에 대한 코드 8....", "url": "/study/ko/Compiler_Design/11_Code_Generation.html"}, {"id": "Compiler_Design/12_Optimization_Local_and_Global", "title": "레슨 12: 최적화 -- 지역 최적화와 전역 최적화", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이 레슨을 완료하면 다음을 수행할 수 있습니다: 1. 설명: 컴파일러 최적화의 원칙 -- 안전성(safety), 수익성(profitability), 기회(opportunity) 2. 적용: 단일 기본 블록 내 지역 최적화(상수 폴딩, CSE, 복사 전파, 죽은 코드 제거, 강도 감소) 3. 공식화: 전역 데이터 흐름 분석(도달 정의, 가용 표현식, 활성 변수, 매우 바쁜 표현식) 4. 설명: 격자(lattice)와 고정점 반복을 사용한 데이터 흐름 분석의 수학적 프레임워크 5. 구현: 반복적 데이터 흐름 분석을 위한 워크리스트(worklist) 알고리즘 6. 구축: Python으로 완전한 데이터 흐름 분석 엔진 구현 --- 컴파일러 용어에서 최적화(optimization)란 프로그램의 관찰 가능한 동작을 보존하면서 어떤 지표 -- 일반적으로 실행 속도, 코드 크기, 또는 에너지 소비 -- 를 개선하는 프로그램 변환입니다. \"최적화\"라는 용어는 다소 오해의 소지가 있습니다:...", "url": "/study/ko/Compiler_Design/12_Optimization_Local_and_Global.html"}, {"id": "Compiler_Design/13_Loop_Optimization", "title": "루프 최적화", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이전: 12. 최적화 -- 지역 최적화와 전역 최적화 | 다음: 14. 가비지 컬렉션 --- 프로그램은 실행 시간의 대부분을 루프 내부에서 보냅니다. \"90/10 규칙\"이라고도 불리는 경험적 법칙에 따르면 실행 시간의 90%는 코드의 10%에서 소비되며 -- 그 10%는 거의 항상 루프 안입니다. 이 때문에 루프 최적화는 컴파일러 최적화 범주 중 가장 큰 영향을 미칩니다. 백만 번 실행되는 루프는 모든 개선을 백만 배로 증폭합니다. 이 레슨은 루프 최적화의 전체 스펙트럼을 다룹니다: 제어 흐름 그래프에서 루프를 감지하는 것부터, 루프 불변 코드 이동(loop-invariant code motion)과 강도 감소(strength reduction)와 같은 고전적인 변환, 벡터화(vectorization)와 다면체 모델(polyhedral model)과 같은 현대적인 기법까지. 난이도: ⭐⭐⭐⭐ 전제 조건: 09. 중간 표현, 12. 최적화 -- 지역 최적화와 전역 최적화 학습 목표:...", "url": "/study/ko/Compiler_Design/13_Loop_Optimization.html"}, {"id": "Compiler_Design/14_Garbage_Collection", "title": "가비지 컬렉션(Garbage Collection)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이전: 13. 루프 최적화 | 다음: 15. 인터프리터와 가상 머신 --- 메모리 관리는 프로그래밍 언어 구현에서 가장 근본적인 과제 중 하나입니다. 모든 프로그램은 메모리를 할당하고, 그 메모리는 결국 회수되어야 합니다. 수동 메모리 관리(C나 C++에서처럼)는 프로그래머에게 완전한 제어권을 주지만 오류가 발생하기 쉽기로 악명 높습니다. 허상 포인터(dangling pointer), 이중 해제(double free), 메모리 누수(memory leak)는 소프트웨어 역사에서 가장 흔하고 위험한 버그들입니다. 가비지 컬렉션(GC)은 이 과정을 자동화하여 프로그래머를 객체 수명 추적으로부터 해방시켜 줍니다 -- 단, 런타임 오버헤드와 제어권 감소라는 비용을 치릅니다. 이 레슨은 주요 가비지 컬렉션 알고리즘과 그 트레이드오프를 다룹니다. 가장 단순한 참조 계수(reference counting) 방식부터 프로덕션 시스템에서 사용되는 정교한 세대별(generational) 및...", "url": "/study/ko/Compiler_Design/14_Garbage_Collection.html"}, {"id": "Compiler_Design/15_Interpreters_and_Virtual_Machines", "title": "인터프리터와 가상 머신(Interpreters and Virtual Machines)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이전: 14. 가비지 컬렉션 | 다음: 16. 현대 컴파일러 인프라 --- 모든 언어 구현이 네이티브 기계 코드로 컴파일되는 것은 아닙니다. Python, Java, JavaScript, Ruby, Erlang, Lua 같이 가장 널리 사용되는 많은 언어들은 프로그램을 실행하기 위해 인터프리터 또는 가상 머신(또는 둘의 조합)에 의존합니다. 인터프리터와 VM이 어떻게 작동하는지 이해하는 것은 언어 구현자와 코드가 실행될 때 무슨 일이 일어나는지 이해하고 싶은 모든 프로그래머에게 필수적입니다. 이 레슨은 단순한 트리 순회 인터프리터부터 정교한 JIT 컴파일 가상 머신까지 실행 전략의 스펙트럼을 다룹니다. 간단한 언어를 위한 바이트코드 컴파일러와 스택 기반 VM을 Python으로 구현하여 프로덕션 VM이 어떻게 작동하는지 이해하기 위한 구체적인 기반을 제공합니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 07. 추상 구문 트리, 09. 중간 표현, 11. 코드 생성 학습 목표: - 여러...", "url": "/study/ko/Compiler_Design/15_Interpreters_and_Virtual_Machines.html"}, {"id": "Compiler_Design/16_Modern_Compiler_Infrastructure", "title": "현대 컴파일러 인프라(Modern Compiler Infrastructure)", "topic": "Compiler_Design", "topic_display": "Compiler Design", "body": "이전: 15. 인터프리터와 가상 머신 --- 현대 컴파일러는 처음부터 만드는 단일 프로그램이 아닙니다. 재사용 가능한 인프라 -- 중간 표현(Intermediate Representation), 최적화 패스(Optimization Pass), 코드 생성기, 도구 프레임워크 -- 를 조립하여 만들어지며, 이를 여러 언어에서 공유할 수 있습니다. LLVM 프로젝트가 이 철학을 잘 보여줍니다: 수십 개의 언어(C, C++, Rust, Swift, Julia, Zig 등)가 동일한 최적화기와 코드 생성기를 공유합니다. 이 레슨에서는 현대 컴파일러를 구동하는 인프라를 탐구합니다: LLVM의 아키텍처와 IR, MLIR의 다중 레벨 접근 방식, GCC 내부, 도메인 특화 언어(DSL) 설계, 컴파일러 구성 도구, 그리고 PGO와 LTO 같은 고급 컴파일 기법들입니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 09. 중간 표현, 11. 코드 생성, 12. 최적화 -- 지역 및 전역 학습 목표: -...", "url": "/study/ko/Compiler_Design/16_Modern_Compiler_Infrastructure.html"}, {"id": "Computer_Architecture/00_Overview", "title": "컴퓨터 구조 학습 가이드", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "이 폴더는 컴퓨터 구조(Computer Architecture)를 체계적으로 학습하기 위한 자료를 담고 있습니다. 데이터 표현부터 CPU 아키텍처, 메모리 시스템, 병렬 처리까지 컴퓨터가 어떻게 작동하는지 이해할 수 있습니다. 대상 독자: 프로그래밍 기초를 아는 개발자, CS 기초를 학습하려는 사람 --- --- - 프로그래밍 기초 (변수, 제어문, 함수) - 기본 수학 (이진수, 논리 연산) - C 또는 Python 중 하나 이상의 언어 --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01ComputerSystemOverview.md | ⭐ | 컴퓨터 역사, 폰 노이만 구조, 하드웨어 구성 | | 02DataRepresentationBasics.md | ⭐ | 이진수, 8진수, 16진수, 진법 변환 | | 03IntegerFloatRepresentation.md | ⭐⭐ | 2의 보수, IEEE 754 부동소수점 | |...", "url": "/study/ko/Computer_Architecture/00_Overview.html"}, {"id": "Computer_Architecture/01_Computer_System_Overview", "title": "컴퓨터 시스템 개요", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "컴퓨터는 데이터를 입력받아 처리하고 결과를 출력하는 전자 장치입니다. 이 레슨에서는 컴퓨터의 역사, 기본 구조, 그리고 하드웨어와 소프트웨어의 관계를 학습합니다. --- 1. 컴퓨터의 역사 2. 폰 노이만 구조 3. 하드웨어 구성요소 4. 소프트웨어 계층 5. 성능 측정 6. 연습 문제 --- | 세대 | 시기 | 핵심 기술 | 특징 | |------|------|-----------|------| | 1세대 | 1940~1950년대 | 진공관 | ENIAC, 대형, 고열, 저신뢰성 | | 2세대 | 1950~1960년대 | 트랜지스터 | 소형화, 저전력, COBOL/FORTRAN | | 3세대 | 1960~1970년대 | 집적회로(IC) | 운영체제, 멀티프로그래밍 | | 4세대 | 1970년대~현재 | VLSI/ULSI | 마이크로프로세서, PC | | 5세대 | 현재~미래 | AI/양자컴퓨터 | 병렬처리, 인공지능 | --- 폰 노이만(John von Neumann)이...", "url": "/study/ko/Computer_Architecture/01_Computer_System_Overview.html"}, {"id": "Computer_Architecture/02_Data_Representation_Basics", "title": "데이터 표현 기초", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "컴퓨터는 모든 데이터를 0과 1의 이진수로 표현합니다. 이 레슨에서는 진법의 개념, 진법 변환 방법, 데이터 단위, 그리고 보수의 개념을 학습합니다. 이는 컴퓨터가 데이터를 어떻게 처리하는지 이해하는 기초가 됩니다. 난이도: ⭐ (기초) --- 1. 진법의 이해 2. 이진수 (Binary) 3. 8진수 (Octal) 4. 16진수 (Hexadecimal) 5. 진법 변환 6. 데이터 단위 7. 보수의 개념 8. 연습 문제 --- 진법은 수를 표현하는 방식으로, 기수(radix 또는 base)를 사용하여 숫자를 나타냅니다. 모든 진법에서 각 자리는 기수의 거듭제곱 값을 가집니다. --- 컴퓨터가 이진수를 사용하는 이유: --- --- --- 방법 1: 나눗셈 이용 (정수 부분) 방법 2: 곱셈 이용 (소수 부분) --- --- --- 1. 다음 10진수를 2진수로 변환하시오. - (a) 42 - (b) 100 - (c) 255 2. 다음 2진수를 10진수로 변환하시오. - (a)...", "url": "/study/ko/Computer_Architecture/02_Data_Representation_Basics.html"}, {"id": "Computer_Architecture/03_Integer_Float_Representation", "title": "정수와 실수 표현", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "컴퓨터에서 수를 표현하는 방법은 정수와 실수로 나뉩니다. 이 레슨에서는 부호 있는 정수의 다양한 표현 방식(부호-크기, 1의 보수, 2의 보수)과 IEEE 754 부동소수점 표준을 학습합니다. 또한 정수 오버플로우와 부동소수점 정밀도 문제도 다룹니다. 난이도: ⭐⭐ (중급) --- 1. 정수 표현 개요 2. 부호-크기 표현 3. 1의 보수 표현 4. 2의 보수 표현 5. 정수 오버플로우 6. 고정소수점 표현 7. IEEE 754 부동소수점 8. 부동소수점 정밀도 문제 9. 연습 문제 --- --- --- --- --- --- --- --- --- 1. 8비트 2의 보수로 다음 수를 표현하시오. - (a) +50 - (b) -50 - (c) -1 - (d) -128 2. 다음 8비트 2의 보수 값을 10진수로 변환하시오. - (a) 01100100 - (b) 11001110 - (c) 10000000 - (d) 11111111 3. 다음 연산의 결과를 8비트 2의 보수로 계산하시오....", "url": "/study/ko/Computer_Architecture/03_Integer_Float_Representation.html"}, {"id": "Computer_Architecture/04_Logic_Gates", "title": "논리 게이트", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "논리 게이트는 디지털 회로의 기본 구성 요소로, 하나 이상의 입력 신호를 받아 논리 연산을 수행하고 출력 신호를 생성합니다. 이 레슨에서는 기본 논리 게이트의 종류, 진리표 작성법, 불 대수의 법칙, 그리고 논리식 간소화 방법을 학습합니다. 난이도: ⭐ (기초) --- 1. 논리 게이트 기초 2. 기본 게이트 (AND, OR, NOT) 3. 유니버설 게이트 (NAND, NOR) 4. XOR과 XNOR 게이트 5. 진리표 작성법 6. 불 대수 기초 7. 불 대수 법칙 8. 논리식 간소화 9. 연습 문제 --- --- --- --- --- --- --- --- --- 1. 다음 논리 연산의 결과를 구하시오. - (a) 1 AND 0 - (b) 1 OR 0 - (c) NOT 1 - (d) 1 NAND 1 - (e) 0 NOR 0 - (f) 1 XOR 1 2. 다음 논리식의 진리표를 작성하시오. - (a) Y = A + B' - (b) Y = AB + A'B' - (c) Y = (A +...", "url": "/study/ko/Computer_Architecture/04_Logic_Gates.html"}, {"id": "Computer_Architecture/05_Combinational_Logic", "title": "조합 논리 회로", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "조합 논리 회로는 현재 입력만으로 출력이 결정되는 디지털 회로입니다. 이 레슨에서는 조합 논리 회로의 특성과 가산기, 멀티플렉서, 디멀티플렉서, 디코더, 인코더 등 주요 조합 회로를 학습합니다. 이 회로들은 CPU와 메모리 등 컴퓨터 하드웨어의 핵심 구성 요소입니다. 난이도: ⭐⭐ (중급) --- 1. 조합 논리 회로의 특성 2. 반가산기 (Half Adder) 3. 전가산기 (Full Adder) 4. 리플 캐리 가산기 5. 멀티플렉서 (MUX) 6. 디멀티플렉서 (DEMUX) 7. 디코더 (Decoder) 8. 인코더 (Encoder) 9. 비교기와 기타 회로 10. 연습 문제 --- --- --- --- --- --- --- --- --- --- 1. 반가산기와 전가산기의 차이점을 설명하시오. 2. 4비트 리플 캐리 가산기에서 0111 + 0011을 계산하시오. 각 FA의 S와 Cₒᵤₜ을 표시하시오. 3. 8:1 멀티플렉서에서 선택선이 S₂S₁S₀ = 101일 때 어떤 입력이...", "url": "/study/ko/Computer_Architecture/05_Combinational_Logic.html"}, {"id": "Computer_Architecture/06_Sequential_Logic", "title": "순차 논리 회로", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "순차 논리 회로는 현재 입력뿐만 아니라 이전 상태(메모리)에 따라 출력이 결정되는 디지털 회로입니다. 이 레슨에서는 기본 기억 소자인 래치와 플립플롭, 그리고 이를 활용한 레지스터와 카운터를 학습합니다. 이들은 CPU 레지스터, 메모리, 상태 기계 등 컴퓨터 핵심 구성 요소의 기반입니다. 난이도: ⭐⭐ (중급) --- 1. 순차 논리 회로의 특성 2. SR 래치 3. D 래치 4. D 플립플롭 5. JK 플립플롭 6. T 플립플롭 7. 레지스터 8. 카운터 9. 클럭과 타이밍 10. 연습 문제 --- --- --- --- --- --- --- --- --- --- 1. 래치와 플립플롭의 차이점을 설명하시오. 2. D 플립플롭의 특성식을 쓰고 동작을 설명하시오. 3. JK 플립플롭에서 J=K=1일 때의 동작을 설명하시오. 4. 다음 회로의 동작을 분석하고 상태 천이표를 작성하시오. 5. 4비트 리플 카운터의 타이밍 다이어그램을 그리시오. 초기 상태는 0000이다. 6. 다음...", "url": "/study/ko/Computer_Architecture/06_Sequential_Logic.html"}, {"id": "Computer_Architecture/07_CPU_Architecture_Basics", "title": "CPU 구조 기초", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "CPU(Central Processing Unit)는 컴퓨터의 두뇌로서, 프로그램의 명령어를 해석하고 실행하는 핵심 장치입니다. 이 레슨에서는 CPU의 내부 구성요소, 레지스터의 종류, 데이터패스 구조, 그리고 명령어 실행 사이클에 대해 상세히 학습합니다. 난이도: ⭐⭐ 선수 지식: 논리 게이트, 순차 논리 회로, 조합 논리 회로 --- 1. CPU의 구성요소 2. 레지스터 종류 3. 데이터패스 4. 명령어 실행 사이클 상세 5. 단일 사이클 vs 다중 사이클 6. 연습 문제 --- ALU는 CPU에서 실제 연산을 수행하는 핵심 장치입니다. | 연산 종류 | 연산 | 설명 | |-----------|------|------| | 산술 연산 | ADD | 덧셈 | | | SUB | 뺄셈 | | | MUL | 곱셈 | | | DIV | 나눗셈 | | | INC | 1 증가 | | | DEC | 1 감소 | | 논리 연산 | AND | 논리곱 | | | OR | 논리합 | | | XOR...", "url": "/study/ko/Computer_Architecture/07_CPU_Architecture_Basics.html"}, {"id": "Computer_Architecture/08_Control_Unit", "title": "제어장치", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "제어장치(Control Unit)는 CPU의 핵심 구성요소로, 명령어를 해독하고 적절한 제어 신호를 생성하여 CPU 내의 모든 구성요소를 조율합니다. 이 레슨에서는 제어장치의 역할, 하드와이어드 제어와 마이크로프로그램 제어의 두 가지 구현 방식, 그리고 마이크로명령어의 구조에 대해 학습합니다. 난이도: ⭐⭐⭐ 선수 지식: CPU 구조 기초, 논리 회로, 상태 기계 --- 1. 제어장치의 역할 2. 하드와이어드 제어 3. 마이크로프로그램 제어 4. 제어 신호 생성 5. 마이크로명령어 6. 연습 문제 --- | 작업 | 설명 | |------|------| | 명령어 해독 | IR의 opcode와 function 필드를 분석하여 명령어 종류 파악 | | 타이밍 생성 | 각 작업의 실행 순서와 시점 결정 | | 제어 신호 생성 | 데이터패스의 각 구성요소를 제어하는 신호 출력 | | 상태 관리 | 현재 실행 상태 추적 및 다음 상태 결정 | | 예외 처리 | 인터럽트, 오류 등 예외...", "url": "/study/ko/Computer_Architecture/08_Control_Unit.html"}, {"id": "Computer_Architecture/09_Instruction_Set_Architecture", "title": "명령어 집합 아키텍처 (ISA)", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "명령어 집합 아키텍처(Instruction Set Architecture, ISA)는 소프트웨어와 하드웨어 사이의 인터페이스를 정의합니다. ISA는 프로세서가 이해할 수 있는 명령어의 집합, 레지스터, 메모리 주소 지정 방식 등을 명세합니다. 이 레슨에서는 ISA의 개념, CISC와 RISC의 비교, 명령어 형식, 그리고 다양한 주소 지정 방식을 학습합니다. 난이도: ⭐⭐⭐ 선수 지식: CPU 구조 기초, 제어장치, 이진수 표현 --- 1. ISA의 개념 2. CISC vs RISC 비교 3. 명령어 형식 4. 주소 지정 방식 5. 대표적인 ISA 6. 연습 문제 --- | 구성 요소 | 설명 | 예시 | |-----------|------|------| | 명령어 집합 | 프로세서가 실행할 수 있는 연산들 | ADD, SUB, LOAD, STORE, JUMP | | 레지스터 | 프로그래머가 사용 가능한 레지스터 | x86: EAX, EBX / ARM: R0-R15 | | 데이터...", "url": "/study/ko/Computer_Architecture/09_Instruction_Set_Architecture.html"}, {"id": "Computer_Architecture/10_Assembly_Language_Basics", "title": "어셈블리 언어 기초", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "어셈블리 언어는 기계어와 1:1로 대응되는 저수준 프로그래밍 언어입니다. 프로세서가 직접 이해하는 명령어를 사람이 읽을 수 있는 형태로 표현합니다. 이 레슨에서는 x86과 ARM 어셈블리의 기초, 주요 명령어 종류, 그리고 간단한 프로그램 작성 방법을 학습합니다. 난이도: ⭐⭐⭐ 선수 지식: 명령어 집합 아키텍처(ISA), CPU 구조 기초 --- 1. 어셈블리 언어 개념 2. x86 어셈블리 기초 3. ARM 어셈블리 기초 4. 산술/논리 명령어 5. 분기 명령어 6. 메모리 접근 명령어 7. 간단한 어셈블리 프로그램 예제 8. 연습 문제 --- --- --- --- --- --- --- --- 1. 어셈블리 언어와 기계어의 관계를 설명하시오. 2. x86에서 다음 레지스터의 용도를 설명하시오: - (a) EAX - (b) ESP - (c) EIP/RIP 3. Intel 문법과 AT&T 문법의 주요 차이점 2가지를 쓰시오. 4. 다음 x86 어셈블리 코드의 실행 후 EAX의...", "url": "/study/ko/Computer_Architecture/10_Assembly_Language_Basics.html"}, {"id": "Computer_Architecture/11_Pipelining", "title": "파이프라이닝 (Pipelining)", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "파이프라이닝은 여러 명령어를 동시에 실행하여 CPU 처리량을 높이는 기술입니다. 세탁기-건조기 비유처럼, 하나의 작업이 끝나기 전에 다음 작업을 시작하여 전체 효율을 높입니다. --- 1. 파이프라이닝 개념 2. 5단계 파이프라인 3. 파이프라인 성능 4. 파이프라인 해저드 5. 해저드 해결 기법 6. 연습 문제 --- --- | 단계 | 이름 | 동작 | |------|------|------| | IF | Instruction Fetch | PC가 가리키는 명령어를 메모리에서 가져옴 | | ID | Instruction Decode | 명령어 해독, 레지스터 읽기 | | EX | Execute | ALU 연산 수행, 주소 계산 | | MEM | Memory Access | 메모리 읽기/쓰기 (load/store) | | WB | Write Back | 연산 결과를 레지스터에 저장 | --- --- --- --- 1. 5단계 파이프라인의 각 단계 이름과 역할은? 2. 100개...", "url": "/study/ko/Computer_Architecture/11_Pipelining.html"}, {"id": "Computer_Architecture/12_Branch_Prediction", "title": "분기 예측 (Branch Prediction)", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "분기 예측은 조건 분기 명령어의 결과를 미리 예측하여 파이프라인 성능을 높이는 기술입니다. 현대 프로세서는 90% 이상의 예측 정확도를 달성합니다. --- 1. 제어 해저드와 분기 문제 2. 정적 분기 예측 3. 동적 분기 예측 4. 분기 타겟 버퍼 5. 투기적 실행 6. 연습 문제 --- --- --- --- --- --- 1. 정적 분기 예측 3가지 방식은? 2. 2비트 예측기의 4가지 상태는? 3. 다음 시퀀스에서 1비트 예측기(초기 T)의 예측 결과: 4. 아래 루프에서 2비트 예측기(초기 ST)의 동작: 5. 분기 비율 25%, 페널티 10 사이클, 예측 정확도 95%일 때 CPI는? 6. 토너먼트 예측기가 단일 예측기보다 좋은 이유를 설명하시오. 7. BTB가 없을 때와 있을 때의 분기 처리 차이를 비교하시오. <details> <summary>정답</summary> 1. Always Not Taken, Always Taken, BTFN (Backward Taken,...", "url": "/study/ko/Computer_Architecture/12_Branch_Prediction.html"}, {"id": "Computer_Architecture/13_Superscalar_Out_of_Order", "title": "슈퍼스칼라와 비순차 실행", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "현대 고성능 프로세서는 단순히 클럭 속도를 높이는 것만으로는 성능 향상에 한계가 있습니다. 슈퍼스칼라(Superscalar)와 비순차 실행(Out-of-Order Execution)은 명령어 수준 병렬성(ILP)을 활용하여 한 사이클에 여러 명령어를 동시에 실행하는 기술입니다. 이 레슨에서는 ILP의 개념, 슈퍼스칼라 아키텍처, 비순차 실행의 원리와 구현 방법을 학습합니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 파이프라이닝, 분기 예측, CPU 구조 기초 --- 1. 명령어 수준 병렬성 (ILP) 2. 슈퍼스칼라 프로세서 3. 비순차 실행의 필요성 4. 레지스터 리네이밍 5. Tomasulo 알고리즘 6. Reorder Buffer (ROB) 7. 현대 프로세서의 실제 구현 8. 연습 문제 --- 명령어 수준 병렬성(Instruction-Level Parallelism, ILP)은 프로그램 내에서 동시에 실행 가능한 명령어들의 잠재적 병렬성을 의미합니다. ILP를 제한하는 가장 중요한...", "url": "/study/ko/Computer_Architecture/13_Superscalar_Out_of_Order.html"}, {"id": "Computer_Architecture/14_Memory_Hierarchy", "title": "메모리 계층 구조", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "컴퓨터 시스템에서 CPU와 메모리 간의 속도 차이는 성능의 주요 병목입니다. 메모리 계층 구조(Memory Hierarchy)는 속도, 용량, 비용의 트레이드오프를 최적화하여 이 문제를 해결합니다. 이 레슨에서는 메모리 계층 구조의 원리, 지역성의 개념, 그리고 각 계층의 특성을 학습합니다. 난이도: ⭐⭐ 선수 지식: 컴퓨터 시스템 개요, CPU 구조 기초 --- 1. 메모리 계층 구조의 필요성 2. 지역성 원리 3. 메모리 기술 비교 4. 메모리 계층 5. 메모리 대역폭과 지연시간 6. 메모리 성능 최적화 7. 연습 문제 --- --- 프로그램이 메모리를 접근하는 패턴에는 규칙성이 있습니다. 이를 지역성(Locality)이라 하며, 메모리 계층 구조가 효과적인 이유입니다. --- --- --- --- --- 1. 메모리 계층 구조가 필요한 이유를 설명하시오. 2. 다음 코드에서 시간적 지역성과 공간적 지역성을 찾으시오: 3. SRAM과 DRAM의 주요 차이점 3가지는? 4. L1...", "url": "/study/ko/Computer_Architecture/14_Memory_Hierarchy.html"}, {"id": "Computer_Architecture/15_Cache_Memory", "title": "캐시 메모리", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "캐시(Cache) 메모리는 CPU와 메인 메모리 사이의 속도 격차를 해소하기 위한 고속 버퍼 메모리입니다. 캐시의 설계는 컴퓨터 성능에 직접적인 영향을 미치며, 사상 방식, 교체 정책, 쓰기 정책 등 다양한 설계 결정이 필요합니다. 이 레슨에서는 캐시의 동작 원리와 다양한 설계 기법을 학습합니다. 난이도: ⭐⭐⭐ 선수 지식: 메모리 계층 구조, 지역성 원리 --- 1. 캐시의 개념과 동작 2. 캐시 사상 방식 3. 캐시 교체 정책 4. 캐시 쓰기 정책 5. 캐시 미스의 종류 6. 다중 레벨 캐시 7. 캐시 최적화 기법 8. 연습 문제 --- --- --- --- --- --- --- --- 1. 32KB 직접 사상 캐시, 64바이트 블록일 때 캐시 라인 수는? 2. 4-way 집합 연관 캐시에서 특정 메모리 블록이 저장될 수 있는 위치는 몇 개인가? 3. Write-Through와 Write-Back의 차이를 설명하시오. 4. 다음 주소에서 Tag, Index, Offset을...", "url": "/study/ko/Computer_Architecture/15_Cache_Memory.html"}, {"id": "Computer_Architecture/16_Virtual_Memory", "title": "가상 메모리", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "가상 메모리(Virtual Memory)는 프로그램에게 연속적이고 독립적인 주소 공간을 제공하며, 물리 메모리보다 큰 프로그램도 실행할 수 있게 해주는 핵심 기술입니다. 이 레슨에서는 가상 메모리의 개념, 페이지 테이블, TLB, 페이지 폴트 처리 등을 학습합니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 메모리 계층 구조, 캐시 메모리 --- 1. 가상 메모리의 필요성 2. 주소 공간 3. 페이지와 페이지 프레임 4. 페이지 테이블 5. TLB (Translation Lookaside Buffer) 6. 페이지 폴트와 페이지 교체 7. 페이지 교체 알고리즘 8. 고급 주제 9. 연습 문제 --- --- --- --- --- --- --- --- --- 1. 가상 메모리의 주요 장점 3가지는? 2. 32비트 시스템, 4KB 페이지에서 가상 주소 0x12345ABC의: - VPN은? - Offset은? 3. TLB의 역할과 필요성을 설명하시오. 4. 다음 접근 순서에서 FIFO, LRU...", "url": "/study/ko/Computer_Architecture/16_Virtual_Memory.html"}, {"id": "Computer_Architecture/17_IO_Systems", "title": "입출력 시스템", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "입출력(I/O) 시스템은 CPU와 외부 장치(키보드, 디스크, 네트워크 등) 간의 데이터 전송을 담당합니다. I/O 시스템의 설계는 시스템 전체 성능에 큰 영향을 미치며, 폴링, 인터럽트, DMA 등 다양한 방식으로 구현됩니다. 이 레슨에서는 I/O 시스템의 구조와 동작 원리를 학습합니다. 난이도: ⭐⭐⭐ 선수 지식: CPU 구조, 메모리 시스템 --- 1. I/O 시스템 개요 2. 프로그램 I/O (폴링) 3. 인터럽트 기반 I/O 4. DMA (Direct Memory Access) 5. 버스 구조 6. I/O 인터페이스 7. 현대 I/O 시스템 8. 연습 문제 --- --- --- --- --- --- --- --- 1. 폴링, 인터럽트, DMA 방식의 차이점을 설명하시오. 2. 인터럽트 벡터 테이블의 역할은? 3. DMA 컨트롤러에 설정해야 하는 정보 3가지는? 4. 다음 상황에서 적합한 I/O 방식을 선택하시오: - (a) 키보드 입력 처리 - (b) 10MB 파일...", "url": "/study/ko/Computer_Architecture/17_IO_Systems.html"}, {"id": "Computer_Architecture/18_Parallel_Processing_Multicore", "title": "병렬 처리와 멀티코어", "topic": "Computer_Architecture", "topic_display": "Computer Architecture", "body": "단일 프로세서의 성능 향상이 물리적 한계에 도달하면서, 현대 컴퓨터는 멀티코어와 병렬 처리를 통해 성능을 높이고 있습니다. 이 레슨에서는 병렬 처리의 기본 개념, 멀티프로세서/멀티코어 아키텍처, 캐시 일관성 문제, 동기화 메커니즘, 그리고 GPU를 활용한 병렬 컴퓨팅까지 학습합니다. 난이도: ⭐⭐⭐⭐ 선수 지식: CPU 구조, 캐시 메모리, 메모리 계층 --- 1. 병렬 처리의 필요성 2. 플린 분류 (Flynn's Taxonomy) 3. 멀티프로세서와 멀티코어 4. 캐시 일관성 문제 5. 스누핑 프로토콜 (MESI) 6. 암달의 법칙과 구스타프슨 법칙 7. 동기화와 락 8. GPU와 병렬 컴퓨팅 9. 연습 문제 --- --- --- --- --- --- --- --- --- 1. Flynn's Taxonomy의 4가지 분류를 설명하시오. 2. SMP와 NUMA의 차이점은? 3. MESI 프로토콜의 4가지 상태를 설명하시오. 4. 프로그램의 80%가 병렬화 가능할 때, 암달의...", "url": "/study/ko/Computer_Architecture/18_Parallel_Processing_Multicore.html"}, {"id": "Computer_Vision/00_Overview", "title": "OpenCV / Computer Vision 학습 가이드", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "이 폴더는 OpenCV를 활용한 컴퓨터 비전을 체계적으로 학습하기 위한 자료를 담고 있습니다. 이미지 처리의 기초부터 딥러닝 기반 객체 검출까지 단계별로 학습할 수 있습니다. 대상 독자: Python 기초를 아는 개발자, 컴퓨터 비전 입문자, 영상 처리 프로젝트 준비자 --- --- - Python 기초 (변수, 제어문, 함수, 클래스) - NumPy 기초 (ndarray, 인덱싱, 슬라이싱, 브로드캐스팅) - 파일 I/O, 예외 처리 - 선형대수 기초 (행렬 연산) - 확률/통계 기초 - 머신러닝 개념 (분류, 학습) --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01EnvironmentSetup.md | ⭐ | OpenCV 설치, opencv-python vs contrib, 버전 확인 | | 02ImageBasics.md | ⭐ | imread, imshow, imwrite, 픽셀 접근, ROI | |...", "url": "/study/ko/Computer_Vision/00_Overview.html"}, {"id": "Computer_Vision/01_Environment_Setup", "title": "환경 설정 및 기초", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "OpenCV(Open Source Computer Vision Library)는 실시간 컴퓨터 비전을 위한 오픈소스 라이브러리입니다. 이 문서에서는 OpenCV 설치부터 첫 프로그램 실행, 그리고 이미지 데이터의 기본 구조를 학습합니다. 난이도: ⭐ (입문) 학습 목표: - OpenCV 설치 및 개발 환경 구성 - 버전 확인 및 첫 번째 프로그램 작성 - OpenCV와 NumPy의 관계 이해 - 이미지가 ndarray로 표현되는 개념 이해 --- 1. OpenCV 소개 2. 설치 방법 3. 개발 환경 설정 4. 버전 확인 및 첫 프로그램 5. OpenCV와 NumPy 관계 6. 이미지는 ndarray 7. 연습 문제 8. 다음 단계 9. 참고 자료 --- OpenCV는 Intel에서 시작하여 현재는 오픈소스로 관리되는 컴퓨터 비전 라이브러리입니다. | 특징 | 설명 | |------|------| | 크로스 플랫폼 | Windows, macOS, Linux, Android, iOS...", "url": "/study/ko/Computer_Vision/01_Environment_Setup.html"}, {"id": "Computer_Vision/02_Image_Basics", "title": "이미지 기초 연산", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "이미지 처리의 기본은 이미지 파일을 읽고, 표시하고, 저장하는 것입니다. 이 문서에서는 OpenCV의 기본 I/O 함수와 픽셀 단위 접근, 관심 영역(ROI) 설정 방법을 학습합니다. 난이도: ⭐ (입문) 학습 목표: - , , 함수 마스터 - IMREAD 플래그 이해 및 활용 - 이미지 좌표 시스템 이해 (y, x 순서) - 픽셀 단위 접근 및 수정 - ROI(관심 영역) 설정과 이미지 복사 --- 1. 이미지 읽기 - imread() 2. 이미지 표시 - imshow() 3. 이미지 저장 - imwrite() 4. 이미지 속성 확인 5. 좌표 시스템과 픽셀 접근 6. ROI와 이미지 복사 7. 연습 문제 8. 다음 단계 9. 참고 자료 --- --- --- --- --- --- --- 하나의 이미지를 세 가지 모드(COLOR, GRAYSCALE, UNCHANGED)로 읽고 각각의 shape를 비교하세요. PNG 파일(투명도 포함)과 JPEG 파일로 테스트해보세요. JPEG...", "url": "/study/ko/Computer_Vision/02_Image_Basics.html"}, {"id": "Computer_Vision/03_Color_Spaces", "title": "색상 공간", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "컴퓨터 비전에서 색상 공간(Color Space)은 색상을 표현하는 방법입니다. OpenCV는 기본적으로 BGR 색상 공간을 사용하지만, 특정 작업에는 HSV, LAB 등 다른 색상 공간이 더 효과적입니다. 이 문서에서는 다양한 색상 공간의 특성과 변환 방법, 그리고 색상 기반 객체 추적을 학습합니다. 난이도: ⭐⭐ (초급-중급) 학습 목표: - BGR과 RGB의 차이 이해 - HSV 색상 공간의 원리와 활용 - 를 사용한 색상 공간 변환 - 채널 분리/병합 - 색상 기반 객체 추적 구현 --- 1. BGR vs RGB 2. cv2.cvtColor()와 색상 변환 상수 3. HSV 색상 공간 4. LAB 색상 공간 5. 그레이스케일 변환 6. 채널 분리와 병합 7. 색상 기반 객체 추적 8. 연습 문제 9. 다음 단계 10. 참고 자료 --- 역사적인 이유입니다. 초기 카메라와 디스플레이 하드웨어가 BGR 순서로 데이터를 저장했고, OpenCV는 이 관례를 따랐습니다. ---...", "url": "/study/ko/Computer_Vision/03_Color_Spaces.html"}, {"id": "Computer_Vision/04_Geometric_Transforms", "title": "기하학적 변환", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "기하학적 변환(Geometric Transformation)은 이미지의 공간적 위치를 변경하는 작업입니다. 크기 조절, 회전, 이동, 뒤집기, 원근 변환 등이 포함됩니다. 이 문서에서는 OpenCV의 기하학적 변환 함수들과 실제 활용 예제를 학습합니다. 난이도: ⭐⭐ (초급-중급) 학습 목표: - 와 보간법(interpolation) 이해 - 회전, 뒤집기 함수 사용 - 어파인 변환 (warpAffine) 활용 - 원근 변환 (warpPerspective) 활용 - 문서 스캔/교정 예제 구현 --- 1. 이미지 크기 조절 - resize() 2. 뒤집기와 회전 - flip(), rotate() 3. 어파인 변환 - warpAffine() 4. 원근 변환 - warpPerspective() 5. 문서 교정 예제 6. 연습 문제 7. 다음 단계 8. 참고 자료 --- --- --- --- --- --- 폴더 내의 모든 이미지를 가로 800px로 리사이즈하고 (비율 유지), 품질...", "url": "/study/ko/Computer_Vision/04_Geometric_Transforms.html"}, {"id": "Computer_Vision/05_Image_Filtering", "title": "이미지 필터링", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "이미지 필터링(Image Filtering)은 이미지의 픽셀 값을 주변 픽셀을 고려하여 변환하는 작업입니다. 노이즈 제거, 블러, 샤프닝 등 다양한 효과를 낼 수 있습니다. 이 문서에서는 커널과 컨볼루션의 개념부터 OpenCV의 다양한 필터 함수까지 학습합니다. 난이도: ⭐⭐ (초급-중급) 학습 목표: - 커널(Kernel)과 컨볼루션(Convolution) 개념 이해 - 다양한 블러 필터 (, , , ) - 엣지 보존 스무딩 - 커스텀 필터와 샤프닝 구현 --- 1. 커널과 컨볼루션 2. 평균 블러 - blur() 3. 가우시안 블러 - GaussianBlur() 4. 중앙값 블러 - medianBlur() 5. 양방향 필터 - bilateralFilter() 6. 커스텀 필터 - filter2D() 7. 샤프닝 필터 8. 연습 문제 9. 다음 단계 10. 참고 자료 --- --- 평균 블러는 가장 단순한 블러 필터로, 커널 영역의 평균값을 사용합니다. 의 일반화된 버전입니다....", "url": "/study/ko/Computer_Vision/05_Image_Filtering.html"}, {"id": "Computer_Vision/06_Morphology", "title": "모폴로지 연산", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "모폴로지 연산(Morphological Operations)은 이진 이미지나 그레이스케일 이미지의 형태를 기반으로 하는 연산입니다. 주로 노이즈 제거, 객체 분리, 홀 채우기 등에 사용됩니다. 이 문서에서는 구조 요소의 개념부터 다양한 모폴로지 연산의 활용까지 학습합니다. 난이도: ⭐⭐ (초급-중급) 학습 목표: - 구조 요소(Structuring Element) 이해 - 침식(Erosion)과 팽창(Dilation) 연산 - 열기(Opening)와 닫기(Closing) 연산 - 그래디언트, 탑햇, 블랙햇 연산 - 노이즈 제거 및 객체 분리 응용 --- 1. 모폴로지 연산 개요 2. 구조 요소 - getStructuringElement() 3. 침식 - erode() 4. 팽창 - dilate() 5. 열기와 닫기 - morphologyEx() 6. 그래디언트, 탑햇, 블랙햇 7. 실전 응용 8. 연습 문제 9. 다음 단계 10. 참고 자료 --- 모폴로지 연산은 구조...", "url": "/study/ko/Computer_Vision/06_Morphology.html"}, {"id": "Computer_Vision/07_Thresholding", "title": "이진화 및 임계처리", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "이진화(Binarization)는 그레이스케일 이미지를 흑백 이미지로 변환하는 과정입니다. 임계값(Threshold)을 기준으로 픽셀을 0 또는 255로 분류합니다. 이 문서에서는 다양한 임계처리 방법과 실전 활용 기법을 학습합니다. 난이도: ⭐⭐ (초급-중급) 학습 목표: - 함수와 다양한 플래그 - OTSU 자동 임계값 결정 - 적응형 임계처리 (Adaptive Threshold) - 다중 임계처리 - HSV 색상 기반 임계처리 - 문서 이진화 및 그림자 처리 --- 1. 이진화 개요 2. 전역 임계처리 - threshold() 3. OTSU 자동 임계값 4. 적응형 임계처리 - adaptiveThreshold() 5. 다중 임계처리 6. HSV 색상 기반 임계처리 7. 문서 이진화와 그림자 처리 8. 연습 문제 9. 다음 단계 10. 참고 자료 --- --- --- --- --- --- --- --- 히스토그램을 분석하여 바이모달 분포의 두 봉우리 사이 최적 임계값을 찾는...", "url": "/study/ko/Computer_Vision/07_Thresholding.html"}, {"id": "Computer_Vision/08_Edge_Detection", "title": "엣지 검출 (Edge Detection)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "엣지(Edge)는 이미지에서 밝기가 급격하게 변하는 영역으로, 객체의 경계나 구조를 나타냅니다. 이 레슨에서는 이미지 그래디언트 개념과 Sobel, Scharr, Laplacian, Canny 등 다양한 엣지 검출 기법을 학습합니다. --- 1. 이미지 그래디언트 개념 2. Sobel 연산자 3. Scharr 연산자 4. Laplacian 연산자 5. Canny 엣지 검출 6. 그래디언트 크기와 방향 7. 연습 문제 --- --- | 파라미터 | 설명 | |----------|------| | src | 입력 이미지 | | ddepth | 출력 이미지 깊이 (cv2.CV64F 권장) | | dx | x 방향 미분 차수 (0 또는 1) | | dy | y 방향 미분 차수 (0 또는 1) | | ksize | 커널 크기 (1, 3, 5, 7) | | scale | 스케일 팩터 | | delta | 결과에 더할 값 | --- --- | 파라미터 | 설명 |...", "url": "/study/ko/Computer_Vision/08_Edge_Detection.html"}, {"id": "Computer_Vision/09_Contours", "title": "윤곽선 검출 (Contour Detection)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "윤곽선(Contour)은 동일한 색상이나 밝기를 가진 연속적인 점들의 곡선으로, 객체의 형태를 나타냅니다. 이 레슨에서는 findContours()를 사용한 윤곽선 검출, 계층 구조, 근사화, 면적/둘레 계산 등을 학습합니다. --- 1. 윤곽선 기초 2. findContours() 함수 3. 윤곽선 계층 구조 4. 윤곽선 그리기와 근사화 5. 윤곽선 속성 계산 6. 객체 카운팅과 분리 7. 연습 문제 --- --- | 파라미터 | 설명 | |----------|------| | image | 입력 이진 이미지 (8비트 단일 채널) | | mode | 윤곽선 검색 모드 (RETR) | | method | 윤곽선 근사화 방법 (CHAIN) | | contours | 검출된 윤곽선 리스트 | | hierarchy | 윤곽선 계층 구조 | --- --- | 파라미터 | 설명 | |----------|------| | image | 그릴 이미지 | | contours | 윤곽선 리스트 |...", "url": "/study/ko/Computer_Vision/09_Contours.html"}, {"id": "Computer_Vision/10_Shape_Analysis", "title": "도형 분석 (Shape Analysis)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "윤곽선에서 추출한 도형의 특성을 분석하고 분류하는 방법을 학습합니다. 모멘트, 무게중심, 경계 도형, 컨벡스 헐, 형상 매칭 등 다양한 도형 분석 기법을 다룹니다. --- 1. 이미지 모멘트 2. 무게중심 계산 3. 경계 사각형 4. 최소 외접 도형 5. 컨벡스 헐 6. 형상 매칭 7. 도형 분류 시스템 8. 연습 문제 --- --- --- --- --- --- --- --- 이미지에서 검출된 도형들을 면적 기준으로 정렬하고 순위를 표시하세요. <details> <summary>정답 코드</summary> </details> 가로세로 비율이 2:1인 사각형만 검출하세요. <details> <summary>정답 코드</summary> </details> 이미지에서 원형도가 가장 높은 도형을 찾아 표시하세요. <details> <summary>정답 코드</summary> </details> | 난이도 | 주제 | 설명 | |--------|------|------| | ⭐ | 무게중심...", "url": "/study/ko/Computer_Vision/10_Shape_Analysis.html"}, {"id": "Computer_Vision/11_Hough_Transform", "title": "허프 변환 (Hough Transform)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "허프 변환은 이미지에서 직선, 원 등의 기하학적 형태를 검출하는 알고리즘입니다. 엣지 검출 결과에서 특정 모양을 찾는 데 사용되며, 차선 검출, 동전 검출 등 다양한 응용 분야가 있습니다. --- 1. 허프 변환 개념 2. 허프 직선 변환 3. 확률적 허프 직선 변환 4. 허프 원 변환 5. 파라미터 튜닝 전략 6. 차선 검출 기초 7. 연습 문제 --- --- | 파라미터 | 설명 | |----------|------| | image | 입력 이미지 (8비트, 단일 채널, 이진화된 엣지 이미지) | | rho | ρ 해상도 (픽셀 단위, 보통 1) | | theta | θ 해상도 (라디안 단위, 보통 np.pi/180) | | threshold | 직선으로 인정할 최소 투표 수 | | lines | 검출된 직선 [(ρ, θ), ...] | --- | 파라미터 | 설명 | |----------|------| | image | 입력 엣지 이미지 | | rho | ρ 해상도 | |...", "url": "/study/ko/Computer_Vision/11_Hough_Transform.html"}, {"id": "Computer_Vision/12_Histogram_Analysis", "title": "히스토그램 분석 (Histogram Analysis)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "히스토그램은 이미지의 밝기 분포를 나타내는 그래프입니다. 이미지 분석, 대비 향상, 색상 비교 등에 활용됩니다. 이 레슨에서는 히스토그램 계산, 균등화, CLAHE, 비교, 역투영 등을 학습합니다. --- 1. 히스토그램 기초 2. 히스토그램 계산 3. 히스토그램 균등화 4. CLAHE 5. 히스토그램 비교 6. 역투영 7. 연습 문제 --- --- | 파라미터 | 설명 | |----------|------| | images | 입력 이미지 리스트 [img] | | channels | 채널 인덱스 [0], [1], [2] 또는 [0, 1] 등 | | mask | 마스크 (None = 전체 이미지) | | histSize | 빈(bin) 개수 [256] | | ranges | 값 범위 [0, 256] | --- --- --- | 방법 | 설명 | 범위 | 해석 | |------|------|------|------| | cv2.HISTCMPCORREL | 상관관계 | -1 ~ 1 |...", "url": "/study/ko/Computer_Vision/12_Histogram_Analysis.html"}, {"id": "Computer_Vision/13_Feature_Detection", "title": "특징점 검출 (Feature Detection)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "특징점(Feature)은 이미지에서 고유하고 반복적으로 검출 가능한 지점입니다. 코너, 블롭, 엣지 교차점 등이 있으며, 이미지 매칭, 객체 인식, 3D 재구성 등에 활용됩니다. 이 레슨에서는 Harris, FAST, SIFT, ORB 등 다양한 특징점 검출 알고리즘을 학습합니다. --- 1. 특징점 기초 개념 2. 코너 검출 - Harris 3. 좋은 특징점 - goodFeaturesToTrack 4. FAST 검출기 5. SIFT 검출기 6. ORB 검출기 7. 키포인트와 디스크립터 8. 연습 문제 --- --- --- --- --- --- --- --- 이미지에서 가장 강한 50개의 특징점만 선택하세요. <details> <summary>정답 코드</summary> </details> 이미지를 그리드로 나누어 각 셀에서 하나씩 특징점을 선택하세요. <details> <summary>정답 코드</summary> </details> 이미지를 회전시킨 후 동일한 특징점이 검출되는지...", "url": "/study/ko/Computer_Vision/13_Feature_Detection.html"}, {"id": "Computer_Vision/14_Feature_Matching", "title": "특징점 매칭 (Feature Matching)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "특징점 매칭은 두 이미지에서 동일한 특징점을 찾아 연결하는 과정입니다. 객체 인식, 이미지 스티칭, 3D 재구성, 객체 추적 등에 활용됩니다. 이 레슨에서는 BFMatcher, FLANN, 거리 메트릭, Lowe's ratio test, Homography, RANSAC 등을 학습합니다. --- 1. 특징점 매칭 기초 2. BFMatcher 3. FLANN 기반 매처 4. 거리 메트릭 5. 매칭 필터링 6. Homography와 RANSAC 7. 이미지 스티칭 기초 8. 연습 문제 --- --- --- --- --- --- --- --- 다양한 ratio threshold 값을 테스트하여 최적의 값을 찾으세요. <details> <summary>정답 코드</summary> </details> 한 장면에서 같은 객체가 여러 개 있을 때 모두 검출하세요. <details> <summary>정답 코드</summary> </details> 웹캠에서 템플릿 객체를 실시간으로 추적하세요....", "url": "/study/ko/Computer_Vision/14_Feature_Matching.html"}, {"id": "Computer_Vision/15_Object_Detection_Basics", "title": "객체 검출 기초 (Object Detection Basics)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "이미지에서 특정 객체를 찾아내는 객체 검출의 기초 방법들을 학습합니다. 템플릿 매칭, Haar Cascade, HOG+SVM 등 전통적인 객체 검출 기법의 원리와 구현 방법을 익힙니다. 난이도: ⭐⭐⭐ 선수 지식: 이미지 필터링, 엣지 검출, 특징점 검출 --- 1. 템플릿 매칭 (Template Matching) 2. 템플릿 매칭 방법 비교 3. 다중 스케일 템플릿 매칭 4. Haar Cascade 분류기 5. CascadeClassifier 사용법 6. HOG + SVM 보행자 검출 7. 연습 문제 --- --- --- --- --- --- --- 여러 종류의 템플릿을 동시에 매칭하는 프로그램을 작성하세요. 요구사항: - 3개 이상의 서로 다른 템플릿 이미지 사용 - 각 템플릿에 대해 다른 색상으로 검출 결과 표시 - 각 템플릿의 매칭 점수 출력 <details> <summary>힌트</summary> </details> 템플릿을 다양한 각도로 회전시켜 매칭하는 프로그램을...", "url": "/study/ko/Computer_Vision/15_Object_Detection_Basics.html"}, {"id": "Computer_Vision/16_Face_Detection", "title": "얼굴 검출 및 인식 (Face Detection and Recognition)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "얼굴 검출과 인식은 컴퓨터 비전의 가장 실용적인 응용 분야입니다. Haar Cascade, dlib, facerecognition 라이브러리를 활용한 다양한 얼굴 처리 기술을 학습합니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 객체 검출 기초, 특징점 검출, 이미지 변환 --- 1. Haar Cascade 얼굴/눈 검출 2. dlib 얼굴 검출기 (HOG-based) 3. dlib 얼굴 랜드마크 (68 포인트) 4. LBPH 얼굴 인식 5. facerecognition 라이브러리 6. 실시간 얼굴 검출 7. 연습 문제 --- --- --- --- --- --- --- 얼굴 인식 기반 출석 체크 시스템을 구현하세요. 요구사항: - 등록된 사용자 얼굴 DB 관리 - 실시간 웹캠 인식 - 출석 시간 기록 (CSV 또는 DB) - 중복 출석 방지 (일정 시간 내) <details> <summary>힌트</summary> </details> 눈 종횡비(EAR)를 이용한 졸음 감지 시스템을...", "url": "/study/ko/Computer_Vision/16_Face_Detection.html"}, {"id": "Computer_Vision/17_Video_Processing", "title": "비디오 처리 (Video Processing)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "비디오는 연속된 이미지 프레임의 시퀀스입니다. OpenCV를 사용하여 비디오 파일과 카메라 스트림을 처리하고, 배경 차분과 옵티컬 플로우를 이용한 동작 분석 방법을 학습합니다. 난이도: ⭐⭐⭐ 선수 지식: 이미지 기초 연산, 필터링, 객체 검출 --- 1. VideoCapture: 파일과 카메라 2. VideoWriter: 비디오 저장 3. 프레임 단위 처리 4. FPS 계산 5. 배경 차분 (MOG2, KNN) 6. 옵티컬 플로우 7. 객체 추적 8. 연습 문제 --- --- --- --- --- --- --- --- 기본적인 비디오 플레이어를 구현하세요. 요구사항: - 재생/일시정지 토글 (스페이스바) - 앞으로/뒤로 건너뛰기 (방향키) - 프레임 단위 이동 (./,) - 현재 시간/총 시간 표시 - 프로그레스 바 <details> <summary>힌트</summary> </details> 비디오에서 움직임이 많은 영역을 히트맵으로 시각화하세요. 요구사항: - 배경 차분으로...", "url": "/study/ko/Computer_Vision/17_Video_Processing.html"}, {"id": "Computer_Vision/18_Camera_Calibration", "title": "카메라 캘리브레이션 (Camera Calibration)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "카메라 캘리브레이션은 카메라의 내부 파라미터와 렌즈 왜곡을 측정하는 과정입니다. 정확한 3D 복원, 증강현실, 로봇 비전 등에서 필수적인 단계입니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 기하학적 변환, 선형대수 기초, 이미지 좌표계 --- 1. 카메라 내부 파라미터 2. 렌즈 왜곡 3. findChessboardCorners() 4. calibrateCamera() 5. undistort(): 왜곡 보정 6. 재투영 오차 7. 연습 문제 --- --- --- --- --- --- --- 웹캠에서 자동으로 캘리브레이션 이미지를 수집하는 프로그램을 작성하세요. 요구사항: - 체스보드 검출 시 자동 캡처 (일정 시간 간격) - 다양한 각도/위치에서 캡처되도록 안내 - 수집된 이미지 품질 확인 (블러 제거) - 최소 15-20장 수집 <details> <summary>힌트</summary> </details> 어안 (fisheye) 렌즈 카메라를 캘리브레이션하세요. 요구사항: -...", "url": "/study/ko/Computer_Vision/18_Camera_Calibration.html"}, {"id": "Computer_Vision/19_DNN_Module", "title": "딥러닝 DNN 모듈 (Deep Neural Network Module)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "OpenCV의 DNN 모듈은 사전 학습된 딥러닝 모델을 로드하고 추론하는 기능을 제공합니다. TensorFlow, Caffe, Darknet, ONNX 등 다양한 프레임워크의 모델을 지원하며, CPU와 GPU에서 효율적으로 실행할 수 있습니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 딥러닝 기초 개념, 객체 검출, 이미지 분류 --- 1. cv2.dnn 모듈 개요 2. readNet(): 모델 로딩 3. blobFromImage(): 전처리 4. YOLO 객체 검출 5. SSD (Single Shot Detector) 6. DNN 얼굴 검출 7. ONNX를 이용한 최신 객체 검출 8. 연습 문제 --- --- --- --- --- --- --- Ultralytics에서 2023년에 출시한 YOLOv8은 YOLO 계열의 큰 진전을 나타냅니다. ONNX 형식으로 내보내서 OpenCV의 DNN 모듈로 효율적으로 실행할 수 있습니다. Meta의 Segment Anything Model (SAM)은...", "url": "/study/ko/Computer_Vision/19_DNN_Module.html"}, {"id": "Computer_Vision/20_Practical_Projects", "title": "실전 프로젝트 (Practical Projects)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "지금까지 학습한 OpenCV 기술들을 종합하여 실제 응용 프로젝트를 구현합니다. 각 프로젝트는 여러 기술을 조합하여 완성된 애플리케이션을 만드는 과정을 단계별로 안내합니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 이전 모든 챕터의 내용 --- 1. 프로젝트 1: 문서 스캐너 2. 프로젝트 2: 차선 검출 3. 프로젝트 3: AR 마커 검출 4. 프로젝트 4: 실시간 얼굴 필터 5. 프로젝트 5: 객체 추적 시스템 6. 연습 문제 및 확장 아이디어 --- --- --- --- --- --- 1. OCR 통합: Tesseract OCR을 연동하여 텍스트 추출 2. 자동 색상 보정: 히스토그램 평활화로 문서 가독성 향상 3. 다중 페이지 지원: 연속 촬영으로 PDF 생성 4. 손글씨 인식: 손으로 쓴 문서의 디지털화 5. 영수증 파싱: 금액, 날짜 등 자동 추출 1. 곡선 차선 검출: 2차/3차 다항식 피팅 2. 차선 이탈 경고: 차량 중심과 차선 중심 비교 3. 야간 모드: 조명 조건에 따른...", "url": "/study/ko/Computer_Vision/20_Practical_Projects.html"}, {"id": "Computer_Vision/21_3D_Vision_Basics", "title": "3D 비전 기초 (3D Vision Basics)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "3D 비전은 2D 이미지로부터 3차원 정보를 추출하고 복원하는 기술입니다. 스테레오 비전, 깊이 맵, 포인트 클라우드 처리, 3D 재구성의 기초를 다룹니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 카메라 캘리브레이션, 특징점 검출/매칭, 선형대수 --- 1. 3D 비전 개요 2. 스테레오 비전 원리 3. 깊이 맵 생성 4. 포인트 클라우드 5. Open3D 기초 6. 3D 재구성 7. 연습 문제 --- --- --- --- --- --- --- 스테레오 이미지 쌍에서 깊이 맵을 생성하세요. 요구사항: - StereoBM과 StereoSGBM 비교 - 시차 맵 시각화 - 깊이 맵으로 변환 - 품질 개선 (필터링) <details> <summary>힌트</summary> </details> 노이즈가 있는 포인트 클라우드를 정제하세요. 요구사항: - 통계적 이상치 제거 - 복셀 다운샘플링 - 평면 영역 추출 - 결과 시각화 <details> <summary>힌트</summary>...", "url": "/study/ko/Computer_Vision/21_3D_Vision_Basics.html"}, {"id": "Computer_Vision/22_Depth_Estimation", "title": "단안 깊이 추정 (Monocular Depth Estimation)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "단안 깊이 추정은 단일 2D 이미지에서 픽셀별 깊이 정보를 추정하는 기술입니다. MiDaS, DPT 같은 딥러닝 모델과 Structure from Motion (SfM)을 통한 기하학적 접근 방법을 다룹니다. 난이도: ⭐⭐⭐⭐ 선수 지식: DNN 모듈, 특징점 검출/매칭, 카메라 캘리브레이션 --- 1. 단안 깊이 추정 개요 2. MiDaS 모델 3. DPT (Dense Prediction Transformer) 4. Structure from Motion (SfM) 5. 깊이 맵 응용 6. 연습 문제 --- --- --- --- --- --- MiDaS를 사용하여 이미지의 깊이를 추정하세요. 요구사항: - 모델 로드 및 추론 - 깊이 맵 시각화 (컬러맵) - 여러 이미지에 대해 테스트 <details> <summary>힌트</summary> </details> 인물 사진에서 배경만 블러 처리하세요. 요구사항: - 깊이 추정 - 전경/배경 분리 - 배경에만 블러 적용 - 자연스러운...", "url": "/study/ko/Computer_Vision/22_Depth_Estimation.html"}, {"id": "Computer_Vision/23_SLAM_Introduction", "title": "SLAM 입문 (Visual SLAM Introduction)", "topic": "Computer_Vision", "topic_display": "Computer Vision", "body": "SLAM (Simultaneous Localization and Mapping)은 로봇이나 자율주행 시스템이 미지의 환경에서 지도를 작성하면서 동시에 자신의 위치를 추정하는 기술입니다. Visual SLAM, LiDAR SLAM, Loop Closure의 기초를 다룹니다. 난이도: ⭐⭐⭐⭐ 선수 지식: 3D 비전, 특징점 검출/매칭, 카메라 캘리브레이션, 기본 확률론 --- 1. SLAM 개요 2. Visual Odometry 3. ORB-SLAM 4. LiDAR SLAM 5. Loop Closure 6. SLAM 구현 실습 7. 연습 문제 --- --- --- --- --- --- --- 단안 Visual Odometry를 구현하세요. 요구사항: - ORB 특징 검출 - 광학 흐름 또는 디스크립터 매칭 - Essential Matrix로 포즈 추정 - 궤적 시각화 <details> <summary>힌트</summary> </details> BoW 기반 루프 클로저를 구현하세요....", "url": "/study/ko/Computer_Vision/23_SLAM_Introduction.html"}, {"id": "Data_Engineering/00_Overview", "title": "데이터 엔지니어링 (Data Engineering) 학습 가이드", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "데이터 엔지니어링은 데이터를 수집, 저장, 변환, 전달하는 시스템을 설계하고 구축하는 분야입니다. 데이터 파이프라인을 통해 원시 데이터를 분석 가능한 형태로 변환하여 데이터 분석가와 과학자가 활용할 수 있도록 합니다. 대상 독자: 데이터 파이프라인 입문자 ~ 중급자 (실무 기초) --- --- | 파일명 | 주제 | 난이도 | 핵심 내용 | |--------|------|--------|----------| | 01DataEngineeringOverview.md | 데이터 엔지니어링 개요 | ⭐ | 역할, 파이프라인, 배치 vs 스트리밍, 아키텍처 패턴 | | 02DataModelingBasics.md | 데이터 모델링 기초 | ⭐⭐ | 차원 모델링, 스타/스노우플레이크 스키마, SCD | | 03ETLvsELT.md | ETL vs ELT | ⭐⭐ | 전통 ETL, 모던 ELT, 도구 비교, 사용 사례 | | 04ApacheAirflowBasics.md | Airflow 기초 |...", "url": "/study/ko/Data_Engineering/00_Overview.html"}, {"id": "Data_Engineering/01_Data_Engineering_Overview", "title": "데이터 엔지니어링 개요", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "데이터 엔지니어링은 조직의 데이터를 수집, 저장, 처리, 전달하는 시스템을 설계하고 구축하는 분야입니다. 데이터 엔지니어는 데이터 파이프라인을 구축하여 원시 데이터를 분석 가능한 형태로 변환합니다. --- | 역할 | 주요 업무 | 필요 기술 | |------|----------|----------| | 데이터 엔지니어 | 파이프라인 구축, 인프라 관리 | Python, SQL, Spark, Airflow, Kafka | | 데이터 과학자 | 모델 개발, 예측 분석 | Python, ML/DL, 통계, 수학 | | 데이터 분석가 | 비즈니스 인사이트 도출 | SQL, BI 도구, 시각화, 통계 | --- 데이터 파이프라인은 데이터를 소스에서 목적지까지 이동시키는 일련의 처리 단계입니다. | 유형 | 설명 | 사용 사례 | |------|------|----------| | 배치 (Batch) | 정해진 시간에 대량 데이터 처리 | 일일 보고서, 월간 집계 | | 스트리밍...", "url": "/study/ko/Data_Engineering/01_Data_Engineering_Overview.html"}, {"id": "Data_Engineering/02_Data_Modeling_Basics", "title": "데이터 모델링 기초", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "데이터 모델링은 데이터의 구조, 관계, 제약 조건을 정의하는 과정입니다. 데이터 웨어하우스와 분석 시스템에서는 차원 모델링(Dimensional Modeling)이 널리 사용됩니다. --- 차원 모델링은 비즈니스 프로세스를 팩트(Fact)와 디멘전(Dimension)으로 분리하여 모델링하는 기법입니다. | 구분 | 팩트 테이블 | 디멘전 테이블 | |------|------------|--------------| | 내용 | 측정 가능한 수치 데이터 | 설명적 속성 데이터 | | 예시 | 판매금액, 수량, 이익 | 고객명, 상품명, 날짜 | | 레코드 수 | 매우 많음 (수억 건) | 상대적으로 적음 | | 변경 빈도 | 계속 추가됨 | 가끔 변경됨 | | 분석 역할 | 집계 대상 | 필터/그룹 기준 | --- 스타 스키마는 중앙에 팩트 테이블이 있고, 주변에 디멘전 테이블이 연결된 형태입니다. --- 디멘전 테이블을 정규화하여 중복을 제거한 형태입니다. | 특성 | 스타 스키마...", "url": "/study/ko/Data_Engineering/02_Data_Modeling_Basics.html"}, {"id": "Data_Engineering/03_ETL_vs_ELT", "title": "ETL vs ELT", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "ETL(Extract, Transform, Load)과 ELT(Extract, Load, Transform)는 데이터 파이프라인의 두 가지 주요 패턴입니다. 전통적인 ETL은 변환 후 적재하고, 모던 ELT는 적재 후 변환합니다. --- | 도구 | 유형 | 특징 | |------|------|------| | Informatica | 상용 | 엔터프라이즈급, GUI 기반 | | Talend | 오픈소스/상용 | Java 기반, 다양한 커넥터 | | SSIS | 상용 (MS) | SQL Server 통합 | | Pentaho | 오픈소스 | 경량, 사용 편의 | | Apache NiFi | 오픈소스 | 데이터 플로우, 실시간 | --- | 도구 | 유형 | 특징 | |------|------|------| | dbt | 오픈소스 | SQL 기반 변환, 테스트, 문서화 | | Fivetran | 상용 | 자동 스키마 관리, 150+ 커넥터 | | Airbyte | 오픈소스 | 커스텀...", "url": "/study/ko/Data_Engineering/03_ETL_vs_ELT.html"}, {"id": "Data_Engineering/04_Apache_Airflow_Basics", "title": "Apache Airflow 기초", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "Apache Airflow는 워크플로우를 프로그래밍 방식으로 작성, 스케줄링, 모니터링하는 플랫폼입니다. Python으로 DAG(Directed Acyclic Graph)를 정의하여 복잡한 데이터 파이프라인을 관리합니다. --- | 구성 요소 | 역할 | |-----------|------| | Web Server | UI 제공, DAG 시각화, 로그 조회 | | Scheduler | DAG 파싱, Task 스케줄링, 실행 트리거 | | Executor | Task 실행 방식 결정 (Local, Celery, K8s) | | Worker | 실제 Task 실행 (Celery/K8s Executor) | | Metadata DB | DAG 메타데이터, 실행 이력 저장 | --- --- --- --- --- --- --- 매시간 실행되는 DAG를 작성하세요. 현재 시간을 로그에 출력하고, 임시 파일을 생성하는 두 개의 Task를 포함해야 합니다. 평일과 주말에 다른 Task를 실행하는...", "url": "/study/ko/Data_Engineering/04_Apache_Airflow_Basics.html"}, {"id": "Data_Engineering/05_Airflow_Advanced", "title": "Airflow 심화", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "이 문서에서는 Airflow의 고급 기능인 XCom을 통한 데이터 공유, 동적 DAG 생성, Sensor, Hook, TaskGroup 등을 다룹니다. 이러한 기능을 활용하면 더 유연하고 강력한 파이프라인을 구축할 수 있습니다. --- XCom은 Task 간에 작은 데이터를 공유하는 메커니즘입니다. --- --- --- --- --- --- 두 개의 Task에서 각각 숫자를 반환하고, 세 번째 Task에서 두 숫자의 합을 계산하는 DAG를 작성하세요. 테이블 목록(users, orders, products)을 기반으로 각 테이블에 대한 ETL Task를 동적으로 생성하는 DAG를 작성하세요. 파일이 생성될 때까지 대기한 후 처리하는 DAG를 작성하세요. --- | 기능 | 설명 | |------|------| | XCom | Task 간 데이터 공유 메커니즘 | | 동적 DAG | 설정 기반으로 DAG/Task 동적 생성 | | Sensor | 조건 충족까지 대기하는...", "url": "/study/ko/Data_Engineering/05_Airflow_Advanced.html"}, {"id": "Data_Engineering/06_Prefect_Modern_Orchestration", "title": "Prefect 모던 오케스트레이션", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "Prefect는 현대적인 워크플로우 오케스트레이션 도구로, Python 네이티브 방식으로 데이터 파이프라인을 구축합니다. Airflow와 비교하여 더 간단한 설정과 동적 워크플로우를 지원합니다. --- | 특성 | Airflow | Prefect | |------|---------|---------| | 정의 방식 | DAG 파일 | Python 데코레이터 | | 스케줄링 | Scheduler 프로세스 | 이벤트 기반, 서버리스 | | 동적 워크플로우 | 제한적 | 네이티브 지원 | | 로컬 실행 | 복잡한 설정 | 즉시 가능 | | 상태 관리 | DB 필수 | 선택적 | | 학습 곡선 | 가파름 | 완만함 | --- --- --- --- --- --- --- 3개의 Task(데이터 추출, 변환, 적재)로 구성된 ETL Flow를 작성하세요. 파일 목록을 입력받아 각 파일을 병렬로 처리하는 Flow를 작성하세요. 데이터 크기에 따라 다른 처리 방식을 선택하는 Flow를 작성하세요....", "url": "/study/ko/Data_Engineering/06_Prefect_Modern_Orchestration.html"}, {"id": "Data_Engineering/07_Apache_Spark_Basics", "title": "Apache Spark 기초", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "Apache Spark는 대규모 데이터 처리를 위한 통합 분석 엔진입니다. 인메모리 처리로 Hadoop MapReduce보다 빠른 성능을 제공하며, 배치 처리와 스트리밍을 모두 지원합니다. --- --- | 개념 | 설명 | |------|------| | Driver | 메인 프로그램 실행, SparkContext 생성 | | Executor | Worker 노드에서 Task 실행 | | Task | 실행의 기본 단위 | | Job | Action에 의해 생성되는 병렬 계산 | | Stage | Job 내의 Task 그룹 (Shuffle 경계) | | Partition | 데이터의 논리적 분할 단위 | --- RDD는 Spark의 기본 데이터 구조로, 분산된 불변 데이터 컬렉션입니다. --- --- --- --- 1부터 100까지의 숫자 중 짝수만 선택하여 제곱의 합을 구하세요. 로그 파일에서 에러 수준별 로그 수를 집계하세요. --- | 개념 | 설명 |...", "url": "/study/ko/Data_Engineering/07_Apache_Spark_Basics.html"}, {"id": "Data_Engineering/08_PySpark_DataFrames", "title": "PySpark DataFrame", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "Spark DataFrame은 분산된 데이터를 테이블 형태로 표현하는 고수준 API입니다. SQL과 유사한 연산을 제공하며, Catalyst 옵티마이저를 통해 자동으로 최적화됩니다. --- --- --- --- --- --- --- 판매 데이터에서 월별, 카테고리별 총 매출과 평균 매출을 계산하세요. 각 부서별로 급여 순위를 매기고, 부서 내 급여 상위 3명을 추출하세요. 이메일 주소에서 도메인을 추출하는 UDF를 작성하고 적용하세요. --- | 연산 | 설명 | 예시 | |------|------|------| | select | 컬럼 선택 | | | filter | 행 필터링 | | | groupBy | 그룹화 | | | join | 테이블 조인 | | | orderBy | 정렬 | | | withColumn | 컬럼 추가/수정 | | --- - PySpark DataFrame Guide - PySpark Functions", "url": "/study/ko/Data_Engineering/08_PySpark_DataFrames.html"}, {"id": "Data_Engineering/09_Spark_SQL_Optimization", "title": "Spark SQL 최적화", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "Spark SQL의 성능을 최적화하기 위해서는 Catalyst 옵티마이저의 동작 원리를 이해하고, 파티셔닝, 캐싱, 조인 전략 등을 적절히 활용해야 합니다. --- --- --- --- --- --- --- --- 주어진 쿼리의 실행 계획을 분석하고 최적화 포인트를 찾으세요. 1억 건의 트랜잭션 테이블과 100만 건의 고객 테이블을 조인하는 최적의 방법을 설계하세요. 특정 카테고리에 데이터가 집중된 상황에서 집계 성능을 개선하세요. --- | 최적화 영역 | 기법 | |-------------|------| | Catalyst | Predicate Pushdown, Column Pruning | | 파티셔닝 | repartition, coalesce, partitionBy | | 캐싱 | cache, persist, StorageLevel | | 조인 | Broadcast, Sort Merge, 버킷팅 | | AQE | 자동 파티션 병합, 스큐 처리 | --- - Spark SQL...", "url": "/study/ko/Data_Engineering/09_Spark_SQL_Optimization.html"}, {"id": "Data_Engineering/10_Kafka_Streaming", "title": "Kafka 스트리밍", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "Apache Kafka는 분산 이벤트 스트리밍 플랫폼으로, 실시간 데이터 파이프라인과 스트리밍 애플리케이션 구축에 사용됩니다. 높은 처리량과 내결함성을 제공합니다. --- | 개념 | 설명 | |------|------| | Broker | Kafka 서버, 메시지 저장/전달 | | Topic | 메시지 카테고리 (논리적 채널) | | Partition | Topic의 물리적 분할, 병렬 처리 | | Producer | 메시지 발행자 | | Consumer | 메시지 소비자 | | Consumer Group | 협력하여 소비하는 Consumer 그룹 | | Offset | 파티션 내 메시지 위치 | | Replication | 파티션 복제로 내결함성 확보 | --- --- --- --- --- --- --- --- 주문 이벤트를 생성하는 Producer와 소비하는 Consumer를 작성하세요. 3개의 Consumer로 구성된 Consumer Group을 만들고 파티션 할당을...", "url": "/study/ko/Data_Engineering/10_Kafka_Streaming.html"}, {"id": "Data_Engineering/11_Data_Lake_Warehouse", "title": "Data Lake와 Data Warehouse", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "데이터 저장소 아키텍처는 조직의 데이터 전략에 핵심적입니다. Data Lake, Data Warehouse, 그리고 둘을 결합한 Lakehouse 아키텍처의 특성과 사용 사례를 이해합니다. --- | 솔루션 | 유형 | 특징 | |--------|------|------| | Snowflake | 클라우드 | 분리된 스토리지/컴퓨팅, 자동 확장 | | BigQuery | 클라우드 (GCP) | 서버리스, 페타바이트 규모 | | Redshift | 클라우드 (AWS) | Columnar, MPP 아키텍처 | | Synapse | 클라우드 (Azure) | 통합 분석 플랫폼 | | PostgreSQL | 온프레미스 | 소규모, 오픈소스 | --- | 스토리지 | 클라우드 | 특징 | |----------|----------|------| | S3 | AWS | 객체 스토리지, 높은 내구성 | | GCS | GCP | Google Cloud Storage | | ADLS | Azure...", "url": "/study/ko/Data_Engineering/11_Data_Lake_Warehouse.html"}, {"id": "Data_Engineering/12_dbt_Transformation", "title": "dbt 변환 도구", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "dbt(data build tool)는 SQL 기반의 데이터 변환 도구입니다. ELT 패턴에서 Transform 단계를 담당하며, 소프트웨어 엔지니어링 모범 사례(버전 관리, 테스트, 문서화)를 데이터 변환에 적용합니다. --- | 특성 | dbt Core | dbt Cloud | |------|----------|-----------| | 비용 | 무료 (오픈소스) | 유료 (SaaS) | | 실행 | CLI | Web UI + API | | 스케줄링 | 외부 도구 필요 (Airflow) | 내장 스케줄러 | | IDE | VS Code 등 | 내장 IDE | | 협업 | Git 사용 | 내장 협업 기능 | --- --- --- --- --- --- --- --- 원본 products 테이블에서 stgproducts 모델을 생성하세요. 가격을 달러로 변환하고 NULL 값을 처리하세요. 일별 판매 집계 테이블을 증분으로 처리하는 모델을 작성하세요. fctsales 모델에 대한...", "url": "/study/ko/Data_Engineering/12_dbt_Transformation.html"}, {"id": "Data_Engineering/13_Data_Quality_Governance", "title": "데이터 품질과 거버넌스", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "데이터 품질은 데이터의 정확성, 완전성, 일관성을 보장하는 것이고, 데이터 거버넌스는 데이터 자산을 체계적으로 관리하는 프레임워크입니다. 신뢰할 수 있는 데이터 파이프라인을 위해 필수적입니다. --- --- --- --- | 도구 | 유형 | 특징 | |------|------|------| | DataHub | 오픈소스 | LinkedIn 개발, 범용 | | Apache Atlas | 오픈소스 | Hadoop 생태계 | | Amundsen | 오픈소스 | Lyft 개발, 검색 중심 | | OpenMetadata | 오픈소스 | 올인원 플랫폼 | | Atlan | 상용 | 협업 중심 | | Alation | 상용 | 엔터프라이즈 | --- --- --- 주문 데이터에 대한 Expectation Suite를 작성하세요 (NULL 체크, 유니크, 값 범위, 참조 무결성). 일별 데이터 품질 점수를 계산하고 시각화하는 파이프라인을 설계하세요. ETL 파이프라인의 리니지를 자동으로...", "url": "/study/ko/Data_Engineering/13_Data_Quality_Governance.html"}, {"id": "Data_Engineering/14_Practical_Pipeline_Project", "title": "실전 파이프라인 프로젝트", "topic": "Data_Engineering", "topic_display": "Data Engineering", "body": "이 레슨에서는 지금까지 배운 모든 기술을 통합하여 실제 데이터 파이프라인을 구축합니다. Airflow로 오케스트레이션, Spark로 대규모 처리, dbt로 변환, Great Expectations로 품질 검증을 수행하는 E2E 파이프라인을 설계합니다. --- --- --- --- --- --- --- --- --- 실시간 재고 이벤트를 Kafka에서 처리하여 재고 부족 알림을 보내는 스트리밍 파이프라인을 추가하세요. 일별 데이터 품질 점수를 Grafana 대시보드로 시각화하세요. 대용량 데이터 처리 시 Spark 파티션 수와 리소스 설정을 최적화하세요. --- 이 프로젝트에서 다룬 핵심 통합: | 도구 | 역할 | |------|------| | Airflow | 파이프라인 오케스트레이션 | | Spark | 대규모 데이터 처리 | | dbt | SQL 기반 변환 | | Great Expectations | 데이터 품질 검증 | | Data Lake | 계층화된 스토리지 | ---...", "url": "/study/ko/Data_Engineering/14_Practical_Pipeline_Project.html"}, {"id": "Data_Science/00_Overview", "title": "데이터 과학 학습 가이드", "topic": "Data_Science", "topic_display": "Data Science", "body": "데이터 과학 학습 가이드에 오신 것을 환영합니다! 이 포괄적인 주제는 현대 데이터 분석을 위한 필수 도구와 통계 방법을 다룹니다. 업계 표준 Python 라이브러리를 사용하여 데이터를 조작하고, 시각화하고, 의미 있는 결론을 도출하는 방법을 배우게 됩니다. 데이터 과학은 다음을 결합합니다: - 데이터 조작 도구 (NumPy, Pandas) - 구조화된 데이터 처리 - 시각화 기법 (Matplotlib, Seaborn) - 패턴 탐색 - 통계적 추론 (scipy, statsmodels) - 타당한 결론 도출 - 실전 응용 - 실습 프로젝트를 통한 적용 이 주제는 기본 데이터 조작에서 탐색적 자료 분석(EDA)을 거쳐 엄격한 통계적 추론과 고급 모델링 기법까지 안내하도록 설계되었습니다. --- 25개의 강의는 구조화된 진행을 따릅니다: 데이터 조작과 전처리를 위한 기본 라이브러리를 숙달합니다. 데이터 패턴을 시각화하고, 요약하고, 탐색하는 방법을 배웁니다. 중요한 전환: 언제 그리고...", "url": "/study/ko/Data_Science/00_Overview.html"}, {"id": "Data_Science/01_NumPy_Basics", "title": "1. NumPy 기초", "topic": "Data_Science", "topic_display": "Data Science", "body": "다음: NumPy 고급 NumPy(Numerical Python)는 Python에서 수치 계산을 위한 핵심 라이브러리입니다. 다차원 배열 객체와 배열 연산을 위한 다양한 함수를 제공합니다. --- --- --- --- --- --- 브로드캐스팅은 크기가 다른 배열 간의 연산을 가능하게 하는 NumPy의 핵심 기능입니다. 1. 두 배열의 차원 수가 다르면, 작은 배열의 shape 앞에 1을 추가 2. 각 차원에서 크기가 1인 배열은 다른 배열의 크기에 맞춰 확장 3. 크기가 1이 아니고 서로 다르면 오류 발생 --- --- --- 1부터 100까지의 정수 중 3의 배수만 포함하는 배열을 생성하세요. 3x3 단위 행렬의 대각선 요소의 합을 구하세요. 4x4 행렬에서 각 열의 최댓값으로 정규화하세요 (각 요소를 해당 열의 최댓값으로 나누기). --- | 기능 | 함수/메서드 | |------|------------| | 배열 생성 | , , , , | | 배열 속성 | , , , | |...", "url": "/study/ko/Data_Science/01_NumPy_Basics.html"}, {"id": "Data_Science/02_NumPy_Advanced", "title": "2. NumPy 고급", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: NumPy 기초 | 다음: Pandas 기초 NumPy의 고급 기능인 선형대수, 통계 함수, 난수 생성, 구조화된 배열, 그리고 성능 최적화 기법을 다룹니다. --- --- --- --- --- --- --- --- 대용량 파일을 메모리에 전부 로딩하지 않고 처리할 때 유용합니다. --- 다음 데이터에 대해 최소 자승법으로 선형 회귀 계수를 구하세요. 3개의 변수를 가진 데이터의 공분산 행렬을 구하고 고유값 분해하세요. 난수를 이용해 원의 넓이(π)를 추정하세요. --- | 기능 | 함수/메서드 | |------|------------| | 행렬 곱셈 | , , | | 선형대수 | , , , | | 통계 | , , , | | 난수 | , , , | | 저장/로딩 | , , , | | 성능 | 벡터화 연산, , 메모리 매핑 |", "url": "/study/ko/Data_Science/02_NumPy_Advanced.html"}, {"id": "Data_Science/03_Pandas_Basics", "title": "3. Pandas 기초", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: NumPy 고급 | 다음: Pandas 데이터 조작 Pandas는 Python에서 데이터 분석을 위한 핵심 라이브러리입니다. 테이블 형태의 데이터를 효율적으로 다루기 위한 DataFrame과 Series 자료구조를 제공합니다. --- Series는 1차원 레이블이 있는 배열입니다. DataFrame은 2차원 테이블 형태의 자료구조입니다. --- --- --- --- --- --- Pandas는 접근자를 통해 문자열 메서드를 제공합니다. --- 다음 데이터를 DataFrame으로 생성하고 기본 정보를 확인하세요. price가 1000 이상인 제품의 이름과 수량만 선택하세요. 총 금액(price * quantity) 열을 추가하세요. --- | 기능 | 함수/메서드 | |------|------------| | 데이터 로딩 | , , , | | 데이터 저장 | , , , | | 열 선택 | , | | 행 선택 | , , | | 데이터 확인 | , , , | | 집계 | , ,...", "url": "/study/ko/Data_Science/03_Pandas_Basics.html"}, {"id": "Data_Science/04_Pandas_Data_Manipulation", "title": "4. Pandas 데이터 조작", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: Pandas 기초 | 다음: Pandas 고급 Pandas의 핵심 데이터 조작 기법인 필터링, 정렬, 그룹화, 병합에 대해 다룹니다. 이 기법들은 실무 데이터 분석에서 가장 많이 사용됩니다. --- --- --- --- --- --- --- --- 부서별 평균 급여와 직원 수를 구하세요. 두 DataFrame을 조인하여 직원의 부서명을 포함하세요. 월별, 카테고리별 매출 합계를 피벗 테이블로 만드세요. --- | 기능 | 함수/메서드 | |------|------------| | 필터링 | , , | | 정렬 | , , | | 그룹화 | , , , | | 병합 | , , | | 피벗 | , , , , | | 중복 | , | | 교차표 | |", "url": "/study/ko/Data_Science/04_Pandas_Data_Manipulation.html"}, {"id": "Data_Science/05_Pandas_Advanced", "title": "5. Pandas 고급", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: Pandas 데이터 조작 | 다음: 데이터 전처리 Pandas의 고급 기능인 피벗테이블, 멀티인덱스, 시계열 데이터 처리, 그리고 성능 최적화 기법을 다룹니다. --- --- --- --- --- --- --- 연도별, 분기별 매출 데이터에서 2023년 데이터만 선택하세요. 일별 데이터를 주간 평균으로 리샘플링하세요. 7일 이동 평균을 계산하고 원본과 함께 표시하세요. --- | 기능 | 함수/메서드 | |------|------------| | 멀티인덱스 | , , , , | | 시계열 | , , , , | | 범주형 | , , 접근자 | | 문자열 | 접근자, 정규표현식, , | | 성능 | 벡터화 연산, , , 청크 처리 | | 파이프라인 | , 메서드 체이닝 |", "url": "/study/ko/Data_Science/05_Pandas_Advanced.html"}, {"id": "Data_Science/06_Data_Preprocessing", "title": "6. 데이터 전처리", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: Pandas 고급 | 다음: 기술통계와 EDA 데이터 전처리는 분석이나 모델링 전에 데이터를 정제하고 변환하는 과정입니다. 결측치 처리, 이상치 탐지, 정규화, 인코딩 등 핵심 기법을 다룹니다. --- --- --- --- --- --- --- --- --- 다음 데이터의 결측치를 적절히 처리하세요. IQR 방법으로 이상치를 찾고 제거하세요. 범주형 변수를 원-핫 인코딩하세요. --- | 기능 | 방법 | |------|------| | 결측치 확인 | , | | 결측치 처리 | , , | | 이상치 탐지 | IQR, Z-score, 박스플롯 | | 정규화/표준화 | , , | | 범주형 인코딩 | , , | | 수치형 변환 | 로그 변환, Box-Cox, 구간화 | | 날짜 처리 | , 접근자 |", "url": "/study/ko/Data_Science/06_Data_Preprocessing.html"}, {"id": "Data_Science/07_Descriptive_Stats_EDA", "title": "7. 기술통계와 EDA (탐색적 데이터 분석)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 데이터 전처리 | 다음: 데이터 시각화 기초 기술통계는 데이터의 특성을 요약하고, EDA(Exploratory Data Analysis)는 데이터를 시각화하고 탐색하여 패턴과 인사이트를 발견하는 과정입니다. --- --- --- --- --- --- --- --- 다음 데이터의 5수 요약을 구하세요. 두 변수 간의 상관계수를 구하고 해석하세요. 그룹별 평균과 표준편차를 구하세요. --- | 측도 유형 | 측도 | 함수 | |----------|------|------| | 중심 경향 | 평균, 중앙값, 최빈값 | , , | | 산포 | 분산, 표준편차, IQR | , , | | 분포 형태 | 왜도, 첨도 | , | | 관계 | 상관계수, 공분산 | , | | 요약 | 기술통계 | |", "url": "/study/ko/Data_Science/07_Descriptive_Stats_EDA.html"}, {"id": "Data_Science/08_Data_Visualization_Basics", "title": "8. 데이터 시각화 기초 (Matplotlib)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 기술통계와 EDA | 다음: 데이터 시각화 고급 Matplotlib은 Python의 대표적인 시각화 라이브러리입니다. 다양한 차트 유형과 커스터마이징 방법을 다룹니다. --- --- --- --- --- --- --- --- --- --- --- | 차트 유형 | 함수 | 용도 | |----------|------|------| | 선 그래프 | | 시계열, 연속 데이터 | | 막대 그래프 | , | 범주형 비교 | | 히스토그램 | | 분포 확인 | | 산점도 | | 두 변수 관계 | | 파이 차트 | | 비율, 구성 | | 박스 플롯 | | 분포, 이상치 | | 히트맵 | | 행렬 데이터 | | 커스터마이징 | 메서드 | |-------------|--------| | 제목/레이블 | , , | | 범위 | , | | 눈금 | , | | 범례 | | | 그리드 | | | 저장 | |", "url": "/study/ko/Data_Science/08_Data_Visualization_Basics.html"}, {"id": "Data_Science/09_Data_Visualization_Advanced", "title": "9. 데이터 시각화 고급 (Seaborn)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 데이터 시각화 기초 | 다음: EDA에서 추론으로 Seaborn은 Matplotlib을 기반으로 한 통계적 데이터 시각화 라이브러리입니다. 보다 아름다운 기본 스타일과 통계적 그래프를 쉽게 만들 수 있습니다. --- --- --- --- --- --- --- --- --- --- --- | 플롯 유형 | Seaborn 함수 | 용도 | |----------|-------------|------| | 분포 | , , | 단일 변수 분포 | | 범주형 | , , , | 범주별 비교 | | 관계 | , , | 변수 간 관계 | | 결합 | , | 다변량 분석 | | 히트맵 | , | 행렬 데이터 | | 다중 플롯 | , , | 조건별 서브플롯 |", "url": "/study/ko/Data_Science/09_Data_Visualization_Advanced.html"}, {"id": "Data_Science/10_From_EDA_to_Inference", "title": "탐색적 자료 분석에서 통계적 추론으로", "topic": "Data_Science", "topic_display": "Data Science", "body": "- 기술통계와 탐색적 자료 분석(EDA)의 한계 이해하기 - 모집단과 표본의 차이를 구별하고 추론의 필요성 파악하기 - 다양한 통계적 질문 유형 인식하기 (추정, 검정, 예측) - 데이터 유형과 연구 질문에 따라 적절한 통계 방법을 선택하는 법 배우기 - EDA 결과를 정식 통계 검정과 연결하기 - 통계적 추론에서 흔한 함정 피하기 - 탐색적 분석에서 확증적 분석으로 전환하기 난이도: ⭐⭐ (중급) --- 이전 강의에서 우리는 탐색적 자료 분석(Exploratory Data Analysis, EDA)을 위한 강력한 도구들을 배웠습니다: - Pandas를 활용한 데이터 조작 - Matplotlib과 Seaborn을 사용한 시각화 - 기술통계 (평균, 중앙값, 표준편차) - 패턴 탐지 및 이상치 식별 하지만 EDA만으로는 중요한 질문에 답할 수 없습니다: - \"이 차이가 진짜인가, 아니면 그냥 무작위 노이즈인가?\" - \"이 결과를 데이터셋을 넘어서 일반화할 수 있는가?\" - \"우리의...", "url": "/study/ko/Data_Science/10_From_EDA_to_Inference.html"}, {"id": "Data_Science/11_Probability_Review", "title": "11. 확률론 복습 (Probability Review)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: EDA에서 추론으로 | 다음: 표본추출과 추정 확률론은 통계학의 수학적 기초입니다. 이 장에서는 고급 통계학을 학습하기 전에 반드시 이해해야 할 확률론의 핵심 개념들을 복습합니다. --- 표본공간 (Sample Space): 모든 가능한 결과의 집합 Ω 사건 (Event): 표본공간의 부분집합 세 가지 공리: 1. 비음수성: P(A) ≥ 0 (모든 사건 A에 대해) 2. 정규성: P(Ω) = 1 (전체 표본공간의 확률은 1) 3. 가산 가법성: 서로소인 사건들의 합의 확률 = 각 확률의 합 --- 확률변수 X가 셀 수 있는 값들만 가질 때 확률질량함수 (PMF): P(X = x) = f(x) 확률변수 X가 연속적인 값을 가질 때 확률밀도함수 (PDF): f(x), P(a ≤ X ≤ b) = ∫[a,b] f(x)dx --- n번의 독립 베르누이 시행에서 성공 횟수 단위 시간/공간당 평균 λ번 발생하는 사건의 횟수 첫 번째 성공까지의 시행 횟수 가장 중요한 연속분포,...", "url": "/study/ko/Data_Science/11_Probability_Review.html"}, {"id": "Data_Science/12_Sampling_and_Estimation", "title": "12. 표본과 추정 (Sampling and Estimation)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 확률론 복습 | 다음: 신뢰구간 통계학의 핵심 목표는 표본(sample)을 통해 모집단(population)의 특성을 추론하는 것입니다. 이 장에서는 표본분포의 개념과 점추정 방법, 특히 최대가능도 추정법(MLE)과 적률추정법(MoM)을 학습합니다. --- --- --- --- --- --- --- 모평균 100, 모표준편차 15인 정규모집단에서 크기 36인 표본을 추출할 때: - (a) 표본평균의 기대값과 표준오차는? - (b) 표본평균이 95와 105 사이일 확률은? 다음 데이터가 포아송 분포를 따른다고 할 때, λ의 MLE를 구하고 95% 신뢰구간을 추정하시오. 균등분포 U(a, b)에서 a와 b의 적률추정량을 유도하시오. (힌트: E[X] = (a+b)/2, Var(X) = (b-a)²/12) --- | 개념 | 핵심 내용 | Python 함수 | |------|-----------|-------------| | 표본평균 분포 | X̄ ~ N(μ, σ²/n) |...", "url": "/study/ko/Data_Science/12_Sampling_and_Estimation.html"}, {"id": "Data_Science/13_Confidence_Intervals", "title": "13. 신뢰구간 (Confidence Intervals)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 표본과 추정 | 다음: 가설검정 심화 신뢰구간(Confidence Interval, CI)은 모수가 포함될 것으로 기대되는 구간을 제공합니다. 점추정이 \"단일 값\"을 제공한다면, 구간추정은 \"불확실성의 범위\"를 함께 제공합니다. --- --- --- --- --- --- --- --- 다음 표본에서 모평균의 95% 신뢰구간을 구하시오. 500명을 대상으로 설문조사한 결과 230명이 찬성했습니다. - (a) 모비율의 95% 신뢰구간을 구하시오 (정규근사) - (b) Wilson 방법으로 다시 계산하시오 - (c) 표본 크기를 2000명으로 늘리면 구간 폭이 어떻게 변하는가? 다음 비대칭 분포에서 평균과 중앙값의 부트스트랩 95% 신뢰구간을 각각 구하시오. --- | 신뢰구간 유형 | 조건 | 공식 | Python | |--------------|------|------|--------| | 평균 (σ 기지) | Z-구간 | x̄ ± z·σ/√n | | | 평균 (σ 미지) |...", "url": "/study/ko/Data_Science/13_Confidence_Intervals.html"}, {"id": "Data_Science/14_Hypothesis_Testing_Advanced", "title": "14. 가설검정 심화 (Advanced Hypothesis Testing)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 신뢰구간 | 다음: 분산분석 이 장에서는 기본적인 가설검정을 넘어서 검정력(Power), 효과크기(Effect Size), 표본크기 결정(Sample Size Determination), 그리고 다중검정 문제(Multiple Testing Problem)를 다룹니다. --- --- --- --- --- --- 두 그룹의 평균 차이가 5점이고, 표준편차가 12일 때: - (a) 각 그룹 30명으로 검정할 때 검정력은? - (b) 80% 검정력을 위한 최소 표본크기는? 다음 10개의 p-value에 대해 Bonferroni와 BH 보정을 적용하시오. 두 그룹 데이터에서 Cohen's d와 Hedges' g를 계산하고 해석하시오. --- | 개념 | 핵심 내용 | Python | |------|-----------|--------| | 제1종 오류 (α) | H₀ 참인데 기각 | 유의수준 | | 제2종 오류 (β) | H₁ 참인데 미기각 | 1 - 검정력 | | 검정력 | 1 -...", "url": "/study/ko/Data_Science/14_Hypothesis_Testing_Advanced.html"}, {"id": "Data_Science/15_ANOVA", "title": "15. 분산분석 (ANOVA - Analysis of Variance)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 가설검정 심화 | 다음: 회귀분석 심화 분산분석(ANOVA)은 세 개 이상의 그룹 평균을 동시에 비교하는 통계 기법입니다. 여러 t-검정을 반복하는 것보다 제1종 오류를 통제하면서 효율적으로 분석할 수 있습니다. --- --- --- --- --- --- --- 세 가지 비료(A, B, C)가 식물 성장에 미치는 효과를 분석하시오. 성별(남/여) × 학습방법(온라인/오프라인)의 효과를 분석하시오. - 주효과와 상호작용 효과를 해석하시오. - 상호작용 플롯을 그리시오. 문제 1의 결과가 유의할 경우, Tukey HSD 사후검정을 수행하고 해석하시오. --- | ANOVA 유형 | 설계 | Python 함수 | |------------|------|-------------| | 일원배치 | 1 요인, k 수준 | , | | 이원배치 | 2 요인 | | | 반복측정 | 피험자 내 요인 | | | 혼합설계 | 피험자 간+내 | | | Kruskal-Wallis | 비모수 일원 |...", "url": "/study/ko/Data_Science/15_ANOVA.html"}, {"id": "Data_Science/16_Regression_Analysis_Advanced", "title": "16. 회귀분석 심화 (Advanced Regression Analysis)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 분산분석 | 다음: 일반화 선형모형 이 장에서는 다중회귀분석(Multiple Regression)의 심화 내용을 다룹니다. 회귀 가정의 검토, 진단 플롯, 다중공선성 문제, 그리고 변수 선택 방법을 학습합니다. --- --- --- --- --- --- --- 다음 데이터로 회귀분석을 수행하고 가정을 검토하시오. 아래 데이터에서 다중공선성을 진단하고 해결하시오. 5개의 독립변수 중 최적의 변수 조합을 선택하시오. - 전진선택, 후진제거, AIC 기준을 각각 적용 - 결과를 비교하시오 --- | 진단 항목 | 검정/방법 | Python 함수 | |-----------|-----------|-------------| | 정규성 | Shapiro-Wilk | | | 등분산성 | Breusch-Pagan | | | 독립성 | Durbin-Watson | | | 영향력 | Cook's D | | | 다중공선성 | VIF | | | 변수선택 | AIC/BIC | , |", "url": "/study/ko/Data_Science/16_Regression_Analysis_Advanced.html"}, {"id": "Data_Science/17_Generalized_Linear_Models", "title": "17. 일반화 선형모형 (Generalized Linear Models)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 회귀분석 심화 | 다음: 베이지안 통계 기초 일반화 선형모형(GLM)은 종속변수가 정규분포를 따르지 않는 경우에도 적용할 수 있는 회귀분석의 확장입니다. 이진 데이터(로지스틱 회귀), 카운트 데이터(포아송 회귀) 등 다양한 유형의 종속변수를 다룰 수 있습니다. --- --- --- --- --- --- --- 다음 데이터로 합격/불합격을 예측하는 로지스틱 회귀 모형을 구축하시오. 웹사이트 클릭 수 데이터에 포아송 회귀를 적용하고, 과대산포를 확인하시오. 로지스틱 회귀에서 AIC를 기준으로 최적 변수 조합을 선택하시오. --- | GLM 유형 | 분포 | 링크 함수 | Python | |----------|------|-----------|--------| | 선형 회귀 | Normal | Identity | | | 로지스틱 | Binomial | Logit | | | 포아송 | Poisson | Log | | | 음이항 | Neg Binomial | Log | | | 감마...", "url": "/study/ko/Data_Science/17_Generalized_Linear_Models.html"}, {"id": "Data_Science/18_Bayesian_Statistics_Basics", "title": "18. 베이지안 통계 기초 (Introduction to Bayesian Statistics)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 일반화 선형모형 | 다음: 베이지안 추론 베이지안 통계학은 확률을 불확실성의 정도로 해석하며, 사전 지식과 데이터를 결합하여 추론합니다. 이 장에서는 빈도주의와 베이지안 패러다임의 차이, 베이즈 정리, 그리고 핵심 개념인 사전분포, 가능도, 사후분포를 학습합니다. --- | 관점 | 빈도주의 (Frequentist) | 베이지안 (Bayesian) | |------|------------------------|---------------------| | 확률의 의미 | 장기적인 빈도 (무한 반복 시) | 불확실성의 정도 (믿음) | | 모수 | 고정된 미지의 상수 | 확률변수 (분포를 가짐) | | 추론 목표 | 점추정, 신뢰구간 | 사후분포 전체 | | 사전 정보 | 사용하지 않음 | 사전분포로 반영 | | 해석 | \"95% 신뢰구간\" (반복 시 95%가 참값 포함) | \"95% 확률로 참값이 구간 내 존재\" | --- 조건부 확률의 정의에서 출발: $$P(A|B) =...", "url": "/study/ko/Data_Science/18_Bayesian_Statistics_Basics.html"}, {"id": "Data_Science/19_Bayesian_Inference", "title": "19. 베이지안 추론 (Bayesian Inference)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 베이지안 통계 기초 | 다음: 시계열 분석 기초 켤레 사전분포가 적용되지 않는 복잡한 모델에서는 사후분포를 해석적으로 구할 수 없습니다. 이 장에서는 MCMC(Markov Chain Monte Carlo) 방법과 PyMC 라이브러리를 사용한 베이지안 추론을 학습합니다. --- 문제: 복잡한 사후분포의 정규화 상수를 계산하기 어려움 $$P(\\theta|D) = \\frac{P(D|\\theta)P(\\theta)}{\\int P(D|\\theta)P(\\theta)d\\theta}$$ 분모의 적분이 고차원에서 계산 불가능할 수 있음. 해결: 사후분포에서 직접 샘플링하여 분포를 근사 정의: 다음 상태가 현재 상태에만 의존하는 확률적 과정 $$P(X{t+1}|X1, X2, ..., Xt) = P(X{t+1}|Xt)$$ --- 목표: 목표 분포 π(x)에서 샘플 추출 알고리즘: 1. 초기값 x₀ 선택 2. 제안 분포 q(x'|x)에서 후보 x' 생성 3. 수락 확률 계산: α = min(1,...", "url": "/study/ko/Data_Science/19_Bayesian_Inference.html"}, {"id": "Data_Science/20_Time_Series_Basics", "title": "20. 시계열 분석 기초 (Time Series Analysis Fundamentals)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 베이지안 추론 | 다음: 시계열 모형 시계열 데이터는 시간 순서로 수집된 데이터입니다. 이 장에서는 시계열의 구성요소, 정상성 개념, 자기상관 분석, 그리고 시계열 분해 방법을 학습합니다. --- | 구성요소 | 설명 | 예시 | |----------|------|------| | 추세 (Trend) | 장기적인 증가/감소 패턴 | 인구 증가, 기술 발전 | | 계절성 (Seasonality) | 고정 주기로 반복되는 패턴 | 여름 에어컨 판매, 연말 쇼핑 | | 순환 (Cycle) | 비고정 주기의 반복 패턴 | 경기 순환 (불규칙적) | | 잔차 (Residual/Noise) | 설명되지 않는 무작위 변동 | 측정 오차, 예측 불가 요인 | --- 강정상성 (Strict Stationarity): 모든 차수의 결합분포가 시간 이동에 불변 약정상성 (Weak Stationarity): 1. 평균이 시간에 상관없이 일정: E[Yₜ] = μ 2. 분산이 시간에 상관없이 일정:...", "url": "/study/ko/Data_Science/20_Time_Series_Basics.html"}, {"id": "Data_Science/21_Time_Series_Models", "title": "21. 시계열 모형 (Time Series Models)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 시계열 분석 기초 | 다음: 다변량 분석 이 장에서는 AR, MA, ARMA, ARIMA 모형을 학습합니다. 모형의 이론적 배경, ACF/PACF를 통한 모델 식별, 파라미터 추정, 그리고 예측 방법을 다룹니다. --- AR(p) 모형: $$Yt = c + \\phi1 Y{t-1} + \\phi2 Y{t-2} + ... + \\phip Y{t-p} + \\epsilont$$ 여기서: - c: 상수 (절편) - φᵢ: AR 계수 - εₜ: 백색 잡음, εₜ ~ WN(0, σ²) 정상성 조건: 특성방정식 1 - φ₁z - φ₂z² - ... - φₚzᵖ = 0의 모든 근이 단위원 밖에 있어야 함 --- MA(q) 모형: $$Yt = c + \\epsilont + \\theta1 \\epsilon{t-1} + \\theta2 \\epsilon{t-2} + ... + \\thetaq \\epsilon{t-q}$$ 여기서: - c: 상수 (평균) - θᵢ: MA 계수 - εₜ: 백색 잡음 특징: MA...", "url": "/study/ko/Data_Science/21_Time_Series_Models.html"}, {"id": "Data_Science/22_Multivariate_Analysis", "title": "22. 다변량 분석 (Multivariate Analysis)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 시계열 모형 | 다음: 비모수 통계 다변량 분석은 여러 변수를 동시에 분석하는 통계 기법입니다. 이 장에서는 차원 축소(PCA, Factor Analysis), 분류(LDA, QDA), 그리고 군집 분석의 타당성 검증을 학습합니다. --- 목표: 고차원 데이터를 저차원으로 투영하면서 분산을 최대한 보존 주성분: 데이터의 분산을 최대화하는 직교 방향 수학적 정의: - 첫 번째 주성분: Var(w₁ᵀX)를 최대화하는 단위벡터 w₁ - k번째 주성분: 이전 주성분들과 직교하면서 분산을 최대화 --- | 측면 | PCA | 요인 분석 | |------|-----|----------| | 목표 | 분산 최대화 | 잠재 요인 발견 | | 모형 | 데이터 = 주성분 | 관측변수 = 요인 + 오차 | | 고유분산 | 없음 | 각 변수별 고유분산 | | 회전 | 불필요 (직교) | 해석을 위해 회전 | | 사용 | 차원 축소 | 구조 발견, 설문 분석 | 모형: $$Xi = \\mui +...", "url": "/study/ko/Data_Science/22_Multivariate_Analysis.html"}, {"id": "Data_Science/23_Nonparametric_Statistics", "title": "23. 비모수 통계 (Nonparametric Statistics)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 다변량 분석 | 다음: 실험 설계 비모수 통계는 모집단의 분포에 대한 가정 없이 데이터를 분석하는 방법입니다. 정규성을 만족하지 않거나 표본 크기가 작을 때 유용합니다. --- | 모수적 검정 | 비모수적 검정 | 상황 | |------------|--------------|------| | 1-표본 t-검정 | Wilcoxon 부호순위 검정 | 단일 표본, 중위수 검정 | | 독립표본 t-검정 | Mann-Whitney U | 두 독립 표본 비교 | | 대응표본 t-검정 | Wilcoxon 부호순위 검정 | 대응 표본 비교 | | 일원 ANOVA | Kruskal-Wallis H | 3개 이상 독립 표본 | | 반복측정 ANOVA | Friedman | 3개 이상 대응 표본 | | Pearson 상관 | Spearman/Kendall | 상관관계 | --- 목적: 두 독립 표본의 분포 비교 (중위수 또는 분포 위치) 가설: - H₀: 두 집단의 분포가 동일 - H₁: 두...", "url": "/study/ko/Data_Science/23_Nonparametric_Statistics.html"}, {"id": "Data_Science/24_Experimental_Design", "title": "24. 실험 설계 (Experimental Design)", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 비모수 통계 | 다음: 실전 프로젝트 실험 설계는 인과관계를 추론하기 위한 체계적인 방법론입니다. 이 장에서는 실험 설계의 기본 원리, A/B 테스트, 검정력 분석을 통한 표본 크기 결정, 그리고 순차적 검정 방법을 학습합니다. --- --- --- --- --- --- --- 기존 전환율이 3%이고, 최소 20%의 상대적 상승(3.6%로)을 탐지하고 싶다면: 1. α=0.05, Power=0.80에서 필요한 표본 크기 2. Power=0.90으로 높이면 표본 크기 변화 3. MDE를 10% 상승으로 낮추면 표본 크기 변화 일일 트래픽이 10,000 방문이고, 50:50으로 분할한다면: 1. 문제 1의 표본 크기를 확보하는데 필요한 기간 2. 주말 효과를 고려하면 최소 몇 주 실험? 5회 중간 분석을 계획한다면: 1. O'Brien-Fleming 방법의 각 분석 임계값 2. Pocock 방법과 비교 3. 첫 번째 분석에서 조기 종료 조건 5개 세그먼트(연령대)에서 A/B...", "url": "/study/ko/Data_Science/24_Experimental_Design.html"}, {"id": "Data_Science/25_Practical_Projects", "title": "25. 실전 프로젝트 - 데이터 분석 종합 실습", "topic": "Data_Science", "topic_display": "Data Science", "body": "이전: 실험 설계 실제 데이터셋을 활용한 종합 EDA 실습입니다. 데이터 로딩부터 인사이트 도출까지 전체 분석 과정을 다룹니다. --- --- --- --- --- | 단계 | 주요 작업 | 도구/함수 | |------|----------|----------| | 데이터 로딩 | CSV/Excel/DB 로드 | | | 개요 파악 | 형태, 타입 확인 | , | | 결측치 | 확인 및 처리 | , | | 단변량 | 분포, 빈도 분석 | , | | 이변량 | 관계 분석 | , | | 다변량 | 패턴 발견 | , | | 통계 검정 | 유의성 검정 | | | 인사이트 | 결과 정리 | 마크다운 보고서 |", "url": "/study/ko/Data_Science/25_Practical_Projects.html"}, {"id": "Database_Theory/00_Overview", "title": "데이터베이스 이론(Database Theory)", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이 주제는 관계형 모델(Relational Model)과 정규화 이론(Normalization Theory)부터 트랜잭션 처리(Transaction Processing), 쿼리 최적화(Query Optimization), 그리고 현대의 분산 패러다임(Distributed Paradigms)에 이르기까지 데이터베이스 시스템의 이론적 기반을 다룹니다. 이 레슨들은 모든 데이터베이스 실무자, 백엔드 엔지니어, 그리고 데이터 아키텍트가 올바르고 효율적이며 확장 가능한 데이터 시스템을 설계하기 위해 필요한 학문적 기반을 제공합니다. - 기본 프로그래밍 경험 (Python 또는 다른 언어) - SQL 기초 지식이 도움되지만 필수는 아님 (기본 원리부터 다룸) - 기초 집합론 및 논리학 (집합, 관계, 서술논리) - 파일 시스템과 데이터 저장 개념에 대한 기본 이해 | 파일명 | 난이도 | 핵심 주제 | 비고 |...", "url": "/study/ko/Database_Theory/00_Overview.html"}, {"id": "Database_Theory/01_Introduction_to_Database_Systems", "title": "데이터베이스 시스템 소개(Introduction to Database Systems)", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 개요 | 다음: 관계형 모델 --- 데이터베이스 시스템은 현대 컴퓨팅에서 가장 중요한 소프트웨어 인프라 중 하나입니다. 은행 거래와 항공 예약부터 소셜 미디어 피드와 과학 연구에 이르기까지, 데이터베이스는 지속적이고 공유되는 데이터를 관리하는 거의 모든 애플리케이션을 뒷받침합니다. 이 레슨에서는 데이터베이스 이론의 기초를 형성하는 기본 개념, 아키텍처, 용어를 소개합니다. 1. 데이터베이스란 무엇인가? 2. 왜 파일만 사용하면 안 되는가? 3. 데이터베이스 관리 시스템 4. 데이터베이스 시스템의 간략한 역사 5. 3단계 스키마 아키텍처 6. 데이터 독립성 7. ANSI/SPARC 아키텍처 8. 데이터 모델 9. 데이터베이스 사용자 및 역할 10. 데이터베이스 시스템 아키텍처 11. 연습문제 --- 데이터베이스(Database)는 조직 내 여러 사용자의 정보 요구를 충족하도록 설계된, 논리적으로 관련된 데이터의 조직화된 집합입니다. 더 정확하게는: > 데이터베이스: 여러...", "url": "/study/ko/Database_Theory/01_Introduction_to_Database_Systems.html"}, {"id": "Database_Theory/02_Relational_Model", "title": "관계형 모델(The Relational Model)", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 데이터베이스 시스템 소개 | 다음: 관계 대수 --- Edgar F. Codd가 1970년에 도입한 관계형 모델은 가장 널리 사용되는 데이터 모델이며 SQL 데이터베이스의 이론적 기반입니다. 이 모델은 데이터를 수학적 관계(테이블)로 표현하고 구조 정의, 무결성 강제, 데이터 조작을 위한 엄격한 프레임워크를 제공합니다. 이 레슨에서는 모든 데이터베이스 실무자가 이해해야 하는 형식적 정의, 핵심 개념, 무결성 제약조건, NULL의 미묘한 의미를 다룹니다. 1. 역사적 맥락: Codd의 비전 2. Codd의 12가지 규칙 3. 형식적 정의 4. 키 5. 무결성 제약조건 6. 관계형 스키마 표기법 7. NULL 의미와 3치 논리 8. 실제 관계형 모델 9. 연습문제 --- 1970년, IBM San Jose Research Laboratory의 연구원 Edgar F. Codd는 Communications of the ACM에 \"A Relational Model of Data...", "url": "/study/ko/Database_Theory/02_Relational_Model.html"}, {"id": "Database_Theory/03_Relational_Algebra", "title": "관계 대수(Relational Algebra)", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 관계 모델 | 다음: ER 모델링 --- 관계 대수는 관계 모델의 형식적 질의 언어입니다. 하나 또는 두 개의 관계를 입력으로 받아 새로운 관계를 출력으로 생성하는 연산자의 집합을 제공합니다. 관계 대수를 이해하는 것은 SQL 쿼리 처리의 기반이 되기 때문에 필수적입니다. 모든 SQL 쿼리는 내부적으로 관계 대수 표현식으로 변환되며, 쿼리 최적화기는 이를 변환하고 개선할 수 있습니다. 1. 관계 대수 개요 2. 단항 연산 3. 집합 연산 4. 이항 연산: 카티션 곱과 조인 5. 나눗셈 6. 추가 연산 7. 쿼리 트리와 대수적 최적화 8. 관계 해석 (간단한 소개) 9. SQL과의 동치성 10. 완전한 작업 예제 11. 연습 문제 --- 관계 대수는 절차적(procedural) 쿼리 언어입니다. 원하는 결과를 계산하기 위한 일련의 연산을 기술합니다. 각 연산은 하나 이상의 관계를 받아 새로운 관계를 생성합니다. 이 강의 전체에서 다음 샘플 데이터베이스를 사용합니다: ---...", "url": "/study/ko/Database_Theory/03_Relational_Algebra.html"}, {"id": "Database_Theory/04_ER_Modeling", "title": "ER 모델링(ER Modeling)", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 관계 대수 | 다음: 함수 종속성 --- 1976년 Peter Chen이 소개한 개체-관계(Entity-Relationship, ER) 모델은 개념적 데이터베이스 설계에 가장 널리 사용되는 접근법입니다. 특정 DBMS와 무관하게 높은 수준의 추상화로 데이터 구조를 표현하기 위한 그래픽 표기법을 제공합니다. 이 강의에서는 ER 모델, 향상된 버전(EER), 그리고 ER 다이어그램을 관계 스키마로 변환하는 체계적인 알고리즘을 다룹니다. 1. 개념적 설계 개요 2. 개체 타입과 개체 집합 3. 속성 4. 관계 타입 5. 카디널리티 제약조건 6. 참여 제약조건 7. 약한 개체 8. 향상된 ER (EER) 모델 9. ER-관계형 매핑 알고리즘 10. 설계 사례 연구: 대학 데이터베이스 11. 일반적인 함정과 모범 사례 12. 연습 문제 --- 데이터베이스 설계는 요구사항에서 구현까지 구조화된 프로세스를 따릅니다: - 의사소통: ER 다이어그램은 비기술 이해관계자도 이해 가능 -...", "url": "/study/ko/Database_Theory/04_ER_Modeling.html"}, {"id": "Database_Theory/05_Functional_Dependencies", "title": "Lesson 05: 함수 종속성(Functional Dependencies)", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 04ERModeling.md | 다음: 06Normalization.md --- > 주제: 데이터베이스 이론(Database Theory) > 레슨: 16개 중 5번째 > 선수 지식: 관계형 모델 개념(릴레이션, 튜플, 속성, 키), 기본 집합론 > 목표: 함수 종속성을 데이터베이스 정규화의 형식적 기반으로 이해하고, Armstrong의 공리 마스터하기, 속성 폐쇄 계산, 후보 키 도출, 최소 커버 계산 함수 종속성(FD: Functional Dependencies)은 관계형 데이터베이스 설계 이론에서 가장 중요한 개념입니다. 이는 \"하나의 속성이 다른 속성을 고유하게 결정한다\"는 개념을 형식화하며, 중복을 줄이고 이상 현상을 방지하기 위해 데이터베이스를 조직하는 과정인 정규화의 수학적 기초를 제공합니다. 함수 종속성이 등장하기 전에는 데이터베이스 설계자들이 직관과 경험에 의존했습니다. FD는 \"좋은\" 스키마가 무엇인지 엄밀하게 추론하고, 체계적으로 달성할 수 있는...", "url": "/study/ko/Database_Theory/05_Functional_Dependencies.html"}, {"id": "Database_Theory/06_Normalization", "title": "Lesson 06: 정규화 (1NF ~ BCNF)", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 05FunctionalDependencies.md | 다음: 07AdvancedNormalization.md --- > 주제: 데이터베이스 이론(Database Theory) > 레슨: 16개 중 6번째 > 선수 지식: 함수 종속성, 속성 폐쇄, 최소 커버 (Lesson 05) > 목표: 1NF부터 BCNF까지의 정규화 이해, 분해 알고리즘 마스터, 무손실 조인과 종속성 보존 속성 검증, 실제 스키마에 정규화 적용 정규화(Normalization)는 관계형 데이터베이스 스키마를 중복을 줄이고 특정 유형의 데이터 이상 현상을 제거하기 위해 조직하는 과정입니다. Edgar F. Codd가 1970년에 도입한 이 방법은 스키마 설계에 대한 체계적이고 이론 기반의 접근 방식을 제공합니다. 대학을 위한 단일 릴레이션 설계를 고려해보세요: 이 \"범용 릴레이션\"은 모든 것을 하나의 테이블에 저장합니다. 간단한 쿼리에는 작동하지만 심각한 문제를 겪습니다. 컴퓨터 과학부가 새 건물로...", "url": "/study/ko/Database_Theory/06_Normalization.html"}, {"id": "Database_Theory/07_Advanced_Normalization", "title": "Lesson 07: 고급 정규화(Advanced Normalization)", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 06Normalization.md | 다음: 08QueryProcessing.md --- > 주제(Topic): Database Theory > 레슨(Lesson): 7 of 16 > 선행 학습(Prerequisites): 함수 종속성(Functional dependencies, Lesson 05), BCNF까지의 정규화(normalization through BCNF, Lesson 06) > 목표(Objective): 다치 종속성과 4NF(Multivalued dependencies and 4NF), 조인 종속성과 5NF(Join dependencies and 5NF), DKNF의 이론적 이상(theoretical ideal of DKNF), 그리고 실무 시스템을 위한 실용적 비정규화 전략(practical denormalization strategies)을 이해합니다 Lesson 06에서 우리는 함수 종속성이 BCNF까지의 정규화를 어떻게 이끄는지 살펴보았습니다. 그러나...", "url": "/study/ko/Database_Theory/07_Advanced_Normalization.html"}, {"id": "Database_Theory/08_Query_Processing", "title": "Lesson 08: 쿼리 처리(Query Processing)", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 07AdvancedNormalization.md | 다음: 09Indexing.md --- > 주제(Topic): Database Theory > 레슨(Lesson): 8 of 16 > 선행 학습(Prerequisites): 관계 대수(Relational algebra, Lesson 03), SQL 기초, 디스크 I/O 이해 > 목표(Objective): DBMS가 SQL 쿼리를 효율적인 실행 계획으로 변환하는 방법을 이해하고, 선택(selection)과 조인(join) 알고리즘의 비용 모델을 숙달하며, 쿼리 최적화 기법을 파악합니다 SQL 쿼리를 작성할 때, 데이터베이스는 작성된 그대로 실행하지 않습니다. SQL 문과 실제 디스크 액세스 사이에는 파싱(parsing), 최적화(optimization), 실행(execution)의 정교한 파이프라인이 있습니다. 이 파이프라인을 이해하는 것은 효율적인 쿼리를 작성하고 성능 문제를 진단하는 데 중요합니다. 1....", "url": "/study/ko/Database_Theory/08_Query_Processing.html"}, {"id": "Database_Theory/09_Indexing", "title": "09. 인덱싱", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 질의 처리와 최적화 | 다음: 트랜잭션 이론 --- - 인덱싱이 데이터베이스 성능에 중요한 이유 이해 - 정렬된 인덱스(Ordered Indices) 구분: 주 인덱스(Primary), 클러스터링(Clustering), 보조 인덱스(Secondary) - B-Tree와 B+Tree 구조, 연산 및 복잡도 마스터 - 해시 기반 인덱싱 기법: 정적(Static), 확장가능(Extendible), 선형 해싱(Linear Hashing) - 비트맵 인덱스(Bitmap Indices)와 다차원 인덱스 구조 이해 - 실무에서 인덱스 설계 지침 적용 --- 100만 개의 행을 가진 테이블이 디스크에 저장되어 있다고 가정하자. 각 디스크 블록은 10개의 행을 담으므로, 테이블은 10만 개의 블록을 차지한다. ID로 직원 한 명을 찾으려면: 10만 블록의 경우: - 순차 스캔: 최대 10만 번의 블록 읽기 - B+Tree 인덱스 (분기 계수 200): 대략 log200(1,000,000)...", "url": "/study/ko/Database_Theory/09_Indexing.html"}, {"id": "Database_Theory/10_Transaction_Theory", "title": "10. 트랜잭션 이론", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 인덱싱 | 다음: 동시성 제어 --- - 트랜잭션 개념과 ACID 속성을 깊이 이해 - 트랜잭션 상태 전이 추적 - 선행 그래프(Precedence Graph)를 사용한 충돌 직렬화 가능성(Conflict Serializability) 분석 - 복구 가능(Recoverable), 연쇄 없는(Cascadeless), 엄격한(Strict) 스케줄 구분 - SQL 격리 수준과 허용하는 이상 현상 이해 - 스냅샷 격리(Snapshot Isolation)와 그 트레이드오프에 대해 추론 --- 트랜잭션(Transaction)은 데이터베이스의 내용을 접근하고 수정할 수 있는 논리적 작업 단위다. 분할 불가능한 단위로 취급되어야 하는 일련의 연산(읽기와 쓰기)으로 구성된다. 실세계 비유: 계좌 A에서 계좌 B로 은행 이체: 와 사이에 시스템이 충돌하면, 돈이 사라질 것이다 -- A에서 $100이 차감되지만 B로 입금되지 않음. 트랜잭션이 이를 방지한다. 트랜잭션은 두 가지 중요한 보장을...", "url": "/study/ko/Database_Theory/10_Transaction_Theory.html"}, {"id": "Database_Theory/11_Concurrency_Control", "title": "11. 동시성 제어", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 트랜잭션 이론 | 다음: 복구 시스템 --- - 동시성 제어가 데이터베이스 정확성에 필수적인 이유 이해 - 잠금 기반 프로토콜 마스터: 공유/배타 잠금, 2단계 잠금 및 변형들 - 데드락 분석 및 처리: 감지, 방지, 타임아웃 전략 - 잠금 세분도와 다중 세분도 잠금을 위한 의도 잠금 이해 - 타임스탬프 기반 프로토콜과 Thomas의 쓰기 규칙 학습 - 다중 버전 동시성 제어(MVCC)와 그 구현 이해 - 낙관적 동시성 제어(OCC)를 비관적 방법과 비교 --- 현대 데이터베이스 시스템은 수천 개의 동시 트랜잭션을 처리한다. 동시성이 없으면: 동시성의 이점: - 향상된 처리량(Throughput): 초당 더 많은 트랜잭션 - 감소된 응답 시간: 짧은 트랜잭션이 긴 트랜잭션 뒤에서 기다리지 않음 - 더 나은 자원 활용: 다른 트랜잭션이 I/O를 기다리는 동안 CPU가 작동 동시성 제어 없이, 인터리빙된 실행은 각 트랜잭션이 개별적으로 정확하더라도 잘못된 결과를 생성할 수...", "url": "/study/ko/Database_Theory/11_Concurrency_Control.html"}, {"id": "Database_Theory/12_Recovery_Systems", "title": "12. 복구 시스템", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 동시성 제어 | 다음: NoSQL와 NewSQL --- - 실패 유형을 분류하고 저장 계층 이해 - 로그 기반 복구 기법 마스터: 지연 및 즉시 수정 - 선행 기록 로깅(WAL) 프로토콜과 그것이 필수적인 이유 이해 - 퍼지 체크포인트를 포함한 체크포인트 메커니즘 학습 - ARIES 복구 알고리즘 상세 학습: 분석, 재실행, 취소 단계 - 복구 접근 비교: 그림자 페이징 vs. WAL 기반 복구 - 버퍼 관리 정책 이해: force/no-force, steal/no-steal - 미디어 복구와 백업 전략 학습 --- 데이터베이스 시스템은 다양한 유형의 실패를 우아하게 처리해야 한다. 실패 유형을 이해하는 것은 적절한 복구 메커니즘을 설계하는 데 필수적이다. 단일 트랜잭션 내의 실패. 시스템의 나머지는 영향을 받지 않는다. 논리적 오류: - 0으로 나누기 - 제약 위반 (예: 고유 키, 외래 키) - 응용 프로그램 수준 단언 실패 - 사용자가 시작한 중단 (ROLLBACK)...", "url": "/study/ko/Database_Theory/12_Recovery_Systems.html"}, {"id": "Database_Theory/13_NoSQL_Data_Models", "title": "NoSQL 데이터 모델", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 12. 동시성 제어 | 다음: 14. 분산 데이터베이스 --- 관계형 모델은 Codd의 1970년 획기적인 논문 이후 데이터 관리의 지배적인 패러다임으로 자리잡았습니다. 그러나 인터넷이 수천 명의 사용자에서 수십억 명으로 진화하고, 데이터가 메가바이트에서 페타바이트로 증가하면서, 실무자들은 관계형 모델의 엄격한 보장이 자산이 아닌 부채가 되는 시나리오를 발견했습니다. 이 레슨에서는 NoSQL 혁명을 탐구합니다: 왜 발생했는지, 어떤 모델이 등장했는지, 그리고 주어진 문제에 적합한 데이터 모델을 선택하는 방법을 다룹니다. 난이도: ⭐⭐⭐ 학습 목표: - 관계형 모델이 웹 스케일에서 어려움을 겪는 이유 설명 - CAP 정리와 형식적 증명 스케치를 진술하고 해석 - BASE와 ACID 일관성 모델 대조 - 키-값, 문서, 와이드 컬럼, 그래프 패러다임을 사용하여 데이터 모델 설계 - 각 NoSQL 패러다임에서 기본 쿼리 작성 - 적절한 데이터 모델을 선택하기 위한 의사결정...", "url": "/study/ko/Database_Theory/13_NoSQL_Data_Models.html"}, {"id": "Database_Theory/14_Distributed_Databases", "title": "분산 데이터베이스", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 13. NoSQL 데이터 모델 | 다음: 15. NewSQL과 현대 트렌드 --- 현대 애플리케이션은 전 세계 사용자를 서비스하고, 대량의 데이터를 생성하며, 하드웨어 장애 시에도 가용성을 유지해야 합니다. 아무리 강력해도 단일 데이터베이스 서버는 이 세 가지 요구사항을 동시에 충족할 수 없습니다. 분산 데이터베이스는 여러 기계에 데이터와 계산을 분산시켜 이 문제를 해결합니다. 이 레슨에서는 모든 분산 데이터베이스 시스템을 뒷받침하는 아키텍처, 알고리즘, 트레이드오프를 데이터 단편화 및 복제부터 합의 프로토콜 및 분산 트랜잭션까지 살펴봅니다. 난이도: ⭐⭐⭐⭐ 학습 목표: - Shared-nothing, shared-disk, shared-memory 아키텍처 비교 - 수평, 수직, 하이브리드 단편화 전략 설계 - 동기 vs 비동기 복제 및 쿼럼 기반 프로토콜 분석 - 분산 쿼리 처리 및 최적화 설명 - Two-Phase Commit (2PC) 및 Three-Phase...", "url": "/study/ko/Database_Theory/14_Distributed_Databases.html"}, {"id": "Database_Theory/15_NewSQL_and_Modern_Trends", "title": "NewSQL과 현대 트렌드", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 14. 분산 데이터베이스 | 다음: 16. 데이터베이스 설계 사례 연구 --- NoSQL 혁명 이후 데이터베이스 환경은 극적으로 진화했습니다. 새로운 세대의 시스템은 두 세계의 장점을 결합하는 것을 목표로 합니다: NoSQL의 수평적 확장성과 가용성, 그리고 관계형 데이터베이스의 ACID 보장과 SQL 인터페이스. NewSQL을 넘어, 특화된 워크로드를 제공하기 위해 완전히 새로운 범주의 데이터베이스가 등장했습니다 -- AI를 위한 벡터 유사도 검색, IoT를 위한 시계열 저장소, 그리고 대규모 그래프 분석. 이 레슨은 데이터베이스 기술의 최첨단과 이러한 시스템을 가능하게 하는 아키텍처 혁신을 조사합니다. 난이도: ⭐⭐⭐ 학습 목표: - NewSQL 설계 철학과 ACID를 수평적 확장성과 어떻게 조화시키는지 설명 - Google Spanner의 TrueTime 메커니즘과 외부 일관성 설명 - CockroachDB, TiDB, Spanner 아키텍처 비교 - 벡터...", "url": "/study/ko/Database_Theory/15_NewSQL_and_Modern_Trends.html"}, {"id": "Database_Theory/16_Database_Design_Case_Study", "title": "데이터베이스 설계 사례 연구", "topic": "Database_Theory", "topic_display": "Database Theory", "body": "이전: 15. NewSQL과 현대 트렌드 --- 이 종합 레슨은 앞선 15개 레슨의 모든 내용을 포괄적이고 종단간 데이터베이스 설계 연습으로 통합합니다. 요구사항 수집부터 최적화된 쿼리 작성까지 전자상거래 플랫폼의 완전한 설계 라이프사이클을 안내하며, ER 모델링, 정규화, 인덱싱, 트랜잭션 및 동시성 제어의 이론을 현실적인 시나리오에 적용합니다. 두 번째 미니 사례 연구(소셜 미디어 플랫폼)는 추가 연습을 제공하며, 레슨은 설계 검토 체크리스트와 일반적인 실수 카탈로그로 마무리됩니다. 난이도: ⭐⭐⭐⭐ 학습 목표: - 데이터베이스 시스템에 대한 요구사항 분석 수행 - 비즈니스 요구사항에서 완전한 ER 다이어그램 생성 - ER 모델을 관계형 스키마로 매핑하고 BCNF로 정규화 - 물리적 설계에 대한 정보에 입각한 결정 (인덱싱, 파티셔닝, 비정규화) - 쿼리 플랜 분석 및 최적화 기술 적용 - 적절한 격리 수준으로 트랜잭션 전략 설계 - 설계 트레이드오프 평가 및 결정 문서화 -...", "url": "/study/ko/Database_Theory/16_Database_Design_Case_Study.html"}, {"id": "Deep_Learning/00_Overview", "title": "딥러닝 학습 가이드", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이 폴더는 딥러닝 이론과 실습을 아우르는 종합 가이드를 제공하며, 개념 중심 레슨과 처음부터 구현하는 모델 실습을 결합합니다. PyTorch를 주요 프레임워크로 사용하며, 4단계 학습 접근법을 통합한 교육 과정을 따릅니다: 1. 레벨 1 (NumPy 스크래치): NumPy만 사용하여 모델을 구축하고 기본 메커니즘 이해 2. 레벨 2 (PyTorch 저수준): 고수준 API 없이 PyTorch 기본 요소(텐서, autograd)로 구현 3. 레벨 3 (논문 재현): 원논문을 읽고 핵심 아키텍처 재현 4. 레벨 4 (코드 분석): 프레임워크 및 연구 저장소의 프로덕션급 구현 분석 이 통합 접근법은 수학적 기초부터 실전 배포까지 딥러닝의 \"왜\"와 \"어떻게\"를 모두 이해할 수 있도록 합니다. - MachineLearning 폴더를 완료한 학습자 - Python, NumPy, 기본 ML 개념(경사 하강법, 과적합, train/test 분할)에 익숙한 독자 - 엄격하고 구현 중심의 딥러닝...", "url": "/study/ko/Deep_Learning/00_Overview.html"}, {"id": "Deep_Learning/01_Tensors_and_Autograd", "title": "01. 텐서와 오토그래드", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "다음: 신경망 기초 --- > PyTorch 2.x 안내: 이 레슨은 PyTorch 2.0+ (2023년~)를 기준으로 합니다. > > PyTorch 2.0의 주요 기능: > - : 그래프 컴파일로 학습/추론 속도 대폭 향상 > - : 함수 변환 (vmap, grad, jacrev 등) > - 향상된 CUDA 그래프 지원 > > 설치: - 텐서(Tensor)의 개념과 NumPy 배열과의 차이점 이해 - PyTorch의 자동 미분(Autograd) 시스템 이해 - GPU 연산의 기초 - (PyTorch 2.x) torch.compile 기초 --- 텐서는 다차원 배열을 일반화한 개념입니다. | 차원 | 이름 | 예시 | |------|------|------| | 0D | 스칼라 | 단일 숫자 (5) | | 1D | 벡터 | [1, 2, 3] | | 2D | 행렬 | [[1,2], [3,4]] | | 3D | 3D 텐서 | 이미지 (H, W, C) | | 4D | 4D 텐서 | 배치...", "url": "/study/ko/Deep_Learning/01_Tensors_and_Autograd.html"}, {"id": "Deep_Learning/02_Neural_Network_Basics", "title": "02. 신경망 기초", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 텐서와 오토그래드 | 다음: 역전파 --- - 퍼셉트론과 다층 퍼셉트론(MLP) 이해 - 활성화 함수의 역할과 종류 - PyTorch의 로 신경망 구축 --- 가장 기본적인 신경망 단위입니다. --- 비선형성을 추가하여 복잡한 패턴을 학습합니다. | 함수 | 수식 | 특징 | |------|------|------| | Sigmoid | σ(x) = 1/(1+e⁻ˣ) | 출력 0~1, 기울기 소실 문제 | | Tanh | tanh(x) = (eˣ-e⁻ˣ)/(eˣ+e⁻ˣ) | 출력 -1~1 | | ReLU | max(0, x) | 가장 많이 사용, 간단하고 효과적 | | Leaky ReLU | max(αx, x) | 음수 영역에서 작은 기울기 | | GELU | x·Φ(x) | Transformer에서 사용 | --- 여러 층을 쌓아 복잡한 함수를 근사합니다. --- PyTorch에서 신경망을 정의하는 표준 방법입니다. --- 적절한 초기화는 학습 성능에 큰 영향을 미칩니다....", "url": "/study/ko/Deep_Learning/02_Neural_Network_Basics.html"}, {"id": "Deep_Learning/03_Backpropagation", "title": "03. 역전파 이해", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 신경망 기초 | 다음: 훈련 기법 --- - 역전파(Backpropagation) 알고리즘의 원리 이해 - 체인 룰(Chain Rule)을 이용한 기울기 계산 - NumPy로 역전파 직접 구현 --- 역전파는 신경망의 가중치를 학습하기 위한 알고리즘입니다. 1. 순전파: 입력에서 출력까지 값 계산 2. 손실 계산: 예측과 정답의 차이 3. 역전파: 손실에서 입력 방향으로 기울기 전파 4. 가중치 업데이트: 기울기를 이용해 가중치 조정 --- 합성 함수의 미분 법칙입니다. --- --- --- 2층 MLP의 역전파 과정입니다. --- --- PyTorch에서는 이 모든 과정이 자동입니다. --- - 원인: 시그모이드/tanh의 미분이 0에 가까움 - 해결: ReLU, 잔차 연결(Residual Connection) - 원인: 깊은 네트워크에서 기울기 누적 - 해결: Gradient Clipping, Batch Normalization --- 역전파 구현이 올바른지 확인하는...", "url": "/study/ko/Deep_Learning/03_Backpropagation.html"}, {"id": "Deep_Learning/04_Training_Techniques", "title": "04. 학습 기법", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 역전파 | 다음: Linear & Logistic Regression --- - 경사 하강법 변형 이해 (SGD, Momentum, Adam) - 학습률 스케줄링 - 정규화 기법 (Dropout, Weight Decay, Batch Norm) - 과적합 방지와 조기 종료 --- - η: 학습률 (learning rate) - ∇L: 손실 함수의 기울기 | 방법 | 수식 | 특징 | |------|------|------| | SGD | W -= lr × g | 단순, 느림 | | Momentum | v = βv + g; W -= lr × v | 관성 추가 | | AdaGrad | 적응적 학습률 | 희소 데이터에 유리 | | RMSprop | 지수 이동 평균 | AdaGrad 개선 | | Adam | Momentum + RMSprop | 가장 보편적 | --- 관성을 추가하여 진동을 줄입니다. --- Momentum과 RMSprop의 장점을 결합합니다. --- 학습 중...", "url": "/study/ko/Deep_Learning/04_Training_Techniques.html"}, {"id": "Deep_Learning/05_Impl_Linear_Logistic", "title": "05. Linear & Logistic Regression", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 훈련 기법 | 다음: Multi-Layer Perceptron (MLP) --- 선형 회귀와 로지스틱 회귀는 딥러닝의 가장 기본적인 building block입니다. 신경망의 각 레이어는 본질적으로 선형 변환 + 비선형 활성화의 조합입니다. 1. 수학적 이해 - Gradient Descent 원리 - Loss Function (MSE, Cross-Entropy) - 행렬 미분 2. 구현 능력 - Forward/Backward pass 직접 구현 - 가중치 초기화 - 학습 루프 작성 3. 실습 - MNIST 이진 분류 - 과적합/정규화 실험 --- --- --- --- --- 1. Linear Regression에 bias 없이 구현해보기 2. 학습률(lr)을 바꾸며 수렴 속도 관찰 3. Batch vs Stochastic Gradient Descent 비교 1. L2 정규화 추가 (Ridge) 2. L1 정규화 추가 (Lasso) 3. Mini-batch GD 구현 1....", "url": "/study/ko/Deep_Learning/05_Impl_Linear_Logistic.html"}, {"id": "Deep_Learning/06_Impl_MLP", "title": "06. Multi-Layer Perceptron (MLP)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: Linear & Logistic Regression | 다음: CNN 기초 --- MLP는 딥러닝의 기본 building block입니다. Backpropagation을 통해 여러 레이어를 학습하는 방법을 이해하는 것이 핵심입니다. 1. Forward Pass: 다층 구조에서 순전파 이해 2. Backward Pass: Chain Rule을 이용한 역전파 3. Activation Functions: ReLU, Sigmoid, Tanh의 특성과 미분 4. Weight Initialization: 올바른 초기화의 중요성 --- --- --- > 하나의 hidden layer를 가진 feedforward 네트워크는 충분한 뉴런이 있다면 임의의 연속 함수를 근사할 수 있다. --- 1. XOR 문제 해결 (2-layer MLP) 2. 다양한 활성화 함수 비교 3. 초기화 방법에 따른 학습 곡선 비교 1. Dropout 구현 2. Batch Normalization 구현 3....", "url": "/study/ko/Deep_Learning/06_Impl_MLP.html"}, {"id": "Deep_Learning/07_CNN_Basics", "title": "05. CNN 기초 (Convolutional Neural Networks)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "- 합성곱 연산의 원리 이해 - 풀링, 패딩, 스트라이드 개념 - PyTorch로 CNN 구현 - MNIST/CIFAR-10 분류 --- 이미지의 지역적 패턴(에지, 텍스처)을 감지합니다. --- --- --- --- --- --- > 참고: 실제 CNN에서는 PyTorch의 최적화된 구현을 사용합니다. --- --- - 32×32 RGB 이미지 - 10개 클래스: airplane, automobile, bird, cat, deer, dog, frog, horse, ship, truck --- 1. 합성곱: 지역 패턴 추출, 파라미터 공유 2. 풀링: 공간 축소, 불변성 증가 3. 채널: 다양한 특징 학습 4. 계층적 학습: 저수준 → 고수준 특징 | 항목 | MLP | CNN | |------|-----|-----| | 연결 | 완전 연결 | 지역 연결 | | 파라미터 | 많음 | 적음 (공유) | | 공간 정보 | 무시 | 보존 | | 이미지 | 비효율적 | 효율적 |...", "url": "/study/ko/Deep_Learning/07_CNN_Basics.html"}, {"id": "Deep_Learning/08_CNN_Advanced", "title": "06. CNN 심화 - 유명 아키텍처", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "- VGG, ResNet, EfficientNet 아키텍처 이해 - Skip Connection과 Residual Learning - 깊은 네트워크의 학습 문제와 해결책 - PyTorch로 구현 --- - 작은 필터(3×3)만 사용 - 깊이를 늘려 성능 향상 - 단순하고 일관된 구조 --- - 네트워크가 깊어지면 기울기가 소실됨 - 단순히 층을 쌓으면 성능이 떨어짐 - 항등 함수 학습이 쉬워짐 - 기울기가 skip connection을 통해 직접 전파 - 1000층 이상도 학습 가능 --- --- - 깊이, 너비, 해상도의 균형 있는 스케일링 - Compound Scaling --- | 모델 | 파라미터 | Top-1 Acc | 특징 | |------|----------|-----------|------| | VGG16 | 138M | 71.5% | 단순, 메모리 많이 사용 | | ResNet-50 | 26M | 76.0% | Skip Connection | | ResNet-152...", "url": "/study/ko/Deep_Learning/08_CNN_Advanced.html"}, {"id": "Deep_Learning/09_Transfer_Learning", "title": "07. 전이학습 (Transfer Learning)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "- 전이학습의 개념과 이점 - 사전 학습 모델 활용 - 미세 조정(Fine-tuning) 전략 - 실전 이미지 분류 프로젝트 --- - 적은 데이터로도 높은 성능 - 빠른 학습 - 더 나은 일반화 --- - 사전 학습된 특징 그대로 사용 - 마지막 분류층만 학습 - 데이터가 적을 때 적합 - 사전 학습 가중치를 시작점으로 - 전체 네트워크 미세 조정 - 데이터가 충분할 때 적합 --- --- --- --- --- | 데이터 크기 | 전략 | 설명 | |-------------|------|------| | 매우 적음 (<1000) | 특성 추출 | 마지막 층만 학습 | | 적음 (1000-10000) | 점진적 해동 | 후반 층부터 해동 | | 보통 (10000+) | 전체 미세 조정 | 낮은 학습률로 전체 학습 | 1. ImageNet 정규화 누락 2. 너무 높은 학습률 3. 훈련/평가 모드 전환 잊음 4. 가중치 고정 후 optimizer에 포함 --- --- 1. 특성 추출:...", "url": "/study/ko/Deep_Learning/09_Transfer_Learning.html"}, {"id": "Deep_Learning/10_Impl_CNN_LeNet", "title": "03. CNN (LeNet)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "LeNet-5는 Yann LeCun이 1998년에 제안한 최초의 성공적인 Convolutional Neural Network입니다. 손글씨 숫자 인식(MNIST)에서 뛰어난 성능을 보여주었으며, 현대 CNN의 기초가 되었습니다. --- --- --- --- --- - Convolution을 루프로 직접 구현 - im2col 최적화 - Backpropagation 수동 구현 - F.conv2d, F.maxpool2d 사용 - nn.Conv2d 미사용 - 파라미터 수동 관리 - 원본 논문 아키텍처 재현 - Tanh 활성화 (ReLU 대신) - Average Pooling (Max 대신) --- - [ ] Convolution 수식 이해 - [ ] 출력 크기 계산 공식 암기 - [ ] im2col 기법 이해 - [ ] Conv backward 유도 - [ ] Max pooling backward 이해 - [ ] LeNet 아키텍처 암기 --- - LeCun et al. (1998)....", "url": "/study/ko/Deep_Learning/10_Impl_CNN_LeNet.html"}, {"id": "Deep_Learning/11_Impl_VGG", "title": "04. VGG", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "VGGNet은 2014년 ILSVRC에서 2위를 차지한 모델로, Karen Simonyan과 Andrew Zisserman이 제안했습니다. \"Very Deep Convolutional Networks for Large-Scale Image Recognition\" 논문에서 3x3 작은 필터를 깊게 쌓는 것이 효과적임을 보여주었습니다. --- --- | 구성 | VGG11 | VGG13 | VGG16 | VGG19 | |------|-------|-------|-------|-------| | Conv Layers | 8 | 10 | 13 | 16 | | FC Layers | 3 | 3 | 3 | 3 | | Total Layers | 11 | 13 | 16 | 19 | | Parameters | 133M | 133M | 138M | 144M | --- --- --- - F.conv2d, F.maxpool2d, F.linear 사용 - nn.Conv2d, nn.Linear 미사용 -...", "url": "/study/ko/Deep_Learning/11_Impl_VGG.html"}, {"id": "Deep_Learning/12_Impl_ResNet", "title": "05. ResNet", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "ResNet(Residual Network)은 2015년 ILSVRC에서 1위를 차지한 혁명적인 모델입니다. Kaiming He 등이 제안한 Skip Connection (Residual Connection)을 통해 수백 개 이상의 레이어를 학습할 수 있게 되었습니다. > \"깊이가 깊어질수록 성능이 떨어지는 degradation 문제를 해결\" --- --- | 모델 | 레이어 | 블록 | 블록 수 | Params | |------|--------|------|---------|--------| | ResNet-18 | 18 | Basic | [2,2,2,2] | 11.7M | | ResNet-34 | 34 | Basic | [3,4,6,3] | 21.8M | | ResNet-50 | 50 | Bottleneck | [3,4,6,3] | 25.6M | | ResNet-101 | 101 | Bottleneck | [3,4,23,3] | 44.5M | | ResNet-152 | 152...", "url": "/study/ko/Deep_Learning/12_Impl_ResNet.html"}, {"id": "Deep_Learning/13_RNN_Basics", "title": "08. RNN 기초 (Recurrent Neural Networks)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "- 순환 신경망의 개념과 구조 - 시퀀스 데이터 처리 - PyTorch nn.RNN 사용법 - 기울기 소실 문제 이해 --- - 고정된 입력 크기 - 순서 정보 무시 - 가변 길이 시퀀스 처리 불가 --- - 모든 시간 단계에서 동일한 Wxh, Whh 사용 - 가변 길이 시퀀스 처리 가능 --- --- --- - |Whh| > 1: 기울기 폭발 - |Whh| < 1: 기울기 소실 1. LSTM/GRU 사용 (다음 레슨) 2. Gradient Clipping --- --- --- --- | 모델 | 장점 | 단점 | |------|------|------| | Simple RNN | 단순, 빠름 | 긴 시퀀스 학습 어려움 | | LSTM | 장기 의존성 학습 | 복잡, 느림 | | GRU | LSTM과 유사, 더 단순 | - | --- 1. 순환 구조: 이전 상태가 다음 계산에 영향 2. 파라미터 공유: 시간 독립적 가중치 3. 기울기 문제: 긴 시퀀스에서 학습 어려움 ---...", "url": "/study/ko/Deep_Learning/13_RNN_Basics.html"}, {"id": "Deep_Learning/14_LSTM_GRU", "title": "09. LSTM과 GRU", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "- LSTM과 GRU의 구조 이해 - 게이트 메커니즘 - 장기 의존성 학습 - PyTorch 구현 --- --- --- --- --- --- | 항목 | LSTM | GRU | |------|------|-----| | 게이트 수 | 3개 (f, i, o) | 2개 (r, z) | | 상태 | 셀 + 은닉 | 은닉만 | | 파라미터 | 더 많음 | 더 적음 | | 학습 속도 | 느림 | 빠름 | | 성능 | 복잡한 패턴 | 비슷하거나 약간 낮음 | - LSTM: 긴 시퀀스, 복잡한 의존성 - GRU: 빠른 학습, 제한된 자원 --- --- 1. LSTM: 셀 상태로 장기 기억 유지, 3개 게이트 2. GRU: LSTM 단순화, 2개 게이트 3. 게이트: 정보 흐름 제어 (시그모이드 × 값) --- 16AttentionTransformer.md에서 Seq2Seq와 Attention을 학습합니다.", "url": "/study/ko/Deep_Learning/14_LSTM_GRU.html"}, {"id": "Deep_Learning/15_Impl_LSTM_GRU", "title": "06. LSTM / GRU", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "LSTM(Long Short-Term Memory)과 GRU(Gated Recurrent Unit)는 vanishing gradient 문제를 해결한 순환 신경망(RNN) 변형입니다. 게이트 메커니즘을 통해 장기 의존성(long-term dependency)을 효과적으로 학습합니다. --- --- --- --- --- - 모든 게이트 연산 직접 구현 - BPTT gradient 수동 계산 - Cell state gradient 유도 - F.linear, torch.sigmoid, torch.tanh 사용 - nn.LSTM 미사용 - 파라미터 수동 관리 - Bidirectional, Stacked 구현 - Hochreiter & Schmidhuber (1997) LSTM - Cho et al. (2014) GRU - Peephole connections --- - [ ] Vanilla RNN의 vanishing gradient 문제 - [ ] LSTM 4개 수식 암기 - [ ]...", "url": "/study/ko/Deep_Learning/15_Impl_LSTM_GRU.html"}, {"id": "Deep_Learning/16_Attention_Transformer", "title": "10. Attention과 Transformer", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "- Attention 메커니즘의 원리 - Self-Attention 이해 - Transformer 아키텍처 - PyTorch 구현 --- --- --- --- --- 1. Multi-Head Attention 2. Position-wise Feed Forward 3. Residual Connection 4. Layer Normalization 5. Positional Encoding --- --- --- --- | 항목 | RNN/LSTM | Transformer | |------|----------|-------------| | 병렬화 | 어려움 | 용이 | | 장거리 의존성 | 어려움 | 용이 | | 학습 속도 | 느림 | 빠름 | | 메모리 | O(n) | O(n²) | | 위치 정보 | 암시적 | 명시적 | --- - BERT: 양방향 인코더 - GPT: 디코더 기반 생성 - T5: 인코더-디코더 - ViT: 이미지 분류 - DETR: 객체 검출 - Swin...", "url": "/study/ko/Deep_Learning/16_Attention_Transformer.html"}, {"id": "Deep_Learning/17_Attention_Deep_Dive", "title": "18. Attention 메커니즘 심화", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "- Multi-Head Attention 수학적 세부 이해 - Attention 복잡도 분석 (O(n^2)) - Flash Attention 원리 - Sparse Attention 기법들 - 위치 인코딩 심화 (RoPE, ALiBi) - Attention 시각화 기법 - PyTorch 효율적 구현 --- --- --- --- --- --- --- --- --- 1. MHA 수학: Q, K, V 투영 → 스케일링 → softmax → 가중합 2. 복잡도: O(n^2) 시간/공간 - 긴 시퀀스 병목 3. Flash Attention: 블록 처리 + Online softmax → O(n) 메모리 4. Sparse Attention: Local, Strided, BigBird 등 5. 위치 인코딩: Sinusoidal, Learned, RoPE, ALiBi | 기법 | 시간 | 공간 | 특징 | |-----|------|------|------| | Standard | O(n^2) |...", "url": "/study/ko/Deep_Learning/17_Attention_Deep_Dive.html"}, {"id": "Deep_Learning/18_Impl_Transformer", "title": "07. Transformer", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "Transformer는 \"Attention Is All You Need\" (Vaswani et al., 2017) 논문에서 제안된 아키텍처로, 현대 딥러닝의 핵심입니다. RNN 없이 Self-Attention만으로 시퀀스를 처리합니다. 1. Self-Attention: Query, Key, Value 연산 이해 2. Multi-Head Attention: 여러 attention head의 병렬 처리 3. Positional Encoding: 위치 정보 주입 4. Encoder-Decoder: 전체 아키텍처 구조 --- --- --- --- 1. Scaled Dot-Product Attention 직접 구현 2. Positional Encoding 시각화 3. Self-Attention 패턴 시각화 1. Multi-Head Attention 구현 2. Encoder 블록 완성 3. Decoder 블록 완성 (causal mask 포함) 1. KV Cache로...", "url": "/study/ko/Deep_Learning/18_Impl_Transformer.html"}, {"id": "Deep_Learning/19_Impl_BERT", "title": "08. BERT", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "BERT (Bidirectional Encoder Representations from Transformers)는 Google이 2018년에 발표한 모델로, NLP 분야에 혁명을 일으켰습니다. 양방향 컨텍스트를 사용하여 단어의 의미를 이해합니다. --- --- --- --- --- - F.linear, F.layernorm 사용 - nn.TransformerEncoder 미사용 - Embedding 수동 구현 - 논문의 정확한 사양 재현 - MLM + NSP pre-training - 분류 fine-tuning - HuggingFace transformers 코드 분석 - BertModel, BertForSequenceClassification --- - [ ] MLM 마스킹 전략 이해 - [ ] NSP 태스크 이해 - [ ] Token/Segment/Position Embedding 이해 - [ ] [CLS] 토큰의 역할 - [ ] Fine-tuning 방법 (분류, NER,...", "url": "/study/ko/Deep_Learning/19_Impl_BERT.html"}, {"id": "Deep_Learning/20_Impl_GPT", "title": "09. GPT", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "GPT (Generative Pre-trained Transformer)는 OpenAI가 개발한 자기회귀(autoregressive) 언어 모델입니다. 왼쪽에서 오른쪽으로 텍스트를 생성하며, 현대 LLM의 기반이 되었습니다. --- --- --- --- --- - Causal Attention 직접 구현 - Pre-LN 구조 - 텍스트 생성 함수 - GPT-2 정확한 사양 - WebText 스타일 학습 - 다양한 생성 전략 - HuggingFace GPT2 분석 - nanoGPT 코드 분석 --- - [ ] Causal mask 구현 - [ ] Pre-LN 구조 이해 - [ ] Weight tying 이해 - [ ] 다양한 생성 전략 구현 - [ ] KV Cache 최적화 - [ ] GPT vs BERT 차이점 --- - Radford et al. (2018). \"Improving Language Understanding by Generative Pre-Training\"...", "url": "/study/ko/Deep_Learning/20_Impl_GPT.html"}, {"id": "Deep_Learning/21_Vision_Transformer", "title": "19. Vision Transformer (ViT)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "- Vision Transformer 아키텍처 이해 - Patch Embedding 원리 - CLS 토큰과 Position Embedding - ViT 변형 모델들 (DeiT, Swin Transformer) - PyTorch 구현 및 활용 --- --- --- --- --- --- --- --- --- --- | 특성 | CNN | ViT | |-----|-----|-----| | 귀납적 편향 | 지역성, 등변성 | 없음 | | 데이터 요구량 | 적음 | 많음 | | 계산 복잡도 | O(n) | O(n²) | | 장거리 의존성 | 어려움 | 용이 | | 해석 가능성 | 필터 시각화 | Attention 시각화 | --- 1. Patch Embedding: 이미지를 패치 시퀀스로 변환 2. CLS Token: 전체 이미지 표현 학습 3. Position Embedding: 패치 위치 정보 제공 4. DeiT: 데이터 효율적 학습 (지식 증류) 5. Swin: 윈도우 기반 효율적...", "url": "/study/ko/Deep_Learning/21_Vision_Transformer.html"}, {"id": "Deep_Learning/22_Impl_ViT", "title": "22. Vision Transformer (ViT)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 비전 트랜스포머 | 다음: 학습 최적화 --- Vision Transformer (ViT)는 Transformer 아키텍처를 이미지 분류에 적용한 모델입니다. 이미지를 패치로 분할하고, 각 패치를 토큰처럼 처리합니다. \"An Image is Worth 16x16 Words\" (Dosovitskiy et al., 2020) --- --- --- --- --- - F.linear, F.layernorm 사용 - nn.TransformerEncoder 미사용 - 패치화 직접 구현 - 논문 정확한 사양 - JFT/ImageNet pre-training - Fine-tuning 코드 - timm 라이브러리 분석 - HuggingFace ViT 분석 --- - [ ] 패치 임베딩 수식 이해 - [ ] 위치 임베딩 역할 - [ ] [CLS] 토큰 역할 - [ ] CNN 대비 장단점 - [ ] Attention map 시각화 - [ ] Fine-tuning 전략 --- -...", "url": "/study/ko/Deep_Learning/22_Impl_ViT.html"}, {"id": "Deep_Learning/23_Training_Optimization", "title": "23. 학습 최적화", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: Vision Transformer (ViT) | 다음: 손실 함수 --- - 하이퍼파라미터 튜닝 전략 - 학습률 스케줄링 심화 - Mixed Precision Training - Gradient Accumulation --- | 파라미터 | 영향 | 일반적 범위 | |----------|------|------------| | Learning Rate | 수렴 속도/안정성 | 1e-5 ~ 1e-2 | | Batch Size | 메모리/일반화 | 16 ~ 512 | | Weight Decay | 과적합 방지 | 1e-5 ~ 1e-2 | | Dropout | 과적합 방지 | 0.1 ~ 0.5 | | Epochs | 학습량 | 데이터 의존적 | --- --- --- --- --- --- --- --- - [ ] 학습률 적절히 설정 (1e-4 시작 권장) - [ ] Warmup 사용 (Transformer 필수) - [ ] Mixed Precision 적용 (GPU 효율) - [...", "url": "/study/ko/Deep_Learning/23_Training_Optimization.html"}, {"id": "Deep_Learning/24_Loss_Functions", "title": "24. 손실 함수(Loss Functions)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 학습 최적화 | 다음: 옵티마이저 --- - 신경망 훈련에서 손실 함수의 역할과 최적화와의 관계 이해하기 - 회귀 손실(MSE, MAE, Huber)과 다양한 시나리오에서의 활용법 익히기 - 분류 손실(BCE, Cross-Entropy, Focal Loss)과 균형/불균형 데이터셋에서의 사용 사례 학습하기 - 표현 학습을 위한 메트릭 학습 손실(Contrastive, Triplet, InfoNCE) 탐구하기 - 세그멘테이션, 검출, 생성 모델을 위한 커스텀 손실 함수를 PyTorch로 구현하기 난이도: ⭐⭐⭐ --- 손실 함수(목적 함수(objective function) 또는 비용 함수(cost function)라고도 함)는 신경망의 예측이 정답과 얼마나 잘 일치하는지를 측정합니다. 훈련 중에는 SGD나 Adam과 같은 최적화 알고리즘을 사용하여 이 손실을 최소화합니다. 좋은 손실 함수의 주요 특성: - 미분 가능(Differentiable): 역전파를 위한 기울기가...", "url": "/study/ko/Deep_Learning/24_Loss_Functions.html"}, {"id": "Deep_Learning/25_Optimizers", "title": "25. 옵티마이저(Optimizers)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 손실 함수 | 다음: 정규화 레이어 --- - 경사 하강법의 변형들과 딥러닝의 최적화 환경 이해하기 - 고전적 옵티마이저(SGD, Momentum, Nesterov)와 적응적 방법(Adagrad, RMSprop, Adam, AdamW) 마스터하기 - 대규모 학습을 위한 현대적 옵티마이저(LAMB, Adafactor, Lion, 8-bit Adam) 탐구하기 - 학습률 스케줄러 구현하기(코사인 어닐링, OneCycleLR, 워밍업 전략) - 실용적인 최적화 기법 적용하기(그래디언트 클리핑, 축적, 파라미터 그룹별 설정) - 다양한 아키텍처와 과제에 적합한 옵티마이저와 하이퍼파라미터 선택하기 난이도: ⭐⭐⭐ --- 배치 경사 하강법(Batch Gradient Descent)은 전체 학습 데이터셋을 사용하여 그래디언트를 계산합니다: $$ \\theta{t+1} = \\thetat - \\eta \\nabla\\theta \\mathcal{L}(\\thetat) $$ 여기서...", "url": "/study/ko/Deep_Learning/25_Optimizers.html"}, {"id": "Deep_Learning/26_Normalization_Layers", "title": "26. 정규화 레이어(Normalization Layers)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 옵티마이저 | 다음: TensorBoard 시각화 --- - 딥러닝에서 정규화의 필요성과 손실 함수 지형을 부드럽게 만드는 원리 이해하기 - 배치 정규화, 레이어 정규화, 그룹 정규화와 각각의 사용 사례 마스터하기 - 현대 대형 언어 모델에서 선호되는 RMSNorm 학습하기 - 정규화 레이어를 처음부터 구현하고 계산상의 의미 이해하기 - 아키텍처와 배치 크기 제약에 따라 적절한 정규화 기법 적용하기 --- 내부 공변량 변화는 훈련 중 네트워크 활성화(activation) 분포의 변화를 의미합니다. 초기 레이어의 파라미터가 변경되면 후반 레이어의 입력이 변화하여 지속적으로 적응해야 합니다. 원래 동기 (Ioffe & Szegedy, 2015): - 레이어 간 활성화 분포 안정화 - 각 레이어가 더 안정적인 입력 분포에서 학습할 수 있도록 함 - 발산 없이 더 높은 학습률 사용 가능 최근 연구(Santurkar et al., 2018)는 정규화의 주요 이점이 손실 함수 지형...", "url": "/study/ko/Deep_Learning/26_Normalization_Layers.html"}, {"id": "Deep_Learning/27_TensorBoard", "title": "27. TensorBoard 시각화", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 정규화 레이어 | 다음: 생성 모델 - GAN --- - TensorBoard의 핵심 기능과 활용 사례 이해 - PyTorch에서 TensorBoard 연동 방법 습득 - 학습 메트릭, 모델 그래프, 임베딩 시각화 - 하이퍼파라미터 튜닝 결과 비교 분석 --- TensorBoard는 머신러닝 실험을 시각화하고 분석하기 위한 도구입니다. --- --- --- --- --- --- --- --- --- \\n{model_summary}\\n --- --- --- --- --- MNIST 분류 모델을 학습하면서 다음을 TensorBoard에 로깅하세요: - 학습/검증 손실 및 정확도 - 학습률 변화 - 샘플 입력 이미지 학습된 CNN 모델에 대해: - 가중치 히스토그램 시각화 - 특징 맵 시각화 - Grad-CAM 적용 학습률, 배치 크기, 드롭아웃 비율에 대해: - 그리드 서치 실행 - HParams 대시보드에서 결과 비교 - 최적 조합 찾기 --- - TensorBoard 공식...", "url": "/study/ko/Deep_Learning/27_TensorBoard.html"}, {"id": "Deep_Learning/28_Generative_Models_GAN", "title": "28. 생성 모델 - GAN (Generative Adversarial Networks)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: TensorBoard 시각화 | 다음: 생성적 적대 신경망(GAN) --- - GAN의 기본 원리와 적대적 학습 이해 - Generator와 Discriminator 구조 설계 - 다양한 손실 함수 (Adversarial, Wasserstein, WGAN-GP) - DCGAN 아키텍처 구현 - 학습 안정화 기법 적용 - StyleGAN 개념 이해 --- --- --- --- --- --- --- --- --- 1. GAN: Generator와 Discriminator의 적대적 학습 2. 손실 함수: BCE, Wasserstein, Gradient Penalty 3. DCGAN: Transposed Conv + BatchNorm + LeakyReLU 4. 안정화: Spectral Norm, TTUR, Progressive Growing 5. StyleGAN: Mapping Network + AdaIN으로 스타일 제어 | 손실 함수 | 장점 | 단점 |...", "url": "/study/ko/Deep_Learning/28_Generative_Models_GAN.html"}, {"id": "Deep_Learning/29_Impl_GAN", "title": "29. 생성적 적대 신경망(Generative Adversarial Networks, GAN)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 생성 모델 - GAN | 다음: 생성 모델 - VAE --- 생성적 적대 신경망(Generative Adversarial Networks, GAN)은 생성자(Generator)와 판별자(Discriminator) 간의 적대적 게임을 통해 현실적인 데이터를 생성하는 방법을 학습합니다. \"Generative Adversarial Networks\" (Goodfellow et al., 2014) --- --- 심층 합성곱 GAN(Deep Convolutional GAN, Radford et al., 2015) - 안정적인 학습 가이드라인 --- --- --- --- --- - 처음부터 DCGAN 아키텍처 구축 - 교대 학습 루프 구현 - MNIST 및 CIFAR-10에서 학습 - 생성된 샘플 시각화 - 학습 트릭이 있는 전체 DCGAN - 그래디언트 페널티가 있는 WGAN - 조건부 GAN (클래스 조건부) - 스타일 모듈레이션이 있는 단순화된 StyleGAN - FID/IS 평가...", "url": "/study/ko/Deep_Learning/29_Impl_GAN.html"}, {"id": "Deep_Learning/30_Generative_Models_VAE", "title": "30. 생성 모델 - VAE (Variational Autoencoder)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 생성적 적대 신경망(GAN) | 다음: Variational Autoencoder (VAE) --- - VAE의 이론적 기반 (Variational Inference) - Latent Space와 확률적 생성 이해 - ELBO 손실 함수 유도 - Reparameterization Trick - Beta-VAE와 Disentanglement - PyTorch 구현 및 시각화 --- --- --- --- --- --- --- --- | 특성 | VAE | GAN | |-----|-----|-----| | 학습 방식 | 우도 최대화 | 적대적 학습 | | 손실 함수 | ELBO (명시적) | Min-max (암시적) | | 학습 안정성 | 안정적 | 불안정 | | 이미지 품질 | 흐릿한 경향 | 선명함 | | 잠재 공간 | 구조화됨 | 해석 어려움 | | Mode Coverage | 좋음 | Mode Collapse 가능 | | 밀도 추정 | 가능 | 불가 | --- ---...", "url": "/study/ko/Deep_Learning/30_Generative_Models_VAE.html"}, {"id": "Deep_Learning/31_Impl_VAE", "title": "31. Variational Autoencoder (VAE)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 생성 모델 - VAE | 다음: 확산 모델 --- Variational Autoencoder (VAE)는 생성 모델의 기초가 되는 아키텍처로, 데이터의 잠재 표현(latent representation)을 학습하고 새로운 샘플을 생성할 수 있습니다. \"Auto-Encoding Variational Bayes\" (Kingma & Welling, 2013) --- --- --- --- --- - F.conv2d, F.linear 직접 사용 - reparameterization trick 구현 - ELBO 손실 함수 구현 - β-VAE 구현 - CVAE (Conditional) 구현 - 잠재 공간 시각화 --- - [ ] ELBO 유도 과정 이해 - [ ] Reparameterization trick 이해 - [ ] KL divergence 계산 - [ ] β의 역할 이해 - [ ] 잠재 공간 시각화 - [ ] Conditional VAE 구현 --- - Kingma &...", "url": "/study/ko/Deep_Learning/31_Impl_VAE.html"}, {"id": "Deep_Learning/32_Diffusion_Models", "title": "32. Diffusion Models", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: Variational Autoencoder (VAE) | 다음: 확산 모델(DDPM) --- - Diffusion Process 이론 이해 (Forward/Reverse) - DDPM (Denoising Diffusion Probabilistic Models) 원리 - Score-based Generative Models 개념 - U-Net 아키텍처 for Diffusion - Stable Diffusion 핵심 원리 - Classifier-free Guidance - 간단한 DDPM PyTorch 구현 --- --- --- --- --- --- --- --- --- --- 1. Forward Process: 점진적 노이즈 추가 q(xt|x0) 2. Reverse Process: 점진적 노이즈 제거 p(x{t-1}|xt) 3. DDPM: 노이즈 예측으로 역과정 학습 4. DDIM: 결정론적 샘플링으로 빠른 생성 5. Latent Diffusion: 잠재 공간에서 효율적 생성...", "url": "/study/ko/Deep_Learning/32_Diffusion_Models.html"}, {"id": "Deep_Learning/33_Impl_Diffusion", "title": "33. 확산 모델(Diffusion Models, DDPM)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: Diffusion Models | 다음: CLIP과 멀티모달 학습 --- 디노이징 확산 확률 모델(Denoising Diffusion Probabilistic Models, DDPM)은 점진적인 노이즈 추가 과정을 역전시켜 데이터를 생성하는 강력한 생성 모델입니다. \"Denoising Diffusion Probabilistic Models\" (Ho et al., 2020) --- --- --- --- --- --- - 순방향/역방향 확산 구현 - 노이즈 스케줄(선형) 구현 - 시간 임베딩이 있는 UNet 구축 - MNIST (28×28) 및 CIFAR-10 (32×32)에서 학습 - 코사인 스케줄을 갖는 전체 DDPM - DDIM 샘플링 (빠른 추론) - 분류기 프리 가이던스 - FID/IS 평가 메트릭 --- --- --- - [ ] 순방향 확산 닫힌 형식 이해 - [ ] ELBO에서 역방향 확산 유도 - [ ] 노이즈 스케줄 구현 (선형, 코사인) - [ ] 시간...", "url": "/study/ko/Deep_Learning/33_Impl_Diffusion.html"}, {"id": "Deep_Learning/34_CLIP_Multimodal", "title": "34. CLIP과 멀티모달 학습", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 확산 모델(DDPM) | 다음: CLIP (Contrastive Language-Image Pre-training) --- - CLIP 아키텍처와 원리 이해 - Contrastive Learning 기반 Image-Text 매칭 - Zero-shot Classification 구현 - BLIP, ALIGN 등 후속 모델 소개 - PyTorch 활용 및 실습 --- --- --- --- --- --- --- --- --- --- --- 1. Contrastive Learning: 이미지-텍스트 쌍의 유사도 학습 2. Zero-shot: 학습 시 본 적 없는 클래스 분류 3. Temperature: 유사도 분포의 sharpness 조절 4. Prompt Engineering: 텍스트 템플릿으로 성능 향상 5. 멀티모달 표현: 공통 임베딩 공간에서 검색/비교 | 모델 | 특징 | 장점 | |------|------|------| | CLIP | Contrastive |...", "url": "/study/ko/Deep_Learning/34_CLIP_Multimodal.html"}, {"id": "Deep_Learning/35_Impl_CLIP", "title": "35. CLIP (Contrastive Language-Image Pre-training)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: CLIP과 멀티모달 학습 | 다음: Self-Supervised Learning --- CLIP은 이미지와 텍스트를 같은 임베딩 공간에 매핑하여 zero-shot 이미지 분류를 가능하게 합니다. \"Learning Transferable Visual Models From Natural Language Supervision\" (Radford et al., 2021) --- --- --- --- --- - Image encoder (ViT) 직접 구현 - Text encoder (Transformer) 직접 구현 - Contrastive loss 구현 - 전체 학습 파이프라인 - Zero-shot 평가 - Prompt engineering - OpenAI CLIP 코드 분석 - openclip 라이브러리 분석 --- - [ ] Contrastive learning 이해 - [ ] InfoNCE loss 수식 이해 - [ ] Zero-shot classification 구현 - [...", "url": "/study/ko/Deep_Learning/35_Impl_CLIP.html"}, {"id": "Deep_Learning/36_Self_Supervised_Learning", "title": "36. Self-Supervised Learning", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: CLIP (Contrastive Language-Image Pre-training) | 다음: 현대 딥러닝 아키텍처 --- - Self-Supervised Learning 개념과 필요성 이해 - Contrastive Learning (SimCLR, MoCo, BYOL) - Masked Image Modeling (MAE) - 사전학습 표현의 전이 학습 - PyTorch 구현 및 실습 --- --- --- --- --- --- --- --- | 방법 | Negative | 배치 사이즈 | 주요 특징 | |------|----------|-------------|----------| | SimCLR | 필요 | 4096+ | 단순, 강력한 augmentation | | MoCo | 필요 (Queue) | 256 | 메모리 효율적 | | BYOL | 불필요 | 256 | Predictor + EMA | | SimSiam | 불필요 | 256 | BYOL 단순화 (EMA 없음) |...", "url": "/study/ko/Deep_Learning/36_Self_Supervised_Learning.html"}, {"id": "Deep_Learning/37_Modern_Architectures", "title": "37. 현대 딥러닝 아키텍처", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: Self-Supervised Learning | 다음: 객체 탐지 --- - 최근 딥러닝 아키텍처 혁신(2020-2024) 살펴보기 - ConvNeXt와 Transformer 시대의 순수 ConvNet의 진화 이해하기 - EfficientNetV2와 점진적 학습 전략(progressive training strategies)에 대해 배우기 - 자기지도 학습 비전 파운데이션 모델인 DINOv2 탐구하기 - 빠른 확산 샘플링을 위한 잠재 일관성 모델(Latent Consistency Models, LCM) 이해하기 - timm 및 transformers 라이브러리를 사용한 사전학습된 현대 아키텍처 적용하기 --- 딥러닝 아키텍처 환경은 빠르게 진화해왔습니다: 1. 하이브리드 아키텍처: 합성곱(convolutions)과 어텐션(attention) 결합 2. 자기지도 사전학습(Self-supervised pretraining): DINO, MAE, CLIP 3. 스케일링...", "url": "/study/ko/Deep_Learning/37_Modern_Architectures.html"}, {"id": "Deep_Learning/38_Object_Detection", "title": "38. 객체 탐지 (Object Detection)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 현대 딥러닝 아키텍처 | 다음: 실전 이미지 분류 프로젝트 --- - Two-stage vs One-stage 탐지기 차이 이해 - YOLO 아키텍처와 발전 과정 학습 - Faster R-CNN의 구조와 RPN 이해 - DETR (Detection Transformer) 개념 파악 - PyTorch/Ultralytics로 실습 --- --- --- --- --- --- --- | 요구사항 | 추천 모델 | |----------|----------| | 실시간 (30+ FPS) | YOLOv8n/s | | 높은 정확도 | YOLOv8x, Faster R-CNN | | 작은 객체 | YOLO + SAHI, RetinaNet | | 인스턴스 분할 | YOLOv8-seg, Mask R-CNN | | End-to-end | DETR, RT-DETR | | Zero-shot | Grounding DINO, SAM | | 개념 | 설명 | |------|------| | IoU | 박스...", "url": "/study/ko/Deep_Learning/38_Object_Detection.html"}, {"id": "Deep_Learning/39_Practical_Image_Classification", "title": "39. 실전 이미지 분류 프로젝트", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 객체 탐지 | 다음: 실전 텍스트 분류 프로젝트 --- - CIFAR-10 분류 프로젝트 완성 - 데이터 증강 전략 - 학습 파이프라인 구축 - 성능 개선 기법 적용 --- | 모델 | 목표 정확도 | |------|------------| | 간단한 CNN | 70-75% | | ResNet-like | 85-90% | | 전이학습 | 90%+ | --- --- --- --- --- --- --- - [ ] 데이터 증강 적용 - [ ] BatchNorm + Dropout 사용 - [ ] 적절한 스케줄러 (Cosine Annealing) - [ ] Weight Decay 사용 - [ ] Mixup/CutMix 고려 - [ ] 모델 저장 및 분석 | 기법 | 테스트 정확도 | |------|--------------| | 기본 CNN | 75-80% | | + 데이터 증강 | 80-85% | | + Mixup | 85-88% | | ResNet + 전이학습 | 90%+ |...", "url": "/study/ko/Deep_Learning/39_Practical_Image_Classification.html"}, {"id": "Deep_Learning/40_Practical_Text_Classification", "title": "40. 실전 텍스트 분류 프로젝트", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 실전 이미지 분류 프로젝트 | 다음: 모델 저장 및 배포 --- - 텍스트 전처리 및 토큰화 - 임베딩 레이어 사용 - LSTM/Transformer 기반 분류기 - 감성 분석 프로젝트 --- --- --- --- --- --- --- --- --- - [ ] 토큰화 및 어휘 구축 - [ ] 패딩 처리 - [ ] 임베딩 (학습 또는 사전학습) - [ ] 모델 선택 (LSTM/Transformer) - [ ] 기울기 클리핑 - [ ] 평가 및 추론 | 모델 | 장점 | 단점 | |------|------|------| | LSTM | 구현 간단, 빠른 학습 | 긴 시퀀스 어려움 | | Transformer | 병렬화, 긴 시퀀스 | 메모리 많이 필요 | | BERT (전이학습) | 최고 성능 | 느림, 무거움 | | 모델 | 정확도 | |------|--------| | LSTM | 85-88% | | Transformer | 87-90% | | BERT...", "url": "/study/ko/Deep_Learning/40_Practical_Text_Classification.html"}, {"id": "Deep_Learning/41_Model_Saving_Deployment", "title": "41. 모델 저장 및 배포", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 실전 텍스트 분류 프로젝트 | 다음: 강화학습 소개 --- - PyTorch 모델 저장 방법 - ONNX 변환 - TorchScript 사용 - 추론 최적화 --- --- | 방법 | 장점 | 단점 | |------|------|------| | Trace | 간단, 대부분 동작 | 동적 제어 흐름 불가 | | Script | 동적 제어 흐름 지원 | 일부 Python 기능 제한 | --- --- --- --- --- --- --- | 용도 | 방법 | |------|------| | 학습 재개 | 체크포인트 (statedict + optimizer) | | Python 배포 | statedict | | C++ 배포 | TorchScript | | 범용 배포 | ONNX | | 모바일 | PyTorch Mobile | --- 39PracticalImage_Classification.md에서 실전 프로젝트를 진행합니다.", "url": "/study/ko/Deep_Learning/41_Model_Saving_Deployment.html"}, {"id": "Deep_Learning/42_Reinforcement_Learning_Intro", "title": "42. 강화학습 입문 (Reinforcement Learning Introduction)", "topic": "Deep_Learning", "topic_display": "Deep Learning", "body": "이전: 모델 저장 및 배포 --- - 강화학습의 기본 개념과 용어 이해 - MDP (Markov Decision Process) 프레임워크 - Q-Learning과 Value-based 방법 - Policy Gradient 개요 - Deep RL 기초 (DQN) - PyTorch 구현 및 실습 --- --- --- --- --- --- --- --- --- | 알고리즘 | 유형 | On/Off-Policy | 특징 | |----------|------|---------------|------| | Q-Learning | Value-based | Off-policy | 테이블, 간단 | | DQN | Value-based | Off-policy | 신경망, 경험 재현 | | REINFORCE | Policy-based | On-policy | Monte Carlo, 높은 분산 | | A2C/A3C | Actor-Critic | On-policy | Advantage, 병렬화 | |...", "url": "/study/ko/Deep_Learning/42_Reinforcement_Learning_Intro.html"}, {"id": "Docker/00_Overview", "title": "Docker & Kubernetes 학습 가이드", "topic": "Docker", "topic_display": "Docker", "body": "이 폴더는 Docker와 Kubernetes를 학습하기 위한 자료를 담고 있습니다. 컨테이너의 기본 개념부터 오케스트레이션까지 단계별로 학습할 수 있습니다. 대상 독자: 개발자, DevOps 입문자 --- --- - 리눅스 기본 명령어 - 터미널/쉘 사용 경험 - 웹 애플리케이션 기본 이해 (권장) --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01DockerBasics.md | ⭐ | Docker 개념, 설치, 기본 명령어 | | 02ImagesandContainers.md | ⭐ | 이미지 관리, 컨테이너 실행/관리 | | 03Dockerfile.md | ⭐⭐ | Dockerfile 작성, 이미지 빌드 | | 04DockerCompose.md | ⭐⭐ | 다중 컨테이너, docker-compose.yml | | 05PracticalExamples.md | ⭐⭐⭐ | 웹앱 컨테이너화, DB 연동 | |...", "url": "/study/ko/Docker/00_Overview.html"}, {"id": "Docker/01_Docker_Basics", "title": "Docker 기초", "topic": "Docker", "topic_display": "Docker", "body": "Docker는 컨테이너 기반 가상화 플랫폼입니다. 애플리케이션과 그 실행 환경을 패키징하여 어디서든 동일하게 실행할 수 있게 해줍니다. 문제 상황: Docker 해결책: | 장점 | 설명 | |------|------| | 일관성 | 개발/테스트/운영 환경 동일 | | 격리 | 애플리케이션 간 독립 실행 | | 이식성 | 어디서든 동일하게 실행 | | 경량 | VM보다 빠르고 가벼움 | | 버전 관리 | 이미지로 환경 버전 관리 | --- --- - 컨테이너를 만들기 위한 템플릿 - 읽기 전용 - 레이어 구조로 구성 - 이미지를 실행한 인스턴스 - 읽기/쓰기 가능 - 격리된 환경에서 실행 - Docker 이미지 저장소 (GitHub 같은 역할) - 공식 이미지 제공: nginx, node, python, mysql 등 - https://hub.docker.com --- Docker Desktop 설치 (권장): 1. Docker Desktop 다운로드 2. DMG 파일 실행 3....", "url": "/study/ko/Docker/01_Docker_Basics.html"}, {"id": "Docker/02_Images_and_Containers", "title": "Docker 이미지와 컨테이너", "topic": "Docker", "topic_display": "Docker", "body": "- 컨테이너를 만들기 위한 읽기 전용 템플릿 - 애플리케이션 + 실행 환경 포함 - 레이어 구조로 효율적 저장 | 구성요소 | 설명 | 예시 | |----------|------|------| | 레지스트리 | 이미지 저장소 | docker.io, gcr.io | | 저장소 | 이미지 이름 | nginx, node | | 태그 | 버전 | latest, 1.25, alpine | --- --- --- --- --- --- | 명령어 | 설명 | |--------|------| | | 이미지 다운로드 | | | 이미지 목록 | | | 이미지 삭제 | | | 미사용 이미지 삭제 | | 명령어 | 설명 | |--------|------| | | 컨테이너 생성 및 실행 | | | 실행 중인 컨테이너 | | | 모든 컨테이너 | | | 컨테이너 중지 | | | 컨테이너 시작 | | | 컨테이너 삭제 | | | 로그 확인 | | | 컨테이너 접속 | | 옵션 | 설명 |...", "url": "/study/ko/Docker/02_Images_and_Containers.html"}, {"id": "Docker/03_Dockerfile", "title": "Dockerfile", "topic": "Docker", "topic_display": "Docker", "body": "Dockerfile은 Docker 이미지를 만들기 위한 설정 파일입니다. 텍스트 파일에 명령어를 작성하면 Docker가 순서대로 실행하여 이미지를 생성합니다. | 장점 | 설명 | |------|------| | 재현성 | 동일한 이미지를 반복 생성 | | 자동화 | 수동 설정 불필요 | | 버전 관리 | Git으로 이력 추적 | | 문서화 | 환경 설정이 코드로 기록 | --- | 명령어 | 설명 | 예시 | |--------|------|------| | | 베이스 이미지 | | | | 작업 디렉토리 | | | | 파일 복사 | | | | 빌드 시 명령 실행 | | | | 컨테이너 시작 명령 | | | | 포트 노출 | | | | 환경 변수 | | --- 모든 Dockerfile은 으로 시작합니다. 이후 명령어가 실행될 디렉토리를 설정합니다. 호스트의 파일을 이미지로 복사합니다. 이미지 빌드 중에 실행됩니다. 컨테이너가 시작될 때 실행됩니다. --- 프로젝트 구조:...", "url": "/study/ko/Docker/03_Dockerfile.html"}, {"id": "Docker/04_Docker_Compose", "title": "Docker Compose", "topic": "Docker", "topic_display": "Docker", "body": "Docker Compose는 여러 컨테이너를 정의하고 실행하는 도구입니다. YAML 파일 하나로 전체 애플리케이션 스택을 관리합니다. 일반 Docker 명령어: Docker Compose: | 장점 | 설명 | |------|------| | 간편함 | 한 명령으로 전체 실행 | | 선언적 | YAML로 명확하게 정의 | | 버전 관리 | 설정 파일을 Git으로 관리 | | 재현성 | 동일한 환경 재현 가능 | --- Docker Desktop에는 Docker Compose가 포함되어 있습니다. > 참고: (하이픈)은 구버전, (공백)은 신버전입니다. --- --- .env 파일: > 주의: 은 시작 순서만 보장합니다. 서비스가 \"준비\"될 때까지 기다리지 않습니다. --- --- 프로젝트 구조: docker-compose.yml: app/Dockerfile: app/index.js: 실행: .env: 실행: --- --- | 명령어 | 설명 | |--------|------| |...", "url": "/study/ko/Docker/04_Docker_Compose.html"}, {"id": "Docker/05_Practical_Examples", "title": "Docker 실전 예제", "topic": "Docker", "topic_display": "Docker", "body": "이 문서에서는 실제 프로젝트에 Docker를 적용하는 방법을 단계별로 실습합니다. --- backend/package.json: backend/src/index.js: backend/Dockerfile: backend/.dockerignore: db/init.sql: .env: docker-compose.yml: --- package.json: public/index.html: src/index.js: src/App.js: Dockerfile (멀티 스테이지 빌드): nginx.conf: docker-compose.yml: --- docker-compose.yml: docker-compose.dev.yml (개발용 오버라이드): --- .env: --- --- Docker 학습을 완료했습니다. 다음 단계로: 1. 실습: 자신의 프로젝트를 Docker화 해보기 2. CI/CD: GitHub Actions와 Docker 연동 3. 오케스트레이션: Kubernetes 기초 학습 4....", "url": "/study/ko/Docker/05_Practical_Examples.html"}, {"id": "Docker/06_Kubernetes_Intro", "title": "Kubernetes 입문", "topic": "Docker", "topic_display": "Docker", "body": "Kubernetes(K8s)는 컨테이너 오케스트레이션 플랫폼입니다. 여러 컨테이너의 배포, 확장, 관리를 자동화합니다. | Docker | Kubernetes | |--------|------------| | 컨테이너 실행 | 컨테이너 관리/오케스트레이션 | | 단일 호스트 | 클러스터 (여러 서버) | | 수동 스케일링 | 자동 스케일링 | | 단순 배포 | 롤링 업데이트, 롤백 | 문제 상황: Kubernetes 해결책: --- | 구성 요소 | 역할 | |-----------|------| | API Server | 모든 요청을 처리하는 중앙 게이트웨이 | | Scheduler | Pod를 어느 Node에 배치할지 결정 | | Controller Manager | 원하는 상태 유지 (복제, 배포 등) | | etcd | 클러스터 상태 저장소 | | kubelet | 각 Node에서 컨테이너 실행 관리 | | kube-proxy | 네트워크 프록시, 서비스 로드밸런싱 | ---...", "url": "/study/ko/Docker/06_Kubernetes_Intro.html"}, {"id": "Docker/07_Kubernetes_Security", "title": "07. Kubernetes 보안", "topic": "Docker", "topic_display": "Docker", "body": "- Kubernetes 보안 아키텍처 이해 - RBAC을 통한 접근 제어 구현 - NetworkPolicy로 네트워크 격리 - Secrets 및 민감 정보 관리 - Pod 보안 정책 적용 1. Kubernetes 보안 개요 2. RBAC (역할 기반 접근 제어) 3. ServiceAccount 4. NetworkPolicy 5. Secrets 관리 6. Pod 보안 7. 연습 문제 --- --- --- --- --- --- --- --- - 08Kubernetes심화 - Ingress, StatefulSet, PV/PVC - 09Helm패키지관리 - Helm 차트 관리 - 10CICD_파이프라인 - 자동화 배포 - Kubernetes Security Best Practices - RBAC Documentation - Network Policies - Pod Security Standards --- ← 이전: Docker Compose | 다음: Kubernetes 심화 → | 목차", "url": "/study/ko/Docker/07_Kubernetes_Security.html"}, {"id": "Docker/08_Kubernetes_Advanced", "title": "08. Kubernetes 심화", "topic": "Docker", "topic_display": "Docker", "body": "- Ingress를 통한 외부 트래픽 라우팅 - StatefulSet으로 상태 있는 애플리케이션 관리 - PersistentVolume/PersistentVolumeClaim 활용 - ConfigMap과 Secret 고급 사용법 - DaemonSet과 Job 활용 1. Ingress 2. StatefulSet 3. 영구 스토리지 4. ConfigMap 고급 5. DaemonSet과 Job 6. 고급 스케줄링 7. 연습 문제 --- --- --- --- --- --- --- --- - 09Helm패키지관리 - Helm 차트 - 10CICD파이프라인 - 자동화 배포 - 07Kubernetes_보안 - 보안 복습 - Kubernetes Ingress - StatefulSets - Persistent Volumes - DaemonSet --- ← 이전: Kubernetes 보안 | 다음: Helm 패키지관리 → | 목차", "url": "/study/ko/Docker/08_Kubernetes_Advanced.html"}, {"id": "Docker/09_Helm_Package_Management", "title": "09. Helm 패키지 관리", "topic": "Docker", "topic_display": "Docker", "body": "- Helm의 개념과 구조 이해 - Helm 차트 생성 및 관리 - values.yaml을 통한 설정 커스터마이징 - 템플릿 함수와 조건문 활용 - 차트 저장소 관리 및 배포 1. Helm 개요 2. Helm 설치 및 설정 3. 차트 구조 4. 템플릿 작성 5. Values와 설정 6. 차트 관리 7. 연습 문제 --- --- --- --- --- --- --- --- - 10CICD파이프라인 - GitHub Actions와 배포 자동화 - 07Kubernetes보안 - 보안 복습 - 08Kubernetes_심화 - 고급 K8s 기능 - Helm 공식 문서 - Helm 차트 모범 사례 - Helm 템플릿 가이드 - Artifact Hub - 차트 검색 --- ← 이전: Kubernetes 심화 | 다음: CI/CD 파이프라인 → | 목차", "url": "/study/ko/Docker/09_Helm_Package_Management.html"}, {"id": "Docker/10_CI_CD_Pipelines", "title": "10. CI/CD 파이프라인", "topic": "Docker", "topic_display": "Docker", "body": "- CI/CD 개념과 워크플로우 이해 - GitHub Actions를 활용한 자동화 구축 - Docker 이미지 빌드 및 레지스트리 푸시 - Kubernetes 자동 배포 구현 - GitOps 패턴 이해 1. CI/CD 개요 2. GitHub Actions 기초 3. Docker 빌드 자동화 4. Kubernetes 배포 자동화 5. 고급 파이프라인 6. GitOps 7. 연습 문제 --- --- --- --- --- --- --- --- - 07Kubernetes보안 - 보안 복습 - 08Kubernetes심화 - 고급 K8s 기능 - 09Helm패키지관리 - Helm 차트 - GitHub Actions 문서 - Docker Build Push Action - ArgoCD 문서 - GitOps 원칙 --- ← 이전: Helm 패키지관리 | 목차", "url": "/study/ko/Docker/10_CI_CD_Pipelines.html"}, {"id": "Docker/11_Container_Networking", "title": "컨테이너 네트워킹(Container Networking)", "topic": "Docker", "topic_display": "Docker", "body": "- Docker 네트워크 드라이버(Network Drivers)와 사용 사례 이해 - 브리지(Bridge), 호스트(Host), 오버레이(Overlay), 맥브이랜(Macvlan) 네트워크 마스터하기 - 서브넷(Subnet), 게이트웨이(Gateway), DNS를 사용한 커스텀 네트워크 구성 - 서비스 디스커버리(Service Discovery)와 컨테이너 간 통신 구현 - 네트워크 연결성 문제 해결 - 네트워크 보안 모범 사례 적용 1. Docker 네트워크 드라이버 2. 브리지 네트워크 심화 3. 호스트 및 None 네트워크 4. 오버레이 네트워크 5. 네트워크 구성 6. DNS와 서비스 디스커버리 7. 고급 포트 매핑 8. 네트워크 보안 9. 문제 해결 10. 연습 문제 난이도: ⭐⭐⭐ --- Docker는 다양한 사용 사례를 위한 여러 네트워크 드라이버를 제공합니다. | 드라이버(Driver) | 사용 사례 | 범위(Scope) | DNS |...", "url": "/study/ko/Docker/11_Container_Networking.html"}, {"id": "Docker/12_Security_Best_Practices", "title": "보안 모범 사례(Security Best Practices)", "topic": "Docker", "topic_display": "Docker", "body": "- 컨테이너 보안 위협 모델 이해 - 이미지 보안 모범 사례 및 취약점 스캐닝 적용 - 런타임 보안 제어 및 최소 권한 구현 - 컨테이너화된 애플리케이션에서 시크릿을 안전하게 관리 - 네트워크 보안 및 격리 구성 - 서명 및 콘텐츠 신뢰로 컨테이너 레지스트리 보안 - Kubernetes 보안 컨텍스트(Security Context) 및 Pod 보안 표준 적용 - 컨테이너 런타임 동작 모니터링 및 감사 1. 컨테이너 보안 개요 2. 이미지 보안 3. Dockerfile 모범 사례 4. 런타임 보안 5. 시크릿 관리 6. 네트워크 보안 7. 컨테이너 레지스트리 보안 8. Kubernetes 보안 컨텍스트 9. 모니터링 및 감사 10. 연습 문제 난이도: ⭐⭐⭐⭐ --- 1. 최소 권한(Least Privilege): 필요한 최소 권한으로 실행 2. 심층 방어(Defense in Depth): 여러 계층의 보안 제어 3. 불변성(Immutability): 컨테이너를 불변 아티팩트로 취급...", "url": "/study/ko/Docker/12_Security_Best_Practices.html"}, {"id": "Foundation_Models/00_Overview", "title": "Foundation Models 학습 가이드", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "Foundation Models(기반 모델)은 대규모 데이터로 사전 학습되어 다양한 하위 작업에 적용 가능한 모델을 의미합니다. 이 폴더는 Foundation Model의 패러다임, Scaling Laws, 최신 아키텍처, 그리고 실무 적용을 다룹니다. - DeepLearning 폴더: ViT, CLIP, Self-Supervised Learning, Transformer - LLMandNLP 폴더: BERT, GPT, HuggingFace, Fine-tuning, RAG 1. Foundation Model 패러다임과 Scaling Laws 이해 2. LLaMA, Mistral, DINOv2, SAM 등 최신 모델 아키텍처 파악 3. 효율적인 적응(PEFT) 및 배포 전략 습득 4. Multimodal Foundation Models의 동작 원리 이해 --- | 파일 | 주제 | 핵심 내용 | 난이도 | |------|------|----------|--------| |...", "url": "/study/ko/Foundation_Models/00_Overview.html"}, {"id": "Foundation_Models/01_Foundation_Model_Paradigm", "title": "Foundation Model 패러다임", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "- Foundation Model의 정의와 특징 이해 - 전통적 ML에서 Foundation Model로의 패러다임 전환 파악 - In-context Learning과 Emergent Capabilities 개념 습득 - 주요 Foundation Model 계보 파악 --- Foundation Model(기반 모델)은 2021년 Stanford HAI에서 제안한 용어로, 다음 특징을 가진 모델을 의미합니다: | 분류 | 대표 모델 | 입력/출력 | |------|----------|----------| | Language Models | GPT-4, LLaMA, Claude | 텍스트 → 텍스트 | | Vision Models | ViT, DINOv2, SAM | 이미지 → 특징/세그멘테이션 | | Multimodal | CLIP, LLaVA, GPT-4V | 텍스트+이미지 → 텍스트 | | Generative | Stable Diffusion, DALL-E | 텍스트 → 이미지...", "url": "/study/ko/Foundation_Models/01_Foundation_Model_Paradigm.html"}, {"id": "Foundation_Models/02_Scaling_Laws", "title": "Scaling Laws", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "- Scaling Laws의 개념과 수학적 형태 이해 - Kaplan et al. vs Chinchilla 법칙 비교 - Compute-optimal 학습 전략 습득 - 실무에서의 Scaling Laws 활용법 파악 --- Scaling Laws는 모델의 파라미터 수(N), 데이터 양(D), 계산량(C)과 성능(Loss)의 관계를 설명하는 경험적 법칙입니다. --- Kaplan et al.의 2020년 논문 \"Scaling Laws for Neural Language Models\"에서 발견한 법칙: --- Hoffmann et al.의 \"Training Compute-Optimal Large Language Models\"는 Kaplan 법칙을 수정: --- --- | 모델 | 파라미터 (N) | 토큰 (D) | D/N 비율 | 상태 | |------|-------------|----------|----------|------| | GPT-3 | 175B | 300B | 1.7 |...", "url": "/study/ko/Foundation_Models/02_Scaling_Laws.html"}, {"id": "Foundation_Models/03_Emergent_Abilities", "title": "Emergent Abilities (창발적 능력)", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "- Emergent Abilities의 정의와 특징 이해 - 규모에 따른 능력 출현 패턴 파악 - Chain-of-Thought 등 주요 창발적 능력 학습 - Capability Elicitation(능력 유도) 기법 습득 --- Emergent Abilities(창발적 능력)은 작은 모델에서는 없다가 특정 규모 이상에서 갑자기 나타나는 능력을 의미합니다. --- | 능력 | 설명 | 출현 규모 (대략) | |------|------|-----------------| | Arithmetic | 다자리 덧셈/뺄셈 | ~10^22 FLOPs | | Word Unscrambling | 섞인 문자 복원 | ~10^22 FLOPs | | Chain-of-Thought | 단계적 추론 | ~10^23 FLOPs | | Multi-step Math | 복잡한 수학 문제 | ~10^23 FLOPs | | Code Generation | 복잡한 코드 작성 | ~10^23 FLOPs | |...", "url": "/study/ko/Foundation_Models/03_Emergent_Abilities.html"}, {"id": "Foundation_Models/04_Pretraining_Objectives", "title": "04. Pre-training 목적함수", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "Pre-training 목적함수는 Foundation Model이 대규모 데이터에서 어떤 패턴을 학습할지 결정합니다. 목적함수 선택이 모델의 능력과 downstream task 성능에 직접적인 영향을 미칩니다. --- | 특성 | Causal LM | Masked LM | Prefix LM | |------|-----------|-----------|-----------| | 대표 모델 | GPT, LLaMA | BERT, RoBERTa | T5, BART | | 컨텍스트 | 왼쪽만 참조 | 양방향 참조 | 인코더: 양방향, 디코더: 왼쪽 | | 학습 신호 | 모든 토큰 | 마스킹된 토큰만 (15%) | Span/시퀀스 | | 생성 능력 | 자연스러운 생성 | 추가 학습 필요 | 자연스러운 생성 | | 이해 능력 | Zero-shot으로 가능 | 강력한 표현 학습 | 균형적 | --- --- --- --- --- --- | 모델 크기 | 권장 접근법 | 이유 |...", "url": "/study/ko/Foundation_Models/04_Pretraining_Objectives.html"}, {"id": "Foundation_Models/05_Data_Curation", "title": "05. 데이터 큐레이션", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "Foundation Model의 성능은 데이터 품질과 다양성에 크게 의존합니다. \"Garbage in, garbage out\"이 그 어느 때보다 중요합니다. 이 레슨에서는 대규모 사전학습 데이터셋의 구축, 정제, 관리 방법을 다룹니다. --- | 데이터셋 | 크기 | 소스 | 특징 | |----------|------|------|------| | The Pile | 825GB | 22개 다양한 소스 | 코드, 학술, 책 포함 | | C4 | 750GB | Common Crawl | 영어만, 필터링됨 | | RedPajama | 1.2T 토큰 | LLaMA 레시피 복제 | 오픈소스 | | ROOTS | 1.6TB | 59개 언어 | 다국어, BigScience | | FineWeb | 15T 토큰 | Common Crawl | HuggingFace, 최신 | | Dolma | 3T 토큰 | 다양한 소스 | Allen AI, 투명성 강조 | --- --- --- --- --- ---...", "url": "/study/ko/Foundation_Models/05_Data_Curation.html"}, {"id": "Foundation_Models/06_Pretraining_Infrastructure", "title": "06. Pre-training 인프라", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "대규모 Foundation Model 학습은 수천 개의 GPU에서 수주에서 수개월간 진행됩니다. 이 레슨에서는 분산 학습 전략, 메모리 최적화, 학습 안정성 기법을 다룹니다. --- --- --- --- --- --- --- --- - PyTorch FSDP - DeepSpeed - Megatron-LM - Rajbhandari et al. (2020). \"ZeRO: Memory Optimizations Toward Training Trillion Parameter Models\" - Narayanan et al. (2021). \"Efficient Large-Scale Language Model Training on GPU Clusters\" - ../DeepLearning/11ModelDeployment.md - ../MLOps/08ModelServingBasics.md", "url": "/study/ko/Foundation_Models/06_Pretraining_Infrastructure.html"}, {"id": "Foundation_Models/07_Tokenization_Deep_Dive", "title": "07. Tokenization 심화", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "Tokenization은 텍스트를 모델이 처리할 수 있는 토큰 시퀀스로 변환하는 과정입니다. Foundation Model의 성능과 효율성에 직접적인 영향을 미치는 중요한 전처리 단계입니다. --- | 알고리즘 | 방식 | 대표 모델 | 특징 | |----------|------|-----------|------| | BPE | 빈도 기반 병합 | GPT, RoBERTa, LLaMA | 가장 널리 사용 | | WordPiece | 우도 기반 병합 | BERT, DistilBERT | 확률적 선택 | | Unigram | 확률 모델 | T5, ALBERT, XLNet | 최적 분할 탐색 | | SentencePiece | 언어 독립적 | 다국어 모델 | BPE/Unigram 구현 | --- --- --- --- --- --- --- --- --- - Sennrich et al. (2016). \"Neural Machine Translation of Rare Words with...", "url": "/study/ko/Foundation_Models/07_Tokenization_Deep_Dive.html"}, {"id": "Foundation_Models/08_LLaMA_Family", "title": "LLaMA Family", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "- LLaMA 1/2/3의 아키텍처 진화 이해 - RoPE, RMSNorm, SwiGLU 등 핵심 기술 습득 - Grouped Query Attention (GQA) 메커니즘 파악 - 실무에서의 LLaMA 활용법 학습 --- LLaMA(Large Language Model Meta AI)는 2023년 Meta가 공개한 오픈소스 LLM으로, Foundation Model 연구의 민주화를 이끌었습니다. | 특성 | LLaMA 1 | LLaMA 2 | LLaMA 3 | LLaMA 3.1 | LLaMA 3.2 | |------|---------|---------|---------|-----------|-----------| | 출시 | 2023.02 | 2023.07 | 2024.04 | 2024.07 | 2024.09 | | 크기 | 7/13/33/65B | 7/13/70B | 8/70B | 8/70/405B | 1/3/11/90B | | 토큰 | 1.4T | 2T | 15T+ |...", "url": "/study/ko/Foundation_Models/08_LLaMA_Family.html"}, {"id": "Foundation_Models/09_Mistral_MoE", "title": "Mistral & Mixture of Experts", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "- Mistral 7B의 아키텍처 특징 이해 - Mixture of Experts (MoE) 개념과 동작 원리 파악 - Mixtral 8x7B 구조 학습 - Sparse MoE의 장단점과 실무 활용법 습득 --- Mistral 7B는 2023년 Mistral AI가 공개한 모델로, 7B 파라미터로 13B 급 성능을 달성했습니다. --- Sliding Window Attention은 각 토큰이 고정된 윈도우 내의 토큰만 attend하도록 제한합니다. --- Mixture of Experts는 여러 \"전문가\" 네트워크 중 일부만 활성화하여 효율성을 높이는 아키텍처입니다. --- Mixtral 8x7B는 8개의 전문가를 가진 MoE 모델로, 각 레이어에서 2개의 전문가만 활성화됩니다. MoE의 핵심 과제 중 하나는 전문가 불균형 문제입니다. --- --- --- | 모델 | 조직 | 전문가 수 | Top-K | 총 파라미터 | 활성 파라미터 |...", "url": "/study/ko/Foundation_Models/09_Mistral_MoE.html"}, {"id": "Foundation_Models/10_Long_Context_Models", "title": "10. Long Context Models", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "표준 Transformer의 Self-Attention은 O(n²) 복잡도로 인해 긴 시퀀스 처리에 한계가 있습니다. 이 레슨에서는 컨텍스트 길이를 확장하는 다양한 기법을 다룹니다. --- | 모델 | 컨텍스트 길이 | 출시 시기 | |------|---------------|-----------| | GPT-3 | 2,048 | 2020 | | GPT-3.5 | 4,096 / 16,384 | 2022-2023 | | GPT-4 | 8,192 / 32,768 / 128K | 2023-2024 | | Claude 2 | 100,000 | 2023 | | Claude 3 | 200,000 | 2024 | | Gemini 1.5 | 1,000,000 / 2,000,000 | 2024 | | LLaMA 2 | 4,096 | 2023 | | LLaMA 3 | 8,192 / 128K | 2024 | --- --- --- --- --- --- - Beltagy et al. (2020)....", "url": "/study/ko/Foundation_Models/10_Long_Context_Models.html"}, {"id": "Foundation_Models/11_Small_Language_Models", "title": "11. Small Language Models", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "대형 모델(100B+)이 화제지만, 실제 프로덕션 환경에서는 Small Language Models (SLM)이 더 실용적입니다. 이 레슨에서는 7B 이하 모델의 아키텍처, 학습 전략, 활용 방법을 다룹니다. --- | 모델 | 파라미터 | 학습 토큰 | 특징 | |------|----------|-----------|------| | Phi-3 | 3.8B | 3.3T | MS, 추론 특화 | | Gemma 2 | 2B / 9B | 8T | Google, 코드 강점 | | Qwen 2.5 | 0.5B - 7B | 18T | 다국어, 수학 | | Llama 3.2 | 1B / 3B | 15T | 모바일 최적화 | | TinyLlama | 1.1B | 3T | 효율적 학습 | | StableLM 2 | 1.6B | 2T | Stability AI | | SmolLM | 135M - 1.7B | 1T | HuggingFace | --- --- --- --- --- --- -...", "url": "/study/ko/Foundation_Models/11_Small_Language_Models.html"}, {"id": "Foundation_Models/12_DINOv2_Self_Supervised", "title": "DINOv2 & Self-Supervised Vision", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "- DINO/DINOv2의 Self-distillation 메커니즘 이해 - Teacher-Student 학습 패러다임 파악 - Dense Visual Features 활용법 습득 - Vision Foundation Model로서의 DINOv2 활용 --- > 선수 지식: DeepLearning/21SelfSupervisedLearning.md > - SimCLR: Contrastive Learning 기초 > - MoCo: Momentum Contrast > - BYOL: Bootstrap Your Own Latent > - MAE: Masked Autoencoders --- DINO (Self-Distillation with No labels)는 Knowledge Distillation을 Self-supervised로 적용합니다. --- --- --- --- | 개념 | 설명 | |------|------| | Self-distillation | Teacher-Student...", "url": "/study/ko/Foundation_Models/12_DINOv2_Self_Supervised.html"}, {"id": "Foundation_Models/13_Segment_Anything", "title": "Segment Anything Model (SAM)", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "- SAM의 \"Promptable Segmentation\" 패러다임 이해 - Image Encoder, Prompt Encoder, Mask Decoder 구조 파악 - SAM의 학습 데이터와 방법론 이해 - 실무에서 SAM 활용법 습득 --- SAM (Segment Anything Model)은 Meta AI가 2023년 발표한 Vision Foundation Model로, 어떤 이미지에서든 어떤 객체든 세그멘테이션할 수 있습니다. --- --- --- --- --- | 구성요소 | 역할 | 특징 | |---------|------|------| | Image Encoder | 이미지 특징 추출 | MAE ViT-H, 632M params | | Prompt Encoder | 프롬프트 인코딩 | Point/Box/Mask 지원 | | Mask Decoder | 마스크 생성 | 2-layer Transformer, 4M params | - Point: 클릭 위치...", "url": "/study/ko/Foundation_Models/13_Segment_Anything.html"}, {"id": "Foundation_Models/14_Unified_Vision_Models", "title": "14. Unified Vision Models", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "Unified Vision Models는 다양한 비전 태스크(분류, 검출, 세그멘테이션 등)를 단일 모델로 처리하는 패러다임입니다. 태스크별 모델 대신 범용 비전 모델을 목표로 합니다. --- | 모델 | 개발 | 특징 | 지원 태스크 | |------|------|------|-------------| | Florence | Microsoft | 대규모 Image-Text | 분류, 검출, 캡셔닝, VQA | | PaLI | Google | 다국어 VLM | 캡셔닝, VQA, OCR | | Unified-IO | Allen AI | 모든 모달리티 | 이미지, 오디오, 텍스트 | | OFA | Alibaba | Seq2Seq 통합 | 다양한 비전-언어 | | GPT-4V | OpenAI | 상용 멀티모달 | 범용 비전 이해 | --- --- --- --- --- --- - Yuan et al. (2021). \"Florence: A New Foundation Model for...", "url": "/study/ko/Foundation_Models/14_Unified_Vision_Models.html"}, {"id": "Foundation_Models/15_Image_Generation_Advanced", "title": "15. Image Generation 심화", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "이 레슨에서는 Stable Diffusion 이후의 최신 이미지 생성 기술을 다룹니다. SDXL, ControlNet, IP-Adapter, Latent Consistency Models 등 실용적인 기법을 학습합니다. --- --- --- --- --- --- --- - Podell et al. (2023). \"SDXL: Improving Latent Diffusion Models for High-Resolution Image Synthesis\" - Zhang et al. (2023). \"Adding Conditional Control to Text-to-Image Diffusion Models\" (ControlNet) - Ye et al. (2023). \"IP-Adapter: Text Compatible Image Prompt Adapter\" - Luo et al. (2023). \"Latent Consistency Models\" - SDXL - ControlNet -...", "url": "/study/ko/Foundation_Models/15_Image_Generation_Advanced.html"}, {"id": "Foundation_Models/16_Vision_Language_Advanced", "title": "16. Vision-Language 심화", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "Vision-Language Models (VLMs)는 이미지와 텍스트를 함께 이해하는 모델입니다. 이 레슨에서는 LLaVA, Qwen-VL 등 최신 VLM 아키텍처와 Visual Instruction Tuning 기법을 다룹니다. --- | 모델 | Vision Encoder | LLM | 연결 방식 | |------|---------------|-----|----------| | LLaVA | CLIP ViT-L | Vicuna/LLaMA | Linear Projection | | Qwen-VL | ViT-G | Qwen | Cross-Attention | | InternVL | InternViT | InternLM | MLP | | Phi-3-Vision | CLIP ViT | Phi-3 | Linear | | GPT-4V | Unknown | GPT-4 | Unknown | --- --- --- --- --- --- - Liu et al. (2023). \"Visual...", "url": "/study/ko/Foundation_Models/16_Vision_Language_Advanced.html"}, {"id": "Foundation_Models/17_GPT4V_Gemini", "title": "17. GPT-4V, GPT-4o, Gemini & Claude 3", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "GPT-4V(ision), GPT-4o, Gemini, Claude 3는 현재 가장 강력한 상용 멀티모달 AI입니다. 이 레슨에서는 이들의 기능, API 사용법, 그리고 실전 응용 사례를 다룹니다. > 2024년 업데이트: > - GPT-4o (2024.05): GPT-4의 \"omni\" 버전, 네이티브 멀티모달 > - Gemini 1.5 Pro: 2M 토큰 컨텍스트, 비디오/오디오 네이티브 > - Claude 3 Family (2024.03): Haiku, Sonnet, Opus 라인업 > - Claude 3.5 Sonnet (2024.06): 비전 기능 강화 --- --- --- --- {language} {code} --- --- --- - OpenAI GPT-4o Documentation - Google Gemini API - Anthropic Claude Documentation - MMMU Benchmark - VQA Challenge - LMSYS Chatbot...", "url": "/study/ko/Foundation_Models/17_GPT4V_Gemini.html"}, {"id": "Foundation_Models/18_Audio_Video_Foundation", "title": "18. Audio/Video Foundation Models", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "Audio와 Video 도메인의 Foundation Model들은 음성 인식, 음악 생성, 비디오 이해 등 다양한 멀티미디어 태스크를 통합적으로 처리합니다. --- OpenAI의 범용 음성 인식 모델: --- Google의 Audio Language Model: Meta의 음악 생성 모델: --- --- --- | 모델 | 파라미터 | 특징 | 용도 | |------|---------|------|------| | Whisper Large | 1.55B | 다국어, 번역 | 범용 ASR | | Whisper Large-v3 | 1.55B | 개선된 정확도 | 프로덕션 | | wav2vec 2.0 | 300M | Self-supervised | Fine-tuning 베이스 | | HuBERT | 300M-1B | Masked prediction | Speech representation | | 모델 | 크기 | 특징 | 출력 | |------|------|------|------|...", "url": "/study/ko/Foundation_Models/18_Audio_Video_Foundation.html"}, {"id": "Foundation_Models/19_PEFT_Unified", "title": "19. PEFT (Parameter-Efficient Fine-Tuning) 통합", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "PEFT 방법론들은 전체 모델 대신 작은 파라미터 세트만 학습하여 효율적인 적응을 가능하게 합니다. 이 레슨에서는 다양한 PEFT 기법들을 통합적으로 다룹니다. --- --- --- --- --- --- | 방법 | 학습 파라미터 (7B 모델) | 메모리 오버헤드 | |------|------------------------|----------------| | Full FT | 7B (100%) | ~84GB | | LoRA (r=8) | ~4M (0.06%) | ~200MB | | LoRA (r=64) | ~30M (0.4%) | ~1GB | | QLoRA (r=64) | ~30M | ~6GB (4bit base) | | Prefix Tuning | ~1M | ~100MB | | Prompt Tuning | ~100K | ~10MB | | IA³ | ~300K | ~30MB | --- --- 1. Hu et al. (2021). \"LoRA: Low-Rank Adaptation...", "url": "/study/ko/Foundation_Models/19_PEFT_Unified.html"}, {"id": "Foundation_Models/20_Instruction_Tuning", "title": "20. Instruction Tuning", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "Instruction Tuning은 pre-trained LLM을 자연어 지시사항을 따르도록 fine-tuning하는 방법입니다. 이를 통해 모델이 다양한 태스크를 zero-shot으로 수행할 수 있게 됩니다. --- --- --- --- --- --- --- --- 1. Wei et al. (2021). \"Finetuned Language Models Are Zero-Shot Learners\" (FLAN) 2. Wang et al. (2022). \"Self-Instruct: Aligning Language Models with Self-Generated Instructions\" 3. Xu et al. (2023). \"WizardLM: Empowering Large Language Models to Follow Complex Instructions\" 4. Taori et al. (2023). \"Stanford Alpaca\" 5. Zheng et al. (2023). \"Judging...", "url": "/study/ko/Foundation_Models/20_Instruction_Tuning.html"}, {"id": "Foundation_Models/21_Continued_Pretraining", "title": "21. Continued Pre-training", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "Continued Pre-training(지속 사전학습)은 기존 pre-trained 모델을 특정 도메인이나 태스크에 맞게 추가 학습하는 방법입니다. 일반적인 fine-tuning과 달리 대량의 도메인 데이터로 language modeling을 수행합니다. --- --- --- --- --- --- --- 1. Gururangan et al. (2020). \"Don't Stop Pretraining: Adapt Language Models to Domains and Tasks\" 2. Ke et al. (2023). \"Continual Pre-training of Language Models\" 3. Ibrahim et al. (2024). \"Simple and Scalable Strategies to Continually Pre-train Large Language Models\" 4. Xie et al. (2023). \"Efficient Continual Pre-training...", "url": "/study/ko/Foundation_Models/21_Continued_Pretraining.html"}, {"id": "Foundation_Models/22_Inference_Optimization", "title": "22. Inference 최적화", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "LLM 추론(inference) 최적화는 프로덕션 환경에서 비용과 지연 시간을 줄이는 핵심 기술입니다. 이 레슨에서는 vLLM, TGI, Speculative Decoding 등을 다룹니다. --- --- --- --- --- | 방법 | 정밀도 | 속도 | 품질 | 메모리 | |------|--------|------|------|--------| | FP16 | 16-bit | 1x | 100% | 1x | | GPTQ | 4-bit | ~1.5x | 98-99% | 0.25x | | AWQ | 4-bit | ~2x | 98-99% | 0.25x | | GGUF | 2-8bit | ~2x | 95-99% | 0.15-0.5x | | bitsandbytes | 4/8-bit | ~1.2x | 97-99% | 0.25-0.5x | --- --- --- --- 1. Kwon et al. (2023). \"Efficient Memory Management for Large...", "url": "/study/ko/Foundation_Models/22_Inference_Optimization.html"}, {"id": "Foundation_Models/23_Advanced_RAG", "title": "23. Advanced RAG", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "기본 RAG를 넘어 더 정교한 검색과 생성 전략을 다룹니다. Agentic RAG, Multi-hop Reasoning, HyDE, RAPTOR 등 최신 기법을 학습합니다. --- --- --- --- --- --- --- --- --- 1. Gao et al. (2022). \"Precise Zero-Shot Dense Retrieval without Relevance Labels\" (HyDE) 2. Sarthi et al. (2024). \"RAPTOR: Recursive Abstractive Processing for Tree-Organized Retrieval\" 3. Khattab et al. (2020). \"ColBERT: Efficient and Effective Passage Search via Contextualized Late Interaction\" 4. Asai et al. (2023). \"Self-RAG: Learning to Retrieve, Generate,...", "url": "/study/ko/Foundation_Models/23_Advanced_RAG.html"}, {"id": "Foundation_Models/24_API_and_Evaluation", "title": "24. API & 평가", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "상용 LLM API 사용법과 비용 최적화, 그리고 LLM 성능 평가를 위한 벤치마크와 방법론을 다룹니다. --- --- --- --- --- 1. OpenAI API Documentation 2. Anthropic Claude Documentation 3. Zheng et al. (2023). \"Judging LLM-as-a-Judge with MT-Bench and Chatbot Arena\" 4. Chen et al. (2021). \"Evaluating Large Language Models Trained on Code\" (HumanEval)", "url": "/study/ko/Foundation_Models/24_API_and_Evaluation.html"}, {"id": "Foundation_Models/25_Research_Frontiers", "title": "25. Research Frontiers", "topic": "Foundation_Models", "topic_display": "Foundation Models", "body": "Foundation Model 연구의 최전선을 다룹니다. World Models, o1-style Reasoning, Synthetic Data, Multi-Agent 시스템 등 미래 방향을 탐구합니다. --- --- --- --- --- --- --- 1. OpenAI (2024). \"Learning to Reason with LLMs\" (o1) 2. Yao et al. (2023). \"Tree of Thoughts: Deliberate Problem Solving with Large Language Models\" 3. Park et al. (2023). \"Generative Agents: Interactive Simulacra of Human Behavior\" 4. Ha & Schmidhuber (2018). \"World Models\" 5. Sora Technical Report (2024)", "url": "/study/ko/Foundation_Models/25_Research_Frontiers.html"}, {"id": "Git/00_Overview", "title": "Git & GitHub 학습 가이드", "topic": "Git", "topic_display": "Git", "body": "이 폴더는 Git 버전 관리 시스템과 GitHub 협업 플랫폼을 학습하기 위한 자료를 담고 있습니다. 기본 명령어부터 CI/CD 자동화까지 단계별로 학습할 수 있습니다. 대상 독자: 개발자 입문자, 버전 관리를 배우고 싶은 분 --- --- - 터미널/명령줄 기본 사용법 - 텍스트 에디터 사용법 --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01GitBasics.md | ⭐ | Git 개념, 설치, 초기 설정 | | 02BasicCommands.md | ⭐ | status, add, commit, log | | 03Branches.md | ⭐⭐ | 브랜치 생성, 병합, 충돌 해결 | | 04GitHubGettingStarted.md | ⭐ | 원격 저장소, push, pull, clone | | 05GitHubCollaboration.md | ⭐⭐ | Pull Request, 코드 리뷰, Fork | |...", "url": "/study/ko/Git/00_Overview.html"}, {"id": "Git/01_Git_Basics", "title": "Git 기초", "topic": "Git", "topic_display": "Git", "body": "Git은 분산 버전 관리 시스템(DVCS)입니다. 파일의 변경 이력을 추적하고, 여러 사람이 협업할 수 있게 해줍니다. - 버전 관리: 파일의 모든 변경 이력을 저장 - 백업: 코드를 안전하게 보관 - 협업: 여러 명이 동시에 작업 가능 - 실험: 새로운 기능을 안전하게 테스트 | Git | GitHub | |-----|--------| | 버전 관리 도구 | Git 저장소 호스팅 서비스 | | 로컬에서 동작 | 온라인 플랫폼 | | 명령어로 사용 | 웹 인터페이스 제공 | --- Git 공식 사이트에서 다운로드하여 설치 --- Git을 처음 사용할 때 사용자 정보를 설정해야 합니다. --- 실행 결과: --- Git은 파일을 3가지 영역에서 관리합니다: 1. Working Directory: 실제 파일을 수정하는 공간 2. Staging Area: 커밋할 파일들을 모아두는 공간 3. Repository: 커밋된 스냅샷이 저장되는 공간 --- 예상 출력: --- | 개념 | 설명...", "url": "/study/ko/Git/01_Git_Basics.html"}, {"id": "Git/02_Basic_Commands", "title": "Git 기본 명령어", "topic": "Git", "topic_display": "Git", "body": "현재 저장소의 상태를 확인합니다. 1. Untracked: Git이 추적하지 않는 새 파일 2. Modified: 수정되었지만 스테이징되지 않은 파일 3. Staged: 커밋 대기 중인 파일 4. Committed: 저장소에 저장된 파일 --- 파일을 스테이징 영역에 추가합니다. --- 스테이징된 변경 사항을 저장소에 기록합니다. --- 저장소의 커밋 이력을 확인합니다. --- 파일의 변경 내용을 비교합니다. - 빨간색: 삭제된 라인 - 녹색: 추가된 라인 --- --- 예상 결과: --- | 명령어 | 설명 | |--------|------| | | 현재 상태 확인 | | | 스테이징 영역에 추가 | | | 모든 변경 파일 추가 | | | 커밋 생성 | | | 커밋 이력 확인 | | | 간단한 이력 확인 | | | 변경 내용 비교 | | | 스테이징 취소 | | | 수정 취소 | --- 03_Branches.md에서 브랜치를 사용한 병렬 작업 방법을 배워봅시다!", "url": "/study/ko/Git/02_Basic_Commands.html"}, {"id": "Git/03_Branches", "title": "Git 브랜치", "topic": "Git", "topic_display": "Git", "body": "브랜치는 독립적인 작업 공간입니다. 메인 코드에 영향을 주지 않고 새로운 기능을 개발하거나 버그를 수정할 수 있습니다. - 안전한 실험: 메인 코드 손상 없이 새 기능 테스트 - 병렬 작업: 여러 기능을 동시에 개발 - 체계적 관리: 기능별, 버그별로 작업 분리 - 협업 용이: 각자 브랜치에서 작업 후 병합 --- --- 작업이 완료된 브랜치를 다른 브랜치에 합칩니다. 브랜치가 분기된 후 main에 변경이 없을 때: 양쪽 브랜치 모두 변경이 있을 때: --- 같은 파일의 같은 부분을 수정했을 때 충돌이 발생합니다. 충돌 전: 충돌 해결 후: --- | 접두사 | 용도 | 예시 | |--------|------|------| | | 새 기능 개발 | | | | 버그 수정 | | | | 긴급 수정 | | | | 배포 준비 | | --- --- | 명령어 | 설명 | |--------|------| | | 브랜치 목록 | | | 브랜치 생성 | | | 브랜치 이동 | | | 생성 +...", "url": "/study/ko/Git/03_Branches.html"}, {"id": "Git/04_GitHub_Getting_Started", "title": "GitHub 시작하기", "topic": "Git", "topic_display": "Git", "body": "GitHub은 Git 저장소를 호스팅하는 웹 서비스입니다. - 원격 저장소: 코드를 클라우드에 백업 - 협업 도구: Pull Request, Issues, Projects - 소셜 코딩: 다른 개발자의 코드 탐색 및 기여 - CI/CD: GitHub Actions로 자동화 1. github.com 접속 2. \"Sign up\" 클릭 3. 이메일, 비밀번호, 사용자명 입력 4. 이메일 인증 완료 --- SSH 키를 사용하면 매번 비밀번호를 입력하지 않아도 됩니다. 1. GitHub → Settings → SSH and GPG keys 2. \"New SSH key\" 클릭 3. 공개 키 내용 붙여넣기 4. \"Add SSH key\" 클릭 --- --- 출력 예시: --- 로컬 변경 사항을 원격 저장소에 업로드합니다. --- 원격 저장소의 변경 사항을 로컬로 가져옵니다. | 명령어 | 동작 | |--------|------| | | 원격 변경 사항 다운로드만 | | | fetch +...", "url": "/study/ko/Git/04_GitHub_Getting_Started.html"}, {"id": "Git/05_GitHub_Collaboration", "title": "GitHub 협업", "topic": "Git", "topic_display": "Git", "body": "GitHub에서 협업하는 두 가지 주요 방식: | 방식 | 설명 | 사용 경우 | |------|------|----------| | Collaborator | 저장소에 직접 푸시 권한 | 팀 프로젝트 | | Fork & PR | 복제 후 Pull Request | 오픈소스 기여 | --- 다른 사람의 저장소를 내 계정으로 복사합니다. 1. 원본 저장소 페이지 방문 2. 우측 상단 \"Fork\" 버튼 클릭 3. 내 계정으로 복사됨 --- 변경 사항을 원본 저장소에 반영해달라고 요청합니다. 1. GitHub에서 \"Compare & pull request\" 버튼 클릭 2. PR 정보 작성: - 제목: 변경 사항 요약 - 설명: 상세 내용, 관련 이슈 3. \"Create pull request\" 클릭 --- PR을 통해 코드를 검토하고 피드백을 주고받습니다. 1. PR 페이지에서 \"Reviewers\" 클릭 2. 리뷰어 선택 1. \"Files changed\" 탭에서 변경 내용 확인 2....", "url": "/study/ko/Git/05_GitHub_Collaboration.html"}, {"id": "Git/06_Git_Advanced", "title": "Git 고급 명령어", "topic": "Git", "topic_display": "Git", "body": "작업 중인 변경 사항을 임시로 저장하고 나중에 복원합니다. --- 커밋 이력을 깔끔하게 재정렬합니다. 커밋 수정, 합치기, 삭제, 순서 변경이 가능합니다. 에디터에서: --- 다른 브랜치의 특정 커밋만 현재 브랜치로 가져옵니다. --- 취소 커밋을 새로 생성합니다. 이미 푸시한 커밋을 되돌릴 때 사용합니다. | 상황 | 사용 | |------|------| | 아직 푸시 안 한 로컬 커밋 | | | 이미 푸시한 공유 커밋 | | | 이력을 깔끔하게 유지하고 싶음 | | | 되돌린 기록을 남기고 싶음 | | --- 모든 HEAD 이동 기록을 보여줍니다. 실수로 삭제한 커밋도 복구할 수 있습니다. --- --- | 명령어 | 설명 | |--------|------| | | 작업 임시 저장 | | | 저장된 작업 복원 | | | main 위로 rebase | | | 대화형 rebase | | | 특정 커밋 가져오기 | | | 커밋만 취소 | | | 모든 것 삭제 | | | 취소 커밋...", "url": "/study/ko/Git/06_Git_Advanced.html"}, {"id": "Git/07_GitHub_Actions", "title": "GitHub Actions", "topic": "Git", "topic_display": "Git", "body": "GitHub Actions는 CI/CD 자동화 플랫폼입니다. 코드 푸시, PR 생성 등의 이벤트에 따라 자동으로 워크플로우를 실행합니다. | 용도 | 예시 | |------|------| | CI (Continuous Integration) | 테스트 자동 실행, 린트 검사 | | CD (Continuous Deployment) | 자동 배포, Docker 이미지 빌드 | | 자동화 | 이슈 라벨링, 릴리스 노트 생성 | | 개념 | 설명 | |------|------| | Workflow | 자동화 프로세스 전체 (YAML 파일) | | Event | 워크플로우를 트리거하는 이벤트 | | Job | 같은 러너에서 실행되는 단계 묶음 | | Step | 개별 작업 단위 | | Action | 재사용 가능한 작업 단위 | | Runner | 워크플로우를 실행하는 서버 | --- 워크플로우는 디렉토리에 YAML 파일로 저장합니다. --- --- 매트릭스 빌드를 사용하면 여러 구성에서...", "url": "/study/ko/Git/07_GitHub_Actions.html"}, {"id": "Git/08_Git_Workflow_Strategies", "title": "08. Git 워크플로우 전략", "topic": "Git", "topic_display": "Git", "body": "- 다양한 Git 브랜치 전략 이해 - 팀 규모와 프로젝트에 맞는 워크플로우 선택 - Git Flow, GitHub Flow, Trunk-based Development 비교 - 릴리스 관리 및 버전 전략 수립 1. 워크플로우 개요 2. Git Flow 3. GitHub Flow 4. Trunk-based Development 5. GitLab Flow 6. 워크플로우 선택 가이드 7. 연습 문제 --- --- --- --- --- --- --- --- - 09고급Git기법 - hooks, submodules, worktrees - 10모노레포관리 - 대규모 저장소 관리 - 07GitHub_Actions - CI/CD 자동화 복습 - Git Flow 원본 문서 - GitHub Flow - Trunk Based Development - GitLab Flow --- ← 이전: GitHub Actions | 다음: 고급 Git 기법 → | 목차", "url": "/study/ko/Git/08_Git_Workflow_Strategies.html"}, {"id": "Git/09_Advanced_Git_Techniques", "title": "09. 고급 Git 기법", "topic": "Git", "topic_display": "Git", "body": "- Git Hooks를 활용한 자동화 - Submodules로 외부 의존성 관리 - Worktrees로 여러 브랜치 동시 작업 - Git 내부 구조와 저수준 명령어 이해 1. Git Hooks 2. Git Submodules 3. Git Worktrees 4. 고급 명령어 5. Git 내부 구조 6. 트러블슈팅 7. 연습 문제 --- --- --- --- --- --- --- --- - 10모노레포관리 - 대규모 저장소 관리 - 08Git워크플로우_전략 - 워크플로우 복습 - Pro Git Book - 심화 학습 - Git Hooks Documentation - Git Submodules - Git Worktree - Git Internals --- ← 이전: Git 워크플로우 전략 | 다음: 모노레포 관리 → | 목차", "url": "/study/ko/Git/09_Advanced_Git_Techniques.html"}, {"id": "Git/10_Monorepo_Management", "title": "10. 모노레포 관리", "topic": "Git", "topic_display": "Git", "body": "- 모노레포 개념과 장단점 이해 - Nx, Turborepo를 활용한 빌드 최적화 - 의존성 관리와 코드 공유 전략 - 대규모 모노레포 성능 최적화 1. 모노레포 개요 2. 모노레포 도구 3. Nx 활용 4. Turborepo 활용 5. 의존성 관리 6. CI/CD 최적화 7. 연습 문제 --- --- --- --- --- --- --- --- - 08Git워크플로우전략 - 워크플로우 복습 - 09고급Git기법 - 고급 Git - Nx 공식 문서 - Nx 심화 - Turborepo 공식 문서 - Turborepo 심화 - Nx Documentation - Turborepo Documentation - pnpm Workspaces - Monorepo Explained - Changesets --- ← 이전: 고급 Git 기법 | 목차", "url": "/study/ko/Git/10_Monorepo_Management.html"}, {"id": "IoT_Embedded/00_Overview", "title": "IoT와 임베디드 시스템 학습 가이드", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "이 폴더는 IoT(사물인터넷)와 임베디드 시스템에 대한 체계적인 학습 자료를 담고 있습니다. 라즈베리파이를 중심으로 Python 기반의 IoT 개발을 다루며, 네트워크 연결, 엣지 AI, 클라우드 통합까지 포괄합니다. - Python 기본 문법을 알고 있는 개발자 - IoT 시스템 구축에 관심 있는 엔지니어 - 라즈베리파이로 프로젝트를 시작하려는 입문자 - 엣지 컴퓨팅과 AI 통합에 관심 있는 개발자 | 구분 | CProgramming | IoTEmbedded | |------|---------------|--------------| | 언어 | C (저수준) | Python (고수준) | | 플랫폼 | Arduino, STM32 | Raspberry Pi | | 초점 | 하드웨어 제어, 레지스터 | 네트워크, 클라우드 연동 | | 통신 | UART, I2C, SPI (저수준) | MQTT, HTTP, BLE (프로토콜) | | AI | 미포함 | Edge AI (TFLite,...", "url": "/study/ko/IoT_Embedded/00_Overview.html"}, {"id": "IoT_Embedded/01_IoT_Overview", "title": "01. IoT 개요", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- IoT(사물인터넷)의 정의와 핵심 개념 이해 - IoT 시스템 아키텍처의 구성 요소 파악 - 엣지 컴퓨팅과 클라우드 컴퓨팅의 차이 이해 - 주요 IoT 프로토콜 개요 학습 - IoT 보안 고려사항 인식 --- IoT(Internet of Things, 사물인터넷)는 센서, 소프트웨어, 네트워크 연결을 갖춘 물리적 장치들이 데이터를 수집하고 교환하는 시스템입니다. | 요소 | 설명 | 예시 | |------|------|------| | Things | 센서/액추에이터가 장착된 물리적 장치 | 온도 센서, 스마트 조명 | | Connectivity | 장치 간 데이터 전송을 위한 네트워크 | WiFi, BLE, LoRa, 5G | | Data Processing | 수집된 데이터의 처리 및 분석 | 엣지 처리, 클라우드 분석 | | User Interface | 사용자와 시스템 간 상호작용 | 모바일 앱, 웹 대시보드 | --- --- | 특성 | 엣지 컴퓨팅 | 클라우드 컴퓨팅...", "url": "/study/ko/IoT_Embedded/01_IoT_Overview.html"}, {"id": "IoT_Embedded/02_Raspberry_Pi_Setup", "title": "02. 라즈베리파이 설정", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- Raspberry Pi 모델별 특징과 선택 기준 이해 - Raspberry Pi OS 설치 및 초기 설정 - SSH 원격 접속 설정 - raspi-config를 통한 시스템 설정 - GPIO 핀아웃 이해 --- | 모델 | CPU | RAM | 특징 | 권장 용도 | |------|-----|-----|------|-----------| | Pi 5 | Cortex-A76 2.4GHz | 4-8GB | PCIe, USB 3.0 | AI, 데스크탑 | | Pi 4B | Cortex-A72 1.8GHz | 1-8GB | USB 3.0, 듀얼 HDMI | 범용, IoT 게이트웨이 | | Pi 3B+ | Cortex-A53 1.4GHz | 1GB | WiFi, BLE 내장 | 교육, 간단한 IoT | | Pi Zero 2W | Cortex-A53 1GHz | 512MB | 소형, 저전력 | 임베디드, 웨어러블 | | Pi Pico | RP2040 133MHz | 264KB |...", "url": "/study/ko/IoT_Embedded/02_Raspberry_Pi_Setup.html"}, {"id": "IoT_Embedded/03_Python_GPIO_Control", "title": "03. Python GPIO 제어", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- RPi.GPIO 라이브러리 사용법 습득 - gpiozero 라이브러리를 통한 간편한 GPIO 제어 - LED 출력 제어 (디지털/PWM) - 버튼 입력 처리 (풀업/풀다운, 인터럽트) - 센서 연결 및 데이터 읽기 (DHT11, PIR) --- | 라이브러리 | 특징 | 난이도 | 권장 용도 | |-----------|------|--------|-----------| | RPi.GPIO | 저수준, 세밀한 제어 | 중급 | 정밀 제어, 타이밍 | | gpiozero | 고수준, 직관적 API | 입문 | 교육, 빠른 프로토타이핑 | | pigpio | 원격 제어, 정밀 타이밍 | 고급 | 서보, 정밀 PWM | | lgpio | 최신, Pi 5 지원 | 중급 | Pi 5 프로젝트 | --- --- --- --- --- --- 빨강-노랑-초록 LED 3개로 신호등을 구현하세요: - 빨강 3초 → 노랑 1초 → 초록 3초 → 노랑 1초 반복 버튼을 누른 횟수를 세고, 5회마다...", "url": "/study/ko/IoT_Embedded/03_Python_GPIO_Control.html"}, {"id": "IoT_Embedded/04_WiFi_Networking", "title": "04. WiFi 네트워킹", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- 라즈베리파이 WiFi 설정 방법 습득 - Python 소켓 프로그래밍 기초 이해 - ESP32 WiFi 개요 파악 - 네트워크 스캔 및 모니터링 - HTTP 클라이언트로 데이터 전송 --- --- --- | 특성 | ESP32 | Raspberry Pi | |------|-------|--------------| | 프로세서 | Xtensa 240MHz | ARM 1.5GHz | | RAM | 520KB | 1-8GB | | OS | FreeRTOS/없음 | Linux | | 언어 | C/C++, MicroPython | Python, 모든 언어 | | WiFi | 내장 | 내장 (Pi 3+) | | 전력 | 낮음 (80mA) | 높음 (700mA+) | | 용도 | 센서 노드 | 게이트웨이, 엣지 | --- --- --- 1. 현재 WiFi 연결 상태를 모니터링하는 스크립트를 작성하세요. 2. 신호 강도가 -70dBm 이하로 떨어지면 경고를 출력하세요. 1. TCP 서버를...", "url": "/study/ko/IoT_Embedded/04_WiFi_Networking.html"}, {"id": "IoT_Embedded/05_BLE_Connectivity", "title": "05. BLE 연결", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- BLE(Bluetooth Low Energy) 프로토콜 개요 이해 - GATT 구조 (서비스, 특성) 파악 - Python bleak 라이브러리 사용법 습득 - BLE 장치 스캔 및 연결 - 센서 데이터 수신 --- | 특성 | BLE (Bluetooth Low Energy) | 클래식 Bluetooth | |------|---------------------------|------------------| | 전력 소비 | 매우 낮음 | 높음 | | 데이터 전송률 | 1-2 Mbps | 1-3 Mbps | | 범위 | ~100m | ~100m | | 지연 시간 | ~6ms | ~100ms | | 페어링 | 간단/자동 | 복잡 | | 용도 | IoT 센서, 웨어러블 | 오디오, 파일 전송 | --- --- --- --- --- 1. 주변 BLE 장치를 스캔하는 프로그램을 작성하세요. 2. RSSI 값 기준으로 정렬하여 출력하세요. 1. 심박수 센서(Heart Rate...", "url": "/study/ko/IoT_Embedded/05_BLE_Connectivity.html"}, {"id": "IoT_Embedded/06_MQTT_Protocol", "title": "06. MQTT 프로토콜", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- MQTT 프로토콜의 원리와 특징 이해 - Mosquitto 브로커 설치 및 설정 - Topic 구조와 QoS 레벨 이해 - paho-mqtt 라이브러리 사용법 습득 - 메시지 발행 및 구독 구현 --- MQTT (Message Queuing Telemetry Transport)는 경량 메시징 프로토콜로, IoT 환경에 최적화되어 있습니다. | 특징 | 설명 | |------|------| | 경량 | 최소 2바이트 헤더 (HTTP 대비 매우 작음) | | Pub/Sub | 발행/구독 패턴 (느슨한 결합) | | QoS | 3가지 메시지 전달 보장 수준 | | Last Will | 비정상 연결 종료 시 알림 | | Retained | 마지막 메시지 저장 | | Keep Alive | 연결 상태 모니터링 | --- --- --- --- --- 1. 온도와 습도 데이터를 5초마다 발행하는 Publisher를 작성하세요. 2. 해당 데이터를 구독하여 콘솔에 출력하는...", "url": "/study/ko/IoT_Embedded/06_MQTT_Protocol.html"}, {"id": "IoT_Embedded/07_HTTP_REST_for_IoT", "title": "07. HTTP/REST for IoT", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- Flask를 이용한 IoT 서버 구축 - 센서 데이터 수집 API 설계 - RESTful API 설계 원칙 이해 - JSON 데이터 처리 및 검증 --- --- --- --- --- --- 1. 센서 CRUD API를 구현하세요. 2. 데이터 검증을 추가하세요. 1. 센서 데이터 목록에 페이지네이션을 구현하세요. 2. 날짜 범위 필터링을 추가하세요. 1. HTTP POST로 받은 데이터를 MQTT로 발행하세요. 2. MQTT로 받은 데이터를 HTTP GET으로 조회하세요. --- - 08EdgeAITFLite.md: 센서 데이터 AI 분석 - 10HomeAutomationProject.md: REST API 기반 스마트홈 --- 최종 업데이트: 2026-02-01", "url": "/study/ko/IoT_Embedded/07_HTTP_REST_for_IoT.html"}, {"id": "IoT_Embedded/08_Edge_AI_TFLite", "title": "08. Edge AI - TensorFlow Lite", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- Edge AI 개념과 장점 이해 - TensorFlow Lite 개요 파악 - 모델 변환 (.tflite) 방법 학습 - 라즈베리파이에서 추론 수행 - 이미지 분류 예제 구현 --- Edge AI는 클라우드가 아닌 엣지 디바이스(라즈베리파이, 스마트폰 등)에서 직접 AI 추론을 수행하는 것입니다. | 분야 | 활용 예시 | |------|-----------| | 스마트홈 | 얼굴 인식 도어락, 음성 인식 | | 산업 | 불량품 검출, 예측 정비 | | 헬스케어 | 웨어러블 건강 모니터링 | | 농업 | 작물 질병 감지, 해충 식별 | | 자동차 | ADAS, 보행자 감지 | | 프레임워크 | 개발사 | 특징 | 하드웨어 지원 | |-----------|--------|------|--------------| | TensorFlow Lite | Google | 범용, 생태계 풍부 | CPU, GPU, Edge TPU | | ONNX Runtime | Microsoft | 다양한...", "url": "/study/ko/IoT_Embedded/08_Edge_AI_TFLite.html"}, {"id": "IoT_Embedded/09_Edge_AI_ONNX", "title": "09. Edge AI - ONNX Runtime", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- ONNX(Open Neural Network Exchange) 개요 이해 - ONNX Runtime 설치 및 사용법 습득 - 모델 최적화 기법 학습 - 라즈베리파이 배포 - 객체 검출 예제 구현 --- ONNX(Open Neural Network Exchange)는 다양한 ML 프레임워크 간 모델 호환성을 제공하는 오픈 포맷입니다. | 특성 | ONNX | TFLite | |------|------|--------| | 개발사 | Microsoft + 파트너 | Google | | 프레임워크 지원 | PyTorch, TF, Sklearn 등 | TensorFlow/Keras | | 포맷 | .onnx (Protobuf) | .tflite (FlatBuffer) | | 최적화 | ONNX Runtime | TF Lite Interpreter | | 양자화 | 지원 | 지원 | | 하드웨어 | CPU, GPU, NPU | CPU, GPU, Edge TPU | --- --- ---...", "url": "/study/ko/IoT_Embedded/09_Edge_AI_ONNX.html"}, {"id": "IoT_Embedded/10_Home_Automation_Project", "title": "10. 홈 자동화 프로젝트", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- 스마트홈 시스템 아키텍처 설계 - 릴레이를 이용한 조명 제어 구현 - 온습도 센서를 통한 환경 모니터링 - MQTT 기반 장치 제어 시스템 구축 - 웹 대시보드 개발 --- | 구성요소 | 모델 | 역할 | GPIO | |---------|------|------|------| | 게이트웨이 | Raspberry Pi 4 | 중앙 제어, MQTT 브로커 | - | | 릴레이 모듈 | 4채널 릴레이 | 조명/가전 제어 | 17, 27, 22, 23 | | 온습도 센서 | DHT11 | 환경 모니터링 | 4 | | 모션 센서 | PIR HC-SR501 | 동작 감지 | 24 | | 조도 센서 | 포토레지스터 | 밝기 감지 | MCP3008 (SPI) | --- --- --- --- --- --- 1. 온도가 30도 이상이면 에어컨(릴레이)을 자동으로 켜세요. 2. 모션 감지 시 조명을 자동으로 켜세요. 1. 특정 시간에 조명을 자동으로 제어하는 스케줄러를 구현하세요. 2....", "url": "/study/ko/IoT_Embedded/10_Home_Automation_Project.html"}, {"id": "IoT_Embedded/11_Image_Analysis_Project", "title": "11. 영상 분석 프로젝트", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- Pi Camera 설정 및 picamera2 라이브러리 사용 - 실시간 영상 스트리밍 구현 - TFLite를 이용한 객체 검출 - 모션 감지 시스템 구축 --- --- --- --- --- --- 1. 일정 간격으로 이미지를 캡처하는 타임랩스 시스템을 구현하세요. 2. 캡처된 이미지를 비디오로 변환하세요. 1. OpenCV 또는 TFLite로 얼굴 검출을 구현하세요. 2. 얼굴 검출 시 알림을 보내세요. 1. 모션 감지 시 이미지를 클라우드에 업로드하세요. 2. 검출 결과를 데이터베이스에 저장하세요. --- - 12CloudIoTIntegration.md: 영상 데이터 클라우드 연동 --- 최종 업데이트: 2026-02-01*", "url": "/study/ko/IoT_Embedded/11_Image_Analysis_Project.html"}, {"id": "IoT_Embedded/12_Cloud_IoT_Integration", "title": "12. 클라우드 IoT 통합", "topic": "IoT_Embedded", "topic_display": "IoT Embedded", "body": "- AWS IoT Core 개요 및 설정 - GCP IoT (Pub/Sub) 연동 - MQTT 브릿지 구현 - 디바이스 등록 및 인증 - 클라우드 데이터 수집 및 분석 --- | 구성 요소 | 설명 | |----------|------| | Device Gateway | MQTT/HTTPS/WebSocket 연결 관리 | | Message Broker | Pub/Sub 메시지 라우팅 | | Rules Engine | 메시지 필터링 및 AWS 서비스 연동 | | Device Shadow | 디바이스 상태의 가상 복제본 | | Registry | 디바이스 ID 및 인증 관리 | --- --- > 중요 안내: GCP IoT Core 서비스는 2023년 8월 16일에 종료되었습니다. > > Google은 IoT Core를 대체하여 Cloud Pub/Sub + Cloud Functions 조합을 권장합니다. > 기존 IoT Core 사용자는 다음 대안을 고려하세요: > - Cloud...", "url": "/study/ko/IoT_Embedded/12_Cloud_IoT_Integration.html"}, {"id": "LLM_and_NLP/00_Overview", "title": "LLM & NLP 학습 가이드", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "이 폴더는 자연어 처리(NLP)와 대규모 언어 모델(LLM)을 학습하기 위한 자료입니다. 기초 NLP부터 최신 LLM 활용까지 단계별로 구성했습니다. 대상 독자: DeepLearning 폴더를 완료한 학습자 (Transformer, Attention 이해 필수) --- --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01NLPBasics.md | ⭐⭐ | 토큰화, 정규화, 어휘 구축 | | 02Word2VecGloVe.md | ⭐⭐ | 단어 임베딩, Skip-gram, CBOW | | 03TransformerReview.md | ⭐⭐⭐ | Attention, Encoder-Decoder | | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 04BERTUnderstanding.md | ⭐⭐⭐ | MLM, NSP, 양방향 인코더 | | 05GPTUnderstanding.md |...", "url": "/study/ko/LLM_and_NLP/00_Overview.html"}, {"id": "LLM_and_NLP/01_NLP_Basics", "title": "01. NLP 기초", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- 텍스트 전처리 기법 - 토큰화 방법 이해 - 어휘 구축과 인코딩 - 텍스트 정규화 --- --- 서브워드는 단어를 더 작은 단위로 분리 장점: - 미등록 단어(OOV) 처리 가능 - 어휘 크기 축소 - 형태소 정보 보존 --- --- --- --- --- --- | 방법 | 장점 | 단점 | 사용 모델 | |------|------|------|----------| | 단어 단위 | 직관적 | OOV 문제 | 전통 NLP | | BPE | OOV 해결 | 학습 필요 | GPT | | WordPiece | OOV 해결 | 학습 필요 | BERT | | SentencePiece | 언어 무관 | 학습 필요 | T5, GPT | --- 02Word2VecGloVe.md에서 단어 임베딩을 학습합니다.", "url": "/study/ko/LLM_and_NLP/01_NLP_Basics.html"}, {"id": "LLM_and_NLP/02_Word2Vec_GloVe", "title": "02. Word2Vec과 GloVe", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- 분산 표현의 개념 - Word2Vec (Skip-gram, CBOW) - GloVe 임베딩 - 사전학습 임베딩 활용 --- > \"같은 맥락에서 등장하는 단어는 비슷한 의미를 갖는다\" > (You shall know a word by the company it keeps) --- 주변 단어를 예측하여 중심 단어 표현 학습 주변 단어로 중심 단어 예측 전체 어휘에 대한 Softmax는 계산 비용이 큼 --- 전역 동시 출현 통계 활용 --- --- --- --- | 항목 | Word2Vec | GloVe | |------|----------|-------| | 방식 | 예측 기반 | 통계 기반 | | 학습 | 윈도우 내 단어 | 전역 동시 출현 | | 메모리 | 적음 | 동시 출현 행렬 필요 | | 학습 속도 | Negative Sampling으로 빠름 | 행렬 전처리 후 빠름 | | 성능 | 유사 | 유사 | --- 1. 분산 표현: 단어를 밀집 벡터로 표현 2....", "url": "/study/ko/LLM_and_NLP/02_Word2Vec_GloVe.html"}, {"id": "LLM_and_NLP/03_Transformer_Review", "title": "03. Transformer 복습", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- NLP 관점에서 Transformer 이해 - Encoder와 Decoder 구조 - 언어 모델링 관점의 Attention - BERT/GPT 기반 구조 이해 --- | 모델 | 구조 | 용도 | |------|------|------| | BERT | 인코더 only | 분류, QA, NER | | GPT | 디코더 only | 텍스트 생성 | | T5, BART | 인코더-디코더 | 번역, 요약 | --- --- --- --- --- --- --- --- | 항목 | BERT (인코더) | GPT (디코더) | T5 (Enc-Dec) | |------|--------------|-------------|--------------| | Attention | 양방향 | 단방향 (Causal) | 양방향 + 단방향 | | 학습 | MLM + NSP | 다음 토큰 예측 | Denoising | | 출력 | 문맥 벡터 | 생성 | 생성 | | 용도 | 분류, QA | 생성, 대화 |...", "url": "/study/ko/LLM_and_NLP/03_Transformer_Review.html"}, {"id": "LLM_and_NLP/04_BERT_Understanding", "title": "04. BERT 이해", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- BERT 아키텍처 이해 - 사전학습 목표 (MLM, NSP) - 입력 표현 - 다양한 BERT 변형 --- | 모델 | 레이어 | dmodel | 헤드 | 파라미터 | |------|-------|---------|------|---------| | BERT-base | 12 | 768 | 12 | 110M | | BERT-large | 24 | 1024 | 16 | 340M | --- | 토큰 | 역할 | |------|------| | [CLS] | 분류 태스크용 집계 토큰 | | [SEP] | 문장 구분자 | | [PAD] | 패딩 | | [MASK] | MLM에서 마스킹된 토큰 | | [UNK] | 미등록 단어 | --- --- --- --- | 모델 | 레이어 | 파라미터 | 속도 | 특징 | |------|-------|---------|------|------| | BERT-base | 12 | 110M | 1x | 기준 | | RoBERTa | 12 | 125M...", "url": "/study/ko/LLM_and_NLP/04_BERT_Understanding.html"}, {"id": "LLM_and_NLP/05_GPT_Understanding", "title": "05. GPT 이해", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- GPT 아키텍처 이해 - 자기회귀 언어 모델링 - 텍스트 생성 기법 - GPT 시리즈 발전 --- | 항목 | BERT | GPT | |------|------|-----| | 구조 | 인코더 | 디코더 | | 방향 | 양방향 | 단방향 | | 학습 | MLM | 다음 토큰 예측 | | 용도 | 이해 (분류, QA) | 생성 (대화, 작문) | --- --- --- --- --- --- --- --- | 방법 | 장점 | 단점 | 용도 | |------|------|------|------| | Greedy | 빠름, 일관성 | 반복, 지루함 | 번역, QA | | Temperature | 다양성 조절 | 튜닝 필요 | 일반 생성 | | Top-k | 안정적 | 고정 k | 일반 생성 | | Top-p | 적응적 | 약간 느림 | 창작, 대화 | --- 06HuggingFaceBasics.md에서 HuggingFace Transformers 라이브러리를 학습합니다.", "url": "/study/ko/LLM_and_NLP/05_GPT_Understanding.html"}, {"id": "LLM_and_NLP/06_HuggingFace_Basics", "title": "06. HuggingFace 기초", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- Transformers 라이브러리 이해 - Pipeline API 사용 - 토크나이저와 모델 로드 - 다양한 태스크 수행 --- --- | 태스크 | Pipeline 이름 | 설명 | |--------|--------------|------| | 감성 분석 | sentiment-analysis | 긍정/부정 분류 | | 텍스트 분류 | text-classification | 일반 분류 | | NER | ner | 개체명 인식 | | QA | question-answering | 질의응답 | | 요약 | summarization | 텍스트 요약 | | 번역 | translation | 언어 번역 | | 텍스트 생성 | text-generation | 문장 생성 | | Fill-Mask | fill-mask | 마스크 예측 | | Zero-shot | zero-shot-classification | 레이블 없는 분류 | --- --- --- --- --- --- --- | 클래스...", "url": "/study/ko/LLM_and_NLP/06_HuggingFace_Basics.html"}, {"id": "LLM_and_NLP/07_Fine_Tuning", "title": "07. 파인튜닝", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- 파인튜닝 전략 이해 - 다양한 태스크 파인튜닝 - 효율적인 파인튜닝 기법 (LoRA, QLoRA) - 실전 파인튜닝 파이프라인 --- | 전략 | 설명 | 사용 시점 | |------|------|----------| | Full Fine-tuning | 전체 파라미터 업데이트 | 충분한 데이터, 컴퓨팅 | | Feature Extraction | 분류기만 학습 | 적은 데이터 | | LoRA | 저랭크 어댑터 | 효율적인 학습 | | Prompt Tuning | 프롬프트만 학습 | 매우 적은 데이터 | --- --- --- --- --- --- --- --- | 상황 | 추천 방법 | |------|----------| | 충분한 데이터 + GPU | Full Fine-tuning | | 제한된 GPU 메모리 | LoRA / QLoRA | | 매우 적은 데이터 | Prompt Tuning | | LLM 정렬 | SFT + DPO/RLHF | ---...", "url": "/study/ko/LLM_and_NLP/07_Fine_Tuning.html"}, {"id": "LLM_and_NLP/08_Prompt_Engineering", "title": "08. 프롬프트 엔지니어링", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- 효과적인 프롬프트 작성 - Zero-shot, Few-shot 기법 - Chain-of-Thought (CoT) - 고급 프롬프팅 기법 --- --- --- --- --- --- --- --- {language} \"\"\" python class PromptTemplate: def init(self, template: str): self.template = template def format(self, kwargs) -> str: return self.template.format(kwargs) @classmethod def fromfile(cls, path: str): with open(path, 'r') as f: return cls(f.read()) template = PromptTemplate(\"\"\" You are a {role}. Task: {task} Input: {input} Output: \"\"\") prompt = template.format( role=\"helpful...", "url": "/study/ko/LLM_and_NLP/08_Prompt_Engineering.html"}, {"id": "LLM_and_NLP/09_RAG_Basics", "title": "09. RAG 기초", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- RAG (Retrieval-Augmented Generation) 이해 - 문서 임베딩과 검색 - 청킹 전략 - RAG 파이프라인 구현 --- --- --- --- --- --- --- | 전략 | 장점 | 단점 | 사용 시점 | |------|------|------|----------| | 고정 크기 | 구현 간단 | 문맥 단절 | 일반적인 텍스트 | | 문장 기반 | 의미 단위 | 길이 불균일 | 구조화된 텍스트 | | 시맨틱 | 의미 보존 | 계산 비용 | 고품질 필요 | | 계층적 | 다단계 검색 | 복잡함 | 긴 문서 | --- --- --- 10LangChainBasics.md에서 LangChain 프레임워크를 학습합니다.", "url": "/study/ko/LLM_and_NLP/09_RAG_Basics.html"}, {"id": "LLM_and_NLP/10_LangChain_Basics", "title": "10. LangChain 기초", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "> 버전 정보: 이 레슨은 LangChain 0.2+ (2024년~) 기준으로 작성되었습니다. > > LangChain은 빠르게 발전하는 라이브러리입니다. 주요 변경사항: > - LCEL (LangChain Expression Language): 권장 체인 구성 방식 > - langchain-core, langchain-community: 패키지 분리 > - ConversationChain 대신 RunnableWithMessageHistory 권장 > > 최신 문서: https://python.langchain.com/docs/ - LangChain 핵심 개념 - LLM 래퍼와 프롬프트 - 체인과 에이전트 - 메모리 시스템 - LCEL (LangChain Expression Language) 심화 - LangGraph 기초 --- --- --- --- --- --- --- > 권장 방식 변경: LangChain 0.2+에서는 , 등이 > deprecated 되었습니다. 새...", "url": "/study/ko/LLM_and_NLP/10_LangChain_Basics.html"}, {"id": "LLM_and_NLP/11_Vector_Databases", "title": "11. 벡터 데이터베이스", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- 벡터 데이터베이스 개념 - Chroma, FAISS, Pinecone 사용 - 인덱싱과 검색 최적화 - 실전 활용 패턴 --- | 이름 | 타입 | 특징 | |------|------|------| | Chroma | 로컬/임베디드 | 간단, 개발용 | | FAISS | 라이브러리 | 빠름, 대규모 | | Pinecone | 클라우드 | 관리형, 확장성 | | Weaviate | 오픈소스 | 하이브리드 검색 | | Qdrant | 오픈소스 | 필터링 강점 | | Milvus | 오픈소스 | 대규모, 분산 | --- --- --- --- | 타입 | 정확도 | 속도 | 메모리 | 사용 시점 | |------|--------|------|--------|----------| | Flat | 100% | 느림 | 높음 | 소규모 (<100K) | | IVF | 95%+ | 빠름 | 중간 | 중규모 | | HNSW | 98%+ | 매우 빠름 | 높음 | 대규모, 실시간 | | PQ |...", "url": "/study/ko/LLM_and_NLP/11_Vector_Databases.html"}, {"id": "LLM_and_NLP/12_Practical_Chatbot", "title": "12. 실전 챗봇 프로젝트", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- 대화형 AI 시스템 설계 - RAG 기반 챗봇 구현 - 대화 관리와 메모리 - 프로덕션 배포 고려사항 --- --- --- --- --- --- --- --- --- --- - 실제 서비스 배포 (AWS, GCP) - A/B 테스트 설정 - 사용자 피드백 수집 - 지속적인 모델 개선 --- 이것으로 LLM & NLP 학습 과정을 완료했습니다! 1. NLP 기초 (01-03): 토큰화, 임베딩, Transformer 2. 사전학습 모델 (04-07): BERT, GPT, HuggingFace, 파인튜닝 3. LLM 활용 (08-12): 프롬프트, RAG, LangChain, 벡터 DB, 챗봇 - 실제 프로젝트에 적용 - Kaggle NLP 대회 참가 - 최신 LLM 논문 읽기 (Claude, Gemini, Llama)", "url": "/study/ko/LLM_and_NLP/12_Practical_Chatbot.html"}, {"id": "LLM_and_NLP/13_Model_Quantization", "title": "13. 모델 양자화 (Model Quantization)", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- 양자화 개념과 필요성 이해 - INT8/INT4 양자화 기법 - GPTQ, AWQ, bitsandbytes 실습 - QLoRA를 통한 효율적인 파인튜닝 --- | 유형 | 설명 | 장점 | 단점 | |------|------|------|------| | Post-Training Quantization (PTQ) | 학습 후 양자화 | 빠름, 간편 | 정확도 손실 가능 | | Quantization-Aware Training (QAT) | 학습 중 양자화 시뮬레이션 | 높은 정확도 | 학습 시간 증가 | | Dynamic Quantization | 런타임 양자화 | 유연함 | 추론 오버헤드 | | Static Quantization | 캘리브레이션 기반 | 빠른 추론 | 캘리브레이션 필요 | --- --- --- --- --- --- --- --- | 방법 | 비트 | 속도 | 품질 | 사용 난이도 |...", "url": "/study/ko/LLM_and_NLP/13_Model_Quantization.html"}, {"id": "LLM_and_NLP/14_RLHF_Alignment", "title": "14. RLHF와 LLM 정렬 (Alignment)", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- RLHF(Reinforcement Learning from Human Feedback) 이해 - Reward Model 학습 - PPO를 통한 정책 최적화 - DPO(Direct Preference Optimization) - Constitutional AI와 안전한 AI --- --- --- --- --- --- | 항목 | RLHF | DPO | |------|------|-----| | Reward Model | 필요 | 불필요 | | 학습 안정성 | 불안정 | 안정적 | | 하이퍼파라미터 | 많음 | 적음 | | 메모리 | 높음 | 낮음 | | 성능 | 우수 | 동등 이상 | --- --- --- | 방법 | 복잡도 | 성능 | 사용 시점 | |------|--------|------|----------| | SFT | 낮음 | 기본 | 항상 첫 단계 | | RLHF (PPO) | 높음 | 우수 | 복잡한 정렬 | | DPO | 중간 | 우수 | 간단한 정렬 | |...", "url": "/study/ko/LLM_and_NLP/14_RLHF_Alignment.html"}, {"id": "LLM_and_NLP/15_LLM_Agents", "title": "15. LLM 에이전트 (LLM Agents)", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- 에이전트 개념과 아키텍처 이해 - ReAct 패턴 구현 - 도구 사용 (Tool Use) 기법 - LangChain Agent 활용 - 자율 에이전트 시스템 (AutoGPT 등) --- | 항목 | 챗봇 | 에이전트 | |------|------|----------| | 응답 방식 | 단일 응답 | 다단계 추론 | | 도구 사용 | 제한적 | 다양한 도구 | | 자율성 | 낮음 | 높음 | | 계획 수립 | 없음 | 있음 | | 예시 | 고객 지원 봇 | AutoGPT, Copilot | --- --- --- --- --- --- --- | 아키텍처 | 특징 | 사용 시점 | |----------|------|----------| | ReAct | 추론-행동 반복 | 단계별 문제 해결 | | Function Calling | 구조화된 도구 호출 | API 연동 | | Plan-and-Execute | 계획 후 실행 | 복잡한 작업 | | AutoGPT | 자율 목표 달성 |...", "url": "/study/ko/LLM_and_NLP/15_LLM_Agents.html"}, {"id": "LLM_and_NLP/16_Evaluation_Metrics", "title": "16. LLM 평가 지표 (Evaluation Metrics)", "topic": "LLM_and_NLP", "topic_display": "LLM and NLP", "body": "- 텍스트 생성 평가 지표 이해 (BLEU, ROUGE, BERTScore) - 코드 생성 평가 (HumanEval, MBPP) - LLM 벤치마크 (MMLU, HellaSwag, TruthfulQA) - 인간 평가와 자동 평가 --- | 평가 유형 | 설명 | 예시 | |----------|------|------| | 자동 평가 | 알고리즘 기반 점수 | BLEU, ROUGE, Perplexity | | 모델 기반 평가 | LLM이 평가 | GPT-4 as Judge | | 인간 평가 | 사람이 직접 평가 | A/B 테스트, 리커트 척도 | | 벤치마크 | 표준화된 테스트셋 | MMLU, HumanEval | --- --- --- --- --- --- --- --- | 태스크 | 추천 지표 | |--------|----------| | 번역 | BLEU, COMET | | 요약 | ROUGE, BERTScore | | 대화 | Human Eval, LLM-as-Judge | |...", "url": "/study/ko/LLM_and_NLP/16_Evaluation_Metrics.html"}, {"id": "LaTeX/00_Overview", "title": "LaTeX", "topic": "LaTeX", "topic_display": "LaTeX", "body": "문서 구조, 수식 조판, 그래픽, 프레젠테이션 및 자동화를 다루는 LaTeX 문서 작성 시스템에 대한 종합 가이드. | # | 제목 | 설명 | |---|-------|-------------| | 01 | 소개 및 설치 | TeX/LaTeX 개요, 설치, 편집기, 첫 문서 | | 02 | 문서 구조 | 문서 클래스, 전문부(preamble), 섹션 구분, 구성 | | 03 | 텍스트 서식 | 글꼴, 크기, 강조, 색상, 간격 | | 04 | 목록 및 환경 | Itemize, enumerate, description, 사용자 정의 목록 | | 05 | 표 | Tabular 환경, multirow, multicolumn, booktabs | | 06 | 그림 및 그래픽 | Includegraphics, subfigures, 위치 지정, 캡션 | | 07 | 수식 조판 I | 인라인 수식, 디스플레이 수식, 기호, 연산자 | | 08 | 수식 조판 II | 행렬, 정렬, 정리, 고급...", "url": "/study/ko/LaTeX/00_Overview.html"}, {"id": "LaTeX/01_Introduction_and_Setup", "title": "LaTeX 소개", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 1 > 사전 요구 사항: 기본 컴퓨터 활용 능력, 텍스트 편집기 사용 경험 > 목표: LaTeX가 무엇인지 이해하고, TeX 배포판을 설치하거나 Overleaf에 접근하여 첫 번째 문서를 컴파일하기 TeX(\"테크\"로 발음)는 1978년 Donald Knuth가 만든 조판 시스템입니다. 전설적인 컴퓨터 과학자인 Knuth는 그의 책 시리즈 \"The Art of Computer Programming\"의 개정판에서 수학 조판의 품질이 낮은 것에 좌절했습니다. 그는 복잡한 수학 공식을 포함한 아름답고 출판 품질의 문서를 만들 수 있는 자체 조판 시스템을 만들기로 결정했습니다. TeX는 사용자에게 문서 서식에 대한 정밀한 제어를 제공하는 저수준 마크업 언어입니다. 그러나 이러한 정밀성은 복잡성의 대가가 따릅니다—원시 TeX를 작성하는 것은 지루하고 조판 규칙에 대한 깊은 지식이 필요합니다. LaTeX(\"라텍\"또는 \"레이텍\"으로 발음)는 1980년대...", "url": "/study/ko/LaTeX/01_Introduction_and_Setup.html"}, {"id": "LaTeX/02_Document_Structure", "title": "문서 구조", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 2 > 사전 요구 사항: 레슨 1 (소개 및 설치) > 목표: 문서 클래스(Document Class), 전문부(preamble) 구성, 섹션 명령 및 복잡한 문서를 구성하는 기술 마스터하기 모든 LaTeX 문서는 로 시작합니다. 문서 클래스는 문서의 전체 구조 및 서식 규칙을 정의합니다. LaTeX는 여러 내장 문서 클래스를 제공합니다: 목적: 챕터가 없는 짧은 문서 (논문, 기사, 보고서) 특성: - 명령 없음 - 최상위 구분으로 으로 시작 - Abstract 환경 사용 가능 - 일반적으로 단면 예제: 목적: 챕터가 있는 긴 문서 (기술 보고서, 논문) 특성: - 명령 포함 - 챕터는 새 페이지에서 시작 - 기본값은 단면 - 제목 페이지가 초록과 분리됨 예제: 목적: 서적 및 긴 문서 특성: - 양면 인쇄용으로 설계됨 - , , , 포함 - 챕터는 오른쪽 페이지에서만 시작 가능 - 전면부(front matter)에 대한 별도 서식...", "url": "/study/ko/LaTeX/02_Document_Structure.html"}, {"id": "LaTeX/03_Text_Formatting", "title": "텍스트 서식", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 3 > 사전 요구 사항: 레슨 2 (문서 구조) > 목표: 텍스트 스타일, 글꼴, 색상, 목록, 인용, 축자(verbatim) 텍스트, 특수 문자, 간격, 정렬 및 각주 마스터하기 LaTeX는 텍스트 모양을 변경하기 위한 여러 명령을 제공합니다. 강조 명령: 예제: 출력: > This is bold, italic, and text. > The command underlines text, while emphasis adapts to context. 는 의미 기반이고 는 표현적입니다: 는 토글됩니다: 일반 텍스트에서는 이탤릭체이고 이탤릭체 텍스트에서는 정체입니다. 단축키 (LaTeX 2ε): 더 이상 사용되지 않지만 여전히 일반적: 구식 스타일을 피해야 하는 이유? - 간격을 자동으로 조정하지 않음 - 중첩이 잘 되지 않음 - 의미적이지 않음 예제: 가장 작은 것부터 가장 큰 것까지: 예제: 범위 지정: 크기 변경은 그룹 에 로컬입니다:...", "url": "/study/ko/LaTeX/03_Text_Formatting.html"}, {"id": "LaTeX/04_Math_Basics", "title": "수학 조판 기초", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 4 > 사전 요구 사항: 레슨 3 (텍스트 서식) > 목표: 인라인 및 디스플레이 수식 모드, 그리스 문자, 아래 첨자/위 첨자, 분수, 근, 연산자, 구분 기호 및 수학 기호 마스터하기 LaTeX의 수학 조판은 가장 강력한 기능 중 하나입니다. 일반 텍스트와 달리 수학 표기법은 특별한 서식 규칙, 간격 및 기호가 필요합니다. 1. 인라인 수식(Inline math): 텍스트 라인 내의 수학 2. 디스플레이 수식(Display math): 자체 라인에 중앙 정렬된 수학 동일한 명령이 두 모드에서 작동하지만 디스플레이 수식은 더 많은 세로 공간과 더 큰 기호를 제공합니다. 인라인 수식은 단락 내의 수학 표현식에 사용됩니다. 전통적인 방법: 출력: > The quadratic formula is ax² + bx + c = 0 where a ≠ 0. > Einstein's famous equation is E = mc². LaTeX2ε는 대안을...", "url": "/study/ko/LaTeX/04_Math_Basics.html"}, {"id": "LaTeX/05_Math_Advanced", "title": "고급 수학", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 5번째 > 선수지식: 기본 수학 조판, 패키지 & 문서 클래스 > 목표: 다중 행 수식, 행렬, 정리 환경, 물리학 및 컴퓨터 과학을 위한 특수 표기법 등 고급 수학 조판 마스터하기. --- 기본 수학 모드가 인라인 수식과 간단한 디스플레이를 다루는 반면, 전문적인 수학 작성에는 다중 행 유도, 정렬된 수식, 행렬, 정리 문장, 도메인별 표기법을 위한 정교한 도구가 필요합니다. 이 레슨에서는 LaTeX를 수학 조판의 표준으로 만드는 강력한 패키지 생태계와 특수 패키지를 탐구합니다. 패키지는 고급 수학에 필수적입니다. 프리앰블에서 로드하세요: 이 패키지는 LaTeX의 기본 수학 기능을 개선하는 수많은 환경과 명령을 제공합니다. 환경은 번호가 매겨진 디스플레이 수식을 생성합니다: 별표 버전 는 번호를 억제합니다: 환경은 특정 지점(일반적으로 또는 )에서 정렬된 여러 수식을 위한 것입니다: 기호가 정렬 지점을 표시합니다. 각 줄은 자체 수식...", "url": "/study/ko/LaTeX/05_Math_Advanced.html"}, {"id": "LaTeX/06_Floats_and_Figures", "title": "부동체, 그림 & 표", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 6번째 > 선수지식: 문서 구조, 패키지 > 목표: 캡션, 레이블, 상호 참조, 고급 배치 기법을 포함한 LaTeX의 부동체 시스템을 사용한 그림, 이미지, 표의 배치 및 관리 마스터하기. --- LaTeX 초보자에게 가장 흔한 좌절감의 원인 중 하나는 그림과 표가 소스 코드에서 입력한 위치에 정확히 나타나지 않는다는 것입니다. 이는 LaTeX가 이것들을 부동체(Floats)로 취급하기 때문입니다—어색한 페이지 나누기를 피하고 좋은 타이포그래피를 유지하기 위해 최적의 위치로 \"떠다니는\" 객체입니다. 이 레슨에서는 부동체 시스템이 어떻게 작동하는지와 효과적으로 제어하는 방법을 설명합니다. 부동체는 다음과 같이 페이지를 가로질러 분할되어서는 안 되는 콘텐츠를 위한 컨테이너입니다: - 그림 (이미지, 다이어그램) - 표 - 알고리즘 (특수 패키지 사용) 다음 시나리오를 고려하세요: 텍스트를 작성하고 큰 이미지를 삽입합니다. 정확히 입력한 위치에...", "url": "/study/ko/LaTeX/06_Floats_and_Figures.html"}, {"id": "LaTeX/07_Tables_Advanced", "title": "고급 표", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 7번째 > 선수지식: 부동체와 그림, 문서 구조 > 목표: booktabs를 사용한 전문 형식, 다중 행 및 다중 열 셀, 색상 표, 여러 페이지에 걸친 긴 표, 연구 논문 및 기술 문서를 위한 정교한 표 레이아웃 등 고급 표 생성 기법 마스터하기. --- 표는 학술 논문, 보고서, 기술 문서에서 구조화된 데이터를 제시하는 데 필수적입니다. LaTeX의 기본 환경이 간단한 표를 만들 수 있지만, 전문 출판물에는 병합된 셀, 일관된 간격, 전문 수평선, 여러 페이지에 걸친 표와 같은 정교한 형식이 필요합니다. 이 레슨에서는 문서를 출판 품질로 끌어올리는 고급 표 기법을 다룹니다. 고급 기능을 살펴보기 전에 기본을 복습하겠습니다: - - 왼쪽 정렬 열 - - 중앙 정렬 열 - - 오른쪽 정렬 열 - - 지정된 너비의 단락 열 - - 수직선 - - 열 구분 - - 행 끝 - - 모든 열에 걸친 수평선 - - i열에서 j열까지 수평선 패키지는...", "url": "/study/ko/LaTeX/07_Tables_Advanced.html"}, {"id": "LaTeX/08_Cross_References", "title": "상호 참조 & 인용", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 8번째 > 선수지식: 부동체와 그림, 표, 수학 조판 > 목표: 섹션, 수식, 그림, 표 상호 참조 마스터하기; BibTeX와 BibLaTeX를 사용한 참고문헌 관리 학습; 전문 학술 문서를 위한 하이퍼링크, 색인, 용어집 생성하기. --- 전문 문서는 광범위한 상호 참조가 필요합니다: 그림, 표, 수식, 섹션, 외부 소스 인용. LaTeX는 콘텐츠를 추가, 제거 또는 재정렬할 때도 일관성을 보장하면서 이러한 참조를 자동으로 관리하는 강력한 시스템을 제공합니다. 이 레슨에서는 LaTeX의 상호 참조 시스템, 참고문헌 관리, 하이퍼링크, 색인, 용어집과 같은 고급 기능을 다룹니다. 두 명령이 함께 작동합니다: - - 위치 표시 - - 레이블이 지정된 항목의 번호 삽입 출력: \"As discussed in Section 1, we propose...\" 중요: 을 수식 환경 내부에 배치하세요. 중요: 을 다음에 배치하세요. 그렇지 않으면 참조가...", "url": "/study/ko/LaTeX/08_Cross_References.html"}, {"id": "LaTeX/09_Page_Layout", "title": "페이지 레이아웃 및 타이포그래피(Page Layout & Typography)", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 9번째 > 선수지식: 기본 LaTeX 문서 구조(레슨 1), 패키지 > 목표: 페이지 레이아웃 커스터마이징, 여백, 헤더/푸터, 간격 및 고급 타이포그래피 기법 숙달 전문적인 문서는 페이지 레이아웃과 타이포그래피에 대한 정밀한 제어를 필요로 합니다. LaTeX는 여백과 헤더부터 줄 간격과 다단 레이아웃에 이르기까지 페이지 디자인의 모든 측면을 커스터마이징할 수 있는 강력한 패키지와 명령어를 제공합니다. 이 레슨은 출판 품질의 전문적인 타이포그래피를 갖춘 문서를 만드는 데 필수적인 도구를 다룹니다. 패키지는 페이지 크기와 여백을 제어하는 표준 도구입니다. 패키지는 헤더와 푸터에 대한 완전한 제어를 제공합니다. Widows(페이지 상단의 단락 마지막 줄)와 orphans(하단의 단락 첫 줄)는 가독성을 해칩니다. 패키지는 문자 간격과 줄 바꿈을 미묘하게 개선합니다. 다음 사양을 갖춘 문서를 만드세요: - A4 용지 크기 - 상단 여백:...", "url": "/study/ko/LaTeX/09_Page_Layout.html"}, {"id": "LaTeX/10_TikZ_Basics", "title": "TikZ 그래픽 기초(TikZ Graphics Basics)", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 10번째 > 선수지식: 기본 LaTeX 문서 구조(레슨 1), 패키지 > 목표: 고품질 벡터 그래픽, 다이어그램 및 기술 일러스트레이션 생성을 위한 TikZ 기초 숙달 TikZ(TikZ ist kein Zeichenprogramm - \"TikZ는 그리기 프로그램이 아닙니다\")는 벡터 그래픽을 프로그래밍 방식으로 생성하기 위한 강력한 LaTeX 패키지입니다. 외부 이미지를 가져오는 것과 달리 TikZ 그래픽은 코드를 사용하여 생성되므로 확장 가능하고 문서 타이포그래피와 일관성이 있으며 버전 제어가 쉽습니다. TikZ는 다이어그램, 차트, 플로차트, 기술 일러스트레이션 및 수학적 시각화에 널리 사용됩니다. TikZ는 하위 레벨 그래픽 시스템인 PGF에 대한 상위 레벨 인터페이스를 제공합니다. 주요 장점: - 프로그래밍 방식: 마우스 클릭이 아닌 코드로 정의된 그래픽 - 확장 가능: 완벽하게 확장되는 벡터 그래픽 - 타이포그래피 통합: 그래픽의...", "url": "/study/ko/LaTeX/10_TikZ_Basics.html"}, {"id": "LaTeX/11_TikZ_Advanced", "title": "고급 TikZ 및 PGFPlots(Advanced TikZ & PGFPlots)", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 11번째 > 선수지식: TikZ 기초(레슨 10), 기본 수학 > 목표: 고급 TikZ 기법 숙달 및 출판 품질의 데이터 시각화와 복잡한 다이어그램 생성을 위한 PGFPlots 학습 TikZ 기초를 바탕으로 이 레슨은 정교한 그래픽을 만들기 위한 고급 기법을 다룹니다. 데이터 시각화를 위한 PGFPlots, foreach 루프, 트리, 장식, 패턴과 같은 고급 TikZ 기능 및 신경망, 상태 기계, 출판 품질의 플롯과 같은 복잡한 다이어그램을 만드는 방법을 배웁니다. PGFPlots는 TikZ를 기반으로 구축되었으며 수학 함수와 데이터의 고품질 플롯 생성을 전문으로 합니다. 명령은 반복적인 그리기를 위한 루프를 가능하게 합니다. TikZ는 강력한 트리 그리기 기능을 제공합니다. 더 복잡한 그래프 구조를 위해서는 graphs 라이브러리를 사용하세요. 장식은 경로에 시각적 효과를 추가합니다. 반복 패턴으로 영역을 채웁니다. 레이어는 그리기...", "url": "/study/ko/LaTeX/11_TikZ_Advanced.html"}, {"id": "LaTeX/12_Beamer_Presentations", "title": "Beamer 프레젠테이션(Beamer Presentations)", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 주제: LaTeX > 레슨: 16개 중 12번째 > 선수지식: 기본 LaTeX 문서 구조(레슨 1), 그림 및 표(레슨 5) > 목표: 오버레이, 테마, 애니메이션 및 고급 기능을 사용하여 전문적인 프레젠테이션을 만들기 위한 Beamer 클래스 숙달 Beamer는 프레젠테이션 슬라이드(슬라이드쇼)를 만들기 위한 LaTeX 문서 클래스입니다. PowerPoint나 Google Slides와 달리 Beamer 프레젠테이션은 코드를 사용하여 생성되므로 일관된 타이포그래피, 쉬운 버전 제어, 수식의 원활한 통합 및 슬라이드 콘텐츠에 대한 프로그래밍 방식 제어가 보장됩니다. Beamer는 수학, 물리학, 컴퓨터 과학 및 공학 분야의 학술 및 기술 프레젠테이션 표준입니다. Beamer는 다음과 같은 PDF 프레젠테이션을 생성합니다: - 프레임(슬라이드): 개별 프레젠테이션 페이지 - 오버레이: 콘텐츠의 점진적 표시 - 테마: 전문적인 시각적 스타일링 - 탐색: 자동 목차, 섹션 링크 -...", "url": "/study/ko/LaTeX/12_Beamer_Presentations.html"}, {"id": "LaTeX/13_Custom_Commands", "title": "사용자 정의 명령 및 환경(Custom Commands & Environments)", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 토픽: LaTeX > 레슨: 13 of 16 > 선수지식: Lessons 01-08 (특히 수식 조판) > 목표: 사용자 정의 명령, 환경, 개인 패키지를 생성하여 효율성을 향상시키고 일관성을 유지하는 방법 학습 사용자 정의 명령과 환경은 다음을 가능하게 하는 강력한 기능입니다: - 반복 방지: 매번 을 입력하는 대신 사용 - 일관성 유지: 한 곳에서 표기법을 변경하면 모든 곳에 적용 - 가독성 향상: 가 보다 명확함 - 바로가기 생성: 복잡한 서식을 간단한 명령으로 정의 - 개인 패키지 구축: 여러 프로젝트에서 정의를 재사용 이 레슨에서는 명령 생성, 사용자 정의 환경, 카운터, 조건부 로직, 패키지 생성을 다룹니다. --- 문제점: - 을 반복적으로 입력하는 것은 지루함 - 로 변경하려면 모든 경우를 수정해야 함 - 일관되지 않은 표기법의 위험 이점: - 대신 입력 - 정의를 한 번만 변경하면 모든 경우가 업데이트됨 - 문서 전체에서 일관된 표기법 --- - **:...", "url": "/study/ko/LaTeX/13_Custom_Commands.html"}, {"id": "LaTeX/14_Document_Classes", "title": "문서 클래스 및 템플릿(Document Classes & Templates)", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 토픽: LaTeX > 레슨: 14 of 16 > 선수지식: Lessons 01-06 (문서 구조, 서식) > 목표: 표준 및 전문 문서 클래스를 이해하고, 학술 논문, 학위논문, 이력서, 출판물을 위한 전문 템플릿 생성 문서 클래스(Document Class)는 모든 LaTeX 문서의 기초로, 맨 첫 줄에 지정됩니다: 문서 클래스는 다음을 결정합니다: - 페이지 레이아웃: 여백, 용지 크기, 텍스트 폭 - 타이포그래피: 글꼴 크기, 제목 스타일 - 구조: 섹션 번호 매기기, 목차 형식 - 사용 가능한 명령: 해당 문서 유형의 특수 명령 이 레슨에서는 표준 클래스, KOMA-Script 대안, 이력서와 학위논문을 위한 전문 클래스, 필요에 맞는 템플릿을 찾고 적응하는 방법을 다룹니다. --- LaTeX는 네 가지 표준 클래스를 제공합니다: | 클래스 | 용도 | 주요 특징 | |-------|---------|--------------| | | 짧은 논문, 기사 | 챕터 없음,...", "url": "/study/ko/LaTeX/14_Document_Classes.html"}, {"id": "LaTeX/15_Automation_and_Build", "title": "빌드 시스템 및 자동화(Build Systems & Automation)", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 토픽: LaTeX > 레슨: 15 of 16 > 선수지식: Lessons 01-10 (문서 생성, 참고문헌) > 목표: 자동화된 컴파일 워크플로우, 빌드 시스템, 버전 관리, CI/CD, 현대적인 LaTeX 개발 환경 마스터 전문적인 LaTeX 워크플로우는 수동 컴파일 이상이 필요합니다. 다음이 필요합니다: - 자동화된 빌드: 한 명령으로 컴파일, 여러 패스 처리 - 에디터 통합: 순방향/역방향 검색, 구문 강조, 자동 완성 - 버전 관리: 변경 사항 추적, Git으로 협업 - 품질 보증: 맞춤법 검사, 린팅, 자동화된 테스트 - 지속적 통합: 모든 커밋에서 자동 PDF 생성 - 재현성: 동일한 소스가 모든 곳에서 동일한 출력 생성 이 레슨에서는 컴파일 엔진에서 클라우드 기반 CI/CD 파이프라인까지 전체 LaTeX 개발 스택을 다룹니다. --- | 엔진 | 유니코드 | 시스템 글꼴 | 미세 타이포그래피 | 속도 |...", "url": "/study/ko/LaTeX/15_Automation_and_Build.html"}, {"id": "LaTeX/16_Practical_Projects", "title": "실전 프로젝트(Practical Projects)", "topic": "LaTeX", "topic_display": "LaTeX", "body": "> 토픽: LaTeX > 레슨: 16 of 16 > 선수지식: 모든 이전 레슨 (01-15) > 목표: 학습한 모든 개념을 세 가지 완전한 실제 프로젝트에 적용: 학술 논문, Beamer 프레젠테이션, 과학 포스터 이 마지막 레슨은 이전 15개 레슨의 모든 내용을 세 가지 완전하고 컴파일 가능한 프로젝트로 통합합니다: 1. 학술 논문(Academic Paper): 초록, 섹션, 그림, 표, 수식, 참고문헌이 있는 완전한 연구 논문 2. Beamer 프레젠테이션(Beamer Presentation): 사용자 정의 테마, 오버레이, TikZ 다이어그램이 있는 15슬라이드 학회 발표 3. TikZ 과학 포스터(TikZ Scientific Poster): 다중 열 레이아웃, 플롯, QR 코드가 있는 A0 포스터 각 프로젝트는 다음을 포함합니다: - 완전한 소스 코드 - 컴파일 지침 - 일반적인 함정과 해결책 - 사용자 정의 팁 - 실제 모범 사례 --- 다음에 적합한 완전한 연구 논문...", "url": "/study/ko/LaTeX/16_Practical_Projects.html"}, {"id": "Linux/00_Overview", "title": "Linux 학습 가이드", "topic": "Linux", "topic_display": "Linux", "body": "이 폴더는 Linux 운영체제의 기초부터 서버 관리까지 체계적으로 학습할 수 있는 자료를 담고 있습니다. - 대상 독자: 리눅스 입문자 ~ 서버 관리자 - 배포판: Ubuntu/Debian 및 CentOS/RHEL 모두 안내 - 목표: 명령어 사용부터 서버 운영까지 --- --- - 기본적인 컴퓨터 사용 능력 - 터미널/명령 프롬프트 개념 이해 - 영어 명령어 읽기 (필수 아님) --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01LinuxBasics.md | ⭐ | 리눅스 개념, 배포판, 터미널, 기본 명령어 | | 02FilesystemNavigation.md | ⭐ | 디렉토리 구조, 경로, ls, cd, find | | 03FileDirectoryManagement.md | ⭐ | touch, mkdir, cp, mv, rm, tar | | 04TextProcessing.md | ⭐⭐ | grep, sed, awk,...", "url": "/study/ko/Linux/00_Overview.html"}, {"id": "Linux/01_Linux_Basics", "title": "리눅스 기초", "topic": "Linux", "topic_display": "Linux", "body": "리눅스는 1991년 리누스 토르발스가 개발한 오픈소스 운영체제입니다. | 특징 | 설명 | |------|------| | 오픈소스 | 소스 코드 공개, 무료 사용 가능 | | 안정성 | 서버 운영에 적합한 높은 안정성 | | 보안 | 권한 기반 보안 모델 | | 멀티유저 | 여러 사용자 동시 접속 지원 | | 멀티태스킹 | 여러 프로세스 동시 실행 | | 이식성 | 다양한 하드웨어에서 동작 | --- 리눅스 커널을 기반으로 다양한 배포판이 존재합니다. | 배포판 | 기반 | 특징 | 용도 | |--------|------|------|------| | Ubuntu | Debian | 사용 편의성, 큰 커뮤니티 | 입문자, 데스크톱, 서버 | | Debian | - | 안정성, 엄격한 패키지 정책 | 서버 | | CentOS/Rocky | RHEL | 엔터프라이즈급 안정성 | 기업 서버 | | Fedora | RHEL | 최신 기술, RHEL 테스트베드 | 개발자 | |...", "url": "/study/ko/Linux/01_Linux_Basics.html"}, {"id": "Linux/02_Filesystem_Navigation", "title": "파일시스템 탐색", "topic": "Linux", "topic_display": "Linux", "body": "리눅스는 FHS(Filesystem Hierarchy Standard)를 따르는 트리 구조입니다. --- | 디렉토리 | 설명 | 예시 | |----------|------|------| | | 루트, 모든 디렉토리의 시작점 | - | | | 일반 사용자 홈 디렉토리 | | | | root 사용자 홈 | - | | | 시스템 설정 파일 | , | | | 로그, 캐시 등 가변 데이터 | | | | 임시 파일 (모든 사용자 쓰기 가능) | - | | | 사용자 프로그램, 라이브러리 | | | | 서드파티 소프트웨어 | | | , | 시스템 필수 명령어 | , | | | 장치 파일 | , | | | 프로세스/커널 정보 (가상) | | --- 루트()부터 시작하는 전체 경로입니다. 현재 위치를 기준으로 한 경로입니다. | 기호 | 의미 | 예시 | |------|------|------| | | 현재 디렉토리 | | | | 상위 디렉토리 | | | | 홈 디렉토리 | = | | | 이전...", "url": "/study/ko/Linux/02_Filesystem_Navigation.html"}, {"id": "Linux/03_File_Directory_Management", "title": "파일과 디렉토리 관리", "topic": "Linux", "topic_display": "Linux", "body": "생성 결과: --- | 옵션 | 설명 | |------|------| | , | 디렉토리 재귀 복사 | | | 덮어쓰기 전 확인 | | | 진행 상황 표시 | | | 권한, 소유자, 타임스탬프 유지 | | | 아카이브 모드 (-rpP와 동일) | | | 더 새로운 파일만 복사 | | | 덮어쓰지 않음 | --- | 옵션 | 설명 | |------|------| | | 덮어쓰기 전 확인 | | | 진행 상황 표시 | | | 덮어쓰지 않음 | | | 더 새로운 경우만 이동 | --- | 옵션 | 설명 | |------|------| | , | 디렉토리 재귀 삭제 | | | 강제 삭제 (확인 없음) | | | 삭제 전 확인 | | | 삭제 파일 표시 | --- 큰 파일을 편하게 볼 수 있습니다. | 키 | 동작 | |----|------| | / | 다음 페이지 | | | 이전 페이지 | | | 파일 처음으로 | | | 파일 끝으로 | | | 앞으로 검색 | | | 뒤로 검색 | | |...", "url": "/study/ko/Linux/03_File_Directory_Management.html"}, {"id": "Linux/04_Text_Processing", "title": "텍스트 처리", "topic": "Linux", "topic_display": "Linux", "body": "grep은 파일에서 패턴을 검색하는 강력한 도구입니다. | 옵션 | 설명 | |------|------| | | 대소문자 무시 (ignore case) | | , | 재귀 검색 (recursive) | | | 줄 번호 표시 (line number) | | | 패턴 제외 (invert) | | | 매칭 줄 수 (count) | | | 파일명만 출력 (files with matches) | | | 매칭 안 된 파일명 | | | 단어 단위 매칭 (word) | | | 매칭 후 n줄 표시 (after) | | | 매칭 전 n줄 표시 (before) | | | 매칭 전후 n줄 표시 (context) | | | 확장 정규표현식 | | | 매칭 부분만 출력 | --- | 패턴 | 설명 | 예시 | |------|------|------| | | 임의의 한 문자 | → abc, adc | | | 앞 문자 0회 이상 | → ac, abc, abbc | | | 줄 시작 | → 줄 시작의 Error...", "url": "/study/ko/Linux/04_Text_Processing.html"}, {"id": "Linux/05_Permissions_Ownership", "title": "권한과 소유권", "topic": "Linux", "topic_display": "Linux", "body": "리눅스의 모든 파일은 권한(permission)을 가집니다. | 권한 | 문자 | 숫자 | 파일 | 디렉토리 | |------|------|------|------|----------| | 읽기 | r | 4 | 내용 읽기 | 목록 보기 (ls) | | 쓰기 | w | 2 | 내용 수정 | 파일 생성/삭제 | | 실행 | x | 1 | 실행 | 진입 (cd) | | 없음 | - | 0 | 권한 없음 | 권한 없음 | 숫자 변환: --- | 권한 | 숫자 | 용도 | |------|------|------| | rwxr-xr-x | 755 | 실행 파일, 디렉토리 | | rw-r--r-- | 644 | 일반 파일 | | rw------- | 600 | 민감한 파일 (키, 설정) | | rwx------ | 700 | 개인 디렉토리 | | rwxrwxr-x | 775 | 그룹 공유 디렉토리 | --- --- --- 실행 시 파일 소유자의 권한으로 실행됩니다. 실행 시 파일 그룹의...", "url": "/study/ko/Linux/05_Permissions_Ownership.html"}, {"id": "Linux/06_User_Group_Management", "title": "사용자와 그룹 관리", "topic": "Linux", "topic_display": "Linux", "body": "리눅스는 사용자 정보를 특정 파일들에 저장합니다. 사용자 계정 정보를 저장합니다. 출력: 암호화된 비밀번호를 저장합니다 (root만 읽기 가능). 출력: 그룹 정보를 저장합니다. 출력: --- 출력: --- --- --- sudo 권한을 설정하는 파일입니다. 항상 visudo로 편집해야 합니다. 별도 파일로 설정을 관리할 수 있습니다. --- 출력: 출력: 출력: --- | UID 범위 | 용도 | |----------|------| | 0 | root | | 1-999 | 시스템 사용자 | | 1000+ | 일반 사용자 | | 사용자 | 용도 | |--------|------| | root | 시스템 관리자 | | www-data | 웹 서버 | | mysql | MySQL 데이터베이스 | | postgres | PostgreSQL | | nobody | 최소 권한 프로세스 | --- --- --- --- 07ProcessManagement.md에서 프로세스 관리를 배워봅시다!", "url": "/study/ko/Linux/06_User_Group_Management.html"}, {"id": "Linux/07_Process_Management", "title": "프로세스 관리", "topic": "Linux", "topic_display": "Linux", "body": "프로세스는 실행 중인 프로그램의 인스턴스입니다. | 상태 | 코드 | 설명 | |------|------|------| | Running | R | 실행 중 또는 실행 대기 | | Sleeping | S | 대기 중 (인터럽트 가능) | | Disk Sleep | D | 대기 중 (인터럽트 불가) | | Stopped | T | 정지됨 (Ctrl+Z) | | Zombie | Z | 종료됐지만 부모가 수거 안 함 | --- | 필드 | 설명 | |------|------| | USER | 실행 사용자 | | PID | 프로세스 ID | | %CPU | CPU 사용률 | | %MEM | 메모리 사용률 | | VSZ | 가상 메모리 크기 | | RSS | 실제 메모리 사용량 | | TTY | 터미널 (? = 없음) | | STAT | 상태 | | START | 시작 시간 | | TIME | CPU 사용 시간 | | COMMAND | 명령어 | --- 출력: | 항목 | 설명 |...", "url": "/study/ko/Linux/07_Process_Management.html"}, {"id": "Linux/08_Package_Management", "title": "패키지 관리", "topic": "Linux", "topic_display": "Linux", "body": "패키지 관리자는 소프트웨어 설치, 업데이트, 제거를 자동화합니다. | 배포판 | 패키지 형식 | 저수준 도구 | 고수준 도구 | |--------|------------|------------|------------| | Ubuntu/Debian | .deb | dpkg | apt | | CentOS/RHEL 8+ | .rpm | rpm | dnf | | CentOS/RHEL 7 | .rpm | rpm | yum | | Fedora | .rpm | rpm | dnf | --- --- --- 저장소 파일 형식: --- --- 저장소에 없는 소프트웨어를 직접 컴파일합니다. --- --- --- CentOS Linux는 모든 버전이 수명 종료(End-of-Life, EOL)되었습니다. - CentOS 8: 2021년 12월 31일 EOL - CentOS 7: 2024년 6월 30일 EOL CentOS Stream은 현재 유일하게 사용 가능한 CentOS 변종이지만, 다른 목적으로...", "url": "/study/ko/Linux/08_Package_Management.html"}, {"id": "Linux/09_Shell_Scripting", "title": "쉘 스크립팅", "topic": "Linux", "topic_display": "Linux", "body": "쉘 스크립트는 명령어들을 파일에 모아 자동화하는 프로그램입니다. 스크립트의 첫 줄은 인터프리터를 지정합니다. --- | 변수 | 설명 | |------|------| | | 스크립트 이름 | | ~ | 위치 매개변수 | | | 매개변수 개수 | | | 모든 매개변수 (개별) | | | 모든 매개변수 (문자열) | | | 직전 명령 종료 상태 | | | 현재 프로세스 PID | | | 마지막 백그라운드 PID | --- --- | 연산자 | 설명 | |--------|------| | | 같다 (equal) | | | 다르다 (not equal) | | | 크다 (greater than) | | | 크거나 같다 | | | 작다 (less than) | | | 작거나 같다 | | 연산자 | 설명 | |--------|------| | | 같다 | | | 다르다 | | | 빈 문자열 | | | 비어있지 않음 | | 연산자 | 설명 | |--------|------| | | 파일 존재 |...", "url": "/study/ko/Linux/09_Shell_Scripting.html"}, {"id": "Linux/10_Network_Basics", "title": "네트워크 기초", "topic": "Linux", "topic_display": "Linux", "body": "| 클래스 | 대역 | 용도 | |--------|------|------| | A | 10.0.0.0/8 | 대규모 네트워크 | | B | 172.16.0.0/12 | 중규모 네트워크 | | C | 192.168.0.0/16 | 가정/소규모 | | 포트 | 서비스 | |------|--------| | 22 | SSH | | 80 | HTTP | | 443 | HTTPS | | 3306 | MySQL | | 5432 | PostgreSQL | | 6379 | Redis | --- 출력: 출력: --- --- 로컬 DNS 설정입니다. DNS 서버 설정입니다. --- 옵션: | 옵션 | 설명 | |------|------| | | TCP | | | UDP | | | LISTEN 상태만 | | | 숫자로 표시 | | | 프로세스 정보 | --- 사용: --- --- --- --- 11SystemMonitoring.md에서 시스템 모니터링을 배워봅시다!", "url": "/study/ko/Linux/10_Network_Basics.html"}, {"id": "Linux/11_System_Monitoring", "title": "시스템 모니터링", "topic": "Linux", "topic_display": "Linux", "body": "출력: 출력: --- 출력: --- 출력: | 필드 | 설명 | |------|------| | total | 전체 메모리 | | used | 사용 중 | | free | 미사용 | | shared | 공유 메모리 | | buff/cache | 버퍼/캐시 | | available | 사용 가능 (free + 해제 가능한 캐시) | --- 출력: 출력: --- | 로그 파일 | 내용 | |-----------|------| | | 시스템 로그 (Ubuntu) | | | 시스템 로그 (CentOS) | | | 인증 로그 (Ubuntu) | | | 인증 로그 (CentOS) | | | 커널 로그 | | | 부팅 메시지 | | | Nginx 로그 | | | Apache 로그 | --- --- 출력: 부하 평균 해석: - CPU 코어 수보다 낮으면 여유 있음 - CPU 코어 수와 같으면 완전 사용 - CPU 코어 수보다 높으면 과부하 출력: | 필드 | 설명 | |------|------|...", "url": "/study/ko/Linux/11_System_Monitoring.html"}, {"id": "Linux/12_Security_and_Firewall", "title": "보안과 방화벽", "topic": "Linux", "topic_display": "Linux", "body": "- [ ] 불필요한 서비스 비활성화 - [ ] 기본 포트 변경 (SSH 등) - [ ] 강력한 비밀번호 정책 - [ ] 정기적인 보안 업데이트 - [ ] 로그 모니터링 - [ ] 방화벽 설정 - [ ] SSH 키 인증 사용 --- --- UFW(Uncomplicated Firewall)는 Ubuntu의 기본 방화벽입니다. --- firewalld는 CentOS/RHEL의 기본 방화벽입니다. | Zone | 설명 | |------|------| | drop | 모든 연결 거부 | | block | 연결 거부 + ICMP 응답 | | public | 공개 (기본) | | external | 외부 (NAT) | | dmz | DMZ | | work | 업무 | | home | 가정 | | internal | 내부 | | trusted | 모든 연결 허용 | --- | 모드 | 설명 | |------|------| | Enforcing | 정책 적용 (기본) | | Permissive |...", "url": "/study/ko/Linux/12_Security_and_Firewall.html"}, {"id": "Linux/13_Systemd_Advanced", "title": "13. systemd 심화", "topic": "Linux", "topic_display": "Linux", "body": "- systemd 아키텍처와 동작 원리 이해 - 커스텀 서비스 유닛 작성 - 타이머 유닛으로 스케줄링 - 소켓 활성화와 의존성 관리 1. systemd 아키텍처 2. 서비스 유닛 작성 3. 타이머 유닛 4. 소켓 활성화 5. 의존성과 순서 6. journald 로깅 7. 연습 문제 --- --- --- --- --- --- --- --- - 14성능튜닝 - 시스템 성능 최적화 - 15컨테이너내부_구조 - cgroups, namespaces - systemd 공식 문서 - systemd Documentation - Arch Wiki - systemd - RHEL systemd Guide --- ← 이전: 보안과 방화벽 | 다음: 성능 튜닝 → | 목차", "url": "/study/ko/Linux/13_Systemd_Advanced.html"}, {"id": "Linux/14_Performance_Tuning", "title": "14. Linux 성능 튜닝", "topic": "Linux", "topic_display": "Linux", "body": "- 시스템 성능 모니터링 및 분석 - sysctl을 통한 커널 파라미터 최적화 - CPU, 메모리, I/O 성능 튜닝 - perf와 flamegraph를 활용한 프로파일링 1. 성능 분석 기초 2. CPU 튜닝 3. 메모리 튜닝 4. I/O 튜닝 5. 네트워크 튜닝 6. 프로파일링 도구 7. 연습 문제 --- --- --- --- --- --- --- --- - 15컨테이너내부구조 - cgroups, namespaces - 16저장소_관리 - LVM, RAID - Brendan Gregg's Blog - Linux Performance - Red Hat Performance Tuning Guide - kernel.org sysctl Documentation - perf Examples --- ← 이전: systemd 심화 | 다음: 컨테이너 내부 구조 → | 목차", "url": "/study/ko/Linux/14_Performance_Tuning.html"}, {"id": "Linux/15_Container_Internals", "title": "15. 컨테이너 내부 구조", "topic": "Linux", "topic_display": "Linux", "body": "- Linux 컨테이너 격리 기술 이해 - namespaces로 리소스 격리 - cgroups로 리소스 제한 - 컨테이너 런타임 동작 원리 1. 컨테이너 기초 2. Linux Namespaces 3. Control Groups (cgroups) 4. Union Filesystem 5. 컨테이너 런타임 6. 보안 7. 연습 문제 --- --- --- --- --- --- --- --- - 16저장소관리 - LVM, RAID - Docker 문서 - OCI Runtime Spec - Linux Namespaces - cgroups v2 - OverlayFS - runc - Container Security --- ← 이전: 성능 튜닝 | 다음: 저장소 관리 → | 목차", "url": "/study/ko/Linux/15_Container_Internals.html"}, {"id": "Linux/16_Storage_Management", "title": "16. 저장소 관리", "topic": "Linux", "topic_display": "Linux", "body": "- LVM(Logical Volume Manager) 구성 및 관리 - RAID 레벨 이해 및 구성 - 파일시스템 선택과 최적화 - LUKS를 통한 디스크 암호화 1. 스토리지 기초 2. LVM 3. RAID 4. 파일시스템 5. 디스크 암호화 6. 모니터링과 유지보수 7. 연습 문제 --- --- --- --- --- --- --- --- - 13systemd심화 - systemd 복습 - 14성능튜닝 - I/O 튜닝 - 15컨테이너내부_구조 - 컨테이너 볼륨 - LVM Administrator's Guide - Linux RAID Wiki - Btrfs Wiki - LUKS Documentation --- ← 이전: 컨테이너 내부 구조 | 목차", "url": "/study/ko/Linux/16_Storage_Management.html"}, {"id": "Linux/17_SELinux_AppArmor", "title": "SELinux와 AppArmor", "topic": "Linux", "topic_display": "Linux", "body": "이 문서를 통해 다음을 학습합니다: - 필수 접근 제어(MAC)의 개념과 필요성 - SELinux 모드와 정책 관리 - AppArmor 프로파일 작성 및 관리 - 보안 모듈 트러블슈팅 난이도: ⭐⭐⭐⭐ (고급) --- 1. 필수 접근 제어 개요 2. SELinux 기초 3. SELinux 정책 관리 4. SELinux 트러블슈팅 5. AppArmor 기초 6. AppArmor 프로파일 7. 실무 시나리오 --- | 특성 | SELinux | AppArmor | |------|---------|----------| | 기반 배포판 | RHEL/CentOS/Fedora | Ubuntu/Debian/SUSE | | 접근 방식 | 레이블 기반 | 경로 기반 | | 복잡도 | 높음 | 낮음 | | 세밀함 | 매우 세밀 | 중간 | | 학습 곡선 | 가파름 | 완만 | | 기본 정책 | 포괄적 | 제한적 | --- 모든 파일, 프로세스, 포트에 보안 컨텍스트가 할당됩니다: | 타입 | 설명...", "url": "/study/ko/Linux/17_SELinux_AppArmor.html"}, {"id": "Linux/18_Log_Management", "title": "로그 관리", "topic": "Linux", "topic_display": "Linux", "body": "이 문서를 통해 다음을 학습합니다: - systemd-journald의 설정과 활용 - rsyslog 설정 및 필터링 - logrotate를 통한 로그 순환 - 원격 로그 수집 구성 난이도: ⭐⭐⭐ (중급-고급) --- 1. Linux 로그 시스템 개요 2. systemd-journald 3. journalctl 고급 사용법 4. rsyslog 설정 5. logrotate 6. 원격 로그 수집 7. 로그 분석 도구 --- | 파일 | 내용 | |------|------| | | 일반 시스템 메시지 (RHEL/CentOS) | | | 일반 시스템 메시지 (Ubuntu/Debian) | | | 인증 관련 로그 (Ubuntu) | | | 인증 관련 로그 (RHEL) | | | 커널 메시지 | | | 부팅 시 커널 메시지 | | | 크론 작업 로그 | | | 메일 서버 로그 | | 레벨 | 이름 | 설명 | |------|------|------| | 0 | emerg | 시스템 사용...", "url": "/study/ko/Linux/18_Log_Management.html"}, {"id": "Linux/19_Backup_Recovery", "title": "백업 및 복구", "topic": "Linux", "topic_display": "Linux", "body": "이 문서를 통해 다음을 학습합니다: - rsync를 활용한 효율적인 백업 - Borg Backup으로 중복 제거 백업 - 시스템 이미지 백업과 복구 - 재해복구(DR) 전략 수립 난이도: ⭐⭐⭐⭐ (고급) --- 1. 백업 전략 개요 2. rsync 고급 사용법 3. Borg Backup 4. tar/cpio 백업 5. 시스템 이미지 백업 6. 재해복구 전략 7. 자동화 및 모니터링 --- | 유형 | 설명 | 장점 | 단점 | |------|------|------|------| | 전체 백업 | 모든 데이터 복사 | 복구 간단 | 시간/용량 많이 소요 | | 증분 백업 | 마지막 백업 이후 변경분만 | 빠르고 용량 적음 | 복구 시 체인 필요 | | 차등 백업 | 마지막 전체 백업 이후 변경분 | 증분보다 복구 간단 | 증분보다 용량 큼 | | 스냅샷 | 특정 시점의 파일시스템 상태 | 즉시 생성 | 저장소 의존적 | --- --- Borg Backup은 중복 제거, 압축,...", "url": "/study/ko/Linux/19_Backup_Recovery.html"}, {"id": "Linux/20_Kernel_Management", "title": "커널 관리", "topic": "Linux", "topic_display": "Linux", "body": "이 문서를 통해 다음을 학습합니다: - Linux 커널 구조와 버전 관리 - 커널 모듈 관리 (로드, 언로드, 설정) - 커널 컴파일과 설치 - GRUB 부트로더 설정 난이도: ⭐⭐⭐⭐ (고급) --- 1. 커널 개요 2. 커널 버전 관리 3. 커널 모듈 4. DKMS 5. 커널 컴파일 6. GRUB 부트로더 7. 커널 파라미터 --- | 구성 요소 | 역할 | |-----------|------| | 프로세스 관리 | 프로세스 생성, 스케줄링, 종료 | | 메모리 관리 | 가상 메모리, 페이징, 캐싱 | | 파일시스템 | VFS, ext4, XFS, NFS 등 | | 네트워킹 | TCP/IP 스택, 소켓, 라우팅 | | 디바이스 드라이버 | 하드웨어 추상화, 모듈 | | 시스템 호출 | 사용자 공간과 커널 인터페이스 | --- --- --- DKMS (Dynamic Kernel Module Support)는 커널 업데이트 시 외부 모듈을 자동으로 재빌드합니다. --- ---...", "url": "/study/ko/Linux/20_Kernel_Management.html"}, {"id": "Linux/21_Virtualization_KVM", "title": "가상화 (KVM)", "topic": "Linux", "topic_display": "Linux", "body": "이 문서를 통해 다음을 학습합니다: - KVM/QEMU 가상화 개념과 아키텍처 - libvirt와 virsh를 이용한 VM 관리 - 가상 네트워크 설정 - 스냅샷과 마이그레이션 난이도: ⭐⭐⭐⭐ (고급) --- 1. KVM/QEMU 개요 2. 설치 및 설정 3. VM 생성 4. virsh 명령어 5. 네트워크 설정 6. 스토리지 관리 7. 스냅샷과 마이그레이션 --- --- --- --- --- --- --- --- virt-install을 사용하여 다음 사양의 VM을 생성하세요: - 이름: test-server - 메모리: 2GB - CPU: 2개 - 디스크: 20GB (qcow2) - 네트워크: default (NAT) - 그래픽: VNC 격리된 내부 네트워크를 생성하세요: - 이름: internal - 대역: 10.10.10.0/24 - DHCP: 10.10.10.100-200 - NAT 없음 1. VM의 스냅샷을 생성하세요 2. VM에 변경을 가하세요 (파일 생성 등) 3....", "url": "/study/ko/Linux/21_Virtualization_KVM.html"}, {"id": "Linux/22_Ansible_Basics", "title": "Ansible 기초", "topic": "Linux", "topic_display": "Linux", "body": "이 문서를 통해 다음을 학습합니다: - Ansible의 개념과 아키텍처 - 인벤토리와 Ad-hoc 명령어 - Playbook 작성 및 실행 - Roles와 변수 관리 난이도: ⭐⭐⭐ (중급-고급) --- 1. Ansible 개요 2. 설치 및 설정 3. 인벤토리 4. Ad-hoc 명령어 5. Playbook 6. 변수와 팩트 7. Roles 8. Ansible Vault --- Ansible은 에이전트 없이 SSH로 작동하는 IT 자동화 도구입니다. | 특성 | Ansible | Puppet | Chef | |------|---------|--------|------| | 에이전트 | 불필요 | 필요 | 필요 | | 언어 | YAML | Ruby DSL | Ruby | | Push/Pull | Push | Pull | Pull | | 학습 곡선 | 낮음 | 중간 | 높음 | --- --- --- --- --- --- --- --- 다음 서버들의 인벤토리를 YAML 형식으로...", "url": "/study/ko/Linux/22_Ansible_Basics.html"}, {"id": "Linux/23_Advanced_Networking", "title": "고급 네트워킹", "topic": "Linux", "topic_display": "Linux", "body": "이 문서를 통해 다음을 학습합니다: - VLAN 설정과 802.1Q 태깅 - NIC Bonding/Teaming - 브릿지 네트워킹 - iptables와 nftables 심화 난이도: ⭐⭐⭐⭐ (고급) --- 1. VLAN 설정 2. NIC Bonding 3. 브릿지 네트워킹 4. iptables 심화 5. nftables 6. 고급 라우팅 7. Traffic Control (tc) --- --- | 모드 | 이름 | 설명 | 스위치 설정 | |------|------|------|-------------| | 0 | balance-rr | 라운드 로빈 | 불필요 | | 1 | active-backup | 액티브-백업 | 불필요 | | 2 | balance-xor | XOR 해시 | 불필요 | | 3 | broadcast | 브로드캐스트 | 불필요 | | 4 | 802.3ad | LACP | LACP 필요 | | 5 | balance-tlb | 전송 부하 분산 | 불필요 | | 6...", "url": "/study/ko/Linux/23_Advanced_Networking.html"}, {"id": "Linux/24_Cloud_Integration", "title": "클라우드 통합", "topic": "Linux", "topic_display": "Linux", "body": "이 문서를 통해 다음을 학습합니다: - cloud-init을 이용한 인스턴스 초기화 - AWS CLI 설치 및 설정 - EC2 메타데이터 서비스 활용 - 클라우드 환경에서의 Linux 운영 난이도: ⭐⭐⭐ (중급-고급) --- 1. cloud-init 개요 2. cloud-init 설정 3. AWS CLI 4. EC2 메타데이터 5. 인스턴스 프로파일과 IAM 6. 기타 클라우드 CLI 7. 클라우드 네이티브 운영 --- cloud-init은 클라우드 인스턴스의 초기 설정을 자동화하는 도구입니다. | 단계 | 설명 | |------|------| | Generator | systemd에서 cloud-init 실행 결정 | | Local | 로컬 데이터소스에서 네트워크 설정 | | Network | 메타데이터 가져오기 | | Config | cloud-config 모듈 실행 | | Final | 최종 스크립트, 패키지 설치 | --- --- --- | 경로 | 설명 |...", "url": "/study/ko/Linux/24_Cloud_Integration.html"}, {"id": "Linux/25_High_Availability_Cluster", "title": "고가용성 클러스터", "topic": "Linux", "topic_display": "Linux", "body": "이 문서를 통해 다음을 학습합니다: - 고가용성(HA) 클러스터의 개념 - Pacemaker와 Corosync 설정 - DRBD를 이용한 스토리지 복제 - 페일오버와 Fencing 난이도: ⭐⭐⭐⭐⭐ (최고급) --- 1. 고가용성 개요 2. Corosync 설정 3. Pacemaker 설정 4. 리소스 관리 5. DRBD 설정 6. Fencing (STONITH) 7. 실전 클러스터 구성 --- | 구성 요소 | 역할 | |-----------|------| | Corosync | 클러스터 통신 및 멤버십 관리 | | Pacemaker | 리소스 관리 및 페일오버 | | DRBD | 블록 레벨 스토리지 복제 | | STONITH/Fencing | Split-brain 방지 | --- --- --- --- --- --- --- pcs를 사용하여 2노드 클러스터를 설정하는 명령 순서를 작성하세요. VIP (192.168.1.200), 파일시스템 (/dev/sdb1 → /data),...", "url": "/study/ko/Linux/25_High_Availability_Cluster.html"}, {"id": "Linux/26_Troubleshooting_Guide", "title": "트러블슈팅 가이드", "topic": "Linux", "topic_display": "Linux", "body": "이 문서를 통해 다음을 학습합니다: - 체계적인 문제 진단 방법론 - 부팅 문제 해결 - 네트워크, 디스크, 메모리 문제 진단 - 성능 병목 분석 난이도: ⭐⭐⭐ (중급-고급) --- 1. 문제 해결 방법론 2. 부팅 문제 3. 네트워크 문제 4. 디스크 문제 5. 메모리 문제 6. 프로세스 문제 7. 성능 분석 --- --- --- --- --- --- --- --- 시스템이 emergency mode로 부팅됩니다. 원인을 찾고 해결하는 단계를 설명하세요. /var 파티션이 100% 찼습니다. 원인을 찾고 해결하는 명령을 작성하세요. 외부 웹 사이트에 접속이 안 됩니다. 단계별 진단 절차를 작성하세요. --- --- - Linux Performance - Red Hat System Administrator's Guide - Ubuntu Server Guide - , , --- 이 문서로 Linux 학습 시리즈가 완료됩니다. 전체 학습 내용: - 01-03: Linux 기초 -...", "url": "/study/ko/Linux/26_Troubleshooting_Guide.html"}, {"id": "MHD/00_Overview", "title": "자기유체역학 (MHD)", "topic": "MHD", "topic_display": "MHD", "body": "이 토픽은 전기 전도성 유체와 자기장의 상호작용을 다루는 심화 자기유체역학을 다룹니다. Numerical Simulation(L17-L18)의 MHD 기초와 PlasmaPhysics의 플라즈마 물리 기반 위에, 평형 이론, 안정성, 자기 재결합, 난류, 다이나모 작용, 천체물리/핵융합 응용을 포괄적인 계산 예제와 함께 탐구합니다. - PlasmaPhysics L04-L06 (하전 입자 운동, 드리프트, 단열 불변량) - PlasmaPhysics L13-L14 (이유체 모형, 운동론→MHD 유도) - NumericalSimulation L17-L18 (이상 MHD 방정식, 1D MHD 수치해법) - MathematicalMethods L05 (벡터 해석), L13 (PDE 방법) - Python 중급 (NumPy, SciPy, Matplotlib) | 파일명 | 난이도 | 주요 내용 | 비고 | |--------|--------|----------|------| |...", "url": "/study/ko/MHD/00_Overview.html"}, {"id": "MHD/01_MHD_Equilibria", "title": "1. MHD 평형", "topic": "MHD", "topic_display": "MHD", "body": "- 이상 MHD 운동량 방정식으로부터 MHD 힘 균형 방정식 유도 - 힘 균형의 결과 이해: 플럭스 표면 상에서 압력 일정 - 1차원 평형 분석: θ-pinch, Z-pinch, screw pinch 구성 - 축대칭 평형에 대한 Grad-Shafranov 방정식 수식화 및 풀이 - 안전 인자 q 계산 및 안정성에 대한 의미 이해 - 플라즈마 베타 계산 및 운영 한계 이해 - 간단한 평형 구성에 대한 수치 해 구현 자기유체역학 평형은 모든 힘이 균형을 이루고 알짜 가속도가 없는 자화 플라즈마의 정상 상태 구성을 설명합니다. 평형을 이해하는 것은 핵융합 에너지 연구, 천체물리학 플라즈마 물리학, 그리고 갇힌 플라즈마와 관련된 모든 응용에 기본적입니다. MHD 평형은 다음을 만족합니다: 평형 상태는 다음 사이의 균형에 의해 지배됩니다: - 플라즈마 압력 구배 힘: ∇p (외부로 밀어냄) - 자기 장력: (B·∇)B/μ₀ (자기장선을 따라 당김) - 자기 압력 구배: -∇(B²/2μ₀)...", "url": "/study/ko/MHD/01_MHD_Equilibria.html"}, {"id": "MHD/02_Linear_Stability", "title": "2. 선형 안정성 이론", "topic": "MHD", "topic_display": "MHD", "body": "- 평형 주변에서 이상 MHD 방정식의 선형화 이해 - 힘 연산자 유도 및 정규 모드에 대한 고유값 문제 수식화 - 고유값 문제를 풀지 않고 안정성을 결정하는 에너지 원리 적용 - 특정 평형에 대한 성장률 및 안정성 경계 계산 - 외부 kink 안정성에 대한 Kruskal-Shafranov 기준 이해 - 국소 interchange 안정성에 대한 Suydam 기준 적용 - MHD 안정성 분석을 위한 수치 고유값 솔버 구현 MHD 평형은 힘 균형을 만족하지만 작은 섭동에 대해 불안정할 수 있습니다. 안정성 분석은 섭동이 성장하는지 (불안정), 감쇠/진동하는지 (안정)를 결정합니다. 선형 안정성 이론은 무한소 섭동의 진화를 조사합니다: 주요 질문: - 섭동이 지수적으로 성장합니까? (불안정) - 성장 없이 진동합니까? (한계 안정) - 감쇠합니까? (안정) 성장률 $\\gamma$ 또는 주파수 $\\omega$는 고유값 문제를 풀어 결정됩니다. 평형으로부터의 플라즈마 변위...", "url": "/study/ko/MHD/02_Linear_Stability.html"}, {"id": "MHD/03_Pressure_Driven_Instabilities", "title": "3. 압력 구동 불안정성", "topic": "MHD", "topic_display": "MHD", "body": "- 불리한 곡률에 의해 구동되는 교환 불안정성의 물리적 메커니즘 이해 - 자화 플라즈마에서의 Rayleigh-Taylor 불안정성 분석 - 층화된 대기에서의 Parker 불안정성 연구 - 토로이달 기하학에서 높은-n 모드에 대한 ballooning 모드 이론 유도 및 적용 - 국소 교환 안정성에 대한 Mercier 기준 사용 - 압력 구동 불안정성의 수치 시뮬레이션 구현 - 실험 관측(토카막의 ELM)과의 연결 이해 압력 구동 불안정성은 압력 구배가 자기장선 굽힘에 대항하여 유체 운동을 구동할 수 있는 자유 에너지를 제공할 때 발생합니다. 이러한 불안정성은 특히 다음에서 중요합니다: - 핵융합 플라즈마: 달성 가능한 압력 제한(베타 한계) - 천체물리학 플라즈마: 태양 홍염, 코로나 질량 방출 - 행성 자기권: 자기꼬리의 자기장 구성 기본 물리학은 다음 사이의 경쟁입니다: - 불안정화: 불리한 곡률에서의 압력 구배 - 안정화: 자기장선 굽힘(장력) 교환 불안정성은 인접한 플럭스...", "url": "/study/ko/MHD/03_Pressure_Driven_Instabilities.html"}, {"id": "MHD/04_Current_Driven_Instabilities", "title": "4. 전류 구동 불안정성", "topic": "MHD", "topic_display": "MHD", "body": "- 플라즈마 전류에 의해 구동되는 kink 불안정성(외부 및 내부) 이해 - Sausage 불안정성과 그 안정화 분석 - Tearing 모드 이론과 자기 섬 형성 유도 - 저항 벽 모드와 피드백 안정화 연구 - 토카막의 신고전 tearing 모드(NTM) 이해 - Tearing 모드에 대한 Δ' 매개변수와 성장률 계산 - 전류 구동 불안정성에 대한 수치 솔버 구현 - 이론과 실험 관측(sawtooth, disruption)의 연결 전류 구동 불안정성은 자유 에너지원이 플라즈마 전류(또는 등가적으로, 자기장 구성)인 MHD 모드입니다. 압력 구동 모드와 달리, 이것들은 압력이 0일 때도 존재할 수 있습니다. 주요 특징: - 전류/자기장 구성에 의해 구동 - 이상적(저항 없음) 또는 저항성(재결합) 가능 - 종종 달성 가능한 최대 플라즈마 전류 제한 - 토카막에서 주요 disruption으로 이어짐 외부 kink (토로이달 시스템에서 m=1, n=1)는 플라즈마 기둥의 전역...", "url": "/study/ko/MHD/04_Current_Driven_Instabilities.html"}, {"id": "MHD/05_Reconnection_Theory", "title": "5. 자기 재결합 이론", "topic": "MHD", "topic_display": "MHD", "body": "이 레슨을 마치면 다음을 할 수 있어야 합니다: 1. 자기 재결합이 플라즈마 물리학 및 천체물리학에서 중요한 이유 설명하기 2. Sweet-Parker 재결합률 유도하고 그 한계 이해하기 3. Petschek 모델을 분석하고 더 빠른 재결합을 달성하는 방법 설명하기 4. 무충돌 재결합에서 Hall 물리학의 역할 이해하기 5. X-점 기하학과 재결합 영역의 구조 설명하기 6. 무차원 재결합률 계산 및 해석하기 7. 재결합률 스케일링의 수치 모델 구현하기 자기 재결합은 자기장 위상 구조가 변화하고 자기 에너지가 플라즈마 운동 및 열 에너지로 빠르게 변환되는 기본적인 플라즈마 과정입니다. 이 과정은 우주에서 가장 폭발적인 현상들을 일으킵니다. 이 과정은 비이상 효과(저항, Hall 물리학 또는 운동학적 효과)로 인해 동결 조건이 무너지는 얇은 전류 시트에서 발생합니다. 변화하는 위상 구조는 자기 에너지가 종종 폭발적으로 방출되도록 합니다. 자기 재결합은 다음을 이해하는 데 중요합니다:...", "url": "/study/ko/MHD/05_Reconnection_Theory.html"}, {"id": "MHD/06_Reconnection_Applications", "title": "6. 재결합 응용", "topic": "MHD", "topic_display": "MHD", "body": "이 레슨을 마치면 다음을 할 수 있어야 합니다: 1. 태양 플레어의 CSHKP 모델을 설명하고 핵심 재결합 신호를 식별하기 2. 코로나 질량 방출(CME)과 자속 로프 분출에서 재결합의 역할 설명하기 3. Dungey 순환과 자기권 서브스톰 이해하기 4. 토카막 톱니파 충돌과 Kadomtsev 재결합 모델 분석하기 5. 자기 섬 병합과 그 동역학 설명하기 6. 천체물리학 제트와 기타 고에너지 현상에서의 재결합 설명하기 7. 이러한 재결합 응용의 간단한 모델을 Python으로 구현하기 태양 플레어는 태양계에서 가장 강력한 폭발로, 수 분에서 수 시간 동안 최대 $10^{32}$ erg ($10^{25}$ J)의 에너지를 방출합니다. 이것은 수십억 메가톤의 TNT에 해당하거나, 천만 번의 화산 폭발이 동시에 발생하는 것과 같습니다. 주요 관측 특징: - 전자기 방출: 전파에서 감마선까지 - 연X선 방출: 10–30 MK의 열 플라즈마 - 경X선 방출: 비열적 전자(제동복사) -...", "url": "/study/ko/MHD/06_Reconnection_Applications.html"}, {"id": "MHD/07_Advanced_Reconnection", "title": "7. 고급 재결합", "topic": "MHD", "topic_display": "MHD", "body": "이 레슨을 마치면 다음을 할 수 있어야 합니다: 1. 플라스모이드 불안정성과 높은 Lundquist 수에서 빠른 재결합에서의 역할 설명하기 2. 난류 재결합 모델(Lazarian-Vishniac) 이해하기 3. 가이드 자기장이 재결합 동역학에 미치는 영향 분석하기 4. 상대론적 재결합과 그 응용 설명하기 5. 3차원 재결합과 준분리층 이해하기 6. 플라스모이드 불안정성과 3D 재결합 구조의 수치 모델 구현하기 레슨 5에서 보았듯이, Sweet-Parker 재결합은 큰 Lundquist 수에서 극도로 느린 속도를 예측합니다: $$MA = S^{-1/2}$$ $S \\sim 10^{14}$인 태양 코로나의 경우: $$MA \\sim 10^{-7}$$ 이것은 너무 느립니다. 그러나 근본적인 문제가 있습니다: Sweet-Parker 전류 시트 자체가 높은 $S$에서 불안정해집니다. 플라스모이드 불안정성(전류 시트의 찢김 불안정성이라고도 함)은 Biskamp(1986)에 의해 처음 식별되었고...", "url": "/study/ko/MHD/07_Advanced_Reconnection.html"}, {"id": "MHD/08_MHD_Turbulence", "title": "8. MHD 난류", "topic": "MHD", "topic_display": "MHD", "body": "이 레슨을 마치면 다음을 할 수 있어야 합니다: 1. 유체역학 난류와 Kolmogorov K41 이론 복습하기 2. MHD 난류의 Iroshnikov-Kraichnan(IK) 이론 이해하기 3. Goldreich-Sridhar 임계 균형(critical balance) 이론과 비등방 캐스케이드(anisotropic cascade) 설명하기 4. Elsässer 변수와 MHD 난류에서의 역할 다루기 5. 에너지 캐스케이드, 간헐성(intermittency), 그리고 구조 함수(structure functions) 설명하기 6. 태양풍 난류 관측 분석하기 7. MHD 난류 스펙트럼의 수치 모델 구현하기 난류는 커피 젓기부터 은하 역학까지 자연에서 어디에나 존재합니다. 난류의 특징은 다음과 같습니다: - 혼란스럽고 불규칙한 운동: 예측 불가능하며, 초기 조건에 민감함 - 다중 스케일 구조: 소용돌이 안의 소용돌이(Richardson 캐스케이드) - 강화된 혼합: 분자 확산을 훨씬...", "url": "/study/ko/MHD/08_MHD_Turbulence.html"}, {"id": "MHD/09_Dynamo_Theory", "title": "9. Dynamo Theory", "topic": "MHD", "topic_display": "MHD", "body": "이 레슨을 마치면 다음을 할 수 있어야 합니다: - 기본적인 dynamo 문제와 행성 및 별들이 자기장을 유지하기 위해 dynamo 메커니즘이 필요한 이유 설명하기 - MHD 근사에서 자기 유도 방정식 유도하고 해석하기 - Anti-dynamo 정리(Cowling, Zeldovich)와 dynamo 요구사항에 대한 함의 이해하기 - Stretch-twist-fold 메커니즘을 포함한 kinematic dynamo 모델 분석하기 - 평균장 이론을 적용하여 대규모 dynamo 작용(α-효과, β-효과, α-Ω dynamos) 이해하기 - Kinematic과 dynamical dynamo 영역 구별하고 포화 메커니즘 이해하기 - 간단한 dynamos의 수치 모델 구현하고 성장률 분석하기 지구, 태양, 그리고 많은 다른 천체 물체들은 수십억 년 동안 지속된 대규모 자기장을 가지고 있습니다. 이것은 근본적인 문제를 제기합니다: 자유 붕괴 문제: 생성 메커니즘이 없는 경우, 전도성 유체의...", "url": "/study/ko/MHD/09_Dynamo_Theory.html"}, {"id": "MHD/10_Turbulent_Dynamo", "title": "10. 난류 Dynamo", "topic": "MHD", "topic_display": "MHD", "body": "이 레슨을 마치면 다음을 할 수 있어야 합니다: - 소규모(변동) 및 대규모(평균장) 난류 dynamos 구별하기 - Kazantsev 이론과 난류에서 자기장의 kinematic 성장 이해하기 - Dynamo 작용에서 자기 Prandtl 수(Pm)의 역할 설명하기 - 자기 helicity 보존과 대규모 dynamo 성장에 대한 제약 분석하기 - 포화 메커니즘과 kinematic에서 dynamic 영역으로의 전환 설명하기 - MHD 난류를 위한 수치 시뮬레이션 접근법(DNS, LES) 이해하기 - 소규모 dynamo 성장과 helicity 진화 모델 구현하기 많은 천체물리학 환경—항성 내부, 강착 원반, 성간 매질, 은하단—에서 흐름은 고도로 난류입니다. 난류 dynamos는 층류 dynamos와 몇 가지 핵심 방식에서 다릅니다: 1. 광범위한 스케일 스펙트럼: 난류는 에너지 주입 스케일 부터 소산 스케일(Kolmogorov 스케일 또는 저항 스케일 )까지 광범위한 길이 스케일에...", "url": "/study/ko/MHD/10_Turbulent_Dynamo.html"}, {"id": "MHD/11_Solar_MHD", "title": "11. 태양 MHD", "topic": "MHD", "topic_display": "MHD", "body": "이 강의를 마치면 다음을 할 수 있어야 합니다: - 태양 구조와 각 층에서 자기장의 역할 설명 - 자기 플럭스 튜브와 흑점의 물리학 이해 - 태양 다이나모 메커니즘과 11/22년 태양 주기 설명 - 코로나 가열 문제 및 제안된 해결책 분석 - Parker의 태양풍 모델 유도 및 적용 - 태양풍 난류 특성화 및 그 성질 파악 - 태양 현상의 수치 모델 구현 (Parker 태양풍, 플럭스 튜브, 나비 다이어그램) 태양은 밀도, 온도, 자기장 강도에서 여러 차수의 크기를 걸쳐 층화된 복잡한 플라즈마 시스템입니다. 내부: 1. 핵(Core) (r < 0.25 R☉): - 온도: - 밀도: - 핵융합: - 에너지 수송: 복사 (광자 확산) 2. 복사층(Radiative zone) (0.25 R☉ < r < 0.7 R☉): - 온도: - 복사 확산이 지배적 - 안정적 층화 (대류 없음) - 차등 회전 확립 3. 타코클라인(Tachocline) (r ~ 0.7 R☉): - 얇은 전단층...", "url": "/study/ko/MHD/11_Solar_MHD.html"}, {"id": "MHD/12_Accretion_Disk_MHD", "title": "12. 강착 원반 MHD", "topic": "MHD", "topic_display": "MHD", "body": "이 강의를 마치면 다음을 할 수 있어야 합니다: - 강착 원반에서 각운동량 수송의 근본적인 문제 이해 - 자기 회전 불안정성(MRI) 분산 관계 유도 및 분석 - 천체물리 원반 강착에 MRI가 필수적인 이유 설명 - MRI 성장률 및 특성 파장 계산 - 맥스웰 및 레이놀즈 응력을 통한 각운동량 수송 이해 - MRI 난류를 α-원반 모델에 연결 - 원반 바람 및 제트 형성 메커니즘 설명 (Blandford-Payne, 자기 타워) - MRI 및 원반 물리학의 수치 모델 구현 강착 원반(Accretion disk)은 낙하하는 물질이 상당한 각운동량을 가질 때 컴팩트 천체 (블랙홀, 중성자별, 백색왜성) 및 원시별 주위에 형성됩니다. 물질은 회전하는 원반 구성으로 정착합니다. 케플러 회전: 중심 질량 주위의 반경 에서 원 궤도를 도는 시험 입자의 경우: 각속도: 이것이 케플러 회전(Keplerian rotation)입니다: 각속도가 반경에 따라 감소합니다. 문제: 물질이 강착(안쪽으로...", "url": "/study/ko/MHD/12_Accretion_Disk_MHD.html"}, {"id": "MHD/13_Fusion_MHD", "title": "13. 핵융합 MHD", "topic": "MHD", "topic_display": "MHD", "body": "- 자기 confinement 개념 이해: tokamak, stellarator, reversed field pinch (RFP) - Tokamak 평형 분석: aspect ratio, elongation, triangularity, Shafranov shift - Beta 한계 유도 및 Troyon limit 이해 - Tokamak의 주요 MHD 불안정성 파악: sawteeth, ELMs, disruptions, NTMs, RWMs - Disruption 완화 전략 적용 및 물리적 기반 이해 - 정상 상태 핵융합을 위한 stellarator 장점 비교 - Beta limits, sawtooth periods, disruption forces를 위한 Python 모델 구현 자기 confinement 핵융합은 자기장을 사용하여 고온 플라즈마(T ~ 10-20 keV)를 가두어 제어된 열핵융합을 달성하는 것을 목표로 합니다. 주요 과제는 MHD 불안정성에 대한 플라즈마 안정성을...", "url": "/study/ko/MHD/13_Fusion_MHD.html"}, {"id": "MHD/14_Space_Weather", "title": "14. 우주 기상 MHD", "topic": "MHD", "topic_display": "MHD", "body": "- 지구 자기권 구조 및 태양풍 상호작용 이해 - Magnetopause standoff 거리 및 bow shock 형성 분석 - Dungey cycle 및 자기 재결합 과정 설명 - 자기 폭풍 및 Dst index 모델링 - CME 전파, 행성간 충격파 및 도착 예측 연구 - 지자기 유도 전류 (GIC) 및 우주 기상 영향 평가 - 자기권 물리 및 우주 기상 예보를 위한 Python 모델 구현 우주 기상은 우주 기반 및 지상 기반 기술 시스템의 성능과 신뢰성에 영향을 미치고 인간의 생명이나 건강을 위협할 수 있는 태양 및 우주의 가변적인 조건을 의미합니다. 태양-지구 시스템은 태양 코로나 ($T \\sim 10^6$ K, $B \\sim 1-100$ G)에서 지구 자기권 ($B \\sim 0.01-1$ G) 및 전리층 ($ne \\sim 10^{11}$ m$^{-3}$)까지 걸친 결합된 MHD 시스템입니다. 주요 구성요소: - 태양풍: 태양으로부터의 초음속, super-Alfvénic...", "url": "/study/ko/MHD/14_Space_Weather.html"}, {"id": "MHD/15_2D_MHD_Solver", "title": "15. 2D MHD 솔버", "topic": "MHD", "topic_display": "MHD", "body": "- 차원 분할(Dimensional Splitting)과 비분할(Unsplit) 기법을 사용하여 1D MHD 방법을 2D로 확장하기 - 2D Cartesian 그리드에서 유한 체적법(Finite Volume Method) 구현하기 - Constrained Transport (CT)를 적용하여 $\\nabla \\cdot B = 0$을 정확히 보존하기 - 자기장 성분을 위한 엇갈린 그리드(Staggered Grid, Yee Mesh) 사용하기 - 고차 재구성 구현하기: PLM, WENO - 벤치마크 문제 시뮬레이션하기: Orszag-Tang 와류, Kelvin-Helmholtz 불안정성 - Corner Transport Upwind (CTU) 방법 이해하기 MHD 시뮬레이션을 1D에서 2D로 확장하면 새로운 과제들이 도입됩니다: 다차원 파동 전파, 기하학적 소스 항, 그리고 다중 차원에서 $\\nabla \\cdot B = 0$을 보존해야 하는 중요한 요구사항입니다. 2D Cartesian...", "url": "/study/ko/MHD/15_2D_MHD_Solver.html"}, {"id": "MHD/16_Relativistic_MHD", "title": "16. 상대론적 MHD", "topic": "MHD", "topic_display": "MHD", "body": "이 레슨을 마치면 다음을 할 수 있습니다: - 공변 표기법을 사용하여 특수 상대론적 MHD(SRMHD) 방정식을 정식화하기 - SRMHD에서 응력-에너지 텐서와 전자기장 텐서 이해하기 - 수치 구현을 위한 SRMHD 방정식의 3+1 분해 유도하기 - 상대론적 원시 변수 복원 문제 해결하기 - 상대론적 MHD의 파동 구조(fast, slow, Alfvén) 분석하기 - 상대론적 제트, 펄서 자기권, 블랙홀 강착에 SRMHD 적용하기 - Python으로 1D SRMHD 충격파 튜브 솔버 구현하기 - 일반 상대론적 MHD(GRMHD)의 기초와 응용 이해하기 --- 비상대론적 MHD는 $v \\ll c$를 가정하고 다음을 무시합니다: - 전자기장의 Lorentz 수축 - Maxwell 방정식의 변위 전류 - 상대론적 질량-에너지 등가성 상대론적 MHD(RMHD)는 다음의 경우 필수적입니다: | 측면 | 비상대론적 | 상대론적 |...", "url": "/study/ko/MHD/16_Relativistic_MHD.html"}, {"id": "MHD/17_Spectral_Methods", "title": "17. 스펙트럴 및 고급 방법", "topic": "MHD", "topic_display": "MHD", "body": "이 레슨을 마치면 다음을 할 수 있습니다: - MHD를 위한 pseudo-spectral 방법의 원리 이해하기 - 주기적 MHD 문제를 위한 Fourier 기반 스펙트럴 솔버 구현하기 - 비선형 항을 올바르게 처리하기 위한 dealiasing 기법 적용하기 - 비주기 경계값 문제를 위한 Chebyshev 스펙트럴 방법 사용하기 - MHD를 위한 Adaptive Mesh Refinement (AMR) 이해하기 - 운동론적 효과를 위한 hybrid MHD-PIC 방법 설명하기 - SPH-MHD를 그리드 기반 방법과 비교하기 - 생산 MHD 코드 조사하기: Athena++, PLUTO, FLASH, Pencil Code, Dedalus - Python으로 간단한 2D pseudo-spectral MHD 솔버 구현하기 --- 유한 차분 및 유한 체적 방법은 제공합니다: - 정확도: $O(\\Delta x^2)$에서 $O(\\Delta x^5)$ (WENO) - 유연성: 복잡한 기하학,...", "url": "/study/ko/MHD/17_Spectral_Methods.html"}, {"id": "MHD/18_Projects", "title": "18. 프로젝트", "topic": "MHD", "topic_display": "MHD", "body": "이 레슨을 마치면 다음을 할 수 있습니다: - 자기 재결합의 완전한 2D 저항성 MHD 시뮬레이션 구현하기 - 태양 플레어 모델에서 재결합률과 에너지 변환 분석하기 - 토카막 플라즈마를 위한 1D MHD 안정성 분석기 구축하기 - 안정성 기준(Kruskal-Shafranov, Suydam) 적용하여 붕괴 예측하기 - 구형 쉘에서 평균장 다이나모 시뮬레이션하기 - 진동 다이나모 해와 나비 다이어그램 관찰하기 - 이 과정에서 학습한 모든 MHD 개념을 실용 응용에 통합하기 --- 태양 플레어는 태양 코로나에서 자기 에너지가 폭발적으로 방출되는 것으로, 자기 재결합에 의해 구동됩니다 - 자기장 선의 위상학적 재구성으로 자기 에너지를 운동 에너지와 열 에너지로 변환합니다. 핵심 물리: - 티어링 불안정성(Tearing Instability): 전류 시트에서 저항성 불안정성 → 플라즈모이드(plasmoid) 형성 - Sweet-Parker 재결합: 고전 모델, 느린 재결합률 $\\sim...", "url": "/study/ko/MHD/18_Projects.html"}, {"id": "MLOps/00_Overview", "title": "MLOps 학습 가이드", "topic": "MLOps", "topic_display": "MLOps", "body": "MLOps(Machine Learning Operations)는 머신러닝 모델의 개발, 배포, 운영을 자동화하고 효율화하는 실무 분야입니다. 이 학습 자료는 Deep Learning 기초를 이수한 학습자를 대상으로, 실무에서 ML 시스템을 안정적으로 운영하기 위한 전반적인 프로세스와 도구를 다룹니다. - Deep Learning 기초 완료자 - ML 모델을 프로덕션에 배포하고자 하는 개발자 - 데이터 과학팀과 협업하는 소프트웨어 엔지니어 - ML 시스템 운영을 담당하는 DevOps/SRE 엔지니어 --- --- | 파일 | 주제 | 난이도 | 핵심 내용 | |------|------|--------|----------| | 01MLOpsOverview.md | MLOps 개요 | ⭐ | MLOps 정의, DevOps vs MLOps, 성숙도 레벨, 도구 생태계 | | 02MLLifecycle.md | ML 라이프사이클 | ⭐⭐ | 프로젝트 단계, 재학습 트리거, 버전 관리 전략 |...", "url": "/study/ko/MLOps/00_Overview.html"}, {"id": "MLOps/01_MLOps_Overview", "title": "MLOps 개요", "topic": "MLOps", "topic_display": "MLOps", "body": "MLOps(Machine Learning Operations)는 머신러닝 모델의 개발, 배포, 운영을 자동화하고 효율적으로 관리하기 위한 실무 방법론입니다. --- | 구분 | DevOps | MLOps | |------|--------|-------| | 주요 산출물 | 애플리케이션 코드 | 데이터 + 모델 + 코드 | | 테스트 | 유닛/통합 테스트 | + 데이터 검증, 모델 검증 | | 배포 단위 | 컨테이너/서비스 | 모델 + 서빙 인프라 | | 모니터링 | 시스템 메트릭 | + 모델 성능, 데이터 드리프트 | | 롤백 | 이전 버전 배포 | 모델 버전 롤백 + 데이터 고려 | --- --- --- --- --- 현재 팀의 ML 프로세스를 평가하고 성숙도 레벨을 결정하세요. 다음 상황에 적합한 MLOps 도구를 선택하세요: - 소규모 팀, PyTorch 사용, 예산 제한 - 대규모 팀, 멀티 프레임워크, 고성능 필요 --- | 개념 | 설명 | |------|------|...", "url": "/study/ko/MLOps/01_MLOps_Overview.html"}, {"id": "MLOps/02_ML_Lifecycle", "title": "ML 프로젝트 라이프사이클", "topic": "MLOps", "topic_display": "MLOps", "body": "머신러닝 프로젝트는 단순히 모델을 학습시키는 것을 넘어, 데이터 수집부터 모니터링까지 전체 생명주기를 관리해야 합니다. --- --- --- --- --- --- --- --- --- 이커머스 추천 시스템의 ML 파이프라인을 설계하세요. 데이터 수집부터 모니터링까지 각 단계를 정의하세요. 다음 상황에서 재학습 정책을 설계하세요: - 일일 신규 주문 10만 건 - 계절성이 강한 상품 판매 - 모델 추론 latency 50ms 이하 요구 --- | 단계 | 주요 활동 | 핵심 산출물 | |------|----------|------------| | 문제 정의 | 비즈니스 목표, ML 문제 정의 | 프로젝트 문서 | | 데이터 준비 | 수집, 검증, 버전 관리 | 검증된 데이터셋 | | 피처 엔지니어링 | 피처 생성, 변환 | 피처 파이프라인 | | 모델 학습 | 학습, 실험 관리 | 학습된 모델, 메트릭 | | 검증 | 품질 게이트, A/B 테스트 | 검증 리포트 | | 배포 |...", "url": "/study/ko/MLOps/02_ML_Lifecycle.html"}, {"id": "MLOps/03_MLflow_Basics", "title": "MLflow 기초", "topic": "MLOps", "topic_display": "MLOps", "body": "MLflow는 머신러닝 라이프사이클을 관리하기 위한 오픈소스 플랫폼입니다. 실험 추적, 모델 패키징, 배포를 통합적으로 지원합니다. --- --- --- --- --- --- Titanic 데이터셋을 사용하여 생존 예측 모델을 학습하고, MLflow로 실험을 추적하세요. 서로 다른 하이퍼파라미터로 5개 이상의 실험을 실행하고, MLflow UI에서 비교하세요. --- | 기능 | 메서드 | 설명 | |------|--------|------| | 실험 설정 | | 실험 그룹 지정 | | 실행 시작 | | 새 실행 시작 | | 파라미터 | | 입력 파라미터 로깅 | | 메트릭 | | 출력 메트릭 로깅 | | 아티팩트 | | 파일 로깅 | | 모델 | | 모델 저장 | | 자동 로깅 | | 자동 추적 활성화 | --- - MLflow Documentation - MLflow Tracking - MLflow Quickstart", "url": "/study/ko/MLOps/03_MLflow_Basics.html"}, {"id": "MLOps/04_MLflow_Advanced", "title": "MLflow 고급", "topic": "MLOps", "topic_display": "MLOps", "body": "MLflow Projects는 재현 가능한 ML 코드 패키징 형식입니다. --- --- --- --- --- --- 완전한 MLflow Project를 생성하고 로컬에서 실행하세요. 전처리와 후처리를 포함하는 커스텀 pyfunc 모델을 작성하세요. 모델을 등록하고 Staging -> Production 전환을 자동화하세요. --- | 기능 | 설명 | |------|------| | MLflow Projects | 재현 가능한 코드 패키징 | | MLflow Models | 표준화된 모델 포맷 | | Model Registry | 모델 버전 및 스테이지 관리 | | MLflow Serving | REST API 서빙 | | pyfunc | 커스텀 모델 래퍼 | --- - MLflow Projects - MLflow Models - Model Registry", "url": "/study/ko/MLOps/04_MLflow_Advanced.html"}, {"id": "MLOps/05_Weights_and_Biases", "title": "Weights & Biases (W&B)", "topic": "MLOps", "topic_display": "MLOps", "body": "Weights & Biases는 ML 실험 추적, 하이퍼파라미터 튜닝, 모델 관리를 위한 플랫폼입니다. --- --- --- --- --- --- MNIST 데이터셋으로 CNN 모델을 학습하고 W&B로 실험을 추적하세요. 3개 이상의 하이퍼파라미터에 대해 Bayesian 최적화 sweep을 실행하세요. 데이터셋과 모델을 아티팩트로 저장하고 리니지를 확인하세요. --- | 기능 | W&B | MLflow | |------|-----|--------| | 실험 추적 | wandb.log() | mlflow.log_metrics() | | 하이퍼파라미터 튜닝 | Sweeps | 외부 도구 | | 데이터/모델 버전 | Artifacts | Model Registry | | 시각화 | 풍부한 대시보드 | 기본 UI | | 협업 | 팀, 리포트 | 제한적 | | 호스팅 | SaaS / Self-hosted | Self-hosted | --- - W&B Documentation - W&B...", "url": "/study/ko/MLOps/05_Weights_and_Biases.html"}, {"id": "MLOps/06_Kubeflow_Pipelines", "title": "Kubeflow Pipelines", "topic": "MLOps", "topic_display": "MLOps", "body": "Kubeflow는 Kubernetes 위에서 ML 워크플로우를 구축, 배포, 관리하기 위한 오픈소스 플랫폼입니다. --- --- --- --- --- --- --- 3단계 파이프라인을 작성하세요: 데이터 로드 -> 전처리 -> 모델 학습 ParallelFor를 사용하여 여러 하이퍼파라미터 조합을 병렬로 실험하는 파이프라인을 작성하세요. 매주 월요일 새벽에 실행되는 재학습 파이프라인을 설정하세요. --- | 개념 | 설명 | |------|------| | Pipeline | ML 워크플로우 DAG | | Component | 파이프라인의 개별 단계 | | @dsl.component | Python 함수 컴포넌트 | | @dsl.pipeline | 파이프라인 정의 | | dsl.Condition | 조건부 실행 | | dsl.ParallelFor | 병렬 반복 실행 | --- - Kubeflow Pipelines Documentation - KFP SDK v2 - Kubeflow...", "url": "/study/ko/MLOps/06_Kubeflow_Pipelines.html"}, {"id": "MLOps/07_Model_Registry", "title": "모델 레지스트리", "topic": "MLOps", "topic_display": "MLOps", "body": "모델 레지스트리는 ML 모델의 중앙 저장소로, 버전 관리, 메타데이터 추적, 배포 관리를 담당합니다. --- --- --- --- --- --- 모델을 3개 버전 등록하고, 메트릭 기반으로 가장 좋은 버전을 자동 선택하세요. Staging -> Production 승격을 위한 검증 스크립트를 작성하세요. 성능 저하 감지 시 자동으로 이전 버전으로 롤백하는 로직을 구현하세요. --- | 개념 | 설명 | |------|------| | 모델 레지스트리 | 모델의 중앙 저장소 | | 버전 관리 | 모델 변경 이력 추적 | | 스테이지 | None -> Staging -> Production | | 메타데이터 | 모델 관련 정보 (메트릭, 의존성 등) | | 롤백 | 이전 버전으로 복원 | --- - MLflow Model Registry - AWS SageMaker Model Registry - Google Vertex AI Model Registry", "url": "/study/ko/MLOps/07_Model_Registry.html"}, {"id": "MLOps/08_Model_Serving_Basics", "title": "모델 서빙 기초", "topic": "MLOps", "topic_display": "MLOps", "body": "모델 서빙은 학습된 ML 모델을 프로덕션 환경에서 예측 서비스로 제공하는 것입니다. --- --- --- --- --- --- scikit-learn 모델을 FastAPI로 서빙하는 완전한 API를 작성하세요. 작성한 API를 Docker 이미지로 빌드하고 실행하세요. locust 또는 wrk를 사용하여 API 성능을 측정하세요. --- | 방식 | 장점 | 단점 | 사용 사례 | |------|------|------|----------| | REST API | 간단, 범용 | 상대적 고지연 | 일반 웹 서비스 | | gRPC | 저지연, 고처리량 | 복잡성 | 마이크로서비스 | | 배치 추론 | 효율적, 비용 절감 | 실시간 불가 | 대량 데이터 처리 | | 실시간 추론 | 즉시 응답 | 인프라 비용 | 사기 탐지, 추천 | --- - FastAPI Documentation - gRPC Python - Kubernetes ML Serving", "url": "/study/ko/MLOps/08_Model_Serving_Basics.html"}, {"id": "MLOps/09_TorchServe_Triton", "title": "TorchServe & Triton Inference Server", "topic": "MLOps", "topic_display": "MLOps", "body": "TorchServe는 PyTorch 모델을 프로덕션 환경에서 서빙하기 위한 공식 도구입니다. --- --- --- --- --- --- PyTorch 이미지 분류 모델을 TorchServe로 배포하세요. PyTorch 모델을 ONNX로 변환하고 Triton에서 서빙하세요. TensorRT로 모델을 최적화하고 추론 속도를 비교하세요. --- | 도구 | 장점 | 적합한 상황 | |------|------|------------| | TorchServe | PyTorch 네이티브, 간단 | PyTorch 모델 | | Triton | 멀티 프레임워크, 고성능 | 복잡한 요구사항 | | ONNX Runtime | 범용, 크로스 플랫폼 | 경량 배포 | | TensorRT | GPU 최적화 | 최고 성능 필요 | --- - TorchServe Documentation - Triton Inference Server - ONNX Runtime - TensorRT", "url": "/study/ko/MLOps/09_TorchServe_Triton.html"}, {"id": "MLOps/10_Drift_Detection_Monitoring", "title": "드리프트 감지 & 모니터링", "topic": "MLOps", "topic_display": "MLOps", "body": "드리프트(Drift)는 시간이 지남에 따라 데이터나 모델 성능이 변화하는 현상입니다. --- --- --- --- --- 합성 데이터로 데이터 드리프트를 시뮬레이션하고 감지하세요. 실제 데이터셋에 대해 완전한 Evidently 리포트를 생성하세요. 드리프트 감지 시 자동으로 알림을 보내는 시스템을 구축하세요. --- | 드리프트 유형 | 설명 | 감지 방법 | |--------------|------|----------| | Data Drift | 입력 분포 변화 | PSI, KS Test | | Concept Drift | 입출력 관계 변화 | 성능 모니터링 | | Label Drift | 타겟 분포 변화 | 클래스 분포 비교 | --- - Evidently AI Documentation - Data Drift Detection - Prometheus Monitoring", "url": "/study/ko/MLOps/10_Drift_Detection_Monitoring.html"}, {"id": "MLOps/11_Feature_Stores", "title": "Feature Store", "topic": "MLOps", "topic_display": "MLOps", "body": "Feature Store는 ML 피처를 중앙에서 관리, 저장, 서빙하는 플랫폼입니다. --- Feast(Feature Store)는 가장 널리 사용되는 오픈소스 Feature Store입니다. --- --- --- --- --- Feast Feature Store를 설정하고 기본 피처를 정의하세요. gethistoricalfeatures를 사용하여 Point-in-time 정확한 학습 데이터를 생성하세요. 온라인 스토어를 설정하고 실시간 추론에 통합하세요. --- | 구성 요소 | 설명 | 사용 사례 | |----------|------|----------| | Offline Store | 대용량 히스토리컬 데이터 | 학습 데이터 생성 | | Online Store | 저지연 키-값 조회 | 실시간 추론 | | Feature Registry | 피처 메타데이터 관리 | 피처 발견, 거버넌스 | | Materialization | 오프라인 → 온라인 동기화 | 피처 서빙 준비 |...", "url": "/study/ko/MLOps/11_Feature_Stores.html"}, {"id": "MLOps/12_Practical_MLOps_Project", "title": "실전 MLOps 프로젝트", "topic": "MLOps", "topic_display": "MLOps", "body": "실제 프로덕션 환경에서 작동하는 완전한 MLOps 파이프라인을 구축합니다. --- --- --- --- --- --- --- 위의 구조를 참고하여 고객 이탈 예측 MLOps 시스템을 처음부터 구축하세요. 1. Feature Store 설정 및 피처 정의 2. 학습 파이프라인 구현 3. 모델 서빙 API 구현 4. 드리프트 모니터링 설정 5. 자동 재학습 트리거 구현 --- | 단계 | 핵심 기술 | 산출물 | |------|----------|--------| | 데이터 | Great Expectations, DVC | 검증된 데이터 | | 피처 | Feast | Feature Store | | 학습 | MLflow, Kubeflow | 학습된 모델 | | 서빙 | FastAPI, K8s | API 엔드포인트 | | 모니터링 | Evidently, Prometheus | 대시보드, 알림 | | 자동화 | GitHub Actions | CI/CD 파이프라인 | --- - Made...", "url": "/study/ko/MLOps/12_Practical_MLOps_Project.html"}, {"id": "Machine_Learning/00_Overview", "title": "Machine Learning (머신러닝) 학습 가이드", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "머신러닝은 데이터로부터 패턴을 학습하여 예측이나 결정을 수행하는 알고리즘의 집합입니다. 이 학습 자료는 머신러닝의 기초 개념부터 주요 알고리즘, 실전 적용까지 체계적으로 다룹니다. --- --- | 파일 | 주제 | 핵심 내용 | |------|------|----------| | 01MLOverview.md | ML 개요 | 지도/비지도/강화학습, ML 워크플로우, 편향-분산 트레이드오프 | | 02LinearRegression.md | 선형회귀 | 단순/다중 회귀, 경사하강법, 정규화(Ridge/Lasso) | | 03LogisticRegression.md | 로지스틱 회귀 | 이진 분류, 시그모이드 함수, 다중 분류(Softmax) | | 04ModelEvaluation.md | 모델 평가 | 정확도, 정밀도, 재현율, F1-score, ROC-AUC | | 05CrossValidationHyperparameters.md | 교차검증과 하이퍼파라미터 | K-Fold CV,...", "url": "/study/ko/Machine_Learning/00_Overview.html"}, {"id": "Machine_Learning/01_ML_Overview", "title": "머신러닝 개요", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "머신러닝(Machine Learning)은 명시적으로 프로그래밍하지 않아도 데이터로부터 학습하여 예측이나 결정을 수행하는 알고리즘입니다. --- 입력(X)과 정답(y)이 있는 데이터로 학습합니다. 주요 알고리즘: - 회귀 (Regression): 연속적인 값 예측 - 선형회귀, 다항회귀, 릿지, 라쏘 - 분류 (Classification): 범주 예측 - 로지스틱 회귀, SVM, 결정트리, 랜덤포레스트 정답 없이 데이터의 구조나 패턴을 학습합니다. 주요 알고리즘: - 클러스터링: K-Means, DBSCAN, 계층적 군집화 - 차원축소: PCA, t-SNE - 이상치 탐지: Isolation Forest 환경과 상호작용하며 보상을 최대화하는 방향으로 학습합니다. - 에이전트가 행동을 선택 - 환경에서 보상 또는 패널티 수신 - 누적 보상 최대화 적용 분야: 게임 AI, 로봇 제어, 자율주행 --- --- - 훈련 데이터: 모델 학습에 사용 - 검증 데이터: 하이퍼파라미터 튜닝에...", "url": "/study/ko/Machine_Learning/01_ML_Overview.html"}, {"id": "Machine_Learning/02_Linear_Regression", "title": "선형회귀 (Linear Regression)", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "선형회귀는 연속적인 값을 예측하는 가장 기본적인 회귀 알고리즘입니다. 입력 변수와 출력 변수 간의 선형 관계를 모델링합니다. --- 하나의 독립변수(X)로 종속변수(y)를 예측합니다. --- 여러 개의 독립변수로 종속변수를 예측합니다. --- --- 과적합을 방지하기 위해 모델의 복잡도에 패널티를 부여합니다. --- 비선형 관계를 선형회귀로 모델링합니다. --- --- 다음 데이터로 선형회귀 모델을 학습하고 X=7일 때 예측값을 구하세요. 당뇨병 데이터에서 Ridge와 Lasso의 성능을 비교하세요. --- | 방법 | 특징 | 사용 시점 | |------|------|----------| | 선형회귀 | 기본, 해석 용이 | 기준 모델 | | Ridge (L2) | 계수 축소, 과적합 방지 | 다중공선성 | | Lasso (L1) | 특성 선택, 희소 모델 | 많은 특성 | | Elastic Net | L1+L2 혼합 | 상관된 특성 | | 다항 회귀 | 비선형 관계 | 곡선...", "url": "/study/ko/Machine_Learning/02_Linear_Regression.html"}, {"id": "Machine_Learning/03_Logistic_Regression", "title": "로지스틱 회귀 (Logistic Regression)", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "로지스틱 회귀는 이름과 달리 분류 알고리즘입니다. 이진 분류와 다중 분류 문제에서 확률을 예측합니다. --- --- --- --- --- --- --- --- 유방암 데이터로 로지스틱 회귀 모델을 학습하고 F1-score를 구하세요. Iris 데이터로 3-클래스 분류를 수행하세요. --- | 개념 | 설명 | |------|------| | 시그모이드 | 확률 출력 (0~1) | | Log Loss | 비용 함수 (Binary Cross-Entropy) | | OvR | 다중 분류 (One-vs-Rest) | | Softmax | 다중 분류 (Multinomial) | | C | 정규화 강도 (1/λ) | | class_weight | 불균형 데이터 처리 |", "url": "/study/ko/Machine_Learning/03_Logistic_Regression.html"}, {"id": "Machine_Learning/04_Model_Evaluation", "title": "모델 평가 (Model Evaluation)", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "모델 평가는 학습된 모델의 성능을 객관적으로 측정하는 과정입니다. 분류와 회귀 문제에 따라 다른 평가 지표를 사용합니다. --- --- --- --- --- --- 혼동 행렬에서 Precision, Recall, F1-score를 계산하세요. 예측값과 실제값으로 R²를 계산하세요. --- | 지표 | 분류/회귀 | 범위 | 설명 | |------|----------|------|------| | Accuracy | 분류 | 0-1 | 전체 정답 비율 | | Precision | 분류 | 0-1 | 양성 예측 중 실제 양성 | | Recall | 분류 | 0-1 | 실제 양성 중 양성 예측 | | F1-Score | 분류 | 0-1 | Precision/Recall 조화평균 | | ROC-AUC | 분류 | 0-1 | 분류기 전반적 성능 | | MAE | 회귀 | 0-∞ | 평균 절대 오차 | | MSE | 회귀 | 0-∞ | 평균 제곱 오차 | | R² | 회귀 | -∞-1 |...", "url": "/study/ko/Machine_Learning/04_Model_Evaluation.html"}, {"id": "Machine_Learning/05_Cross_Validation_Hyperparameters", "title": "교차검증과 하이퍼파라미터 튜닝", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "교차검증은 모델의 일반화 성능을 더 정확하게 평가하고, 하이퍼파라미터 튜닝은 최적의 모델 설정을 찾는 과정입니다. --- --- --- --- --- --- --- --- Iris 데이터로 10-Fold 교차검증을 수행하세요. 로지스틱 회귀의 C 파라미터를 튜닝하세요. --- | 기법 | 용도 | 특징 | |------|------|------| | K-Fold | 모델 평가 | 데이터를 K개로 분할 | | Stratified K-Fold | 불균형 데이터 | 클래스 비율 유지 | | Time Series Split | 시계열 | 시간 순서 유지 | | Grid Search | 파라미터 튜닝 | 모든 조합 탐색 | | Randomized Search | 파라미터 튜닝 | 랜덤 샘플링 | | Nested CV | 신뢰성 높은 평가 | 튜닝과 평가 분리 |", "url": "/study/ko/Machine_Learning/05_Cross_Validation_Hyperparameters.html"}, {"id": "Machine_Learning/06_Decision_Trees", "title": "결정 트리 (Decision Tree)", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "결정 트리는 데이터를 특성(feature)에 따라 분할하여 트리 구조로 의사결정을 수행하는 알고리즘입니다. 직관적이고 해석이 쉬워 실무에서 많이 사용됩니다. --- --- --- --- --- --- --- --- --- 유방암 데이터로 결정 트리를 학습하고 평가하세요. CCP를 사용하여 최적의 alpha를 찾고 가지치기하세요. 당뇨병 데이터로 회귀 트리를 학습하세요. --- | 개념 | 설명 | 용도 | |------|------|------| | 엔트로피 | 정보의 불확실성 측정 | 분할 기준 (criterion='entropy') | | 지니 불순도 | 잘못 분류될 확률 | 분할 기준 (criterion='gini') | | 정보 이득 | 분할 후 불순도 감소량 | 최적 분할 선택 | | maxdepth | 트리 최대 깊이 | 과적합 방지 | | minsamplessplit | 분할에 필요한 최소 샘플 | 과적합 방지 | | minsamplesleaf | 리프 노드 최소 샘플...", "url": "/study/ko/Machine_Learning/06_Decision_Trees.html"}, {"id": "Machine_Learning/07_Ensemble_Bagging", "title": "앙상블 학습 - 배깅 (Bagging)", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "배깅(Bagging, Bootstrap Aggregating)은 여러 개의 기본 모델을 학습시켜 그 결과를 종합하는 앙상블 기법입니다. 대표적인 알고리즘으로 Random Forest가 있습니다. --- --- --- --- --- --- --- --- --- --- --- 유방암 데이터로 Random Forest를 학습하고 특성 중요도를 분석하세요. Grid Search로 최적의 Random Forest 파라미터를 찾으세요. 여러 모델을 결합한 Voting Classifier를 만드세요. --- | 모델 | 특징 | 장점 | 단점 | |------|------|------|------| | Bagging | 부트스트랩 + 평균 | 분산 감소, 과적합 방지 | 해석 어려움 | | Random Forest | 배깅 + 특성 랜덤 | 높은 성능, 특성 중요도 | 많은 계산량 | | Extra Trees | 완전 랜덤 분할 | 빠른 학습 | RF보다 낮은 성능 가능 | | Voting |...", "url": "/study/ko/Machine_Learning/07_Ensemble_Bagging.html"}, {"id": "Machine_Learning/08_Ensemble_Boosting", "title": "앙상블 학습 - 부스팅 (Boosting)", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "부스팅(Boosting)은 여러 개의 약한 학습기를 순차적으로 학습하여 강한 학습기를 만드는 앙상블 기법입니다. 각 학습기는 이전 학습기의 오류를 보완하도록 학습됩니다. --- --- --- --- --- --- --- --- --- --- --- 유방암 데이터로 XGBoost를 학습하고 조기 종료를 적용하세요. Grid Search로 LightGBM 최적 파라미터를 찾으세요. 여러 부스팅 알고리즘을 비교하세요. --- | 알고리즘 | 특징 | 장점 | 단점 | |----------|------|------|------| | AdaBoost | 가중치 기반 | 간단, 해석 용이 | 노이즈에 민감 | | Gradient Boosting | 잔차 학습 | 높은 정확도 | 느린 학습 | | XGBoost | 정규화 + 병렬화 | 빠름, 정확함 | 메모리 사용 | | LightGBM | Leaf-wise | 매우 빠름, 대용량 | 과적합 위험 | | CatBoost | 범주형 처리 |...", "url": "/study/ko/Machine_Learning/08_Ensemble_Boosting.html"}, {"id": "Machine_Learning/09_SVM", "title": "서포트 벡터 머신 (Support Vector Machine)", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "서포트 벡터 머신(SVM)은 데이터를 분류하기 위한 최적의 결정 경계(초평면)를 찾는 알고리즘입니다. 마진 최대화와 커널 트릭을 통해 고차원 데이터와 비선형 패턴도 효과적으로 처리할 수 있습니다. --- --- --- --- --- --- --- --- --- --- --- 유방암 데이터로 SVM을 학습하고 평가하세요. 여러 커널의 성능을 비교하세요. Grid Search로 최적의 C와 gamma를 찾으세요. --- | 개념 | 설명 | 파라미터 | |------|------|----------| | 서포트 벡터 | 마진 경계의 데이터 포인트 | - | | 마진 | 결정 경계와 서포트 벡터 거리 | C로 조절 | | C | 규제 파라미터 | 큼: 좁은 마진, 작음: 넓은 마진 | | 커널 | 데이터 변환 함수 | linear, poly, rbf, sigmoid | | gamma | RBF 커널 범위 | 큼: 좁은 영향, 작음: 넓은 영향 | 1. 스케일링 필수:...", "url": "/study/ko/Machine_Learning/09_SVM.html"}, {"id": "Machine_Learning/10_kNN_and_Naive_Bayes", "title": "k-최근접 이웃(kNN)과 나이브 베이즈", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "k-최근접 이웃(kNN)은 거리 기반 분류 알고리즘이고, 나이브 베이즈는 확률 기반 분류 알고리즘입니다. 두 알고리즘 모두 간단하면서도 효과적인 분류기입니다. --- --- --- --- --- --- --- --- --- --- --- --- 교차 검증으로 Iris 데이터에 최적인 k를 찾으세요. 간단한 텍스트 분류를 구현하세요. 거리 가중치를 사용하여 kNN 회귀를 수행하세요. --- | 파라미터 | 설명 | 권장 | |----------|------|------| | nneighbors | 이웃 수 | 교차 검증으로 선택 | | weights | 가중치 방식 | 'distance' 추천 | | metric | 거리 측정 | 'euclidean' 기본 | | algorithm | 탐색 알고리즘 | 'auto' | | 종류 | 특성 타입 | 용도 | |------|-----------|------| | GaussianNB | 연속형 (정규 분포) | 일반 분류 | |...", "url": "/study/ko/Machine_Learning/10_kNN_and_Naive_Bayes.html"}, {"id": "Machine_Learning/11_Clustering", "title": "클러스터링 (Clustering)", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "클러스터링은 비지도 학습의 대표적인 방법으로, 레이블 없는 데이터를 유사한 그룹으로 분류합니다. 데이터 탐색, 고객 세분화, 이상 탐지 등에 활용됩니다. --- --- --- --- --- --- --- --- --- --- --- 엘보우 방법으로 최적의 k를 찾으세요. 노이즈가 있는 데이터에 DBSCAN을 적용하세요. 여러 평가 지표로 클러스터링 결과를 평가하세요. --- | 알고리즘 | 특징 | 장점 | 단점 | |----------|------|------|------| | K-Means | 중심점 기반 | 빠름, 간단 | k 지정 필요, 구형 클러스터만 | | DBSCAN | 밀도 기반 | 노이즈 처리, 임의 모양 | eps, min_samples 튜닝 | | Hierarchical | 병합/분할 | 덴드로그램 | 느림, 대용량에 부적합 | | GMM | 확률 기반 | 소프트 클러스터링, 타원형 | 많은 파라미터 | | 상황 | 권장 알고리즘 |...", "url": "/study/ko/Machine_Learning/11_Clustering.html"}, {"id": "Machine_Learning/12_Dimensionality_Reduction", "title": "차원 축소 (Dimensionality Reduction)", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "차원 축소는 고차원 데이터를 저차원으로 변환하여 계산 효율성을 높이고 시각화를 가능하게 합니다. 주요 방법으로 PCA, t-SNE, 특성 선택 등이 있습니다. --- --- --- --- --- --- --- --- --- --- --- Digits 데이터에 PCA를 적용하고 95% 분산을 설명하는 주성분 수를 찾으세요. Digits 데이터를 t-SNE로 시각화하세요. Random Forest 중요도 기반으로 상위 20개 특성을 선택하세요. --- | 방법 | 유형 | 특징 | 용도 | |------|------|------|------| | PCA | 선형 | 분산 최대화 | 일반적인 차원 축소 | | Kernel PCA | 비선형 | 커널 트릭 | 비선형 패턴 | | LDA | 지도 학습 | 클래스 분리 | 분류 전처리 | | t-SNE | 비선형 | 지역 구조 보존 | 시각화 | | UMAP | 비선형 | 빠름, 전역 구조 | 시각화 | | 방법 | 유형 | 장점 | 단점 |...", "url": "/study/ko/Machine_Learning/12_Dimensionality_Reduction.html"}, {"id": "Machine_Learning/13_Pipelines_and_Practice", "title": "파이프라인과 실무 (Pipeline & Practice)", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "sklearn의 Pipeline과 ColumnTransformer를 사용하면 전처리와 모델링을 하나의 워크플로우로 통합할 수 있습니다. 모델 저장과 배포까지 포함한 실무 노하우를 다룹니다. --- --- --- --- --- --- --- --- --- --- --- Iris 데이터에 스케일링 + PCA + 로지스틱 회귀 파이프라인을 만드세요. 수치형과 범주형 특성을 다르게 처리하는 파이프라인을 만드세요. 학습된 파이프라인을 저장하고 로드하세요. --- | 구성 요소 | 용도 | 예시 | |-----------|------|------| | Pipeline | 단계 순차 연결 | 스케일링 → PCA → 모델 | | ColumnTransformer | 특성별 다른 처리 | 수치형/범주형 분리 | | FunctionTransformer | 커스텀 함수 | 로그 변환 | | make_pipeline | 자동 이름 지정 | 간단한 파이프라인 | | 방법 | 장점 | 단점 |...", "url": "/study/ko/Machine_Learning/13_Pipelines_and_Practice.html"}, {"id": "Machine_Learning/14_Practical_Projects", "title": "실전 프로젝트 (Real-World Projects)", "topic": "Machine_Learning", "topic_display": "Machine Learning", "body": "실제 데이터셋을 사용하여 분류와 회귀 문제를 처음부터 끝까지 해결합니다. Kaggle 스타일의 문제 해결 과정과 실무 노하우를 다룹니다. --- --- --- --- --- --- Iris 데이터로 전체 ML 파이프라인을 구축하세요. 주어진 데이터에 새로운 특성을 추가하세요. 여러 모델을 블렌딩하세요. --- | 단계 | 분류 | 회귀 | |------|------|------| | 평가 지표 | Accuracy, F1, AUC | RMSE, MAE, R2 | | 타겟 처리 | 인코딩 | 이상치 확인, 로그 변환 | | 불균형 | SMOTE, 클래스 가중치 | 해당 없음 | | 오차 분석 | 혼동 행렬 | 잔차 분석 | | 상황 | 권장 모델 | |------|-----------| | 빠른 기준선 | 로지스틱/선형 회귀 | | 일반적인 성능 | Random Forest | | 최고 성능 | XGBoost, LightGBM | | 해석 필요 | 결정 트리, 선형 모델 | | 대용량...", "url": "/study/ko/Machine_Learning/14_Practical_Projects.html"}, {"id": "Math_for_AI/00_Overview", "title": "AI/ML/DL을 위한 수학 (Mathematics for AI) - Overview", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "인공지능과 머신러닝, 딥러닝을 깊이 이해하고 효과적으로 활용하려면 탄탄한 수학적 기초가 필수적입니다. 이 과정은 AI/ML/DL에 필요한 핵심 수학 개념들을 체계적으로 정리하여 제공합니다. 본 과정은 선형대수, 미적분학, 확률론, 최적화 이론, 정보 이론 등 AI의 이론적 토대를 이루는 수학 분야들을 다룹니다. 각 레슨은 이론적 설명과 함께 Python 코드 예제를 제공하여 수학적 개념을 실제로 구현하고 시각화할 수 있도록 구성되어 있습니다. 단순히 공식을 암기하는 것이 아니라, 왜 이 수학이 필요한지, 어떻게 ML 알고리즘에 적용되는지를 이해하는 것이 목표입니다. | 번호 | 파일명 | 주제 | 주요 내용 | |------|--------|------|-----------| | 00 | 00Overview.md | 개요 | 과정 소개 및 학습 가이드 | | 01 | 01VectorsandMatrices.md | 벡터와 행렬 | 벡터 공간, 기저, 행렬 연산, 선형 변환 | |...", "url": "/study/ko/Math_for_AI/00_Overview.html"}, {"id": "Math_for_AI/01_Vectors_and_Matrices", "title": "01. 벡터와 행렬 (Vectors and Matrices)", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 벡터의 기하학적 의미와 대수적 연산을 이해하고 Python으로 구현할 수 있다 - 벡터 공간, 기저, 차원의 개념을 이해하고 선형 독립성을 판별할 수 있다 - 행렬을 선형 변환으로 해석하고 기하학적 의미를 시각화할 수 있다 - 행렬식, 역행렬, 랭크의 개념을 이해하고 연립방정식의 해를 구할 수 있다 - 머신러닝에서 벡터와 행렬이 어떻게 사용되는지 구체적인 예를 들 수 있다 --- 벡터는 크기와 방향을 가진 양입니다. 벡터는 두 가지 관점에서 이해할 수 있습니다: 1. 기하학적 관점: 화살표. 시작점에서 끝점으로의 변위 2. 대수적 관점: 순서가 있는 숫자들의 리스트 n차원 벡터 $\\mathbf{v}$는 다음과 같이 표현됩니다: $$\\mathbf{v} = \\begin{bmatrix} v1 \\\\ v2 \\\\ \\vdots \\\\ vn \\end{bmatrix} \\in \\mathbb{R}^n$$ 벡터 덧셈: 두 벡터를 더하면 평행사변형 법칙을 따릅니다. $$\\mathbf{v} +...", "url": "/study/ko/Math_for_AI/01_Vectors_and_Matrices.html"}, {"id": "Math_for_AI/02_Matrix_Decompositions", "title": "02. 행렬 분해 (Matrix Decompositions)", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 고유값과 고유벡터의 개념을 이해하고 계산할 수 있다 - 대칭 행렬의 스펙트럼 정리와 양정치 행렬의 성질을 설명할 수 있다 - 특이값 분해(SVD)의 기하학적 의미를 이해하고 구현할 수 있다 - SVD를 이용한 저랭크 근사와 PCA의 수학적 원리를 설명할 수 있다 - LU, QR, Cholesky 분해의 용도와 계산 방법을 이해한다 - 행렬 분해가 머신러닝에서 어떻게 활용되는지 구체적인 예를 들 수 있다 --- 행렬 $A$의 고유벡터(eigenvector) $\\mathbf{v}$는 다음을 만족하는 0이 아닌 벡터입니다: $$A\\mathbf{v} = \\lambda\\mathbf{v}$$ 여기서 $\\lambda$는 고유값(eigenvalue)입니다. 기하학적 해석: 고유벡터는 선형 변환 $A$에 의해 방향은 바뀌지 않고 크기만 $\\lambda$배 변하는 특별한 방향입니다. 고유값은 특성방정식의 해입니다: $$\\det(A - \\lambda I) = 0$$ 이는 $n$차 다항식이며,...", "url": "/study/ko/Math_for_AI/02_Matrix_Decompositions.html"}, {"id": "Math_for_AI/03_Matrix_Calculus", "title": "03. 행렬 미분 (Matrix Calculus)", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 스칼라-벡터 미분과 그래디언트의 개념을 이해하고 계산할 수 있다 - 야코비안 행렬의 정의와 체인 룰 적용 방법을 학습한다 - 헤시안 행렬의 의미와 최적화에서의 역할을 이해한다 - 주요 행렬 미분 항등식을 유도하고 활용할 수 있다 - 머신러닝의 손실 함수 그래디언트를 직접 유도할 수 있다 - PyTorch의 자동 미분 기능을 이해하고 검증에 활용할 수 있다 --- 스칼라 함수 $f: \\mathbb{R}^n \\to \\mathbb{R}$에 대해 그래디언트는 모든 편미분을 모아놓은 벡터입니다: $$\\nabla f(\\mathbf{x}) = \\begin{bmatrix} \\frac{\\partial f}{\\partial x1} \\\\ \\frac{\\partial f}{\\partial x2} \\\\ \\vdots \\\\ \\frac{\\partial f}{\\partial xn} \\end{bmatrix}$$ 그래디언트는 함수가 가장 가파르게 증가하는 방향을 가리킵니다. 예제 1: $f(\\mathbf{x})...", "url": "/study/ko/Math_for_AI/03_Matrix_Calculus.html"}, {"id": "Math_for_AI/04_Norms_and_Distances", "title": "04. 노름과 거리 측도 (Norms and Distance Metrics)", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 벡터 노름의 정의와 종류 (L1, L2, Lp, L∞)를 이해하고 계산할 수 있다 - 행렬 노름 (프로베니우스, 스펙트럼, 핵 노름)의 의미와 활용을 학습한다 - 다양한 거리 측도 (유클리드, 마할라노비스, 코사인)의 특성을 이해한다 - 정규화와 노름의 관계, L1/L2 정규화의 기하학적 해석을 학습한다 - 머신러닝에서 노름과 거리가 어떻게 활용되는지 실습을 통해 이해한다 - NumPy와 scikit-learn을 사용하여 노름과 거리를 계산하고 시각화할 수 있다 --- 벡터 공간의 노름은 다음 세 가지 성질을 만족하는 함수 $\\|\\cdot\\|: \\mathbb{R}^n \\to \\mathbb{R}+$입니다: 1. 양의 정부호성: $\\|\\mathbf{x}\\| \\geq 0$이고, $\\|\\mathbf{x}\\| = 0 \\Leftrightarrow \\mathbf{x} = \\mathbf{0}$ 2. 동차성: $\\|\\alpha \\mathbf{x}\\| = |\\alpha|...", "url": "/study/ko/Math_for_AI/04_Norms_and_Distances.html"}, {"id": "Math_for_AI/05_Multivariate_Calculus", "title": "05. 다변수 미적분 (Multivariate Calculus)", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 편미분의 기하학적 의미를 이해하고 계산할 수 있다 - 그래디언트 벡터와 등고선의 관계를 시각화하고 해석할 수 있다 - 방향 도함수를 계산하고 그래디언트와의 관계를 이해한다 - 다변수 체인 룰을 적용하여 복잡한 합성 함수를 미분할 수 있다 - 테일러 전개를 이용한 함수 근사와 뉴턴 방법의 원리를 이해한다 - 머신러닝의 손실 지형을 시각화하고 최적화 문제와 연결한다 --- 다변수 함수 $f(x1, x2, \\ldots, xn)$에서 $xi$에 대한 편미분은 다른 변수를 상수로 고정하고 $xi$만 변화시킬 때의 변화율입니다: $$\\frac{\\partial f}{\\partial xi} = \\lim{h \\to 0} \\frac{f(x1, \\ldots, xi + h, \\ldots, xn) - f(x1, \\ldots, xi, \\ldots, xn)}{h}$$ 예제 1: $f(x, y) = x^2 + 3xy + y^2$ $$\\frac{\\partial f}{\\partial x} = 2x + 3y$$...", "url": "/study/ko/Math_for_AI/05_Multivariate_Calculus.html"}, {"id": "Math_for_AI/06_Optimization_Fundamentals", "title": "06. 최적화 기초 (Optimization Fundamentals)", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 최적화 문제의 수학적 형식화와 제약 조건의 종류를 이해한다 - 볼록 집합과 볼록 함수의 정의와 성질을 학습하고, 볼록성이 최적화에 미치는 영향을 파악한다 - 극값의 필요조건과 충분조건을 그래디언트와 헤시안으로 표현하고 적용한다 - 라그랑주 승수법을 사용하여 등식 제약 최적화 문제를 해결한다 - KKT 조건을 이해하고 부등식 제약이 있는 최적화 문제에 적용한다 - 머신러닝에서 최적화 이론이 어떻게 활용되는지 실제 예제를 통해 학습한다 --- 최적화는 주어진 제약 조건 하에서 목적 함수를 최소화(또는 최대화)하는 변수 값을 찾는 과정입니다. 표준 형태: $$ \\begin{align} \\min{x \\in \\mathbb{R}^n} \\quad & f(x) \\\\ \\text{subject to} \\quad & hi(x) = 0, \\quad i = 1, \\ldots, m \\\\ & gj(x) \\leq 0, \\quad j = 1, \\ldots, p \\end{align} $$ - $f(x)$:...", "url": "/study/ko/Math_for_AI/06_Optimization_Fundamentals.html"}, {"id": "Math_for_AI/07_Gradient_Descent_Theory", "title": "07. 경사 하강법 이론 (Gradient Descent Theory)", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 경사 하강법의 기본 원리와 업데이트 규칙을 이해하고 구현한다 - 볼록 함수와 강볼록 함수에서의 수렴 속도를 이론적으로 분석한다 - 확률적 경사 하강법(SGD)의 원리와 미니배치의 역할을 학습한다 - 모멘텀과 네스테로프 가속 경사법의 작동 원리를 물리적 직관으로 이해한다 - Adam, RMSProp 등 적응적 학습률 방법의 유도 과정을 학습한다 - 신경망 최적화에서의 실전 고려사항을 이해하고 적용한다 --- 경사 하강법(Gradient Descent)은 함수를 최소화하기 위해 그래디언트의 반대 방향으로 반복적으로 이동하는 1차 최적화 알고리즘입니다. 업데이트 규칙: $$ x{t+1} = xt - \\eta \\nabla f(xt) $$ - $xt$: $t$ 시점의 파라미터 - $\\eta$: 학습률 (learning rate, step size) - $\\nabla f(xt)$: $xt$에서의 그래디언트 직관: - 그래디언트 $\\nabla f(x)$는 함수가 가장 빠르게 증가하는 방향...", "url": "/study/ko/Math_for_AI/07_Gradient_Descent_Theory.html"}, {"id": "Math_for_AI/08_Probability_for_ML", "title": "08. 머신러닝을 위한 확률론 (Probability for Machine Learning)", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 확률의 기본 공리와 조건부 확률, 베이즈 정리를 이해하고 응용한다 - 확률 변수의 개념과 이산/연속 분포의 차이를 학습한다 - 기댓값, 분산, 공분산 등 확률 변수의 주요 통계량을 계산하고 해석한다 - 머신러닝에서 자주 사용되는 확률 분포들의 특성과 응용을 학습한다 - 베이즈 정리를 사용한 확률적 추론과 베이지안 업데이트를 구현한다 - 생성 모델과 판별 모델의 차이를 확률론적 관점에서 이해한다 --- 표본공간 (Sample Space) $\\Omega$: 모든 가능한 결과의 집합 사건 (Event) $A$: 표본공간의 부분집합 확률 측도 (Probability Measure) $P$는 다음 공리를 만족합니다: 1. 비음성 (Non-negativity): $P(A) \\geq 0$ for all $A$ 2. 정규성 (Normalization): $P(\\Omega) = 1$ 3. 가산 가법성 (Countable Additivity): 서로 배반인 사건 $A1, A2, \\ldots$에...", "url": "/study/ko/Math_for_AI/08_Probability_for_ML.html"}, {"id": "Math_for_AI/09_Maximum_Likelihood_and_MAP", "title": "09. 최대우도추정과 MAP (Maximum Likelihood and MAP)", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 우도 함수와 확률의 차이를 이해하고, 로그 우도의 역할을 파악한다 - 최대우도추정(MLE)의 정의와 다양한 확률분포에 대한 MLE를 유도할 수 있다 - MAP 추정의 원리를 이해하고 MLE와의 차이점을 설명할 수 있다 - 정규화 항이 사전분포와 어떻게 연결되는지 수학적으로 유도할 수 있다 - EM 알고리즘의 원리를 이해하고 잠재 변수가 있는 모델에 적용할 수 있다 - 머신러닝에서 MLE와 MAP가 어떻게 활용되는지 실제 예제를 통해 학습한다 --- 확률(Probability)과 우도(Likelihood)는 같은 식으로 계산되지만, 의미가 다릅니다. - 확률: 파라미터 $\\theta$가 고정되어 있을 때, 데이터 $D$가 발생할 확률 $$P(D|\\theta)$$ - 우도: 데이터 $D$가 관측된 후, 파라미터 $\\theta$에 대한 함수 $$\\mathcal{L}(\\theta|D) = P(D|\\theta)$$ 핵심 차이점: - 확률: $\\theta$ 고정, $D$ 변수 →...", "url": "/study/ko/Math_for_AI/09_Maximum_Likelihood_and_MAP.html"}, {"id": "Math_for_AI/10_Information_Theory", "title": "10. 정보 이론 (Information Theory)", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 정보량과 엔트로피의 개념을 이해하고 불확실성의 측도로서의 역할을 파악한다 - 교차 엔트로피와 KL 발산의 정의와 성질을 학습하고 머신러닝에서의 활용을 이해한다 - 상호 정보량을 이해하고 변수 간 의존성 측정 방법을 익힌다 - 옌센 부등식을 활용하여 정보 이론의 주요 부등식을 증명할 수 있다 - VAE, GAN 등 생성 모델에서 정보 이론이 어떻게 활용되는지 학습한다 - Python으로 엔트로피, KL 발산, 상호 정보량을 계산하고 시각화할 수 있다 --- 사건 $x$가 발생했을 때의 정보량: $$I(x) = -\\log P(x) = \\log \\frac{1}{P(x)}$$ 직관: - 확률이 낮은 사건 → 많은 정보 (놀라움) - 확률이 높은 사건 → 적은 정보 단위: - $\\log2$: bits - $\\loge$: nats 예제: - 동전 던지기 (앞면 확률 0.5): $I(\\text{H}) = -\\log2(0.5) = 1$ bit - 주사위 (각 면 확률 1/6): $I(1) =...", "url": "/study/ko/Math_for_AI/10_Information_Theory.html"}, {"id": "Math_for_AI/11_Probability_Distributions_Advanced", "title": "11. 고급 확률 분포 (Advanced Probability Distributions)", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 지수족의 일반 형태와 성질을 이해하고 다양한 분포를 지수족으로 표현할 수 있다 - 충분 통계량과 자연 매개변수의 개념을 파악하고 GLM과의 연결고리를 이해한다 - 켤레 사전분포의 원리를 이해하고 베이지안 추론에서의 활용을 학습한다 - 다변량 가우시안 분포의 성질과 조건부/주변화 연산을 수행할 수 있다 - 가우시안 혼합 모델(GMM)의 구조를 이해하고 EM 알고리즘을 적용할 수 있다 - 머신러닝에서 고급 확률 분포가 어떻게 활용되는지 실제 예제로 학습한다 --- 확률 분포가 지수족(exponential family)에 속한다는 것은 다음 형태로 표현 가능함을 의미합니다: $$p(x|\\eta) = h(x) \\exp\\left(\\eta^T T(x) - A(\\eta)\\right)$$ 여기서: - $\\eta$: 자연 매개변수(natural parameter) 또는 정준 매개변수 - $T(x)$: 충분 통계량(sufficient statistic) - $A(\\eta)$: 로그 분배...", "url": "/study/ko/Math_for_AI/11_Probability_Distributions_Advanced.html"}, {"id": "Math_for_AI/12_Sampling_and_Monte_Carlo", "title": "12. 샘플링과 몬테카를로 방법", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 몬테카를로 방법의 기본 원리와 수렴 속도를 이해한다 - 기본 샘플링 방법(역변환, 기각 샘플링)을 구현하고 한계를 파악한다 - 중요도 샘플링을 통한 분산 감소 기법을 습득한다 - MCMC(메트로폴리스-헤이스팅스, 깁스 샘플링)의 원리와 구현을 이해한다 - 재매개변수화 트릭의 수학적 배경과 VAE에서의 역할을 파악한다 - 머신러닝에서 샘플링이 사용되는 다양한 사례를 학습한다 --- 많은 머신러닝 문제에서 다음과 같은 적분을 계산해야 합니다: $$ \\mathbb{E}{p(x)}[f(x)] = \\int f(x) p(x) dx $$ 예를 들어: - 베이지안 추론: 사후 분포의 정규화 상수 $\\int p(x|\\theta) p(\\theta) d\\theta$ - 강화학습: 정책의 기대 보상 $\\mathbb{E}{\\pi}[R]$ - VAE: ELBO의 기대값 $\\mathbb{E}{q(z|x)}[\\log p(x|z)]$ 이러한 적분은 고차원에서 해석적으로 계산이 불가능합니다. 몬테카를로 원리:...", "url": "/study/ko/Math_for_AI/12_Sampling_and_Monte_Carlo.html"}, {"id": "Math_for_AI/13_Linear_Algebra_for_Deep_Learning", "title": "13. 딥러닝을 위한 선형대수", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 텐서의 개념과 차원, 축(axis) 연산을 이해하고 활용한다 - 아인슈타인 표기법과 einsum을 사용한 효율적인 텐서 연산을 습득한다 - 자동 미분의 원리(포워드/리버스 모드)와 계산 그래프를 이해한다 - 딥러닝에서의 수치 안정성 문제와 해결책을 파악한다 - 가중치 초기화의 수학적 이론과 실제 적용을 학습한다 - 배치/레이어 정규화, 잔차 연결 등의 수학적 배경을 이해한다 --- 스칼라 (0-텐서): 단일 숫자 벡터 (1-텐서): 1차원 배열 행렬 (2-텐서): 2차원 배열 텐서 (n-텐서): n차원 배열 딥러닝에서 전형적인 텐서 형태: - 이미지: (batch, channels, height, width) 또는 (batch, height, width, channels) - 시퀀스: (batch, sequencelength, features) - 가중치: (outputfeatures, inputfeatures) NumPy와 PyTorch는 크기가 다른 배열을 자동으로 확장하여...", "url": "/study/ko/Math_for_AI/13_Linear_Algebra_for_Deep_Learning.html"}, {"id": "Math_for_AI/14_Convexity_and_Duality", "title": "14. 볼록성과 쌍대성", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 볼록 집합과 볼록 함수의 심화된 성질을 이해한다 - 라그랑주 쌍대성의 원리와 약/강 쌍대성을 파악한다 - SVM의 쌍대 문제 유도 과정을 완전히 이해하고 커널 트릭과의 연결을 학습한다 - 펜첼 켤레(Fenchel Conjugate)의 개념과 응용을 습득한다 - 근위 연산자와 근위 경사법을 이해하고 LASSO에 적용한다 - 머신러닝에서 볼록 최적화와 쌍대성의 실제 활용 사례를 학습한다 --- 집합 $C$가 볼록(convex)하다: $$ \\forall x, y \\in C, \\forall \\theta \\in [0, 1]: \\quad \\theta x + (1-\\theta) y \\in C $$ 예시: - 초평면: $\\{x : a^T x = b\\}$ - 반공간: $\\{x : a^T x \\leq b\\}$ - 노름 볼: $\\{x : \\|x\\| \\leq r\\}$ - 양의 준정부호 행렬: $\\mathbb{S}+^n$ 함수 $f: \\mathbb{R}^n \\to \\mathbb{R}$가 볼록하다:...", "url": "/study/ko/Math_for_AI/14_Convexity_and_Duality.html"}, {"id": "Math_for_AI/15_Graph_Theory_and_Spectral_Methods", "title": "15. 그래프 이론과 스펙트럼 방법", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 그래프의 수학적 표현(인접 행렬, 차수 행렬, 라플라시안)을 이해하고 구현할 수 있다 - 그래프 라플라시안의 고유값 분해와 스펙트럼 특성을 설명할 수 있다 - 스펙트럼 군집화 알고리즘의 수학적 원리를 이해하고 구현할 수 있다 - 랜덤 워크와 PageRank 알고리즘의 수학적 기초를 이해할 수 있다 - 그래프 신호 처리와 그래프 푸리에 변환의 개념을 이해할 수 있다 - GNN(Graph Neural Networks)의 수학적 기초와 메시지 패싱 메커니즘을 이해할 수 있다 --- 그래프 $G = (V, E)$는 정점(vertex) 집합 $V$와 간선(edge) 집합 $E \\subseteq V \\times V$로 구성됩니다. 그래프의 유형: - 무방향 그래프: $(i,j) \\in E \\Rightarrow (j,i) \\in E$ - 방향 그래프: 간선에 방향이 있음 - 가중 그래프: 각 간선에 가중치 $w{ij}$가 할당됨 $n$개의 정점을 가진 그래프의 인접 행렬 $A \\in...", "url": "/study/ko/Math_for_AI/15_Graph_Theory_and_Spectral_Methods.html"}, {"id": "Math_for_AI/16_Manifold_and_Representation_Learning", "title": "16. 다양체 학습과 표현 학습", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 다양체 가설과 고차원 데이터의 저차원 구조를 이해할 수 있다 - 다양체의 수학적 정의와 기하학적 개념(측지 거리, 접선 공간)을 설명할 수 있다 - 선형/비선형 차원 축소 기법(PCA, Isomap, LLE)의 수학적 원리를 이해할 수 있다 - t-SNE의 KL 발산 최소화와 크라우딩 문제 해결 원리를 이해할 수 있다 - UMAP의 퍼지 위상 수학과 리만 기하학적 기초를 이해할 수 있다 - 신경망 기반 표현 학습(오토인코더, 대조 학습)과 다양체의 관계를 설명할 수 있다 --- 다양체 가설: 자연계의 고차원 데이터는 실제로 저차원 다양체(low-dimensional manifold) 위에 또는 그 근처에 존재한다. 예시: - 이미지: $256 \\times 256$ RGB 이미지는 $196{,}608$차원 공간의 점이지만, 실제 자연 이미지는 훨씬 낮은 차원의 다양체 위에 존재 - 음성: 파형 데이터는 고차원이지만, 발음 기관의 자유도는 제한적 - 분자 구조: 3D 좌표는...", "url": "/study/ko/Math_for_AI/16_Manifold_and_Representation_Learning.html"}, {"id": "Math_for_AI/17_Math_of_Attention_and_Transformers", "title": "17. 어텐션과 트랜스포머의 수학", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 소프트맥스 함수의 수학적 성질과 미분 가능한 argmax로서의 해석을 이해할 수 있다 - 스케일드 닷-프로덕트 어텐션의 수학적 원리와 스케일링의 필요성을 설명할 수 있다 - 멀티헤드 어텐션의 부분공간 투영 해석과 파라미터 효율성을 이해할 수 있다 - 위치 인코딩(사인/코사인, RoPE, ALiBi)의 수학적 기초를 이해할 수 있다 - 어텐션의 계산 복잡도를 분석하고 효율적인 구현 방법을 이해할 수 있다 - 트랜스포머의 주요 응용(BERT, GPT, 크로스 어텐션)에서의 수학적 차이를 설명할 수 있다 --- 소프트맥스 함수: $$\\text{softmax}(\\mathbf{z})i = \\frac{\\exp(zi)}{\\sum{j=1}^{n} \\exp(zj)}$$ 성질: - 확률 분포: $\\sumi \\text{softmax}(\\mathbf{z})i = 1$, 모든 원소 $\\geq 0$ - 순서 보존: $zi > zj \\Rightarrow \\text{softmax}(\\mathbf{z})i...", "url": "/study/ko/Math_for_AI/17_Math_of_Attention_and_Transformers.html"}, {"id": "Math_for_AI/18_Math_of_Generative_Models", "title": "18. 생성 모델의 수학", "topic": "Math_for_AI", "topic_display": "Math for AI", "body": "- 생성 모델의 목표와 명시적/암묵적 밀도 모델의 차이를 이해할 수 있다 - VAE의 ELBO를 완전히 유도하고 재구성 항과 KL 항의 의미를 설명할 수 있다 - GAN의 미니맥스 게임 이론과 JS 발산의 관계를 이해할 수 있다 - Wasserstein 거리와 최적 수송 이론의 기초를 이해할 수 있다 - 확산 모델의 정방향/역방향 과정과 스코어 매칭의 수학을 이해할 수 있다 - Flow Matching과 연속 정규화 흐름(CNF)의 최신 발전을 이해할 수 있다 --- 목표: 관측된 데이터 $\\{\\mathbf{x}^{(1)}, \\ldots, \\mathbf{x}^{(n)}\\} \\sim p{\\text{data}}(\\mathbf{x})$로부터 진짜 데이터 분포 $p{\\text{data}}$를 학습 응용: - 샘플링: 새로운 데이터 생성 - 밀도 추정: $p(\\mathbf{x})$ 계산 (이상 탐지) - 조건부 생성: $p(\\mathbf{y}|\\mathbf{x})$ (이미지-텍스트, 스타일...", "url": "/study/ko/Math_for_AI/18_Math_of_Generative_Models.html"}, {"id": "Mathematical_Methods/00_Overview", "title": "물리과학을 위한 수학적 방법론 (Mathematical Methods in the Physical Sciences) - Overview", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "물리학과 공학의 핵심 문제들을 해결하기 위해서는 체계적인 수학적 도구가 필수적입니다. 이 과정은 Mary L. Boas의 Mathematical Methods in the Physical Sciences를 기반으로, 물리과학에서 가장 빈번하게 사용되는 수학적 방법론들을 체계적으로 다룹니다. 무한급수와 복소수로 시작하여, 선형대수, 편미분, 벡터 해석, 푸리에 해석, 미분방정식, 특수함수, 복소해석, 적분변환, 변분법, 텐서 해석까지 — 현대 물리학과 공학의 이론적 기반을 이루는 수학적 도구들을 빠짐없이 다룹니다. 각 레슨은 엄밀한 수학적 이론과 함께 Python(NumPy, SciPy, SymPy, Matplotlib) 구현을 제공하여, 추상적인 수식을 직접 계산하고 시각화할 수 있도록 구성되어 있습니다. | 번호 | 파일명 | 주제 | 주요 내용 | |------|--------|------|-----------| | 00 | 00Overview.md | 개요 | 과정 소개 및...", "url": "/study/ko/Mathematical_Methods/00_Overview.html"}, {"id": "Mathematical_Methods/01_Infinite_Series", "title": "01. 무한급수와 수렴 (Infinite Series and Convergence)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 급수의 수렴과 발산을 정의하고, 부분합(partial sum)을 통해 수렴을 판별할 수 있다 - 비교 판정법, 비율 판정법, 근 판정법, 적분 판정법, 교대급수 판정법 등 주요 수렴 판정법을 적용할 수 있다 - 멱급수 (power series) 의 수렴 반경을 구하고, 항별 미분/적분을 수행할 수 있다 - 테일러 급수와 매클로린 급수를 이용하여 함수를 근사하고, 물리학 문제에 적용할 수 있다 - 점근 급수 (asymptotic series) 와 스털링 근사의 개념을 이해하고 물리학적 응용에 활용할 수 있다 --- 수열 (sequence) 은 자연수에서 실수(또는 복소수)로의 함수입니다: $$a1, a2, a3, \\ldots, an, \\ldots$$ 수열 $\\{an\\}$이 특정 값 $L$에 수렴한다는 것은: $$\\lim{n \\to \\infty} an = L$$ 즉, $n$이 충분히 클 때 $an$이 $L$에 임의로 가까워진다는 의미입니다. 급수 (series) 는 수열의 항들의...", "url": "/study/ko/Mathematical_Methods/01_Infinite_Series.html"}, {"id": "Mathematical_Methods/02_Complex_Numbers", "title": "02. 복소수 (Complex Numbers)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "> Boas Chapter 2 — 물리과학에서 복소수는 단순한 수학적 도구를 넘어, 파동 현상, 교류 회로, 양자역학 등 핵심 물리학의 언어입니다. --- 이 레슨을 완료하면 다음을 할 수 있습니다: - 복소수의 대수적, 기하학적 표현을 자유자재로 변환할 수 있다 (직교좌표, 극좌표, 지수 형식) - 오일러 공식과 드모아브르 정리를 이용하여 삼각함수 항등식을 유도하고 거듭제곱근을 구할 수 있다 - 복소 함수(지수, 삼각, 쌍곡, 로그)의 성질을 이해하고 계산할 수 있다 - 물리학 응용: 교류 회로의 임피던스 계산, 파동의 복소 표현, 양자역학적 파동함수를 다룰 수 있다 - 복소수를 이용한 2D 변환의 기하학적 의미를 파악하고, 등각사상(conformal mapping)의 기본 원리를 이해한다 --- 실수(real number)만으로는 $x^2 + 1 = 0$과 같은 방정식을 풀 수 없습니다. 허수 단위(imaginary unit) $i$를 다음과 같이 정의합니다: $$ i^2 =...", "url": "/study/ko/Mathematical_Methods/02_Complex_Numbers.html"}, {"id": "Mathematical_Methods/03_Linear_Algebra", "title": "03. 선형대수 (Linear Algebra)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "> Boas Chapter 3 — 물리과학에서 선형대수는 역학의 관성 텐서, 양자역학의 행렬 형식, 연성 진동 분석 등 거의 모든 분야의 기초를 이룹니다. --- 이 레슨을 완료하면 다음을 할 수 있습니다: - 행렬 연산(덧셈, 곱셈, 전치, 역행렬)을 수행하고 행렬식(determinant)을 계산할 수 있다 - 가우스 소거법과 크래머 법칙을 이용하여 연립일차방정식을 풀 수 있다 - 고유값/고유벡터를 구하고 행렬의 대각화(diagonalization)를 수행할 수 있다 - 대칭 행렬과 에르미트 행렬의 스펙트럼 정리를 이해하고, 직교/유니터리 행렬의 성질을 활용할 수 있다 - 이차형식(quadratic form)의 양정치/음정치 판별을 수행할 수 있다 - 물리학 응용: 관성 텐서의 주축 변환, 연성 진동의 고유 모드, 양자역학의 행렬 역학을 다룰 수 있다 --- 행렬(matrix)은 수를 직사각형으로 배열한 것입니다. $m \\times n$ 행렬 $A$의 원소를 $a{ij}$로...", "url": "/study/ko/Mathematical_Methods/03_Linear_Algebra.html"}, {"id": "Mathematical_Methods/04_Partial_Differentiation", "title": "04. 편미분 (Partial Differentiation)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "> Boas Chapter 4 — 편미분은 물리학의 거의 모든 법칙이 다변수 함수로 기술되기 때문에, 열역학, 전자기학, 유체역학 등 물리과학 전반에서 핵심 도구입니다. --- 이 레슨을 완료하면 다음을 할 수 있습니다: - 편미분의 정의와 표기법을 이해하고, 다변수 함수의 편미분을 계산할 수 있다 - 다변수 연쇄법칙을 적용하여 복합 함수의 도함수를 구할 수 있다 - 음함수 미분을 수행하고 물리적 관계식에 적용할 수 있다 - 극값과 안장점을 2차 도함수 판정법으로 분류할 수 있다 - 라그랑주 승수법을 이용하여 구속 조건이 있는 최적화 문제를 풀 수 있다 - 완전미분의 조건을 이해하고, 열역학의 맥스웰 관계식을 유도할 수 있다 - 다변수 테일러 급수를 전개하고 물리학 근사에 활용할 수 있다 --- 다변수 함수 $f(x, y, z, \\ldots)$의 특정 변수에 대한 편미분은 나머지 변수를 상수로 취급하고 그 변수에 대해서만 미분하는 것입니다: $$ \\frac{\\partial...", "url": "/study/ko/Mathematical_Methods/04_Partial_Differentiation.html"}, {"id": "Mathematical_Methods/05_Vector_Analysis", "title": "05. 벡터 해석 (Vector Analysis)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 기울기(gradient), 발산(divergence), 회전(curl) 연산자의 물리적 의미를 이해하고 계산할 수 있다 - 선적분과 면적분을 수행하고, 보존장(conservative field)의 판별 조건을 설명할 수 있다 - 그린 정리, 스토크스 정리, 가우스 발산 정리를 서술하고 적용할 수 있다 - 맥스웰 방정식을 적분 형태와 미분 형태로 상호 변환할 수 있다 - Python(SymPy, Matplotlib)을 이용하여 벡터장을 시각화하고, 선적분/면적분을 수치적으로 계산할 수 있다 --- 벡터 미분 연산자는 스칼라장(scalar field)과 벡터장(vector field)의 공간적 변화를 기술하는 핵심 도구이다. 3차원 직교 좌표계에서 나블라(nabla) 연산자는 다음과 같이 정의된다: $$ \\nabla = \\hat{x}\\frac{\\partial}{\\partial x} + \\hat{y}\\frac{\\partial}{\\partial y} +...", "url": "/study/ko/Mathematical_Methods/05_Vector_Analysis.html"}, {"id": "Mathematical_Methods/06_Curvilinear_Coordinates", "title": "06. 곡선좌표계와 다중적분 (Curvilinear Coordinates and Multiple Integrals)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 다중적분의 정의와 계산법을 이해하고, 적분 순서 변경 기법을 익힌다 - 야코비안(Jacobian)을 이용한 좌표 변환에서의 적분 변수 치환을 수행할 수 있다 - 원통 좌표계(cylindrical)와 구면 좌표계(spherical)의 좌표 변환, 체적/면적 요소, 미분 연산자를 유도하고 활용한다 - 일반 곡선좌표계에서 스케일 인자(scale factor)와 미분 연산자의 일반적 표현을 이해한다 - 물리학 문제(관성 모멘트, 전기장, 중력장)에 적절한 좌표계를 선택하여 적용할 수 있다 --- 이중적분(double integral)은 2차원 영역 $R$ 위에서 함수 $f(x, y)$를 적분하는 것이다: $$\\iintR f(x, y) \\, dA = \\lim{n \\to \\infty} \\sum{i=1}^{n} f(xi, yi) \\, \\Delta Ai$$ 직교 좌표에서 면적 요소는 $dA = dx \\, dy$이므로, 반복적분(iterated integral)으로 계산한다: $$\\iintR...", "url": "/study/ko/Mathematical_Methods/06_Curvilinear_Coordinates.html"}, {"id": "Mathematical_Methods/07_Fourier_Series", "title": "07. 푸리에 급수 (Fourier Series)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 주기 함수(periodic function)를 삼각 함수의 급수로 분해하는 푸리에 급수의 개념과 수학적 기반(직교성)을 이해한다 - 푸리에 계수 $a0, an, bn$을 계산하고, 구형파·톱니파 등 대표적인 파형에 적용할 수 있다 - 디리클레 조건, 점별·균등 수렴, 깁스 현상(Gibbs phenomenon)을 이해하고, 수렴 거동을 분석할 수 있다 - 반구간 전개(half-range expansion)와 파르세발 정리(Parseval's theorem)를 활용하여 물리 문제를 풀 수 있다 - 진동하는 현, 열전도, 전자기파 등 물리학 응용에서 푸리에 급수가 핵심 도구로 쓰이는 방식을 이해한다 --- 주기 함수(periodic function)는 양의 상수 $T > 0$에 대해 다음을 만족하는 함수이다: $$f(x + T) = f(x) \\quad \\text{for all } x$$ 여기서 $T$를 주기(period)라 한다. 가장 작은 양의 주기를 기본...", "url": "/study/ko/Mathematical_Methods/07_Fourier_Series.html"}, {"id": "Mathematical_Methods/08_Fourier_Transforms", "title": "08. 푸리에 변환 (Fourier Transforms)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 푸리에 급수에서 푸리에 변환으로의 전환 과정을 이해하고, 비주기 함수에 대한 스펙트럼 표현을 유도할 수 있다 - 푸리에 변환의 주요 성질 (선형성, 이동, 스케일링, 미분)을 증명하고 활용할 수 있다 - 가우시안, 직사각형 함수, 디랙 델타 함수 등 핵심 변환 쌍을 계산하고 물리적으로 해석할 수 있다 - 컨볼루션 정리를 이해하고, 신호 필터링 등 실제 응용에 적용할 수 있다 - 이산 푸리에 변환(DFT)과 FFT 알고리즘의 원리를 이해하고, 나이퀴스트 정리의 의미를 설명할 수 있다 - 불확정성 원리, 프라운호퍼 회절, 스펙트럼 분석 등 물리학 응용에 푸리에 변환을 적용할 수 있다 --- 주기 $T$를 가지는 함수 $f(x)$의 푸리에 급수는 다음과 같이 쓸 수 있습니다: $$f(x) = \\sum{n=-\\infty}^{\\infty} cn e^{i \\cdot 2\\pi n x / T}$$ 여기서 복소 푸리에 계수 $cn$은: $$cn = \\frac{1}{T}...", "url": "/study/ko/Mathematical_Methods/08_Fourier_Transforms.html"}, {"id": "Mathematical_Methods/09_ODE_First_Second_Order", "title": "09. 상미분방정식: 1차와 2차 (Ordinary Differential Equations: First and Second Order)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 1차 ODE의 주요 풀이 기법(분리형, 적분인자, 완전미분, 치환법)을 익힌다 - 2차 상수계수 ODE의 제차·비제차 해법을 이해한다 - 감쇠 조화 진동자와 RLC 회로를 ODE로 모델링하고 해석한다 - 해의 존재·유일성 정리와 론스키안의 의미를 파악한다 - SymPy와 SciPy를 사용하여 해석해를 검증하고 수치해를 구한다 --- 1차 상미분방정식의 일반적 형태는 다음과 같다: $$\\frac{dy}{dx} = f(x, y)$$ 초기 조건 $y(x0) = y0$가 주어지면 초기값 문제(Initial Value Problem, IVP)가 된다. $f(x,y)$가 $g(x) \\cdot h(y)$ 꼴로 분리되면 분리형 방정식이다: $$\\frac{dy}{dx} = g(x)\\,h(y) \\quad\\Longrightarrow\\quad \\frac{dy}{h(y)} = g(x)\\,dx$$ 양변을 적분하면 해를 얻는다. 예제: 인구 성장 모델 (로지스틱 방정식) $$\\frac{dP}{dt} =...", "url": "/study/ko/Mathematical_Methods/09_ODE_First_Second_Order.html"}, {"id": "Mathematical_Methods/10_Higher_Order_ODE_Systems", "title": "10. 고차 ODE와 연립계 (Higher-Order ODE and Systems)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- n차 상수계수 선형 ODE의 특성방정식을 세우고 일반해를 구할 수 있다 - 미정계수법과 매개변수 변환법으로 비제차 ODE의 특수해를 구할 수 있다 - 연립 ODE를 벡터-행렬 형태로 표현하고, 고유값/고유벡터 및 행렬 지수로 풀 수 있다 - 위상 평면(phase plane)에서 평형점을 분류하고 안정성을 판별할 수 있다 - 비선형 시스템의 선형화 기법과 대표적인 물리/생물 모델을 분석할 수 있다 - 결합 진동자의 정규 모드(normal modes)를 구하고, 라그랑주 역학과의 연결을 이해한다 --- n차 상수계수 선형 ODE의 일반적 형태는 다음과 같다: $$an y^{(n)} + a{n-1} y^{(n-1)} + \\cdots + a1 y' + a0 y = f(x)$$ 여기서 $a0, a1, \\ldots, an$은 상수이며, $f(x) = 0$이면 제차(homogeneous), $f(x) \\neq 0$이면 비제차(non-homogeneous) 방정식이다. 핵심 원리 -...", "url": "/study/ko/Mathematical_Methods/10_Higher_Order_ODE_Systems.html"}, {"id": "Mathematical_Methods/11_Series_Solutions_Special_Functions", "title": "11. 급수해와 특수함수 (Series Solutions and Special Functions)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 정상점(ordinary point)과 특이점(singular point)을 구별하고, 정상점 주위에서 멱급수 해법을 적용할 수 있다 - 프로베니우스 방법(Frobenius method)으로 정칙 특이점 주위의 급수해를 구하고, 지표 방정식(indicial equation)의 세 가지 경우를 처리할 수 있다 - 베셀 함수(Bessel functions) $Jn(x)$, $Yn(x)$의 성질, 직교성, 점화식을 이해하고 원통 좌표계 문제에 적용할 수 있다 - 르장드르 다항식(Legendre polynomials) $Pl(x)$의 로드리게스 공식, 생성 함수, 직교성을 이해하고 구면 좌표계 문제에 적용할 수 있다 - 에르미트 함수와 라게르 함수가 양자역학의 조화 진동자 및 수소 원자 문제에서 어떻게 등장하는지 이해한다 - 감마 함수와 베타 함수의 정의, 성질, 상호 관계를 알고 적분 계산에 활용할 수 있다 --- 2차 선형 ODE의 표준형을 고려하자: $$y'' + P(x)y' +...", "url": "/study/ko/Mathematical_Methods/11_Series_Solutions_Special_Functions.html"}, {"id": "Mathematical_Methods/12_Sturm_Liouville_Theory", "title": "12. 스투름-리우빌 이론 (Sturm-Liouville Theory)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 스투름-리우빌(Sturm-Liouville) 문제의 표준 형태를 이해하고, 일반적인 2차 ODE를 자기수반 형태로 변환할 수 있다 - 고유값의 실수성, 고유함수의 직교성, 완비성 등 S-L 정리의 핵심 결과를 증명하고 활용할 수 있다 - 일반 푸리에 급수(Generalized Fourier Series)로 임의의 함수를 고유함수 전개할 수 있다 - 삼각함수, 베셀 함수, 르장드르 다항식이 각각 어떤 S-L 문제의 고유함수인지 파악할 수 있다 - 가중 내적(weighted inner product)과 그람-슈미트 직교화를 수행할 수 있다 - 열방정식, 진동 문제, 양자역학 등 물리학 응용에서 S-L 이론의 역할을 이해한다 --- 스투름-리우빌 방정식은 다음과 같은 2차 상미분방정식의 표준 형태이다: $$\\frac{d}{dx}\\left[p(x)\\frac{dy}{dx}\\right] + q(x)y + \\lambda w(x) y = 0$$ 여기서: - $p(x) > 0$: 계수 함수...", "url": "/study/ko/Mathematical_Methods/12_Sturm_Liouville_Theory.html"}, {"id": "Mathematical_Methods/13_Partial_Differential_Equations", "title": "13. 편미분방정식 (Partial Differential Equations)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 편미분방정식(PDE)을 타원형, 포물형, 쌍곡형으로 분류하고, 각 유형에 적합한 경계 조건 및 초기 조건을 설정할 수 있다 - 변수분리법(separation of variables)을 직교좌표, 원통좌표, 구면좌표에서 적용하여 PDE를 ODE로 분해할 수 있다 - 열방정식, 파동방정식, 라플라스 방정식의 해석적 해를 구하고 물리적 의미를 해석할 수 있다 - 달랑베르 해를 이용하여 파동의 전파를 기술할 수 있다 - 전자기학의 전위 문제와 양자역학의 무한 퍼텐셜 우물에 PDE 해법을 적용할 수 있다 --- 2차 선형 PDE의 일반적 형태: $$A \\frac{\\partial^2 u}{\\partial x^2} + 2B \\frac{\\partial^2 u}{\\partial x \\partial y} + C \\frac{\\partial^2 u}{\\partial y^2} + \\text{(저차 항)} = 0$$ 판별식 $\\Delta = B^2 - AC$에 따라 세 가지 유형으로 분류한다: |...", "url": "/study/ko/Mathematical_Methods/13_Partial_Differential_Equations.html"}, {"id": "Mathematical_Methods/14_Complex_Analysis", "title": "14. 복소해석 (Complex Analysis)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 복소함수의 미분 가능성과 코시-리만 조건을 이해한다 - 코시 적분 정리와 적분 공식을 활용하여 복소 적분을 계산한다 - 테일러 급수와 로랑 급수를 통해 복소함수를 급수로 전개한다 - 유수 정리를 이용하여 실수 적분 문제를 효율적으로 풀 수 있다 - 등각사상의 개념을 이해하고 물리학 문제에 적용한다 > 물리학에서의 중요성: 복소해석은 양자역학의 전파함수, 전기역학의 전위론, 유체역학의 흐름 함수, 신호처리의 주파수 분석 등 물리학 전반에 걸쳐 핵심 도구이다. 특히 유수 정리를 통한 적분 계산은 이론물리학에서 가장 빈번하게 활용되는 기법 중 하나이다. --- 복소함수 $f(z) = u(x, y) + iv(x, y)$가 점 $z0$에서 미분 가능하려면, 극한 $$f'(z0) = \\lim{\\Delta z \\to 0} \\frac{f(z0 + \\Delta z) - f(z0)}{\\Delta z}$$ 이 $\\Delta z$가 어떤 방향에서 접근하든 같은 값으로 수렴해야 한다. 이로부터...", "url": "/study/ko/Mathematical_Methods/14_Complex_Analysis.html"}, {"id": "Mathematical_Methods/15_Laplace_Transform", "title": "15. 라플라스 변환 (Laplace Transform)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 라플라스 변환의 정의와 존재 조건을 이해하고, 수렴 영역의 개념을 설명할 수 있다 - 기본 함수들의 라플라스 변환을 유도하고, 변환표를 활용하여 복잡한 함수의 변환을 계산할 수 있다 - 이동 정리, 미분 성질, 합성곱 정리 등 라플라스 변환의 주요 성질을 증명하고 적용할 수 있다 - 부분분수 분해와 역 라플라스 변환을 이용하여 상미분방정식의 초기값 문제를 체계적으로 풀 수 있다 - 전달함수를 이용한 선형 시스템 해석과 안정성 판별의 기본 원리를 이해한다 - RLC 회로, 감쇠 진동 등 물리·공학 문제에 라플라스 변환을 적용할 수 있다 > 물리학과 공학에서의 중요성: 라플라스 변환은 미분방정식을 대수방정식으로 변환하여 초기값 문제를 체계적으로 풀 수 있게 해주는 핵심 도구이다. 회로 해석, 제어 공학, 신호 처리, 기계 진동, 열전도 등 거의 모든 공학 분야에서 필수적이며, 푸리에 변환의 일반화로서 과도 응답(transient response) 해석에 특히 강력한 위력을...", "url": "/study/ko/Mathematical_Methods/15_Laplace_Transform.html"}, {"id": "Mathematical_Methods/16_Greens_Functions", "title": "16. 그린 함수 (Green's Functions)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 디랙 델타 함수 $\\delta(x)$의 정의, 성질, 다양한 표현을 이해하고 활용할 수 있다 - 비제차 미분방정식 $L[u] = f(x)$의 해를 그린 함수를 이용하여 적분 형태로 표현할 수 있다 - 경계값 문제에서 그린 함수를 직접 구성하고, 접합 조건(matching conditions)을 적용할 수 있다 - 고유함수 전개법으로 그린 함수를 급수 형태로 나타내고, 스투름-리우빌 이론과의 연결을 이해한다 - 편미분방정식의 그린 함수(푸아송 방정식, 열방정식, 파동방정식)를 구하고 물리적으로 해석할 수 있다 - 정전기학, 양자역학, 음향학 등 물리적 응용에서 그린 함수를 활용하여 실제 문제를 풀 수 있다 > 물리학에서의 중요성: 그린 함수는 \"점 소스가 만드는 응답\"을 기술하는 보편적 도구이다. 일단 점 소스에 대한 응답(그린 함수)을 알면, 중첩 원리에 의해 임의의 소스 분포에 대한 해를 적분 하나로 구할 수 있다. 정전기학에서 점전하의 전위, 양자역학에서...", "url": "/study/ko/Mathematical_Methods/16_Greens_Functions.html"}, {"id": "Mathematical_Methods/17_Calculus_of_Variations", "title": "17. 변분법 (Calculus of Variations)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 범함수(functional)의 개념과 일반 함수와의 차이를 이해한다 - 오일러-라그랑주 방정식을 유도하고 다양한 특수 형태에 적용한다 - 최속 강하선, 측지선, 현수선 등 고전적 변분 문제를 풀 수 있다 - 구속 조건이 있는 변분 문제에 라그랑주 승수법을 적용한다 - 라그랑주 역학과 해밀턴 역학의 변분법적 기초를 이해한다 - 변분법의 현대적 응용(유한요소법, 최적제어, 레일리-리츠법)을 파악한다 > 물리학에서의 중요성: 변분법은 \"자연은 작용을 최소화한다\"는 최소작용 원리의 수학적 토대이다. 뉴턴 역학을 라그랑주·해밀턴 형식으로 재구성하고, 페르마 원리(광학), 최소 곡면(비누막), 최적 경로 문제 등 물리학과 공학 전반에서 핵심적 역할을 한다. 양자역학의 경로적분, 일반상대론의 아인슈타인 방정식, 고전장론의 라그랑지안 밀도 모두 변분법에 기초한다. --- 일반 함수 $f: \\mathbb{R} \\to \\mathbb{R}$는 수를 입력받아 수를 반환한다. 반면...", "url": "/study/ko/Mathematical_Methods/17_Calculus_of_Variations.html"}, {"id": "Mathematical_Methods/18_Tensor_Analysis", "title": "18. 텐서 해석 (Tensor Analysis)", "topic": "Mathematical_Methods", "topic_display": "Mathematical Methods", "body": "- 텐서의 정의를 좌표 변환 법칙의 관점에서 이해하고, 스칼라·벡터·행렬을 텐서의 특수한 경우로 분류할 수 있다 - 아인슈타인 합산 규약과 인덱스 표기법을 사용하여 텐서 방정식을 간결하게 표현하고 조작할 수 있다 - 반변(contravariant)·공변(covariant) 텐서의 변환 법칙을 구분하고, 계량 텐서를 통한 인덱스 올림/내림을 수행할 수 있다 - 크리스토펠 기호와 공변 미분의 개념을 이해하고, 곡선 좌표계에서 텐서의 미분을 올바르게 계산할 수 있다 - 리만 곡률 텐서의 정의와 기하학적 의미를 이해하고, 간단한 공간에서 곡률을 계산할 수 있다 - 텐서 해석의 물리적 응용(응력 텐서, 전자기장 텐서, 아인슈타인 방정식)을 서술하고 Python으로 계산할 수 있다 > 텐서는 왜 필요한가? 자연 법칙은 좌표계의 선택에 무관해야 한다. 스칼라(rank-0)와 벡터(rank-1)만으로는 응력, 관성 모멘트, 전자기장 같은 물리량을 기술할 수 없다. 텐서는 임의의 좌표 변환에서...", "url": "/study/ko/Mathematical_Methods/18_Tensor_Analysis.html"}, {"id": "Networking/00_Overview", "title": "네트워크 학습 가이드", "topic": "Networking", "topic_display": "Networking", "body": "이 폴더는 컴퓨터 네트워크를 체계적으로 학습하기 위한 자료를 담고 있습니다. OSI 7계층부터 TCP/IP, 라우팅, 보안까지 네트워크 통신의 원리를 이해할 수 있습니다. 대상 독자: 개발자, 시스템 관리자, 네트워크 기초를 배우려는 사람 --- --- - 컴퓨터 기초 (운영체제 개념) - 이진수와 16진수 이해 - 기본적인 명령줄 사용 --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01NetworkFundamentals.md | ⭐ | 네트워크 정의, LAN/WAN, 토폴로지 | | 02OSI7LayerModel.md | ⭐⭐ | 각 계층 역할, 프로토콜, PDU | | 03TCPIPModel.md | ⭐⭐ | TCP/IP 4계층, OSI와 비교 | | 04PhysicalLayer.md | ⭐ | 전송 매체, 신호, 이더넷 케이블 | | 파일명 | 난이도 | 주요 내용 |...", "url": "/study/ko/Networking/00_Overview.html"}, {"id": "Networking/01_Network_Fundamentals", "title": "네트워크 기초 개념", "topic": "Networking", "topic_display": "Networking", "body": "네트워크(Network)는 두 대 이상의 컴퓨터가 데이터를 주고받을 수 있도록 연결된 시스템입니다. 이 레슨에서는 네트워크의 기본 개념, 유형, 토폴로지, 그리고 통신 방식의 기초를 학습합니다. 네트워크의 기본 원리를 이해하는 것은 현대 IT 인프라를 이해하는 첫 걸음입니다. 난이도: ⭐ (기초) --- 1. 네트워크란 무엇인가? 2. 네트워크의 역사 3. 네트워크 유형 4. 네트워크 토폴로지 5. 패킷 교환 vs 회선 교환 6. 클라이언트-서버 vs P2P 7. 네트워크 장비 8. 연습 문제 --- --- | 연도 | 이벤트 | 설명 | |------|--------|------| | 1969 | ARPANET | 최초의 패킷 교환 네트워크, 인터넷의 시초 | | 1973 | 이더넷 발명 | Xerox PARC, Bob Metcalfe | | 1974 | TCP/IP 제안 | Vint Cerf, Bob Kahn | | 1983 | DNS 도입 | 도메인 이름 시스템 | |...", "url": "/study/ko/Networking/01_Network_Fundamentals.html"}, {"id": "Networking/02_OSI_7_Layer_Model", "title": "OSI 7계층 모델", "topic": "Networking", "topic_display": "Networking", "body": "OSI(Open Systems Interconnection) 7계층 모델은 네트워크 통신을 7개의 계층으로 나누어 표준화한 참조 모델입니다. ISO(국제표준화기구)에서 1984년에 발표한 이 모델은 서로 다른 시스템 간의 통신을 가능하게 하는 프레임워크를 제공합니다. 이 레슨에서는 각 계층의 역할, 프로토콜, PDU의 개념, 그리고 캡슐화 과정을 학습합니다. 난이도: ⭐⭐ (초급-중급) --- 1. OSI 모델 개요 2. 7계층 상세 설명 3. 각 계층의 프로토콜 4. PDU (Protocol Data Unit) 5. 캡슐화와 역캡슐화 6. 계층별 주요 장비 7. OSI 모델의 실제 적용 8. 연습 문제 --- --- --- --- --- --- --- --- 1. OSI 7계층을 아래에서 위로 순서대로 나열하시오. 2. 다음 프로토콜이 동작하는 계층을 연결하시오. - (a) HTTP ( ) 전송 계층 - (b) TCP ( ) 네트워크 계층 - (c) IP ( ) 데이터링크 계층...", "url": "/study/ko/Networking/02_OSI_7_Layer_Model.html"}, {"id": "Networking/03_TCP_IP_Model", "title": "TCP/IP 모델", "topic": "Networking", "topic_display": "Networking", "body": "TCP/IP(Transmission Control Protocol/Internet Protocol) 모델은 인터넷의 기초가 되는 프로토콜 스택입니다. 1970년대 미국 국방부 ARPANET 프로젝트에서 개발되어 현재 전 세계 인터넷 통신의 표준으로 사용되고 있습니다. 이 레슨에서는 TCP/IP 모델의 4계층 구조, OSI 모델과의 비교, 인터넷의 역사, 그리고 실제 통신 흐름을 학습합니다. 난이도: ⭐⭐ (초급-중급) --- 1. TCP/IP 모델 개요 2. 인터넷의 역사 3. TCP/IP 4계층 4. OSI와 TCP/IP 비교 5. 각 계층의 프로토콜 6. 실제 통신 흐름 7. TCP vs UDP 8. 연습 문제 --- --- | 인물 | 기여 | 주요 성과 | |------|------|-----------| | Vint Cerf | TCP/IP 공동 발명 | \"인터넷의 아버지\" | | Bob Kahn | TCP/IP 공동 발명 | ARPANET 설계 | | Tim...", "url": "/study/ko/Networking/03_TCP_IP_Model.html"}, {"id": "Networking/04_Physical_Layer", "title": "물리 계층", "topic": "Networking", "topic_display": "Networking", "body": "물리 계층(Physical Layer)은 OSI 모델의 최하위 계층으로, 비트(0과 1)를 실제 물리적 신호(전기, 광, 무선)로 변환하여 전송하는 역할을 담당합니다. 이 레슨에서는 물리 계층의 역할, 전송 매체의 종류, 신호의 특성, 대역폭과 전송 속도, 그리고 실제 케이블과 커넥터의 종류를 학습합니다. 난이도: ⭐ (기초) --- 1. 물리 계층의 역할 2. 전송 매체 3. 신호 유형 4. 대역폭과 전송 속도 5. 이더넷 케이블 종류 6. 커넥터 종류 7. 무선 전송 8. 연습 문제 --- --- --- --- --- --- --- --- 1. 물리 계층의 주요 기능 3가지를 설명하시오. 2. 다음 매체를 전송 거리가 긴 순서대로 나열하시오. - UTP, 싱글모드 광섬유, 동축 케이블, 멀티모드 광섬유 3. Cat5e와 Cat6 케이블의 차이점을 설명하시오. 4. 스트레이트 케이블과 크로스오버 케이블의 용도를 각각 설명하시오. 5. 다음 상황에서 적절한 전송 매체를 선택하고...", "url": "/study/ko/Networking/04_Physical_Layer.html"}, {"id": "Networking/05_Data_Link_Layer", "title": "데이터링크 계층", "topic": "Networking", "topic_display": "Networking", "body": "데이터링크 계층(Data Link Layer)은 OSI 모델의 2계층으로, 인접한 노드 간의 신뢰성 있는 데이터 전송을 담당합니다. 물리 계층의 비트 스트림을 프레임 단위로 구성하고, MAC 주소를 이용한 물리적 주소 지정, 오류 검출, 매체 접근 제어 등의 기능을 수행합니다. 이 레슨에서는 MAC 주소, 프레임 구조, 이더넷, 스위치 동작 원리, ARP 프로토콜 등을 학습합니다. 난이도: ⭐⭐ (초급-중급) --- 1. 데이터링크 계층의 역할 2. MAC 주소 3. 프레임 구조 4. 이더넷 (IEEE 802.3) 5. 스위치 동작 원리 6. ARP (Address Resolution Protocol) 7. 충돌 도메인과 브로드캐스트 도메인 8. 연습 문제 --- --- --- --- --- --- --- --- 1. MAC 주소의 구조를 설명하고, OUI가 의미하는 것을 설명하시오. 2. 다음 중 브로드캐스트 MAC 주소는? - (a) 00:00:00:00:00:00 - (b)...", "url": "/study/ko/Networking/05_Data_Link_Layer.html"}, {"id": "Networking/06_IP_Address_Subnetting", "title": "IP 주소와 서브네팅", "topic": "Networking", "topic_display": "Networking", "body": "IP(Internet Protocol) 주소는 네트워크에서 각 장치를 고유하게 식별하는 논리적 주소입니다. 이 레슨에서는 IPv4 주소의 구조, 클래스 기반 주소 체계, 서브넷 마스크, CIDR 표기법, 공인/사설 IP, 그리고 IPv6 기초를 학습합니다. 서브네팅은 네트워크 설계와 관리에서 가장 중요한 기술 중 하나입니다. 난이도: ⭐⭐ (초급-중급) --- 1. IP 주소의 개념 2. IPv4 주소 구조 3. IP 주소 클래스 4. 서브넷 마스크 5. CIDR 표기법 6. 공인 IP vs 사설 IP 7. IPv6 기초 8. 연습 문제 --- --- --- | 클래스 | 첫 옥텟 | 네트워크 비트 | 호스트 비트 | 네트워크 수 | 호스트 수 | |--------|---------|---------------|-------------|-------------|-----------| | A | 1-126 | 8 | 24 | 126 | 16,777,214 | | B | 128-191...", "url": "/study/ko/Networking/06_IP_Address_Subnetting.html"}, {"id": "Networking/07_Subnetting_Practice", "title": "서브네팅 실습", "topic": "Networking", "topic_display": "Networking", "body": "이 문서에서는 서브네팅(Subnetting)의 실제 계산 방법과 다양한 실습 문제를 다룹니다. 서브네팅은 네트워크 설계와 관리의 핵심 기술로, 효율적인 IP 주소 할당과 네트워크 분할을 가능하게 합니다. 난이도: ⭐⭐⭐ 예상 학습 시간: 3-4시간 선수 지식: 06IPAddressSubnetting.md --- 1. 서브넷 계산 기초 2. 네트워크 주소, 브로드캐스트 주소, 호스트 범위 3. 서브넷 분할 예제 4. VLSM (Variable Length Subnet Mask) 5. 서브넷 설계 문제 6. 연습 문제 7. 다음 단계 8. 참고 자료 --- 서브네팅을 빠르게 계산하려면 2의 거듭제곱을 암기해야 합니다. | CIDR | 서브넷 마스크 | 호스트 비트 | 사용 가능 호스트 | |------|------------------|------------|-----------------| | /24 | 255.255.255.0 | 8 | 254 | | /25 |...", "url": "/study/ko/Networking/07_Subnetting_Practice.html"}, {"id": "Networking/08_Routing_Basics", "title": "라우팅 기초", "topic": "Networking", "topic_display": "Networking", "body": "이 문서에서는 네트워크 라우팅의 기본 개념을 다룹니다. 라우팅은 네트워크 간 데이터 전송의 핵심으로, 패킷이 출발지에서 목적지까지 최적의 경로를 찾아가는 과정입니다. 난이도: ⭐⭐⭐ 예상 학습 시간: 2-3시간 선수 지식: 07SubnettingPractice.md --- 1. 라우팅이란? 2. 라우터의 역할 3. 라우팅 테이블 구조 4. 정적 라우팅 vs 동적 라우팅 5. 기본 게이트웨이 6. 최장 접두어 매칭 7. 연습 문제 8. 다음 단계 9. 참고 자료 --- 라우팅(Routing)은 네트워크에서 패킷을 출발지에서 목적지까지 전달하기 위한 최적의 경로를 결정하는 과정입니다. | 구분 | 스위칭 (L2) | 라우팅 (L3) | |------|------------|------------| | 동작 계층 | 데이터링크 계층 | 네트워크 계층 | | 주소 사용 | MAC 주소 | IP 주소 | | 범위 | 동일 네트워크 내 | 서로 다른 네트워크 간 | | 장비 | 스위치 |...", "url": "/study/ko/Networking/08_Routing_Basics.html"}, {"id": "Networking/09_Routing_Protocols", "title": "라우팅 프로토콜", "topic": "Networking", "topic_display": "Networking", "body": "이 문서에서는 동적 라우팅 프로토콜의 종류와 특징을 다룹니다. RIP, OSPF, BGP 등 주요 라우팅 프로토콜의 동작 원리를 이해하고, 각 프로토콜이 적합한 환경을 학습합니다. 난이도: ⭐⭐⭐ 예상 학습 시간: 3-4시간 선수 지식: 08RoutingBasics.md --- 1. 라우팅 프로토콜 분류 2. 거리 벡터 vs 링크 상태 3. RIP (Routing Information Protocol) 4. OSPF (Open Shortest Path First) 5. BGP (Border Gateway Protocol) 6. AS (Autonomous System) 7. 연습 문제 8. 다음 단계 9. 참고 자료 --- 라우팅 프로토콜은 사용 범위에 따라 IGP와 EGP로 분류됩니다. | 구분 | IGP (Interior Gateway Protocol) | EGP (Exterior Gateway Protocol) |...", "url": "/study/ko/Networking/09_Routing_Protocols.html"}, {"id": "Networking/10_TCP_Protocol", "title": "TCP 프로토콜", "topic": "Networking", "topic_display": "Networking", "body": "이 문서에서는 TCP(Transmission Control Protocol)의 핵심 개념을 다룹니다. 연결 지향적이고 신뢰성 있는 데이터 전송을 보장하는 TCP의 동작 원리, 헤더 구조, 흐름 제어, 혼잡 제어 메커니즘을 학습합니다. 난이도: ⭐⭐⭐ 예상 학습 시간: 3-4시간 선수 지식: 09RoutingProtocols.md --- 1. TCP의 특징 2. TCP 헤더 구조 3. 3-Way Handshake 4. 4-Way Handshake 5. 시퀀스 번호와 ACK 6. 흐름 제어 7. 혼잡 제어 8. 연습 문제 9. 다음 단계 10. 참고 자료 --- | 특성 | TCP | UDP | |------|-----|-----| | 연결 | 연결 지향 | 비연결 | | 신뢰성 | 신뢰성 보장 | 비신뢰성 | | 순서 | 순서 보장 | 순서 미보장 | | 속도 | 상대적 느림 | 빠름 | | 헤더 크기 | 20-60 바이트 | 8 바이트 | | 용도 | 웹, 이메일, 파일 전송 |...", "url": "/study/ko/Networking/10_TCP_Protocol.html"}, {"id": "Networking/11_UDP_and_Ports", "title": "UDP와 포트", "topic": "Networking", "topic_display": "Networking", "body": "이 문서에서는 UDP(User Datagram Protocol)와 포트 번호의 개념을 다룹니다. TCP와 대비되는 UDP의 특징을 이해하고, 전송 계층에서 포트가 어떻게 사용되는지 학습합니다. 난이도: ⭐⭐ 예상 학습 시간: 2시간 선수 지식: 10TCPProtocol.md --- 1. UDP의 특징 2. UDP 헤더 구조 3. TCP vs UDP 비교 4. 포트 번호의 개념 5. 포트 번호 범위 6. 소켓 7. 연습 문제 8. 다음 단계 9. 참고 자료 --- UDP(User Datagram Protocol)는 간단하고 빠른 전송을 위한 비연결형 프로토콜입니다. | 장점 | 단점 | |------|------| | 빠른 전송 속도 | 전달 보장 없음 | | 적은 오버헤드 | 순서 보장 없음 | | 연결 설정 불필요 | 혼잡 제어 없음 | | 멀티캐스트 지원 | 흐름 제어 없음 | | 서버 부하 적음 | 보안 취약 (스푸핑) | --- | 필드 | 크기 | 설명 |...", "url": "/study/ko/Networking/11_UDP_and_Ports.html"}, {"id": "Networking/12_DNS", "title": "DNS", "topic": "Networking", "topic_display": "Networking", "body": "이 문서에서는 DNS(Domain Name System)의 구조와 동작 원리를 다룹니다. 사람이 읽을 수 있는 도메인 이름을 IP 주소로 변환하는 DNS의 계층 구조, 조회 방식, 레코드 유형을 학습합니다. 난이도: ⭐⭐ 예상 학습 시간: 2시간 선수 지식: 11UDP와포트.md --- 1. DNS란? 2. 도메인 이름 구조 3. DNS 동작 원리 4. DNS 레코드 유형 5. DNS 캐싱 6. DNS 도구 7. 연습 문제 8. 다음 단계 9. 참고 자료 --- DNS(Domain Name System)는 도메인 이름을 IP 주소로 변환하는 분산 데이터베이스 시스템입니다. | 특성 | 설명 | |------|------| | 분산 시스템 | 전 세계에 분산된 서버들이 협력 | | 계층 구조 | 루트 → TLD → 권한 서버 계층 | | 캐싱 | 성능 향상을 위한 캐시 사용 | | 중복성 | 여러 서버로 가용성 보장 | | 프로토콜 | 주로 UDP 53 (대용량은 TCP 53) |...", "url": "/study/ko/Networking/12_DNS.html"}, {"id": "Networking/13_HTTP_and_HTTPS", "title": "HTTP와 HTTPS", "topic": "Networking", "topic_display": "Networking", "body": "HTTP(HyperText Transfer Protocol)는 웹에서 클라이언트와 서버 간 데이터를 주고받기 위한 애플리케이션 계층 프로토콜입니다. HTTPS는 HTTP에 TLS/SSL 암호화를 추가하여 보안을 강화한 프로토콜입니다. 난이도: ⭐⭐⭐ 학습 목표: - HTTP 요청/응답 구조 이해 - HTTP 메서드와 상태 코드 숙지 - HTTP 버전별 차이점 파악 - HTTPS와 TLS/SSL 동작 원리 이해 --- 1. HTTP 기초 2. HTTP 메서드 3. HTTP 상태 코드 4. HTTP 헤더 5. HTTP 버전 비교 6. HTTPS와 TLS/SSL 7. 인증서 8. 연습 문제 9. 다음 단계 10. 참고 자료 --- | 특성 | 설명 | |------|------| | 비연결성 (Connectionless) | 요청-응답 후 연결 종료 (HTTP/1.0) | | 무상태 (Stateless) | 각 요청은 독립적, 이전 상태 미보관 | | 텍스트 기반 | 사람이 읽을 수...", "url": "/study/ko/Networking/13_HTTP_and_HTTPS.html"}, {"id": "Networking/14_Other_Application_Protocols", "title": "기타 애플리케이션 프로토콜", "topic": "Networking", "topic_display": "Networking", "body": "HTTP 외에도 네트워크에서는 다양한 애플리케이션 계층 프로토콜이 사용됩니다. 이 장에서는 DHCP, FTP, 이메일 프로토콜(SMTP, POP3, IMAP), SSH, Telnet, WebSocket 등을 학습합니다. 난이도: ⭐⭐ 학습 목표: - 각 프로토콜의 역할과 동작 원리 이해 - 프로토콜별 포트 번호 숙지 - 보안 고려사항 파악 - 실무에서의 활용 방법 학습 --- 1. DHCP 2. FTP 3. 이메일 프로토콜 4. SSH 5. Telnet 6. WebSocket 7. 연습 문제 8. 다음 단계 9. 참고 자료 --- DHCP(Dynamic Host Configuration Protocol)는 네트워크에 연결된 장치에 IP 주소와 네트워크 설정을 자동으로 할당하는 프로토콜입니다. | 메시지 | 방향 | 설명 | |--------|------|------| | DISCOVER | 클라이언트 → 서버 | IP 주소 요청 (브로드캐스트) | | OFFER | 서버 →...", "url": "/study/ko/Networking/14_Other_Application_Protocols.html"}, {"id": "Networking/15_Network_Security_Basics", "title": "네트워크 보안 기초", "topic": "Networking", "topic_display": "Networking", "body": "네트워크 보안은 컴퓨터 네트워크와 데이터를 무단 접근, 오용, 변조로부터 보호하는 것입니다. 이 장에서는 방화벽, NAT, VPN, 암호화 기초 등 네트워크 보안의 핵심 개념을 학습합니다. 난이도: ⭐⭐⭐ 학습 목표: - 네트워크 보안의 기본 원칙 이해 - 방화벽의 종류와 동작 원리 파악 - NAT의 개념과 보안적 역할 이해 - VPN의 종류와 활용 방법 학습 - 암호화 기초 개념 습득 --- 1. 네트워크 보안 개요 2. 방화벽 3. NAT 4. VPN 5. 암호화 기초 6. 연습 문제 7. 다음 단계 8. 참고 자료 --- | 요소 | 설명 | 위협 예시 | 대응 방법 | |------|------|----------|----------| | 기밀성 | 인가된 자만 접근 | 도청, 스니핑 | 암호화, 접근 제어 | | 무결성 | 데이터 변조 방지 | 중간자 공격, 변조 | 해시, 디지털 서명 | | 가용성 | 서비스 지속 제공 | DoS/DDoS 공격 | 이중화, 로드밸런싱 |...", "url": "/study/ko/Networking/15_Network_Security_Basics.html"}, {"id": "Networking/16_Security_Threats_Response", "title": "보안 위협과 대응", "topic": "Networking", "topic_display": "Networking", "body": "네트워크 보안 위협은 지속적으로 진화하고 있습니다. 이 장에서는 주요 네트워크 공격 유형, 동작 원리, 그리고 효과적인 대응 방안을 학습합니다. 난이도: ⭐⭐⭐⭐ 학습 목표: - 주요 네트워크 공격 유형과 원리 이해 - 스니핑, 스푸핑, DoS/DDoS 공격 식별 - 웹 보안 위협 (SQL Injection, XSS) 개념 파악 - 침입 탐지/방지 시스템(IDS/IPS) 이해 - 효과적인 보안 대응 방안 수립 --- 1. 네트워크 보안 위협 유형 2. 스니핑 3. 스푸핑 4. DoS/DDoS 공격 5. MITM 공격 6. 웹 보안 위협 7. 침입 탐지 시스템 8. 보안 대응 방안 9. 연습 문제 10. 다음 단계 11. 참고 자료 --- | 공격 유형 | 목표 | CIA 위협 | 계층 | |----------|------|----------|------| | 스니핑 | 정보 수집 | 기밀성 | L2-L7 | | 스푸핑 | 신뢰 악용 | 무결성, 인증 | L2-L4 | |...", "url": "/study/ko/Networking/16_Security_Threats_Response.html"}, {"id": "Networking/17_Practical_Network_Tools", "title": "실무 네트워크 도구", "topic": "Networking", "topic_display": "Networking", "body": "네트워크 관리와 트러블슈팅에는 다양한 도구가 필요합니다. 이 장에서는 ping, traceroute, netstat, tcpdump, Wireshark 등 실무에서 자주 사용되는 네트워크 도구의 사용법을 학습합니다. 난이도: ⭐⭐⭐ 학습 목표: - 기본 네트워크 진단 도구 활용 - 패킷 캡처 및 분석 방법 습득 - DNS 조회 도구 사용법 이해 - 체계적인 네트워크 트러블슈팅 방법론 학습 --- 1. ping 2. traceroute / tracert 3. netstat / ss 4. nslookup / dig 5. tcpdump 6. Wireshark 기초 7. curl 8. 네트워크 트러블슈팅 방법론 9. 연습 문제 10. 참고 자료 --- ping은 ICMP(Internet Control Message Protocol)를 사용하여 네트워크 연결을 테스트하는 기본 도구입니다. | 메시지 | 원인 | |--------|------| | | 대상까지 경로 없음 | | | 응답 없음...", "url": "/study/ko/Networking/17_Practical_Network_Tools.html"}, {"id": "Networking/18_IPv6", "title": "IPv6", "topic": "Networking", "topic_display": "Networking", "body": "- IPv6의 필요성과 IPv4의 한계 이해하기 - IPv6 주소 형식, 표기법, 유형 마스터하기 - IPv6 헤더 구조와 IPv4 대비 개선사항 학습하기 - 주소 자동 구성 메커니즘(SLAAC, DHCPv6) 이해하기 - 인접 탐색 프로토콜(NDP)과 역할 학습하기 - IPv4에서 IPv6로의 전환 메커니즘 탐구하기 - IPv6 라우팅 프로토콜 이해하기 - IPv6 보안 고려사항 학습하기 - IPv6 네트워크 구성 및 문제 해결하기 1. 왜 IPv6인가? 2. IPv6 주소 형식 3. IPv6 주소 유형 4. IPv6 헤더 5. 주소 자동 구성 6. 인접 탐색 프로토콜 7. 전환 메커니즘 8. IPv6 라우팅 9. IPv6 보안 10. 실전 구성 11. 연습 문제 --- IPv4는 32비트 주소를 사용하여 약 43억 개의 주소를 제공합니다: 고갈 타임라인: - 2011: IANA 중앙 풀 고갈 - 2015: ARIN (북미) 고갈 - 2019: RIPE NCC (유럽) 고갈 -...", "url": "/study/ko/Networking/18_IPv6.html"}, {"id": "Networking/19_Container_Networking", "title": "컨테이너 네트워킹", "topic": "Networking", "topic_display": "Networking", "body": "- Linux 네트워크 네임스페이스와 가상 네트워킹 이해하기 - Docker 네트워킹 아키텍처와 네트워크 드라이버 마스터하기 - Kubernetes 네트워킹 모델과 CNI 플러그인 학습하기 - 컨테이너의 서비스 디스커버리와 로드 밸런싱 이해하기 - 보안을 위한 네트워크 정책 구현하기 - 서비스 메시 개념과 구현 학습하기 - 인그레스와 외부 로드 밸런싱 구성하기 - 컨테이너 네트워킹 문제 해결하기 1. 컨테이너 네트워킹 기초 2. Docker 네트워킹 모델 3. Docker 네트워크 드라이버 4. Kubernetes 네트워킹 모델 5. CNI 플러그인 비교 6. 서비스 디스커버리와 로드 밸런싱 7. 네트워크 정책 8. 서비스 메시 9. 인그레스와 로드 밸런싱 10. 컨테이너 네트워크 문제 해결 11. 연습 문제 --- 네트워크 네임스페이스는 Linux에서 네트워크 격리를 제공합니다: 네트워크 네임스페이스 생성: veth 쌍은 가상 케이블 연결입니다: veth 쌍 생성: 브리지는 여러...", "url": "/study/ko/Networking/19_Container_Networking.html"}, {"id": "Numerical_Simulation/00_Overview", "title": "수치 시뮬레이션 Overview", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "이 폴더는 파이썬을 이용한 수치 시뮬레이션 학습 자료를 담고 있습니다. 상미분방정식(ODE)의 기초부터 자기유체역학(MHD)과 플라즈마 시뮬레이션까지 전 범위를 다룹니다. --- --- | 파일 | 주제 | 핵심 내용 | |------|------|----------| | 01NumericalAnalysisBasics.md | 수치해석 기초 | 부동소수점, 오차 분석, 수치 미분/적분 | | 02LinearAlgebraReview.md | 선형대수 복습 | 행렬 연산, 고유값, 분해(LU, QR, SVD) | | 03ODEBasics.md | 상미분방정식 기초 | ODE 개념, 초기값 문제, 해석적 해 | | 04ODENumericalMethods.md | ODE 수치해법 | Euler, RK2, RK4, 적응형 스텝 | | 05ODEAdvanced.md | ODE 고급 | 강성(stiff) 문제, 암시적 방법, scipy.integrate | | 06ODESystems.md |...", "url": "/study/ko/Numerical_Simulation/00_Overview.html"}, {"id": "Numerical_Simulation/01_Numerical_Analysis_Basics", "title": "수치해석 기초", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "수치해석은 수학적 문제를 컴퓨터로 근사적으로 푸는 방법을 연구합니다. 시뮬레이션의 기초가 되는 부동소수점 표현, 오차 분석, 수치 미분과 적분을 학습합니다. --- --- --- --- --- 함수 f(x) = e^(-x²)의 도함수를 x=0.5에서 다양한 스텝 크기로 계산하고 오차를 분석하세요. ∫₀^1 e^(-x²) dx를 사다리꼴과 심슨 공식으로 계산하세요. --- | 개념 | 핵심 내용 | |------|----------| | 부동소수점 | IEEE 754, 머신 엡실론, 정밀도 한계 | | 오차 유형 | 절단 오차, 반올림 오차, 조건수 | | 수치 미분 | 전진/후진/중심차분, 스텝 크기 선택 | | 수치 적분 | 사다리꼴(O(h²)), 심슨(O(h⁴)) |", "url": "/study/ko/Numerical_Simulation/01_Numerical_Analysis_Basics.html"}, {"id": "Numerical_Simulation/02_Linear_Algebra_Review", "title": "선형대수 복습", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "수치 시뮬레이션에서 선형대수는 핵심적인 역할을 합니다. 행렬 연산, 연립방정식 풀이, 고유값 문제, 행렬 분해 등을 NumPy/SciPy로 구현하는 방법을 학습합니다. --- --- --- --- --- --- --- 3x3 삼중대각 행렬의 고유값을 구하고, 거듭제곱법 결과와 비교하세요. 100x100 희소 행렬의 연립방정식을 직접법과 반복법으로 풀고 시간을 비교하세요. --- | 분해 방법 | 용도 | 조건 | |----------|------|------| | LU | 연립방정식 풀이 | 정방 행렬 | | Cholesky | 연립방정식 (빠름) | 대칭 양정치 | | QR | 최소자승, 고유값 | 모든 행렬 | | SVD | 압축, 의사역행렬 | 모든 행렬 | | 솔버 | 행렬 유형 | 특징 | |------|----------|------| | spsolve | 희소 | 직접법 | | CG | 대칭 양정치 | 반복법 | | GMRES | 일반 | 반복법 | | BiCGSTAB...", "url": "/study/ko/Numerical_Simulation/02_Linear_Algebra_Review.html"}, {"id": "Numerical_Simulation/03_ODE_Basics", "title": "상미분방정식 기초", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "상미분방정식(ODE)은 하나의 독립변수에 대한 미분을 포함하는 방정식입니다. 물리적 시스템의 시간 변화를 기술하는 데 널리 사용됩니다. --- --- --- --- --- --- 냉각의 법칙: dT/dt = -k(T - T_ambient) 초기 온도 90°C, 주변 온도 20°C, k=0.1일 때 시간에 따른 온도 변화를 그리세요. 감쇠 진동: x'' + 2γx' + ω₀²x = 0 ω₀ = 2, γ = 0.5일 때 위상 평면과 시간 응답을 그리세요. --- | 개념 | 내용 | |------|------| | ODE 분류 | 차수, 선형성, 자율성 | | 해석적 해법 | 변수분리, 적분인자, 특성방정식 | | 고차→1차 변환 | n차 ODE → n개 1차 시스템 | | 위상 평면 | 평형점, 안정성, 궤적 분석 | | 존재성/유일성 | 리프시츠 조건 |", "url": "/study/ko/Numerical_Simulation/03_ODE_Basics.html"}, {"id": "Numerical_Simulation/04_ODE_Numerical_Methods", "title": "ODE 수치해법", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "상미분방정식의 수치해법은 해석적 해를 구할 수 없거나 어려운 경우에 근사해를 계산합니다. 오일러 방법부터 4차 룽게-쿠타까지 주요 방법들을 학습합니다. --- --- --- --- --- --- --- RK4로 Van der Pol 진동자를 풀어보세요: x'' - μ(1 - x²)x' + x = 0, μ = 2 --- | 방법 | 차수 | 특징 | |------|------|------| | 전진 오일러 | O(h) | 간단, 제한적 안정성 | | 후진 오일러 | O(h) | 암시적, A-안정 | | RK2 | O(h²) | 중점법, Heun | | RK4 | O(h⁴) | 가장 널리 사용 | | RK4-5 | O(h⁵) | 적응형 스텝 | | SciPy 솔버 | 유형 | 용도 | |-----------|------|------| | RK45 | 명시적 | 일반 문제 (기본) | | DOP853 | 명시적 | 고정밀도 | | Radau | 암시적 | 강성 문제 | | BDF |...", "url": "/study/ko/Numerical_Simulation/04_ODE_Numerical_Methods.html"}, {"id": "Numerical_Simulation/05_ODE_Advanced", "title": "ODE 고급", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "강성(stiff) 문제, 암시적 방법, scipy.integrate의 고급 사용법을 학습합니다. 실제 응용에서 자주 등장하는 어려운 ODE 문제들을 다룹니다. --- --- --- --- --- --- 다음 강성 시스템을 BDF와 Radau로 풀고 비교하세요: dy₁/dt = -1000y₁ + y₂ dy₂/dt = 999y₁ - 2y₂ y₁(0) = 1, y₂(0) = 0 --- | 문제 유형 | 권장 솔버 | 특징 | |----------|----------|------| | 일반 비강성 | RK45, DOP853 | 명시적, 빠름 | | 강성 문제 | Radau, BDF | 암시적, 안정 | | DAE | Radau + massmatrix | 대수 구속조건 | | BVP | solve_bvp, 슈팅 | 경계조건 | | 암시적 방법 | 차수 | A-안정 | |------------|------|--------| | 후진 오일러 | 1 | O | | Crank-Nicolson |...", "url": "/study/ko/Numerical_Simulation/05_ODE_Advanced.html"}, {"id": "Numerical_Simulation/06_ODE_Systems", "title": "연립 ODE와 시스템", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "실제 물리적 시스템은 여러 변수가 상호작용하는 연립 ODE로 기술됩니다. 생태계 모델, 진자 운동, 혼돈 시스템 등 다양한 예제를 통해 연립 ODE의 수치해법을 학습합니다. --- --- --- --- --- Lotka-Volterra 시스템의 평형점 주변에서 선형화하고 고유값을 분석하세요. --- | 시스템 | 특징 | 주요 현상 | |--------|------|----------| | Lotka-Volterra | 2D, 보존계 | 주기 진동 | | 단순 진자 | 2D, 비선형 | 작은 각도: 주기, 큰 각도: 비선형 | | 이중 진자 | 4D, 혼돈 | 초기조건 민감도 | | 로렌츠 | 3D, 혼돈 | 이상한 끌개 | | SIR | 3D, 소산 | 전염병 동역학 | | 뢰슬러 | 3D, 혼돈 | 띠 끌개 | | 분석 도구 | 용도 | |----------|------| | 위상 초상화 | 궤적 시각화 | | 포앙카레 단면 | 주기성/혼돈 구분 | | 리아푸노프 지수 | 혼돈...", "url": "/study/ko/Numerical_Simulation/06_ODE_Systems.html"}, {"id": "Numerical_Simulation/07_PDE_Overview", "title": "07. 편미분방정식 개요 (Partial Differential Equations Overview)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 편미분방정식(PDE)의 기본 개념과 분류 이해 - 포물선형, 쌍곡선형, 타원형 PDE의 특성 파악 - 경계조건과 초기조건의 역할 이해 - 적정조건 문제(Well-posed problem)의 개념 학습 --- 편미분방정식(Partial Differential Equation, PDE)은 여러 독립변수에 대한 편미분을 포함하는 방정식입니다. 여기서 A, B, C, D, E, F, G는 x, y의 함수일 수 있습니다. | 특성 | ODE | PDE | |------|-----|-----| | 독립변수 | 1개 (보통 t) | 2개 이상 (보통 x, y, z, t) | | 미분 종류 | 상미분 | 편미분 | | 해의 형태 | 함수 y(t) | 함수 u(x, y, ...) | | 경계조건 | 초기조건 | 경계조건 + 초기조건 | | 해법 난이도 | 상대적 쉬움 | 복잡함 | --- 2차 선형 PDE의 일반형: 판별식 Δ = B² - 4AC에 따라 분류: | 분류 | 조건 | 대표 방정식...", "url": "/study/ko/Numerical_Simulation/07_PDE_Overview.html"}, {"id": "Numerical_Simulation/08_Finite_Difference_Basics", "title": "08. 유한차분법 기초 (Finite Difference Method Basics)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 유한차분법의 기본 원리 이해 - 격자/메쉬 생성 방법 학습 - 전방/후방/중심 차분의 유도와 정확도 분석 - 절단오차(Truncation Error) 개념 이해 - CFL 조건과 von Neumann 안정성 분석 --- 유한차분법(Finite Difference Method, FDM)은 미분을 유한한 차분으로 근사하는 방법입니다. | 장점 | 단점 | |------|------| | 구현이 간단함 | 복잡한 기하형상에 부적합 | | 직관적 이해 가능 | 불규칙 격자 처리 어려움 | | 계산 효율적 | 국소 해상도 조절 제한 | | 고차 정확도 가능 | 경계조건 처리 복잡할 수 있음 | --- --- 테일러 급수를 사용하여 차분 공식을 유도합니다. | 이름 | 공식 | 정확도 | 스텐실 | |------|------|--------|--------| | 전방차분 | (u{i+1} - ui) / Δx | O(Δx) | [i, i+1] | | 후방차분 | (ui - u{i-1}) /...", "url": "/study/ko/Numerical_Simulation/08_Finite_Difference_Basics.html"}, {"id": "Numerical_Simulation/09_Heat_Equation", "title": "09. 열방정식 (Heat Equation)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 1D/2D 열방정식의 물리적 의미 이해 - FTCS (Forward Time Central Space) 양해법 구현 - BTCS (Backward Time Central Space) 음해법 구현 - Crank-Nicolson 방법 이해 및 구현 - 다양한 경계조건 처리 방법 학습 --- 열방정식은 열전도 현상을 기술하는 포물선형 PDE입니다. 경계조건 u(0,t) = u(L,t) = 0, 초기조건 u(x,0) = f(x)인 경우: --- FTCS = Forward Time, Central Space --- BTCS = Backward Time, Central Space --- Crank-Nicolson = FTCS와 BTCS의 평균 (2차 정확도) --- 대규모 2D 문제에서는 ADI (Alternating Direction Implicit) 방법이 효율적입니다. --- --- | 스킴 | 정확도 | 안정성 | 계산 비용 | 특징 |...", "url": "/study/ko/Numerical_Simulation/09_Heat_Equation.html"}, {"id": "Numerical_Simulation/10_Wave_Equation", "title": "10. 파동방정식 (Wave Equation)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 1D/2D 파동방정식의 물리적 의미 이해 - CTCS (Central Time Central Space) 방법 구현 - 다양한 경계조건 (고정, 자유, 흡수) 처리 - 파동 전파 애니메이션 시각화 --- 파동방정식은 파동 현상을 기술하는 쌍곡선형 PDE입니다. | 분야 | 물리량 u | 전파속도 c | |------|----------|-----------| | 현의 진동 | 변위 | √(T/ρ) (T: 장력, ρ: 선밀도) | | 음파 | 압력 | √(γP/ρ) (공기 중 ~340 m/s) | | 전자기파 | 전기장/자기장 | 광속 (~3×10⁸ m/s) | | 지진파 | 지반 변위 | 수 km/s | 무한 영역에서의 해석해: --- CTCS는 시간과 공간 모두에 중심차분을 사용합니다. --- --- 고정 경계조건에서의 고유모드: --- --- --- --- --- | 개념 | 설명 | |------|------| | 파동방정식 | ∂²u/∂t² = c²·∇²u, 쌍곡선형...", "url": "/study/ko/Numerical_Simulation/10_Wave_Equation.html"}, {"id": "Numerical_Simulation/11_Laplace_Poisson", "title": "11. 라플라스와 포아송 방정식 (Laplace and Poisson Equations)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 타원형 PDE의 특성 이해 - 5점 스텐실 유한차분법 구현 - 반복법 (Jacobi, Gauss-Seidel, SOR) 학습 - 수렴 분석 및 최적화 - scipy.sparse를 이용한 효율적 구현 --- | 분야 | 방정식 | u의 의미 | |------|--------|----------| | 정상 열전도 | ∇²T = 0 | 온도 | | 정전기학 | ∇²φ = -ρ/ε | 전위 | | 유체 역학 | ∇²ψ = -ω | 유동함수 | | 중력장 | ∇²φ = 4πGρ | 중력 퍼텐셜 | | 막의 변형 | ∇²w = p/T | 변위 | 라플라스 방정식의 해는 영역 내부에서 극값을 가지지 않습니다. (최대/최소는 경계에서만 발생) --- 2D 라플라시안의 중심차분: 포아송 방정식 ∇²u = f를 이산화하면 선형 시스템 Au = b를 얻습니다. --- --- 대규모 시스템에서 직접 풀이보다 반복법이 효율적일 수 있습니다. 각 점의 새 값을 이웃들의 이전 값으로 계산: 새로 계산된...", "url": "/study/ko/Numerical_Simulation/11_Laplace_Poisson.html"}, {"id": "Numerical_Simulation/12_Advection_Equation", "title": "12. 이류방정식 (Advection Equation)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 1차 쌍곡선형 PDE인 이류방정식 이해 - 풍상법 (Upwind Scheme) 구현 - FTCS의 불안정성 분석 - Lax-Friedrichs, Lax-Wendroff 방법 학습 - 수치 분산과 수치 확산 이해 - Courant 수의 중요성 파악 --- 이류방정식의 해는 초기 프로파일이 속도 c로 이동하는 것입니다: 이류방정식의 특성선은 직선 x - ct = const 입니다. --- von Neumann 분석: --- 정보가 흐르는 방향(풍상)에서 공간 미분을 근사: 풍상법은 안정하지만 수치 확산(numerical diffusion)을 도입합니다. --- FTCS를 수정하여 안정화: --- 2차 정확도를 위해 테일러 전개 사용: --- --- --- --- | 스킴 | 정확도 | 안정성 | 특성 | |------|--------|--------|------| | FTCS | O(Δt, Δx²) | 무조건 불안정 | 사용 금지 | | Upwind | O(Δt, Δx) | C ≤...", "url": "/study/ko/Numerical_Simulation/12_Advection_Equation.html"}, {"id": "Numerical_Simulation/13_CFD_Basics", "title": "13. CFD 기초 (Computational Fluid Dynamics Basics)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 유체역학의 기본 원리와 지배방정식 이해 - 레이놀즈 수와 유동 특성 관계 파악 - Navier-Stokes 방정식의 유도와 의미 이해 - 압축성/비압축성 유동 구분 - 경계층 개념 학습 - 간단한 채널 유동 CFD 구현 --- --- --- --- --- --- --- 직경 5cm 관에서 물(20°C)이 평균 속도 2m/s로 흐를 때 레이놀즈 수를 계산하고 유동 상태를 판별하시오. Poiseuille 유동에서 평균 속도와 최대 속도의 관계를 유도하시오. 공기(20°C)가 5m/s로 평판 위를 흐를 때, 선단에서 10cm 떨어진 위치의 층류 경계층 두께를 계산하시오. 채널 유동 CFD 코드를 수정하여 격자 수를 변화시키면서 격자 수렴 테스트를 수행하시오. --- - Versteeg & Malalasekera, \"An Introduction to Computational Fluid Dynamics\" - Anderson, \"Computational Fluid Dynamics: The...", "url": "/study/ko/Numerical_Simulation/13_CFD_Basics.html"}, {"id": "Numerical_Simulation/14_Incompressible_Flow", "title": "14. 비압축성 유동 (Incompressible Flow)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 유동함수-와도 정식화 이해 - Lid-Driven Cavity 문제 구현 - 압력-속도 결합 문제 이해 - SIMPLE 알고리즘 기초 학습 - 엇갈린 격자 (Staggered Grid) 개념 파악 --- --- --- --- --- --- --- 유동함수 ψ = xy에 해당하는 속도장과 와도를 구하고, 이것이 비압축성 조건을 만족하는지 확인하시오. Re = 400에서 Lid-Driven Cavity 시뮬레이션을 수행하고, Re = 100 결과와 비교하시오. 코너 와류의 발달을 관찰하시오. SIMPLE 알고리즘에서 under-relaxation 계수 αp를 0.1, 0.3, 0.5로 변화시키며 수렴 속도를 비교하시오. Lid-Driven Cavity 문제에서 격자 크기를 16x16, 32x32, 64x64로 변화시키며 수치해의 수렴을 분석하시오. --- - Ghia et al. (1982) \"High-Re Solutions for Incompressible Flow Using...", "url": "/study/ko/Numerical_Simulation/14_Incompressible_Flow.html"}, {"id": "Numerical_Simulation/15_Electromagnetics_Numerical", "title": "15. 전자기학 수치해석 (Computational Electromagnetics)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- Maxwell 방정식의 물리적 의미 복습 - 전자기장의 수치적 이산화 이해 - FDTD (Finite-Difference Time-Domain) 방법 소개 - Yee 격자 구조 파악 - 전자기파의 Courant 조건 학습 --- --- --- --- --- --- --- Faraday 법칙과 Ampère 법칙을 결합하여 자기장 B에 대한 파동 방정식을 유도하시오. 1D FDTD 코드에서 매질 경계면(ε₁ → ε₂)에서의 반사와 투과를 시뮬레이션하시오. 반사 계수와 투과 계수를 Fresnel 공식과 비교하시오. 2D 등방성 격자에서 Courant 수 S = 0.5와 S = 1.0의 수치 분산을 비교하시오. 어느 경우가 더 정확한가? 3D Yee 격자에서 Ex 업데이트에 필요한 H 성분들의 위치를 도시하고, 업데이트 방정식을 작성하시오. --- - Yee (1966) \"Numerical Solution of Initial Boundary Value Problems Involving...", "url": "/study/ko/Numerical_Simulation/15_Electromagnetics_Numerical.html"}, {"id": "Numerical_Simulation/16_FDTD_Implementation", "title": "16. FDTD 구현 (FDTD Implementation)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 1D FDTD의 완전한 구현 - 소스 여기 방법 (가우시안 펄스, 정현파) - 흡수 경계조건 (Simple ABC, Mur ABC) - 2D FDTD (TM, TE 모드) - PML (Perfectly Matched Layer) 개념 --- --- --- --- --- --- --- 가우시안 펄스와 Ricker wavelet을 소스로 사용할 때 1D FDTD 결과를 비교하시오. 주파수 응답 특성을 분석하시오. 1차 Mur ABC와 2차 Mur ABC의 반사 계수를 비교하시오. 입사각에 따른 성능을 분석하시오. PML 층 두께(5, 10, 15, 20)와 다항식 차수(2, 3, 4)에 따른 흡수 성능을 비교하시오. TE10 차단 주파수 이하와 이상에서의 도파관 전파를 시뮬레이션하고 차이를 분석하시오. --- - Yee (1966) \"Numerical Solution of Initial Boundary Value Problems...\" - Mur (1981) \"Absorbing...", "url": "/study/ko/Numerical_Simulation/16_FDTD_Implementation.html"}, {"id": "Numerical_Simulation/17_MHD_Basics", "title": "17. MHD 기초 이론 (Magnetohydrodynamics Basics)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 자기유체역학(MHD)의 기본 개념 이해 - MHD 가정과 적용 범위 파악 - 이상 MHD 방정식 유도 - Alfven 속도와 MHD 파동 이해 - 자기압과 자기장력 개념 학습 --- --- --- --- --- --- --- --- 태양 코로나에서 B = 10 G, n = 10^8 cm^-3 일 때 Alfven 속도를 계산하시오. 이것을 음속(T = 10^6 K)과 비교하고 플라즈마 베타를 구하시오. vA = 2cs 인 경우, 자기장에 수직한 방향(θ = 90°)으로 전파하는 빠른 자기음파의 위상 속도를 구하시오. 균일한 자기장 Bz 영역과 무자기장 영역 사이의 경계에서 압력 평형 조건을 구하시오. 길이 L = 1 Mm, 전도도 σ = 10^6 S/m인 플라즈마에서 자기 확산 시간을 계산하시오. 속도 v = 100 km/s일 때 자기 Reynolds 수는? --- - Goedbloed & Poedts, \"Principles of Magnetohydrodynamics\" -...", "url": "/study/ko/Numerical_Simulation/17_MHD_Basics.html"}, {"id": "Numerical_Simulation/18_MHD_Numerical_Methods", "title": "18. MHD 수치해법 (MHD Numerical Methods)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- MHD 방정식의 보존 형태 이해 - 유한 체적법 기초 학습 - Godunov 유형 스킴 이해 - MHD Riemann 문제 파악 - 간단한 MHD 충격파 관 문제 구현 - div B = 0 제약조건 처리 방법 --- --- --- --- --- --- --- --- ρ = 1, p = 0.5, Bx = 1, By = 0.5, Bz = 0 일 때 빠른/느린/Alfven 파동 속도를 계산하시오. (γ = 5/3) 1D 선형 이류방정식에 Lax-Friedrichs 스킴을 적용하고, 수치 확산 계수를 유도하시오. Brio-Wu 문제를 HLL과 Lax-Friedrichs 플럭스로 각각 풀고 결과를 비교하시오. 2D MHD 시뮬레이션에서 div B 오류를 모니터링하는 코드를 작성하시오. --- - Brio & Wu (1988) \"An Upwind Differencing Scheme for the Equations of Ideal Magnetohydrodynamics\" - Dedner et...", "url": "/study/ko/Numerical_Simulation/18_MHD_Numerical_Methods.html"}, {"id": "Numerical_Simulation/19_Plasma_Simulation", "title": "19. 플라즈마 시뮬레이션 (Plasma Simulation)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- Particle-In-Cell (PIC) 방법의 기본 원리 이해 - 입자 푸시 (Boris 알고리즘) 구현 - 장 풀이 (Poisson 방정식) - 입자-격자 보간 - 1D 정전기 PIC 시뮬레이션 구현 - Two-stream 불안정성 시뮬레이션 --- --- --- --- --- --- --- --- 균일 전기장 E = E₀x 와 자기장 B = B₀z 에서의 입자 운동을 시뮬레이션하시오. E×B 드리프트를 확인하시오. 같은 입자 분포에 대해 CIC와 NGP 전하 할당을 비교하시오. 어느 것이 더 매끄러운 전하 밀도를 주는가? 단일 종 플라즈마의 PIC 시뮬레이션에서 Maxwell 분포가 유지되는지 확인하시오. 수치적 가열이 발생하는가? Two-stream 시뮬레이션에서 드리프트 속도 v₀를 변화시키며 성장률 γ를 측정하시오. 이론값과 비교하시오. --- - Birdsall & Langdon, \"Plasma Physics via Computer Simulation\" (표준...", "url": "/study/ko/Numerical_Simulation/19_Plasma_Simulation.html"}, {"id": "Numerical_Simulation/20_Monte_Carlo_Simulation", "title": "몬테카를로 시뮬레이션", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "몬테카를로(Monte Carlo) 방법은 난수를 이용하여 수치적 결과를 얻는 확률적 알고리즘입니다. 복잡한 적분, 최적화, 물리 시스템 시뮬레이션 등 다양한 분야에서 활용됩니다. --- --- --- --- --- --- --- --- 몬테카를로로 d차원 단위 구의 부피를 추정하세요. (d=3일 때 4π/3 ≈ 4.19) 경로 의존 옵션(아시안 콜 옵션)의 가격을 시뮬레이션하세요. --- | 기법 | 설명 | 용도 | |------|------|------| | 기본 MC | 균등 샘플링으로 적분 | 일반 적분 | | 중요도 샘플링 | 제안 분포 사용 | 희귀 사건, 분산 감소 | | 대조 변량 | U와 1-U 사용 | 단조 함수 | | 층화 샘플링 | 영역 분할 | 균등 커버리지 | | 제어 변량 | 상관된 변수 활용 | 기대값 아는 변수 존재 | | 응용 | 예시 | |------|------| | 물리학 | Ising 모델, 분자 동역학 | | 금융 | 옵션 가격, VaR |...", "url": "/study/ko/Numerical_Simulation/20_Monte_Carlo_Simulation.html"}, {"id": "Numerical_Simulation/21_Spectral_Methods", "title": "스펙트럼 방법(Spectral Methods)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 스펙트럼 방법의 수학적 기초 이해하기 - 푸리에 스펙트럼 방법과 FFT 기반 미분 마스터하기 - 체비셰프 콜로케이션(Chebyshev collocation)과 의사-스펙트럼(pseudospectral) 기법 학습하기 - 에일리어싱 오류를 방지하기 위한 디에일리어싱(dealiasing) 전략(3/2 규칙) 적용하기 - PDE를 위한 스펙트럼 솔버 구현하기(버거스 방정식, KdV 방정식) 1. 스펙트럼 방법 소개 2. 푸리에 스펙트럼 방법 3. 이산 푸리에 변환과 FFT 4. 스펙트럼 미분 5. 체비셰프 다항식 6. 의사-스펙트럼 방법 7. 디에일리어싱 8. 응용: 스펙트럼 방법으로 PDE 풀기 9. 연습 문제 --- 스펙트럼 방법은 전역 기저 함수(예: 푸리에 급수, 체비셰프 다항식)를 사용하여 미분 방정식의 해를 근사합니다. 국소 근사를 사용하는 유한 차분이나 유한 요소 방법과 달리, 스펙트럼 방법은 매끄러운 문제에 대해 지수 수렴(exponential convergence)을...", "url": "/study/ko/Numerical_Simulation/21_Spectral_Methods.html"}, {"id": "Numerical_Simulation/22_Finite_Element_Method", "title": "유한 요소 방법(Finite Element Method, FEM)", "topic": "Numerical_Simulation", "topic_display": "Numerical Simulation", "body": "- 약형식(weak formulation)과 변분 원리 이해하기 - 유한 요소 공간과 기저 함수 마스터하기 - 요소 강성 행렬 구성 및 조립 수행하기 - 푸아송 방정식을 위한 1D FEM 구현하기 - 디리클레 및 노이만 경계 조건 다루기 - 오차 분석 및 수렴률 이해하기 - 2D FEM 확장에 대한 통찰 얻기 1. FEM 소개 2. 약형식과 변분 정식화 3. 유한 요소 공간 4. 요소 강성 행렬과 조립 5. 1D FEM 구현 6. 경계 조건 7. 2D FEM 개요 8. 오차 분석과 수렴 9. 연습 문제 --- 유한 요소 방법(FEM)은 편미분 방정식(PDE)을 풀기 위한 강력한 수치 기법입니다. 도함수를 직접 근사하는 유한 차분 방법과 달리, FEM은: 1. PDE를 약형식(weak, variational form)으로 변환 2. 영역을 요소(elements)(삼각형, 사면체 등)로 이산화 3. 구간별 다항식 기저 함수를 사용하여 해 근사 4. 문제를 선형 시스템 풀기로 축소...", "url": "/study/ko/Numerical_Simulation/22_Finite_Element_Method.html"}, {"id": "OS_Theory/00_Overview", "title": "운영체제 이론 학습 가이드", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "이 폴더는 운영체제(Operating System) 이론을 체계적으로 학습하기 위한 자료를 담고 있습니다. 프로세스 관리부터 메모리 관리, 파일 시스템까지 운영체제의 핵심 개념을 단계별로 학습할 수 있습니다. 대상 독자: C/C++ 프로그래밍 경험이 있는 개발자, CS 기초를 학습하려는 사람 --- --- - C/C++ 프로그래밍: 포인터, 메모리 관리, 멀티스레드 기초 - 컴퓨터 구조 기초: CPU, 메모리 계층, 인터럽트 - 기본 자료구조: 큐, 스택, 연결 리스트 - 기본 알고리즘: 복잡도 분석 (Big O) --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01OSOverview.md | ⭐ | OS 정의, 역할, 역사, 커널 구조 | | 02ProcessConcepts.md | ⭐⭐ | 프로세스 메모리 구조, PCB, 상태 전이 | | 03ThreadsandMultithreading.md | ⭐⭐ | 스레드 vs...", "url": "/study/ko/OS_Theory/00_Overview.html"}, {"id": "OS_Theory/01_OS_Overview", "title": "운영체제 개요", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "운영체제(Operating System, OS)는 컴퓨터 하드웨어를 관리하고 응용 프로그램에 서비스를 제공하는 시스템 소프트웨어입니다. 이 레슨에서는 운영체제의 정의, 역할, 발전 역사, 그리고 커널 구조에 대해 학습합니다. --- 1. 운영체제란? 2. 운영체제의 역할 3. 운영체제 발전 역사 4. 커널 구조 5. 시스템 콜 6. 인터럽트 처리 7. 연습 문제 --- --- --- --- --- --- --- 다음 빈칸을 채우세요. 1. 운영체제의 두 가지 관점은 ______와 서비스 제공자이다. 2. 멀티프로그래밍의 목적은 ____를 줄여 CPU 이용률을 높이는 것이다. 3. 커널 중 모든 기능이 하나로 통합된 구조를 ____이라 한다. <details> <summary>정답 보기</summary> 1. 자원 관리자 2. CPU 유휴 시간 3. 모놀리식 커널 (Monolithic Kernel) </details> 다음 시스템 콜을 적절한 범주로 분류하세요. | 프로세스 제어 |...", "url": "/study/ko/OS_Theory/01_OS_Overview.html"}, {"id": "OS_Theory/02_Process_Concepts", "title": "프로세스 개념", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "프로세스(Process)는 실행 중인 프로그램을 의미합니다. 이 레슨에서는 프로세스의 메모리 구조, 프로세스 제어 블록(PCB), 프로세스 상태 전이, 그리고 컨텍스트 스위치에 대해 학습합니다. --- 1. 프로세스란? 2. 프로세스 메모리 구조 3. 프로세스 제어 블록 (PCB) 4. 프로세스 상태 전이 5. 컨텍스트 스위치 6. 프로세스 생성과 종료 7. 연습 문제 --- --- --- --- --- --- --- 다음 변수들이 저장되는 메모리 영역을 고르세요. 보기: Text, Data, BSS, Stack, Heap <details> <summary>정답 보기</summary> </details> 다음 상황에서 프로세스 상태 전이를 설명하세요. 1. 프로세스 A가 CPU를 사용 중, 타임 슬라이스 만료 2. 프로세스 B가 파일 읽기 요청 3. 프로세스 C의 파일 읽기 완료 4. 스케줄러가 프로세스 D를 선택 <details> <summary>정답 보기</summary> 1....", "url": "/study/ko/OS_Theory/02_Process_Concepts.html"}, {"id": "OS_Theory/03_Threads_and_Multithreading", "title": "스레드와 멀티스레딩", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "스레드(Thread)는 프로세스 내에서 실행되는 경량 실행 단위입니다. 이 레슨에서는 스레드와 프로세스의 차이, 사용자/커널 스레드, 멀티스레딩 모델, 그리고 pthread API를 학습합니다. --- 1. 스레드란? 2. 스레드 vs 프로세스 3. 스레드 제어 블록 (TCB) 4. 사용자 스레드와 커널 스레드 5. 멀티스레딩 모델 6. pthread API 기초 7. 연습 문제 --- --- --- --- --- --- --- 다음 중 스레드가 공유하지 않는 것을 모두 고르세요. A. 코드 섹션 B. 데이터 섹션 C. 스택 D. 힙 E. 프로그램 카운터 F. 열린 파일 <details> <summary>정답 보기</summary> C, E - 스택: 각 스레드는 자신만의 스택을 가짐 (지역 변수, 함수 호출 정보) - 프로그램 카운터: 각 스레드는 다른 위치의 코드를 실행할 수 있음 나머지는 모두 스레드 간 공유됨. </details> 다음 설명에 맞는 멀티스레딩 모델을...", "url": "/study/ko/OS_Theory/03_Threads_and_Multithreading.html"}, {"id": "OS_Theory/04_CPU_Scheduling_Basics", "title": "CPU 스케줄링 기초", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "CPU 스케줄링은 준비 상태의 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 과정입니다. 이 레슨에서는 CPU burst와 I/O burst, 스케줄링 목표, 선점/비선점 스케줄링, 그리고 다양한 스케줄러의 역할을 학습합니다. --- 1. CPU 스케줄링이란? 2. CPU Burst와 I/O Burst 3. 스케줄링 목표 4. 선점 vs 비선점 스케줄링 5. 스케줄러 종류 6. 디스패처 7. 연습 문제 --- --- --- --- --- --- --- 다음 용어를 정의하세요. 1. CPU Burst 2. 처리량 (Throughput) 3. 총 처리 시간 (Turnaround Time) 4. 선점 스케줄링 <details> <summary>정답 보기</summary> 1. CPU Burst: 프로세스가 CPU를 연속적으로 사용하는 시간. I/O 요청 없이 계산만 수행하는 구간. 2. 처리량 (Throughput): 단위 시간당 완료되는 프로세스의 수. 시스템 효율성의...", "url": "/study/ko/OS_Theory/04_CPU_Scheduling_Basics.html"}, {"id": "OS_Theory/05_Scheduling_Algorithms", "title": "스케줄링 알고리즘", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "이 레슨에서는 다양한 CPU 스케줄링 알고리즘을 학습합니다. FCFS, SJF, SRTF, Priority, Round Robin 알고리즘의 동작 원리를 이해하고, 간트 차트를 통해 평균 대기 시간과 총 처리 시간을 계산합니다. --- 1. FCFS (First-Come, First-Served) 2. SJF (Shortest Job First) 3. SRTF (Shortest Remaining Time First) 4. Priority Scheduling 5. Round Robin 6. 알고리즘 비교 7. 연습 문제 --- --- --- --- --- --- --- 다음 프로세스에 대해 FCFS 스케줄링을 적용하고 평균 대기 시간을 계산하세요. | 프로세스 | 도착 시간 | 실행 시간 | |---------|----------|----------| | P1 | 0 | 5 | | P2 | 1 | 3 | | P3 | 2 | 8 | | P4 | 3 | 6 | <details>...", "url": "/study/ko/OS_Theory/05_Scheduling_Algorithms.html"}, {"id": "OS_Theory/06_Advanced_Scheduling", "title": "고급 스케줄링", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "이 레슨에서는 실제 운영체제에서 사용되는 고급 스케줄링 기법을 학습합니다. MLFQ(Multi-Level Feedback Queue), 멀티프로세서 스케줄링, 그리고 실시간 스케줄링에 대해 알아봅니다. --- 1. MLFQ (Multi-Level Feedback Queue) 2. 멀티프로세서 스케줄링 3. 프로세서 친화성 4. 실시간 스케줄링 5. Linux CFS 6. 연습 문제 --- --- --- c │ │ #define GNUSOURCE │ │ #include <sched.h> │ │ │ │ cpusett mask; │ │ CPUZERO(&mask); │ │ CPUSET(0, &mask); // CPU 0에만 실행 │ │ CPUSET(2, &mask); // CPU 2에도 실행 가능 │ │ │ │ // 현재 프로세스의 친화성 설정 │ │ schedsetaffinity(0, sizeof(mask), &mask); │ │ bash │ │ # CPU 0,1에서만 실행 │ │...", "url": "/study/ko/OS_Theory/06_Advanced_Scheduling.html"}, {"id": "OS_Theory/07_Synchronization_Basics", "title": "동기화 기초", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "동시에 실행되는 프로세스나 스레드가 공유 자원에 접근할 때 문제가 발생할 수 있습니다. 이 레슨에서는 경쟁 상태(Race Condition), 임계 구역(Critical Section), 그리고 Peterson's Solution과 하드웨어 지원 동기화 방법을 학습합니다. --- 1. 경쟁 상태 (Race Condition) 2. 임계 구역 문제 3. 임계 구역 해결 조건 4. Peterson's Solution 5. 하드웨어 지원 6. 연습 문제 --- --- --- --- --- │ │ bool testandset(bool target) { │ │ bool rv = target; // 현재 값 읽기 │ │ target = true; // true로 설정 │ │ return rv; // 이전 값 반환 │ │ } │ │ // 이 전체가 원자적으로 실행됨 (인터럽트 불가) │ │ │ │ bool compareandswap(int word, int expected, int...", "url": "/study/ko/OS_Theory/07_Synchronization_Basics.html"}, {"id": "OS_Theory/08_Synchronization_Tools", "title": "동기화 도구", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "운영체제와 프로그래밍 언어는 동기화를 위한 다양한 도구를 제공합니다. 이 레슨에서는 뮤텍스, 세마포어, 모니터, 조건 변수를 학습하고, 고전적인 동기화 문제들을 해결합니다. --- 1. 뮤텍스 (Mutex) 2. 세마포어 (Semaphore) 3. 모니터 (Monitor) 4. 조건 변수 (Condition Variable) 5. 고전 동기화 문제 6. 연습 문제 --- --- --- --- --- --- 초기값이 5인 세마포어에 대해 P, P, V, P, P, P 연산을 순서대로 수행하면 최종 세마포어 값은? <details> <summary>정답 보기</summary> 연산 순서와 값 변화: - 초기값: 5 - P: 5 - 1 = 4 - P: 4 - 1 = 3 - V: 3 + 1 = 4 - P: 4 - 1 = 3 - P: 3 - 1 = 2 - P: 2 - 1 = 1 최종 값: 1 </details> 생산자-소비자 문제에서 empty와 full 세마포어의 역할을 설명하고, 순서가...", "url": "/study/ko/OS_Theory/08_Synchronization_Tools.html"}, {"id": "OS_Theory/09_Deadlock", "title": "데드락", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "데드락(Deadlock)은 두 개 이상의 프로세스가 서로 상대방이 가진 자원을 기다리며 무한히 대기하는 상태입니다. 이 레슨에서는 데드락의 네 가지 필요조건, 자원 할당 그래프, 그리고 예방, 회피, 탐지, 복구 방법을 학습합니다. --- 1. 데드락이란? 2. 데드락 필요조건 3. 자원 할당 그래프 4. 데드락 예방 5. 데드락 회피 6. 데드락 탐지와 복구 7. 연습 문제 --- --- --- --- --- --- --- 다음 중 데드락의 네 가지 필요조건에 해당하지 않는 것은? A. 상호 배제 B. 순환 대기 C. 우선순위 역전 D. 비선점 E. 점유와 대기 <details> <summary>정답 보기</summary> 정답: C. 우선순위 역전 데드락의 네 가지 필요조건: 1. 상호 배제 (Mutual Exclusion) 2. 점유와 대기 (Hold and Wait) 3. 비선점 (No Preemption) 4. 순환 대기 (Circular Wait) 우선순위 역전은...", "url": "/study/ko/OS_Theory/09_Deadlock.html"}, {"id": "OS_Theory/10_Memory_Management_Basics", "title": "메모리 관리 기초 ⭐⭐", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "운영체제의 메모리 관리는 프로그램 실행에 필요한 메모리를 효율적으로 할당하고 관리하는 핵심 기능입니다. 이 장에서는 주소 바인딩, 논리/물리 주소 변환, 그리고 동적 로딩과 스와핑에 대해 학습합니다. --- 1. 메모리 관리의 필요성 2. 주소 바인딩 3. 논리 주소와 물리 주소 4. MMU (Memory Management Unit) 5. 동적 로딩 6. 동적 링킹 7. 스와핑 8. 연습 문제 --- | 목표 | 설명 | |------|------| | 보호 | 프로세스 간 메모리 영역 보호 | | 재배치 | 프로세스를 메모리 어디든 배치 가능 | | 공유 | 여러 프로세스가 공통 코드 공유 | | 효율성 | 메모리 낭비 최소화 | | 논리적 구성 | 모듈 단위로 프로그램 구성 | --- 주소 바인딩은 프로그램의 명령어와 데이터를 메모리 주소에 연결하는 과정입니다. 프로세스가 메모리의 어느 위치에 적재될지 컴파일 시점에 알 수 있는 경우: 특징: - 절대 코드(Absolute...", "url": "/study/ko/OS_Theory/10_Memory_Management_Basics.html"}, {"id": "OS_Theory/11_Contiguous_Memory_Allocation", "title": "연속 메모리 할당 ⭐⭐", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "연속 메모리 할당은 각 프로세스가 메모리에서 연속된 하나의 영역을 차지하는 메모리 관리 기법입니다. 고정 분할과 가변 분할 방식, 그리고 효율적인 메모리 배치 전략에 대해 학습합니다. --- 1. 메모리 분할 개요 2. 고정 분할 (Fixed Partitioning) 3. 가변 분할 (Variable Partitioning) 4. 메모리 배치 전략 5. 단편화 (Fragmentation) 6. 압축 (Compaction) 7. 연습 문제 --- --- 메모리를 고정된 크기의 파티션으로 미리 나누어 놓는 방식입니다. --- 프로세스 크기에 맞게 파티션을 동적으로 생성하는 방식입니다. --- 새 프로세스를 메모리의 어떤 홀에 배치할지 결정하는 전략입니다. --- 통계적으로, N개의 할당 블록이 있을 때 약 0.5N개의 홀이 생성됩니다. 즉, 메모리의 1/3이 단편화로 손실될 수 있습니다. --- 외부 단편화를 해결하기 위해 모든 프로세스를 한쪽으로 밀어 큰 연속 공간을 만드는...", "url": "/study/ko/OS_Theory/11_Contiguous_Memory_Allocation.html"}, {"id": "OS_Theory/12_Paging", "title": "페이징 ⭐⭐⭐", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "페이징(Paging)은 물리 메모리를 고정 크기 블록(프레임)으로 나누고, 프로세스의 논리 주소 공간도 같은 크기의 블록(페이지)으로 나누어 비연속적으로 할당하는 메모리 관리 기법입니다. 외부 단편화를 완전히 제거할 수 있습니다. --- 1. 페이징의 기본 개념 2. 주소 변환 3. 페이지 테이블 4. TLB (Translation Lookaside Buffer) 5. 다단계 페이지 테이블 6. 해시 페이지 테이블 7. 역 페이지 테이블 8. 연습 문제 --- | 용어 | 설명 | |------|------| | 페이지 (Page) | 논리 주소 공간의 고정 크기 블록 | | 프레임 (Frame) | 물리 메모리의 고정 크기 블록 | | 페이지 테이블 | 페이지 → 프레임 매핑 정보 | | 페이지 번호 (p) | 논리 주소에서 페이지 식별 | | 오프셋 (d) | 페이지/프레임 내 위치 | --- --- --- --- 32비트 주소 공간, 4KB 페이지 크기의 경우: - 페이지 수...", "url": "/study/ko/OS_Theory/12_Paging.html"}, {"id": "OS_Theory/13_Segmentation", "title": "세그멘테이션 ⭐⭐⭐", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "세그멘테이션(Segmentation)은 프로그램을 논리적 단위인 세그먼트로 나누어 관리하는 메모리 기법입니다. 코드, 데이터, 스택 등 의미 있는 단위로 분리하여 보호와 공유가 용이합니다. --- 1. 세그먼트의 개념 2. 세그먼트 테이블 3. 주소 변환 4. 보호와 공유 5. 페이징과 세그멘테이션 비교 6. 세그멘테이션 + 페이징 결합 7. Intel x86 세그멘테이션 8. 연습 문제 --- --- --- --- --- --- --- --- 다음 세그먼트 테이블로 논리 주소 <1, 500>을 물리 주소로 변환하시오. | 세그먼트 | Base | Limit | |---------|------|-------| | 0 | 1000 | 600 | | 1 | 2000 | 400 | | 2 | 3000 | 800 | <details> <summary>정답 보기</summary> </details> 다음 시나리오에서 보호 위반이 발생하는지 판단하시오. 세그먼트 테이블: | 세그먼트 |...", "url": "/study/ko/OS_Theory/13_Segmentation.html"}, {"id": "OS_Theory/14_Virtual_Memory", "title": "가상 메모리 ⭐⭐⭐", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "가상 메모리(Virtual Memory)는 물리 메모리보다 큰 프로그램을 실행할 수 있게 하는 메모리 관리 기법입니다. 요구 페이징, 페이지 폴트 처리, Copy-on-Write 등 핵심 개념을 학습합니다. --- 1. 가상 메모리의 개념 2. 요구 페이징 3. 페이지 폴트 4. Copy-on-Write 5. 메모리 매핑 파일 6. 성능 분석 7. 연습 문제 --- --- --- --- --- --- --- 프로세스가 다음 순서로 페이지에 접근합니다. 메모리에는 3개의 프레임만 있고, 초기에 모두 비어있을 때 페이지 폴트 횟수를 구하시오. 접근 순서: 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5 <details> <summary>정답 보기</summary> </details> 메모리 접근 시간이 50ns이고 페이지 폴트 처리 시간이 10ms일 때, 성능 저하를 5% 이내로 유지하려면 페이지 폴트 확률이 얼마 이하여야 하는가? <details> <summary>정답...", "url": "/study/ko/OS_Theory/14_Virtual_Memory.html"}, {"id": "OS_Theory/15_Page_Replacement", "title": "페이지 교체 ⭐⭐⭐⭐", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "물리 메모리가 부족할 때 어떤 페이지를 내보낼지 결정하는 것이 페이지 교체 알고리즘입니다. FIFO, Optimal, LRU 등 주요 알고리즘과 Belady's Anomaly, 스래싱 현상을 학습합니다. --- 1. 페이지 교체의 필요성 2. FIFO 알고리즘 3. Optimal 알고리즘 4. LRU 알고리즘 5. LRU 근사 알고리즘 6. Belady's Anomaly 7. 스래싱과 Working Set 8. 연습 문제 --- --- --- --- --- --- --- --- 참조 문자열 1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5에 대해 3개의 프레임으로 FIFO, LRU, Optimal 각각의 페이지 폴트 수를 구하시오. <details> <summary>정답 보기</summary> </details> 4개의 프레임이 있고 상태가 다음과 같을 때, 새 페이지 E를 삽입하면 어떤 페이지가 교체되는가? <details> <summary>정답...", "url": "/study/ko/OS_Theory/15_Page_Replacement.html"}, {"id": "OS_Theory/16_File_System_Basics", "title": "파일 시스템 기초 ⭐⭐⭐", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "파일 시스템은 운영체제가 데이터를 디스크에 저장하고 관리하는 방법을 정의합니다. 파일의 개념, 속성, 연산, 디렉토리 구조, 접근 방법 등 핵심 개념을 학습합니다. --- 1. 파일의 개념 2. 파일 속성 3. 파일 연산과 시스템 콜 4. 디렉토리 구조 5. 파일 접근 방법 6. 파일 시스템 마운트 7. 연습 문제 --- --- --- --- --- --- --- 출력이 다음과 같을 때 각 필드를 해석하시오. <details> <summary>정답 보기</summary> </details> 파일 에 \"Hello World\"를 추가(append)하는 시스템 콜 시퀀스를 작성하시오. <details> <summary>정답 보기</summary> </details> 다음 시나리오에서 각 링크 유형의 동작을 설명하시오. <details> <summary>정답 보기</summary> </details> 경로를 정규화하시오. <details> <summary>정답 보기</summary>...", "url": "/study/ko/OS_Theory/16_File_System_Basics.html"}, {"id": "OS_Theory/17_File_System_Implementation", "title": "파일 시스템 구현 ⭐⭐⭐⭐", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "파일 시스템이 디스크에 데이터를 어떻게 저장하고 관리하는지 학습합니다. 블록 할당 방식, inode 구조, 저널링, RAID 등 실제 구현에 필요한 핵심 개념을 다룹니다. --- 1. 파일 시스템 구조 2. 디스크 블록 할당 3. inode 구조 4. 디렉토리 구현 5. 파일 시스템 예시 6. 저널링 7. RAID 8. 연습 문제 --- --- --- --- --- --- --- --- 4KB 블록, 4바이트 포인터를 사용하는 Unix 파일 시스템에서 100MB 파일을 저장하려면 몇 개의 간접 블록이 필요한가? <details> <summary>정답 보기</summary> </details> FAT 테이블이 다음과 같을 때 파일 A(시작: 3)의 클러스터 체인을 나열하시오. | 클러스터 | 값 | |---------|-----| | 0 | FREE | | 1 | 8 | | 2 | FREE | | 3 | 7 | | 4 | EOF | | 5 | 1 | | 6 | FREE | | 7 |...", "url": "/study/ko/OS_Theory/17_File_System_Implementation.html"}, {"id": "OS_Theory/18_IO_and_IPC", "title": "I/O와 IPC ⭐⭐⭐", "topic": "OS_Theory", "topic_display": "OS Theory", "body": "이 장에서는 운영체제의 입출력(I/O) 시스템과 프로세스 간 통신(IPC) 메커니즘을 학습합니다. 하드웨어 제어부터 고수준 통신 방법까지 다룹니다. --- 1. I/O 하드웨어 2. I/O 방식 3. 디바이스 드라이버 4. 버퍼링 전략 5. IPC 개요 6. 파이프 7. 공유 메모리 8. 메시지 큐와 소켓 9. 연습 문제 --- --- --- --- --- --- --- --- --- 폴링, 인터럽트, DMA의 적합한 사용 사례를 각각 제시하시오. <details> <summary>정답 보기</summary> </details> 다음 쉘 명령의 내부 동작을 파이프 관점에서 설명하시오. <details> <summary>정답 보기</summary> </details> 프로듀서-컨슈머 문제를 구현할 때 공유 메모리와 메시지 큐의 장단점을 비교하시오. <details> <summary>정답 보기</summary> </details> 1MB 파일을 디스크에서 읽을 때 DMA와...", "url": "/study/ko/OS_Theory/18_IO_and_IPC.html"}, {"id": "Plasma_Physics/00_Overview", "title": "플라즈마 물리", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "이 토픽은 물질의 네 번째 상태인 플라즈마의 기초 물리를 단일 입자 역학부터 운동론, 유체 기술까지 다룹니다. 기초 전자기학과 자기유체역학(MHD) 등 고급 주제 사이의 간극을 메우며, 핵융합, 우주, 천체물리 플라즈마 연구에 필요한 물리적 기반을 제공합니다. - 벡터 해석 (MathematicalMethods L05) - 편미분방정식 (MathematicalMethods L13) - 기초 전자기학 (Maxwell 방정식, Lorentz 힘) - Python 중급 (NumPy, SciPy, Matplotlib) | 파일명 | 난이도 | 주요 내용 | 비고 | |--------|--------|----------|------| | 01IntroductiontoPlasma.md | ⭐ | Debye 차폐, 플라즈마 주파수, 자이로주파수, 플라즈마 β, 준중성 | 개념적 기초 | | 02CoulombCollisions.md | ⭐⭐ | 쿨롱 산란, 충돌 주파수, Spitzer 저항,...", "url": "/study/ko/Plasma_Physics/00_Overview.html"}, {"id": "Plasma_Physics/01_Introduction_to_Plasma", "title": "1. 플라즈마 소개", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 플라즈마를 물질의 네 번째 상태로 이해하고 자연 및 실험실 예시 식별하기 - Debye 차폐 개념을 유도하고 다양한 플라즈마에 대해 Debye 길이를 계산하기 - 집단적 행동 및 준중성 조건에 대한 플라즈마 기준 설명하기 - 특성 플라즈마 주파수(플라즈마 주파수 및 gyrofrequency)를 제1원리로부터 계산하기 - 플라즈마 베타 매개변수를 계산하고 열압력 대 자기압력의 상대적 중요성 해석하기 - Python 도구를 적용하여 다양한 물리 시스템에 걸친 플라즈마 매개변수 계산 및 비교하기 플라즈마는 고체, 액체, 기체에 이어 물질의 네 번째 상태라고 불립니다. 장거리 전자기 상호작용으로 인해 집단적 행동을 나타내는 자유 전하 입자(전자와 이온)의 집합으로 구성됩니다. 기체에서 플라즈마로의 전이는 이온화를 통해 발생합니다. 이는 중성 원자나 분자가 다음과 같은 이유로 전자를 잃는 과정입니다: - 열에너지(고온) - 전자기 복사(광이온화) - 에너지가 높은 입자와의 충돌 -...", "url": "/study/ko/Plasma_Physics/01_Introduction_to_Plasma.html"}, {"id": "Plasma_Physics/02_Coulomb_Collisions", "title": "2. Coulomb 충돌", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 전하 입자 간의 Coulomb 산란 물리를 이해하고 Rutherford 단면적 유도하기 - 전자-전자, 이온-이온, 전자-이온 상호작용에 대한 충돌 주파수 계산하기 - Coulomb 로그를 유도하고 충돌 속도 결정에서의 역할 이해하기 - Spitzer 저항률을 계산하고 온도 의존성 이해하기 - Knudsen 수를 사용하여 충돌성 및 무충돌성 플라즈마 영역 구별하기 - Python 도구를 적용하여 충돌 역학 및 수송 특성 분석하기 전하 $q1$과 $q2$, 질량 $m1$과 $m2$를 가진 두 전하 입자가 Coulomb 힘을 통해 상호작용하는 경우를 고려합시다. 질량 중심 좌표계에서 이것은 환산 질량을 가진 단일 입자 문제로 축소됩니다: $$\\mu = \\frac{m1 m2}{m1 + m2}$$ 입자는 Coulomb 퍼텐셜에서 움직입니다: $$V(r) = \\frac{1}{4\\pi\\epsilon0} \\frac{q1 q2}{r}$$ 척력 Coulomb 상호작용($q1 q2 > 0$)의...", "url": "/study/ko/Plasma_Physics/02_Coulomb_Collisions.html"}, {"id": "Plasma_Physics/03_Plasma_Description_Hierarchy", "title": "3. 플라스마 기술 계층 구조", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- N-체 모델에서 kinetic 모델, fluid 모델까지의 플라스마 기술 계층 구조 이해 - Klimontovich 방정식 유도와 통계적 기술과의 관계 파악 - moment 방정식에서의 closure 문제와 일반적인 closure 기법 설명 - 물리적 regime에 따라 입자, kinetic, fluid 기술을 언제 사용할지 판단 - 서로 다른 기술 수준의 간단한 수치 비교 구현 - 계층 구조 전반에 걸친 정확도와 계산 효율성 간의 trade-off 이해 플라스마는 여러 수준의 세밀도(detail)로 기술될 수 있으며, 정확도와 계산 가능성(computational tractability) 사이의 trade-off를 만드는 모델 계층 구조를 형성합니다: 각 수준은 그 위의 수준으로부터 coarse-graining 또는 averaging을 통해 얻어지며, 정보를 희생하는 대신 계산 효율성을 얻습니다. | 기술 방법 | 최적 용도 | 예시 |...", "url": "/study/ko/Plasma_Physics/03_Plasma_Description_Hierarchy.html"}, {"id": "Plasma_Physics/04_Single_Particle_Motion_I", "title": "4. 단일 입자 운동 I", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 전자기장에서 하전 입자의 운동 방정식 유도 - 균일한 자기장에서의 cyclotron 운동 분석 및 Larmor 반지름과 gyrofrequency 계산 - E×B drift와 비대칭 gyration으로부터의 물리적 기원 이해 - 빠른 gyration과 느린 drift를 분리하는 guiding center 근사 소개 - 정확한 입자 궤도 적분을 위한 Boris 알고리즘 구현 - Python을 사용하여 다양한 장 구성에서 입자 궤적 시각화 전하 $q$와 질량 $m$을 가진 하전 입자가 속도 $\\mathbf{v}$로 전기장 $\\mathbf{E}$와 자기장 $\\mathbf{B}$에서 움직일 때 Lorentz 힘을 경험합니다: $$\\mathbf{F} = q(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})$$ Newton의 제2법칙은 운동 방정식을 제공합니다: $$m\\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v}...", "url": "/study/ko/Plasma_Physics/04_Single_Particle_Motion_I.html"}, {"id": "Plasma_Physics/05_Single_Particle_Motion_II", "title": "5. 단일 입자 운동 II", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 자기화된 플라즈마에서 임의의 힘에 대한 일반 드리프트 속도 공식 유도 - 불균일한 자기장에서 grad-B 드리프트와 그 물리적 기원 이해 - 곡선 자기장 기하학에서 곡률 드리프트와 그 역할 분석 - 시간 변동 전기장에 의한 편극 드리프트 계산 및 질량 의존성 - 모든 드리프트 유형의 전하 및 질량 의존성 비교 및 대조 - Python을 사용하여 공간적으로 변화하는 자기장에서 입자 궤도 시뮬레이션 Lesson 4에서 우리는 $\\mathbf{E}\\times\\mathbf{B}$ 드리프트를 공부했습니다. 이제 임의의 힘으로 일반화합니다. 추가 힘 $\\mathbf{F}$를 받는 균일한 자기장 $\\mathbf{B}$에서의 입자를 고려합니다. 운동 방정식은: $$ m\\frac{d\\mathbf{v}}{dt} = q(\\mathbf{E} + \\mathbf{v}\\times\\mathbf{B}) + \\mathbf{F} $$ 속도를 다음과 같이 분해합니다: - 자기력선 주위의 자이로운동 -...", "url": "/study/ko/Plasma_Physics/05_Single_Particle_Motion_II.html"}, {"id": "Plasma_Physics/06_Magnetic_Mirrors_Adiabatic_Invariants", "title": "6. 자기 거울과 단열 불변량", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 자기 거울 힘과 입자 구속에서의 역할 이해 - 첫 번째 단열 불변량(자기 모멘트) 유도 및 보존 증명 - 자기 거울 기하학, 손실 원뿔, 포획된 입자 대 통과 입자 분석 - 단열 불변량의 계층과 관련 시간 규모 탐구 - 토카막 궤도(바나나 궤도와 통과 입자) 연구 - Python을 사용하여 자기 거울 구속과 손실 원뿔 동역학 시뮬레이션 자기력선이 수렴하는(자기장 세기가 증가하는) 영역에서, 자이로하는 입자는 더 높은 자기장 영역으로의 운동을 반대하는 힘을 경험합니다. 이것이 자기 거울 힘입니다. 호장 $s$에 따라 $B = B(s)$가 변하는 자기력선을 따라 움직이는 입자를 고려하세요: 입자의 수직 속도 성분은 반경 $rL = mv\\perp/(|q|B)$로 자이로합니다. $B$가 증가하면 $rL$이 감소하지만, 수직 운동 에너지는 Lorentz 힘이 한 일로 인해 변합니다. 자기 모멘트는 다음과 같이 정의됩니다: $$ \\mu = \\frac{mv\\perp^2}{2B} =...", "url": "/study/ko/Plasma_Physics/06_Magnetic_Mirrors_Adiabatic_Invariants.html"}, {"id": "Plasma_Physics/07_Vlasov_Equation", "title": "7. Vlasov 방정식", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 위상 공간과 분포 함수 $f(\\mathbf{x},\\mathbf{v},t)$ 이해하기 - 무충돌 플라즈마에 대한 Liouville 정리로부터 Vlasov 방정식 유도하기 - $f$의 모멘트로부터 거시적 물리량(밀도, 평균 속도, 압력) 계산하기 - 평형 분포 함수(Maxwellian, bi-Maxwellian, kappa) 탐구하기 - Vlasov 방정식으로부터 보존 법칙(입자, 운동량, 에너지, 엔트로피) 분석하기 - Python을 사용하여 Vlasov 방정식의 수치 해 구현하기 단일 입자의 경우, 위상 공간은 위치와 속도의 6차원 공간입니다: $$ (\\mathbf{x}, \\mathbf{v}) = (x, y, z, vx, vy, vz) $$ $N$개 입자의 경우, 전체 위상 공간은 $6N$차원입니다. 하지만 큰 $N$ (플라즈마는 $\\sim 10^{20}$개의 입자를 가집니다!)에 대해, 개별 입자를 추적하는 것은 비실용적입니다. 대신, 우리는 분포 함수를 통한 통계적 기술을...", "url": "/study/ko/Plasma_Physics/07_Vlasov_Equation.html"}, {"id": "Plasma_Physics/08_Landau_Damping", "title": "8. Landau 감쇠", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 선형화된 Vlasov-Poisson을 사용하여 따뜻한 플라즈마에서 정전기 파동에 대한 분산 관계 유도하기 - Landau 윤곽과 $v = \\omega/k$에서 특이점을 처리하는 역할 이해하기 - Landau 감쇠율을 계산하고 플라즈마 매개변수에 대한 의존성 분석하기 - 공명에서 파동-입자 에너지 교환의 물리적 메커니즘 탐구하기 - 역 Landau 감쇠와 bump-on-tail 불안정성 연구하기 - Python을 사용하여 Landau 감쇠와 입자 포획 시뮬레이션하기 1D, 자화되지 않은, 정전기 플라즈마를 고려합니다. 평형은: $$ f = f0(v), \\quad \\mathbf{E} = 0 $$ 여기서 $f0(v)$는 평형 분포입니다 (일반적으로 Maxwellian). 작은 섭동의 경우: $$ f = f0(v) + f1(x, v, t), \\quad E = E1(x, t) $$ $|f1| \\ll f0$, $|E1|$는 작습니다. 선형화된 Vlasov 방정식: $$...", "url": "/study/ko/Plasma_Physics/08_Landau_Damping.html"}, {"id": "Plasma_Physics/09_Collisional_Kinetics", "title": "9. 충돌 동역학", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- Boltzmann 충돌 연산자와 그 물리적 의미 이해 - 플라즈마의 Coulomb 충돌에 대한 Fokker-Planck 방정식 유도 - 효율적인 충돌 계산을 위한 Rosenbluth potential 공식화 습득 - 자화 플라즈마에서 Braginskii 수송 이론과 수송 계수 학습 - 토로이달 confinement 장치에서 neoclassical 수송 regime 이해 - 입자 감속 및 저항성과 같은 실제 문제에 충돌 연산자 적용 이전 강의에서는 플라즈마를 Vlasov 방정식으로 지배되는 무충돌 시스템으로 다루었습니다. 그러나 실제 플라즈마는 중성 기체보다 훨씬 낮은 비율이지만 충돌을 경험합니다. 충돌은 다음 측면에서 중요합니다: - 열화(thermalization) 및 평형으로의 접근 - 전기 저항성 및 에너지 소산 - 자기장을 가로지르는 입자, 운동량, 에너지의 수송 - 토로이달 confinement의 neoclassical 효과 플라즈마 충돌 이론의 과제는...", "url": "/study/ko/Plasma_Physics/09_Collisional_Kinetics.html"}, {"id": "Plasma_Physics/10_Electrostatic_Waves", "title": "10. 정전기 파동", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 정전기 파동 분산 관계에 대한 일반 프레임워크 이해 - 따뜻한 플라즈마에서 Langmuir 파동에 대한 Bohm-Gross 분산 유도 - 이온 음향 파동 및 그 감쇠 조건 분석 - 자화 플라즈마에서 upper hybrid 및 lower hybrid 공명 계산 - Bernstein modes와 파동 가열에서의 역할 학습 - 다양한 플라즈마 매개변수에 대한 정전기 분산 관계를 수치적으로 풀이 이전 강의에서 우리는 자기장 섭동을 포함하는 MHD 및 전자기 파동을 연구했습니다. 이제 우리는 정전기 파동에 초점을 맞춥니다: $$\\mathbf{B}1 = 0, \\quad \\mathbf{E}1 = -\\nabla\\phi1$$ 이러한 파동은 전기장 변동만을 포함하며 스칼라 포텐셜로부터 유도될 수 있습니다. 이들은 전하 분리에서 발생하며 Poisson 방정식에 의해 지배됩니다: $$\\nabla \\cdot \\mathbf{E}1 = \\frac{\\rho1}{\\epsilon0}$$ 정전기 파동은 다음에...", "url": "/study/ko/Plasma_Physics/10_Electrostatic_Waves.html"}, {"id": "Plasma_Physics/11_Electromagnetic_Waves", "title": "11. 플라즈마에서의 전자기파", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 무자화 플라즈마에서 전자기파 전파와 플라즈마 차단을 이해 - 자화 플라즈마를 위한 Stix cold plasma 유전 텐서 마스터 - R-파, L-파, O-모드, X-모드의 분산 관계 유도 - 휘슬러파 분산 및 응용 분석 - CMA (Clemmow-Mullaly-Allis) 다이어그램 구성 및 해석 - Faraday 회전을 적용하여 플라즈마의 자기장 측정 정전파(electric field $\\mathbf{E}$ 섭동만 포함)와 달리, 전자기파 (EM waves)는 전기장과 자기장 성분을 모두 가집니다: $$\\mathbf{E}1 \\neq -\\nabla\\phi, \\quad \\mathbf{B}1 \\neq 0$$ 플라즈마에서 EM 파는 풍부한 물리학을 보여줍니다: - 차단 (Cutoffs): 파동이 전파할 수 없는 주파수 이하 (감쇠) - 공명 (Resonances): 파동 특성이 발산하는 주파수 - 편광 (Polarization): 파동 전기장이 선형, 원형 또는 타원형일 수 있음...", "url": "/study/ko/Plasma_Physics/11_Electromagnetic_Waves.html"}, {"id": "Plasma_Physics/12_Wave_Heating_and_Instabilities", "title": "12. 파동 가열과 불안정성", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 핵융합 플라즈마에서 파동 가열의 물리적 메커니즘 이해 - 속도 공간 불안정성 (빔-플라즈마, bump-on-tail, Weibel) 이론 마스터 - 자화 플라즈마에서 압력 구동 불안정성 (firehose, mirror) 분석 - 레이저-플라즈마 상호작용에서 파라메트릭 불안정성 조건 학습 - 핵융합 및 천체물리학의 실용적 문제에 불안정성 이론 적용 - 다양한 불안정성 메커니즘에 대한 성장률과 안정성 경계 계산 플라즈마에서 파동은 두 가지 중요한 역할을 합니다: 1. 가열 및 전류 구동: 외부 파동이 플라즈마 입자에 에너지를 전달 2. 불안정성: 파동이 자발적으로 성장하여 플라즈마로부터 자유 에너지를 추출 이 레슨은 두 측면을 모두 다루며, 다음에 초점을 맞춥니다: - 파동 가열: RF 파동이 핵융합 플라즈마에 에너지를 침착시키는 방법 - 속도 공간 불안정성: 비Maxwell 분포로부터 발생 - 압력 구동 불안정성: 온도 비등방성으로부터 발생 - 파라메트릭 불안정성: 고출력 레이저...", "url": "/study/ko/Plasma_Physics/12_Wave_Heating_and_Instabilities.html"}, {"id": "Plasma_Physics/13_Two_Fluid_Model", "title": "13. Two-Fluid Model", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- Vlasov 방정식의 속도 공간 모멘트를 취하여 유체 방정식 유도하기 - 닫힘 문제(closure problem)와 다양한 닫힘 근사(등온, 단열, CGL) 이해하기 - 전자 운동량 방정식으로부터 일반화된 Ohm의 법칙 유도하고 각 항의 물리적 의미 분석하기 - Hall 효과와 작은 스케일에서 이온과 자기장의 분리에서의 역할 설명하기 - 입자 표류와 유체 표류의 차이, 특히 반자성 표류 구별하기 - 단일 유체 MHD를 넘어서는 파동 현상을 이해하기 위해 이유체 이론 적용하기 Vlasov 방정식은 입자 종류 $s$에 대한 분포함수 $fs(\\mathbf{r}, \\mathbf{v}, t)$의 진화를 기술합니다: $$\\frac{\\partial fs}{\\partial t} + \\mathbf{v} \\cdot \\nabla fs + \\frac{qs}{ms}(\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\cdot \\frac{\\partial fs}{\\partial...", "url": "/study/ko/Plasma_Physics/13_Two_Fluid_Model.html"}, {"id": "Plasma_Physics/14_From_Kinetic_to_MHD", "title": "14. From Kinetic to MHD", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 6차원 운동 이론에서 3차원 단일 유체 MHD로의 체계적 축소 이해하기 - 이유체 이론에서 종을 결합하여 단일 유체 MHD 방정식 유도하기 - MHD 근사의 유효 조건과 한계 식별하기 - 무충돌 플라즈마에 대한 CGL (Chew-Goldberger-Low) 이중 단열 모델 설명하기 - 중간 축소로서 drift-kinetic과 gyrokinetic 이론 이해하기 - 다양한 플라즈마 모델 비교하고 각각을 언제 적용할지 알기 플라즈마 물리학은 다양한 근사 수준과 계산 비용을 가진 풍부한 모델 계층을 가지고 있습니다: 계층의 각 단계 아래로: - 차원성 또는 변수 수를 감소시킴 - 방정식을 간소화함 - 일부 물리를 손실함 - 계산 효율성을 증가시킴 플라즈마 물리학의 기술은 당면 문제에 적합한 모델을 선택하는 것입니다. | 모델 | 차원 | 포착 | 놓침 | |-------|------------|----------|---------| | Vlasov-Maxwell | 6D...", "url": "/study/ko/Plasma_Physics/14_From_Kinetic_to_MHD.html"}, {"id": "Plasma_Physics/15_Plasma_Diagnostics", "title": "15. 플라즈마 진단", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 밀도, 온도, 플라즈마 전위 측정을 위한 랭뮤어 프로브의 원리 이해 - 비교란 밀도 및 온도 진단을 위한 톰슨 산란(비간섭성 및 간섭성) 설명 - 선적분 및 국소 밀도 측정을 위한 간섭계와 반사계 적용 - 온도, 밀도, 유동 속도, 자기장 측정을 위한 분광학 사용 - 전류, 저장 에너지, 내부 자기장 측정을 위한 자기 진단 이해 - 산업용 응용을 위한 저온 플라즈마 진단 설명 플라즈마는 독특한 측정 도전 과제를 제시합니다: 1. 극한 환경: 높은 온도(10⁶–10⁸ K), 낮은 밀도(10¹⁴–10²¹ m⁻³), 강한 자기장(1–10 T) 2. 교란에 대한 민감성: 프로브를 삽입하면 플라즈마를 냉각시키거나 불순물을 유입하거나 평형을 교란할 수 있습니다 3. 직접 접근 불가: 핵융합 장치에서 플라즈마는 자기장으로 구속되고 진공 용기로 둘러싸여 있습니다 4. 다중 스케일: mm(난류)부터 미터(평형)까지 현상을 측정해야 합니다 5. 시간 변화: 플라즈마는 나노초(파동)부터 초(방전...", "url": "/study/ko/Plasma_Physics/15_Plasma_Diagnostics.html"}, {"id": "Plasma_Physics/16_Projects", "title": "16. 프로젝트", "topic": "Plasma_Physics", "topic_display": "Plasma Physics", "body": "- 다양한 장 기하학을 가진 보리스 알고리즘을 사용하여 완전한 3D 입자 궤도 적분기 구현 - 시각화 도구를 갖춘 냉각 및 온난 플라즈마의 일반 분산 관계 해결기 개발 - 반라그랑주 방법을 사용하여 운동 플라즈마 현상을 연구하는 1D 블라소프-푸아송 해결기 생성 - 단일 입자 궤도, 파동 이론, 운동 이론의 지식 종합 - 수치 결과를 해석적 예측과 대조 검증하고 선형 이론을 넘어선 비선형 물리 탐구 - 연구에 사용되는 계산 플라즈마 물리 방법에 대한 실무 경험 획득 목표: 다양한 전자기장 구성을 처리하고 입자 궤적, 표류, 불변량을 시각화할 수 있는 다목적 3D 입자 궤도 적분기를 구축합니다. 난이도: ⭐⭐⭐ 예상 시간: 10–15시간 개발 기술: - 운동 방정식의 수치 적분 - 보리스 알고리즘(E&M 장에서 입자를 위한 도약 방법) - 3D 시각화 - 해석적 표류 속도와 대조 검증 - 입자 구속 및 손실 메커니즘 이해 전하를 띤 입자의 상대론적 운동 방정식은:...", "url": "/study/ko/Plasma_Physics/16_Projects.html"}, {"id": "PostgreSQL/00_Overview", "title": "PostgreSQL 학습 가이드", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "이 폴더는 PostgreSQL 관계형 데이터베이스를 학습하기 위한 자료를 담고 있습니다. SQL 기초부터 고급 기능, 운영까지 단계별로 학습할 수 있습니다. 대상 독자: SQL 입문자 ~ 중급자, 백엔드 개발자 --- --- - 기본적인 컴퓨터 사용법 - 터미널/명령줄 사용 경험 - (선택) Docker 기초 지식 --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01PostgreSQLBasics.md | ⭐ | 개념, 설치, psql 기본 | | 02DatabaseManagement.md | ⭐ | DB 생성/삭제, 사용자, 권한 | | 03TablesandDataTypes.md | ⭐⭐ | CREATE TABLE, 자료형, 제약조건 | | 04CRUDBasics.md | ⭐ | SELECT, INSERT, UPDATE, DELETE | | 05ConditionsandSorting.md | ⭐⭐ | WHERE, ORDER...", "url": "/study/ko/PostgreSQL/00_Overview.html"}, {"id": "PostgreSQL/01_PostgreSQL_Basics", "title": "PostgreSQL 기초", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "PostgreSQL(포스트그레스큐엘)은 오픈소스 관계형 데이터베이스 관리 시스템(RDBMS)입니다. - 오픈소스: 무료로 사용 가능 - 표준 SQL 준수: ANSI SQL 표준을 잘 따름 - 확장성: JSON, 배열, 사용자 정의 타입 지원 - ACID 준수: 트랜잭션의 안정성 보장 - 동시성 제어: MVCC(Multi-Version Concurrency Control) --- | 특징 | PostgreSQL | MySQL | SQLite | |------|------------|-------|--------| | 라이선스 | PostgreSQL License | GPL | Public Domain | | JSON 지원 | JSONB (고성능) | JSON | JSON (제한적) | | 동시성 | MVCC | InnoDB MVCC | 파일 잠금 | | 확장성 | 매우 높음 | 높음 | 낮음 | | 용도 | 엔터프라이즈, 분석 | 웹 애플리케이션 | 임베디드, 테스트 | --- 가장...", "url": "/study/ko/PostgreSQL/01_PostgreSQL_Basics.html"}, {"id": "PostgreSQL/02_Database_Management", "title": "데이터베이스 관리", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "PostgreSQL에서 데이터베이스는 테이블, 뷰, 함수 등을 담는 최상위 컨테이너입니다. --- | 옵션 | 설명 | |------|------| | | 데이터베이스 소유자 | | | 문자 인코딩 (UTF8 권장) | | | 정렬 순서 로케일 | | | 문자 분류 로케일 | | | 템플릿 데이터베이스 | | | 최대 동시 연결 수 (-1은 무제한) | --- --- --- --- PostgreSQL에서는 사용자와 그룹을 모두 \"Role\"이라고 합니다. | 옵션 | 설명 | |------|------| | | 로그인 가능 | | | 슈퍼유저 권한 | | | 데이터베이스 생성 권한 | | | Role 생성 권한 | | | 그룹 권한 상속 | | | 복제 권한 | | | 비밀번호 설정 | | | 계정 만료일 | | | 최대 연결 수 | --- | 권한 | 적용 대상 | 설명 | |------|-----------|------| | | 테이블, 뷰 | 데이터 조회 | | | 테이블 |...", "url": "/study/ko/PostgreSQL/02_Database_Management.html"}, {"id": "PostgreSQL/03_Tables_and_Data_Types", "title": "테이블과 데이터타입", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "테이블은 데이터를 행(row)과 열(column)로 구성하여 저장하는 구조입니다. --- --- | 타입 | 크기 | 범위 | |------|------|------| | | 2 bytes | -32,768 ~ 32,767 | | (INT) | 4 bytes | -2,147,483,648 ~ 2,147,483,647 | | | 8 bytes | -9경 ~ 9경 | | 타입 | 범위 | |------|------| | | 1 ~ 32,767 | | | 1 ~ 2,147,483,647 | | | 1 ~ 9경 | | 타입 | 설명 | |------|------| | | 4 bytes, 6자리 정밀도 | | | 8 bytes, 15자리 정밀도 | | | 정확한 숫자 (p: 전체 자릿수, s: 소수점 자릿수) | | | NUMERIC과 동일 | --- | 타입 | 설명 | |------|------| | | 고정 길이 문자열 (남는 공간은 공백으로 채움) | | | 가변 길이 문자열 (최대...", "url": "/study/ko/PostgreSQL/03_Tables_and_Data_Types.html"}, {"id": "PostgreSQL/04_CRUD_Basics", "title": "CRUD 기본", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "CRUD는 Create(생성), Read(읽기), Update(수정), Delete(삭제)의 약자로, 데이터베이스의 기본 작업입니다. --- --- --- --- | 특징 | DELETE | TRUNCATE | |------|--------|----------| | WHERE 조건 | 가능 | 불가능 | | 속도 | 느림 | 빠름 | | 트랜잭션 롤백 | 가능 | 제한적 | | RETURNING | 가능 | 불가능 | | 트리거 실행 | 실행됨 | 실행 안됨 | | SERIAL 리셋 | 안됨 | 선택 가능 | --- 삽입 시 충돌이 발생하면 업데이트하는 기능입니다. 는 삽입하려고 했던 데이터를 참조합니다. --- --- --- --- 05Conditionsand_Sorting.md에서 WHERE 절과 ORDER BY를 자세히 다뤄봅시다!", "url": "/study/ko/PostgreSQL/04_CRUD_Basics.html"}, {"id": "PostgreSQL/05_Conditions_and_Sorting", "title": "조건과 정렬", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "WHERE 절은 조건에 맞는 행만 선택합니다. --- | 연산자 | 설명 | 예시 | |--------|------|------| | | 같음 | | | 또는 | 다름 | | | | 작음 | | | | 큼 | | | | 작거나 같음 | | | | 크거나 같음 | | --- 모든 조건이 참이어야 합니다. 하나 이상의 조건이 참이면 됩니다. 조건을 부정합니다. > > 순서로 처리됩니다. 괄호로 명확하게 표현하는 것이 좋습니다. --- 범위 조건을 간단하게 표현합니다. --- 여러 값 중 하나와 일치하는지 확인합니다. --- | 기호 | 의미 | |------|------| | | 0개 이상의 모든 문자 | | | 정확히 1개의 문자 | --- NULL은 \"알 수 없는 값\"으로, 일반 비교 연산자로는 비교할 수 없습니다. --- --- --- --- --- --- 06_JOIN.md에서 여러 테이블을 연결하는 JOIN을 배워봅시다!", "url": "/study/ko/PostgreSQL/05_Conditions_and_Sorting.html"}, {"id": "PostgreSQL/06_JOIN", "title": "JOIN", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "JOIN은 두 개 이상의 테이블을 연결하여 데이터를 조회하는 방법입니다. --- --- 양쪽 테이블 모두에 일치하는 데이터만 반환합니다. 결과: --- 왼쪽 테이블의 모든 행 + 오른쪽에서 일치하는 행을 반환합니다. 일치하지 않으면 NULL로 채워집니다. 결과: --- 오른쪽 테이블의 모든 행 + 왼쪽에서 일치하는 행을 반환합니다. 결과: --- 양쪽 테이블의 모든 행을 반환합니다. 일치하지 않으면 NULL로 채워집니다. 결과: --- 모든 가능한 조합을 반환합니다 (카티션 곱). 결과: --- 같은 테이블을 자기 자신과 조인합니다. 결과: --- 3개 이상의 테이블을 연결합니다. --- --- 동일한 컬럼명으로 조인할 때 간단하게 표현합니다. --- 동일한 이름의 모든 컬럼으로 자동 조인합니다. (권장하지 않음) --- --- --- --- 07Aggregationand_Grouping.md에서 집계 함수와 GROUP BY를 배워봅시다!", "url": "/study/ko/PostgreSQL/06_JOIN.html"}, {"id": "PostgreSQL/07_Aggregation_and_Grouping", "title": "집계와 그룹", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "집계 함수는 여러 행의 값을 하나의 결과로 계산합니다. | 함수 | 설명 | |------|------| | | 행 개수 | | | 합계 | | | 평균 | | | 최소값 | | | 최대값 | --- --- --- --- --- --- --- 데이터를 특정 컬럼 기준으로 그룹화하여 집계합니다. 결과: --- 결과: --- WHERE는 그룹화 전, HAVING은 그룹화 후 필터링합니다. --- --- --- --- 결과: --- 결과: --- --- 08Subqueriesand_CTE.md에서 서브쿼리와 WITH 절을 배워봅시다!", "url": "/study/ko/PostgreSQL/07_Aggregation_and_Grouping.html"}, {"id": "PostgreSQL/08_Subqueries_and_CTE", "title": "서브쿼리와 CTE", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "서브쿼리(Subquery)는 쿼리 안에 포함된 또 다른 쿼리입니다. --- --- 행의 존재 여부만 확인합니다. --- --- --- 외부 쿼리의 값을 참조하는 서브쿼리입니다. --- WITH 절을 사용하여 임시 결과 집합에 이름을 붙입니다. --- 자기 자신을 참조하는 CTE입니다. 결과: --- --- | 상황 | 권장 | |------|------| | 단순 값 비교 | 서브쿼리 | | 여러 번 참조 | CTE | | 테이블 연결 | JOIN | | 복잡한 로직 분리 | CTE | | 재귀 탐색 | WITH RECURSIVE | --- 09Viewsand_Indexes.md에서 VIEW와 INDEX를 배워봅시다!", "url": "/study/ko/PostgreSQL/08_Subqueries_and_CTE.html"}, {"id": "PostgreSQL/09_Views_and_Indexes", "title": "뷰와 인덱스", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "뷰는 저장된 쿼리로, 가상의 테이블처럼 사용할 수 있습니다. --- --- --- --- 단순한 뷰는 INSERT, UPDATE, DELETE가 가능합니다. --- 결과를 물리적으로 저장하는 뷰입니다. | 특성 | VIEW | MATERIALIZED VIEW | |------|------|-------------------| | 데이터 저장 | X | O | | 실시간 반영 | O | X (REFRESH 필요) | | 조회 속도 | 느림 (매번 실행) | 빠름 (저장된 결과) | | 저장 공간 | 없음 | 필요 | --- 인덱스는 데이터 검색 속도를 높이는 자료구조입니다. --- --- --- --- 출력: 출력: | 스캔 방식 | 설명 | 성능 | |-----------|------|------| | Seq Scan | 전체 테이블 순차 스캔 | 느림 | | Index Scan | 인덱스 사용 | 빠름 | | Index Only Scan | 인덱스만으로 결과 반환 | 매우 빠름...", "url": "/study/ko/PostgreSQL/09_Views_and_Indexes.html"}, {"id": "PostgreSQL/10_Functions_and_Procedures", "title": "함수와 프로시저", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "PostgreSQL은 다양한 내장 함수를 제공합니다. | 함수 | 설명 | 예시 | 결과 | |------|------|------|------| | | 문자열 길이 | | 5 | | | 대문자 변환 | | HELLO | | | 소문자 변환 | | hello | | | 공백 제거 | | hi | | | 부분 문자열 | | Hel | | | 문자열 치환 | | HeLLo | | | 문자열 연결 | | ABC | | | 구분자로 분리 | | b | | 함수 | 설명 | 예시 | 결과 | |------|------|------|------| | | 반올림 | | 3.57 | | | 내림 | | 3 | | | 올림 | | 4 | | | 절대값 | | 5 | | | 나머지 | | 1 | | | 거듭제곱 | | 8 | | | 제곱근 | | 4 | | | 0~1 난수 | | 0.xxx | | 함수 | 설명 | |------|------| | | 현재 타임스탬프 | | | 현재 날짜 | | |...", "url": "/study/ko/PostgreSQL/10_Functions_and_Procedures.html"}, {"id": "PostgreSQL/11_Transactions", "title": "트랜잭션", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "트랜잭션은 하나의 논리적 작업 단위를 구성하는 연산들의 집합입니다. --- | 속성 | 영문 | 설명 | |------|------|------| | 원자성 | Atomicity | 전부 성공 또는 전부 실패 | | 일관성 | Consistency | 트랜잭션 전후로 데이터 일관성 유지 | | 격리성 | Isolation | 동시 실행 트랜잭션 간 간섭 방지 | | 지속성 | Durability | 완료된 트랜잭션은 영구 저장 | --- --- psql은 기본적으로 자동 커밋 모드입니다. --- 트랜잭션 내에서 부분 롤백 지점을 만듭니다. --- 동시에 실행되는 트랜잭션 간의 격리 정도를 결정합니다. | 수준 | Dirty Read | Non-repeatable Read | Phantom Read | |------|------------|---------------------|--------------| | READ UNCOMMITTED | 가능 | 가능 | 가능 | | READ...", "url": "/study/ko/PostgreSQL/11_Transactions.html"}, {"id": "PostgreSQL/12_Triggers", "title": "트리거", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "트리거는 특정 이벤트(INSERT, UPDATE, DELETE)가 발생할 때 자동으로 실행되는 함수입니다. --- 1. 트리거 함수: 실행할 로직 2. 트리거: 언제, 어떤 테이블에서 함수를 실행할지 정의 --- 이벤트 발생 전에 실행됩니다. 데이터를 검증하거나 수정할 수 있습니다. 이벤트 발생 후에 실행됩니다. 감사 로그, 알림 등에 사용합니다. --- | 변수 | INSERT | UPDATE | DELETE | |------|--------|--------|--------| | | 새 행 | 새 행 | 없음 | | | 없음 | 기존 행 | 삭제될 행 | --- 각 행마다 트리거가 실행됩니다. 문장당 한 번만 실행됩니다. --- --- --- --- | 변수 | 설명 | |------|------| | | 트리거 이름 | | | 테이블 이름 | | | 스키마 이름 | | | 작업 (INSERT, UPDATE, DELETE) | | | BEFORE 또는 AFTER | | | ROW...", "url": "/study/ko/PostgreSQL/12_Triggers.html"}, {"id": "PostgreSQL/13_Backup_and_Operations", "title": "백업과 운영", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "데이터베이스 백업은 데이터 손실을 방지하는 가장 중요한 작업입니다. --- --- 모든 데이터베이스와 전역 객체(사용자, 권한 등)를 백업합니다. --- --- 전체 데이터 디렉토리를 백업합니다. : --- --- --- --- 불필요한 공간을 정리합니다. 쿼리 최적화를 위한 통계를 수집합니다. 인덱스를 재구성합니다. : --- : --- --- --- - [ ] 백업 성공 확인 - [ ] 디스크 사용량 확인 - [ ] 연결 수 확인 - [ ] 오류 로그 확인 - [ ] 인덱스 사용률 확인 - [ ] 느린 쿼리 분석 - [ ] 테이블 크기 추이 - [ ] 백업 복원 테스트 - [ ] 불필요한 데이터 정리 - [ ] 성능 추이 분석 --- 이것으로 PostgreSQL 학습 자료를 마칩니다. 학습 순서 복습: 1. 기초 → DB 관리 → 테이블 → CRUD → 조건/정렬 2. JOIN → 집계 → 서브쿼리 → 뷰/인덱스 3. 함수 → 트랜잭션 → 트리거 → 백업/운영 더 깊이 있는...", "url": "/study/ko/PostgreSQL/13_Backup_and_Operations.html"}, {"id": "PostgreSQL/14_JSON_JSONB", "title": "14. PostgreSQL JSON/JSONB 기능", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "- JSON과 JSONB 타입의 차이점 이해 - JSON 데이터 저장 및 조회 - JSON 연산자와 함수 활용 - GIN 인덱스를 통한 JSON 검색 최적화 1. JSON vs JSONB 2. JSON 데이터 저장 3. JSON 연산자 4. JSON 함수 5. 인덱싱과 성능 6. 실전 패턴 7. 연습 문제 --- --- --- --- --- --- --- --- - 15쿼리최적화심화 - JSON 쿼리 최적화 - 17윈도우함수분석 - JSON과 윈도우 함수 - PostgreSQL JSON Documentation - PostgreSQL JSON Functions - PostgreSQL JSON Types - GIN Index --- ← 이전: 백업과 복구 | 다음: 쿼리 최적화 심화 → | 목차", "url": "/study/ko/PostgreSQL/14_JSON_JSONB.html"}, {"id": "PostgreSQL/15_Query_Optimization", "title": "15. PostgreSQL 쿼리 최적화 심화", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "- EXPLAIN ANALYZE 출력 완전 이해 - 쿼리 플래너 동작 원리 파악 - 인덱스 선택 전략 수립 - 복잡한 쿼리 최적화 기법 1. EXPLAIN ANALYZE 심화 2. 쿼리 플래너 3. 인덱스 전략 4. 조인 최적화 5. 통계와 비용 추정 6. 고급 최적화 기법 7. 연습 문제 --- --- --- --- --- --- --- --- - 16복제와고가용성 - 읽기 분산 - 17윈도우함수_분석 - 고급 분석 - PostgreSQL Performance - PostgreSQL EXPLAIN - Query Planning - Index Types - Use The Index, Luke --- ← 이전: JSON/JSONB 기능 | 다음: 복제와 고가용성 → | 목차", "url": "/study/ko/PostgreSQL/15_Query_Optimization.html"}, {"id": "PostgreSQL/16_Replication_HA", "title": "16. 복제와 고가용성 (Replication & High Availability)", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "- PostgreSQL 복제 아키텍처와 종류 이해 - 스트리밍 복제 구성 및 관리 - 논리 복제를 활용한 선택적 데이터 복제 - 페일오버 전략과 자동화 구현 - 고가용성 클러스터 설계 1. 복제 개요 2. 물리적 복제 (스트리밍 복제) 3. 논리적 복제 4. 복제 모니터링 5. 페일오버와 스위치오버 6. 고가용성 솔루션 7. 연습 문제 --- --- --- --- --- --- --- Docker를 사용하여 Primary-Standby 구성을 설정하세요. 특정 테이블만 복제하는 논리 복제를 구성하세요. 복제 상태를 종합적으로 보여주는 쿼리를 작성하세요. --- - 17. 윈도우 함수와 분석 - 18. 테이블 파티셔닝 - PostgreSQL Replication - Logical Replication - Patroni Documentation - pg_basebackup", "url": "/study/ko/PostgreSQL/16_Replication_HA.html"}, {"id": "PostgreSQL/17_Window_Functions", "title": "17. 윈도우 함수와 분석 쿼리 (Window Functions & Analytics)", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "- 윈도우 함수의 개념과 일반 집계 함수와의 차이 이해 - OVER 절과 파티션, 프레임 개념 마스터 - 순위 함수 (ROWNUMBER, RANK, DENSERANK) 활용 - 분석 함수 (LEAD, LAG, FIRST_VALUE) 활용 - 실무 분석 쿼리 작성 능력 향상 1. 윈도우 함수 기초 2. 순위 함수 3. 분석 함수 4. 집계 윈도우 함수 5. 프레임 상세 6. 실전 활용 패턴 7. 연습 문제 --- --- --- --- --- --- --- 각 영업사원의 판매 금액을 분석하여 다음을 계산하세요: - 영업사원별 순위 - 전체 대비 비율 - 이전 판매 대비 증감 최근 7일간의 이동 합계를 계산하세요. 누적 매출이 5000을 처음 달성한 날짜를 찾으세요. --- - 18. 테이블 파티셔닝 - 14. JSON/JSONB 기능 - PostgreSQL Window Functions - Window Function Tutorial - SQL Window Functions", "url": "/study/ko/PostgreSQL/17_Window_Functions.html"}, {"id": "PostgreSQL/18_Table_Partitioning", "title": "18. 테이블 파티셔닝 (Table Partitioning)", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "- 파티셔닝의 개념과 필요성 이해 - PostgreSQL의 선언적 파티셔닝 활용 - Range, List, Hash 파티셔닝 구현 - 파티션 프루닝과 성능 최적화 - 파티션 유지보수 자동화 1. 파티셔닝 개요 2. Range 파티셔닝 3. List 파티셔닝 4. Hash 파티셔닝 5. 파티션 프루닝 6. 파티션 관리 7. 연습 문제 --- --- --- --- --- --- --- accesslogs 테이블을 월별로 파티셔닝하세요. 국가 코드 기반으로 주문을 파티셔닝하세요. 90일 이전 데이터가 있는 파티션을 식별하고 처리하는 쿼리를 작성하세요. --- - 15. 쿼리 최적화 심화 - 16. 복제와 고가용성 - PostgreSQL Table Partitioning - Partition Pruning - pgpartman Extension - Best Practices for Partitioning", "url": "/study/ko/PostgreSQL/18_Table_Partitioning.html"}, {"id": "PostgreSQL/19_Full_Text_Search", "title": "19. 전문 검색(Full-Text Search)", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "- PostgreSQL 전문 검색(Full-Text Search) 아키텍처 이해하기 - tsvector와 tsquery 데이터 타입 효과적으로 사용하기 - 빠른 텍스트 검색을 위한 GIN 인덱스 생성하기 - 가중치를 활용한 랭킹 검색 구현하기 - 다국어 검색 지원 설정하기 - 퍼지 매칭(Fuzzy Matching)을 위한 pgtrgm 활용하기 1. 전문 검색 개요 2. tsvector와 tsquery 3. 검색 구성 4. GIN과 GiST 인덱스 5. 랭킹과 가중치 6. 고급 검색 기법 7. 퍼지 매칭을 위한 pgtrgm 8. 연습 문제 --- --- --- --- --- --- --- --- 전자상거래 제품 카탈로그를 위한 전문 검색 시스템을 구축하세요. 하이라이트된 매치가 있는 검색 결과를 생성하세요. 영어와 simple(형태소 분석 없음) 텍스트를 모두 처리하는 검색 시스템을 설계하세요. --- - 20. 보안과 접근 제어 - 15. 쿼리 최적화 - PostgreSQL...", "url": "/study/ko/PostgreSQL/19_Full_Text_Search.html"}, {"id": "PostgreSQL/20_Security_Access_Control", "title": "20. 보안과 접근 제어", "topic": "PostgreSQL", "topic_display": "PostgreSQL", "body": "- 역할(Role)과 권한(Privilege)을 효과적으로 관리하기 - 행 수준 보안(Row-Level Security, RLS) 구현하기 - 인증을 위한 pghba.conf 구성하기 - SSL/TLS 암호화 연결 설정하기 - 규정 준수를 위한 감사 로깅 활성화하기 - 보안 모범 사례 적용하기 1. 보안 개요 2. 역할과 권한 3. 행 수준 보안(RLS) 4. 인증(pghba.conf) 5. SSL/TLS 연결 6. 감사 로깅 7. 보안 모범 사례 8. 연습 문제 --- --- --- --- --- --- --- --- 테넌트 격리가 있는 SaaS 애플리케이션을 위한 RLS를 설정하세요. employees 테이블을 위한 포괄적인 감사 시스템을 생성하세요. 웹 애플리케이션을 위한 역할 계층 구조를 생성하세요. --- - 19. 전문 검색 - 15. 쿼리 최적화 - PostgreSQL Roles - Row-Level Security - pg_hba.conf - SSL Support -...", "url": "/study/ko/PostgreSQL/20_Security_Access_Control.html"}, {"id": "Programming/00_Overview", "title": "Programming", "topic": "Programming", "topic_display": "Programming", "body": "단일 프로그래밍 언어를 초월하는 프로그래밍의 기본 개념, 원리, 방법론에 대한 포괄적인 가이드입니다. 이 토픽은 계산적 사고와 패러다임부터 클린 코드 실천법, 테스팅 전략, 동시성 패턴, 소프트웨어 아키텍처에 이르기까지 균형 잡힌 소프트웨어 개발자가 되기 위한 필수 지식을 다룹니다. 이 토픽은 언어 독립적인 다음 내용을 제공합니다: - 핵심 개념: 계산적 사고(Computational thinking), 추상화(Abstraction), 알고리즘, 자료구조 - 패러다임: 명령형(Imperative), 객체지향(Object-oriented), 함수형(Functional), 선언형(Declarative) 프로그래밍 접근법 - 코드 품질: 클린 코드 원칙, 디자인 패턴, SOLID 원칙, 리팩토링 - 전문적 실천법: 테스팅, 디버깅, 성능 최적화, API 설계, 버전 관리 워크플로우 - 소프트웨어 아키텍처: 모놀리스, 마이크로서비스, 계층형 아키텍처, 아키텍처 패턴 - 윤리와 커리어:...", "url": "/study/ko/Programming/00_Overview.html"}, {"id": "Programming/01_What_Is_Programming", "title": "프로그래밍이란 무엇인가", "topic": "Programming", "topic_display": "Programming", "body": "> 토픽: Programming > 레슨: 1 of 16 > 선수 지식: 없음 > 목표: 프로그래밍이 무엇인지, 문제 해결 과정, 계산적 사고, 컴퓨터가 프로그램을 실행하는 방법을 이해합니다. --- 프로그래밍은 컴퓨터에게 작업을 수행하도록 지시하는 예술이자 과학입니다. 핵심은 문제 해결입니다 — 현실 세계의 문제를 가져와 논리적 단계로 나누고, 컴퓨터가 실행할 수 있는 언어로 그 단계를 표현하는 것입니다. 용어가 종종 혼용되지만, 미묘하지만 중요한 차이가 있습니다: - 코딩(Coding): 특정 프로그래밍 언어로 코드를 작성하는 행위 — 문법, 키워드, 메커니즘 - 프로그래밍(Programming): 문제 이해, 솔루션 설계, 코드 작성, 테스팅, 디버깅, 시간에 걸쳐 소프트웨어를 유지보수하는 것을 포함하는 더 넓은 개념 프로그래머는 단순히 코드를 작성하는 것이 아니라: - 문제를 분석합니다 - 알고리즘을 설계합니다 - 적절한 자료구조를 선택합니다 - 유지보수 가능하고 읽기 쉬운...", "url": "/study/ko/Programming/01_What_Is_Programming.html"}, {"id": "Programming/02_Programming_Paradigms", "title": "프로그래밍 패러다임", "topic": "Programming", "topic_display": "Programming", "body": "> 토픽: Programming > 레슨: 2 of 16 > 선수 지식: What Is Programming > 목표: 다양한 프로그래밍 패러다임, 그 원칙, 각 접근법을 사용하는 시기를 이해합니다. --- 프로그래밍 패러다임(Programming Paradigm)은 프로그래밍의 기본적인 스타일이나 접근법입니다. 다음을 정의합니다: - 코드를 구조화하는 방법 - 문제에 대해 생각하는 방법 - 사용하는 개념과 추상화 패러다임을 코드로 문제를 해결하는 다양한 철학으로 생각하세요. 비유: 건축 양식(고딕, 모더니즘, 브루탈리즘)이 다양하듯이, 프로그래밍 스타일도 다양합니다. 각각은 장점, 절충안, 적절한 사용 사례가 있습니다. --- 컴퓨터에게 어떻게(HOW) 하는지를 단계별로 알려줍니다. 명시적인 명령을 통해 상태 변경에 집중합니다. - 명시적인 문장 시퀀스 - 시간에 따라 변하는 변수 (가변 상태) - 제어 흐름: 루프, 조건문 - 생각: \"이것을 하고, 그 다음 저것을 하고, 그...", "url": "/study/ko/Programming/02_Programming_Paradigms.html"}, {"id": "Programming/03_Data_Types_and_Abstraction", "title": "데이터 타입과 추상화", "topic": "Programming", "topic_display": "Programming", "body": "> 토픽: Programming > 레슨: 3 of 16 > 선수 지식: What Is Programming, Programming Paradigms > 목표: 데이터 타입, 타입 시스템, 추상 데이터 타입, 추상화가 복잡성을 관리하는 방법을 이해합니다. --- 타입(type)은 다음을 결정하는 데이터의 분류입니다: - 데이터가 가질 수 있는 값 - 데이터에 수행할 수 있는 연산 - 차지하는 메모리 크기 - 컴퓨터가 해석하는 방법 비유: 타입은 컨테이너와 같습니다 — 유리병은 액체를 담고, 판지 상자는 고체를 담습니다. 판지 상자에 물을 부을 수 없습니다 (또는 부어서는 안 됩니다). 타입은 코드에서 유사한 제약을 강제합니다. 타입은 어떤 연산이 유효한지에 대한 제약을 강제하여 오류를 방지합니다. --- 기본 타입은 언어가 제공하는 구성 요소입니다. 일반적으로 하드웨어 표현에 직접 매핑됩니다. 소수 부분이 없는 정수. Python: Java: C++: 소수 부분이 있는 숫자. 이진...", "url": "/study/ko/Programming/03_Data_Types_and_Abstraction.html"}, {"id": "Programming/04_Control_Flow_Patterns", "title": "제어 흐름 패턴", "topic": "Programming", "topic_display": "Programming", "body": "> 토픽: Programming > 레슨: 4 of 16 > 선수 지식: What Is Programming, Programming Paradigms, Data Types & Abstraction > 목표: 제어 흐름 메커니즘 — 분기, 루프, 재귀, 반복자, 에러 처리 — 을 마스터하고 각 패턴을 언제 사용할지 학습합니다. --- 기본적으로 프로그램은 순차적으로 실행됩니다 — 한 문장씩, 위에서 아래로. Python: JavaScript: Java: 이것이 가장 간단한 제어 흐름 형태입니다. 하지만 실제 프로그램은 결정과 반복이 필요합니다. --- 조건에 따라 다른 코드 경로를 실행합니다. Python: JavaScript: Java: C++: 여러 개별 케이스를 위한 구문. Java (switch): JavaScript (switch): C++ (switch): Python (3.10+): Rust (match): 패턴 매칭의 이점: 더 표현력 있고, 완전성 검사 (컴파일러가...", "url": "/study/ko/Programming/04_Control_Flow_Patterns.html"}, {"id": "Programming/05_OOP_Principles", "title": "OOP 원칙", "topic": "Programming", "topic_display": "Programming", "body": "> 주제: Programming > 레슨: 5 of 16 > 선수지식: 클래스와 객체에 대한 기본 이해, 객체지향 언어 하나 이상 숙지 > 목표: OOP의 네 가지 기둥(캡슐화, 추상화, 상속, 다형성)을 마스터하고 SOLID 원칙을 적용하여 유지보수 가능하고 확장 가능한 코드 작성 객체지향 프로그래밍(OOP, Object-Oriented Programming)은 코드를 구조화하는 방법을 안내하는 기본 원칙들 위에 구축됩니다. 이러한 원칙들을 피상적으로가 아니라 깊이 이해하는 것은 유지보수 가능하고 확장 가능한 소프트웨어를 작성하는 데 필수적입니다. 이 레슨에서는 OOP의 네 가지 기둥, SOLID 원칙, 그리고 각 개념을 언제 적용하고(혹은 피해야) 하는지 탐구합니다. 캡슐화는 데이터와 그 데이터를 조작하는 메서드를 단일 단위(클래스) 내에 묶는 것이며, 객체의 일부 컴포넌트에 대한 직접 접근을 제한합니다. 언어마다 캡슐화를 다르게 구현합니다: Java: Python: C++:...", "url": "/study/ko/Programming/05_OOP_Principles.html"}, {"id": "Programming/06_Functional_Programming", "title": "함수형 프로그래밍 개념", "topic": "Programming", "topic_display": "Programming", "body": "> 주제: Programming > 레슨: 6 of 16 > 선수지식: 함수 이해, 기본 데이터 구조, 프로그래밍 언어 하나 이상 숙지 > 목표: 함수형 프로그래밍 개념(순수 함수, 불변성, 고차 함수, 컴포지션)을 마스터하고 더 예측 가능하고 테스트 가능한 코드 작성 함수형 프로그래밍(FP, Functional Programming)은 계산을 수학적 함수의 평가로 취급하며, 상태 변경과 가변 데이터를 피합니다. Haskell과 Lisp 같은 언어들이 순수 함수형이지만, FP 개념은 JavaScript, Python, Java, C++ 같은 주류 언어에서도 점점 더 채택되고 있습니다. 이 레슨에서는 핵심 FP 원칙을 탐구하고 다중 패러다임 언어에서 이를 적용하는 방법을 보여줍니다. 명령형(OOP) 접근: 함수형 접근: FP는 어떻게 계산할지보다 무엇을 계산할지를 강조합니다. 순수 함수는 동일한 입력에 대해 항상 동일한 출력을 반환하고 부수 효과(side effects)가 없습니다....", "url": "/study/ko/Programming/06_Functional_Programming.html"}, {"id": "Programming/07_Design_Patterns", "title": "디자인 패턴", "topic": "Programming", "topic_display": "Programming", "body": "> 주제: Programming > 레슨: 7 of 16 > 선수지식: OOP 원칙(캡슐화, 상속, 다형성) 이해, 기본 프로그래밍 경험 > 목표: 일반적인 디자인 패턴(Gang of Four 및 그 이상)을 마스터하고, 언제 적용할지 인식하며, 트레이드오프 이해 디자인 패턴(Design Pattern)은 소프트웨어 설계에서 일반적으로 발생하는 문제에 대한 재사용 가능한 솔루션입니다. 개발자를 위한 공유 어휘를 제공하고 수십 년간 다듬어진 모범 사례를 캡슐화합니다. 이 레슨에서는 고전적인 Gang of Four(GoF) 패턴, 언제 사용할지, 그리고 언제 과도할 수 있는지를 다룹니다. 디자인 패턴 = 이름 + 문제 + 솔루션 + 결과 - 이름: 공유 어휘 (예: \"여기서 Factory 패턴을 사용하세요\") - 문제: 패턴을 적용할 때 - 솔루션: 문제를 해결하는 일반적인 설계 - 결과: 트레이드오프, 비용, 이점 Gamma, Helm, Johnson, Vlissides의 책...", "url": "/study/ko/Programming/07_Design_Patterns.html"}, {"id": "Programming/08_Clean_Code", "title": "클린 코드와 코드 스멜", "topic": "Programming", "topic_display": "Programming", "body": "> 주제: Programming > 레슨: 8 of 16 > 선수지식: 최소 하나 이상의 언어에서 프로그래밍 경험, 함수와 클래스 숙지 > 목표: 모범 사례를 따르고 코드 스멜을 인식하며 효과적인 리팩토링 기법을 적용하여 깨끗하고 유지보수 가능한 코드 작성 학습 \"바보도 컴퓨터가 이해할 수 있는 코드를 작성할 수 있습니다. 좋은 프로그래머는 사람이 이해할 수 있는 코드를 작성합니다.\" — Martin Fowler 클린 코드(Clean Code)는 읽기 쉽고, 이해하기 쉬우며, 수정하기 쉬운 코드입니다. 인지 부하를 최소화하고, 버그를 줄이며, 협업을 더 쉽게 만듭니다. 이 레슨에서는 Robert C. Martin의 Clean Code, Martin Fowler의 Refactoring, 그리고 기타 업계 모범 사례의 원칙들을 다룹니다. 기술 부채(Technical Debt)는 지름길을 택할 때 누적됩니다: 클린 버전: 이름은 우리가 의도를 전달하는 주요 방법입니다. 좋은 이름은...", "url": "/study/ko/Programming/08_Clean_Code.html"}, {"id": "Programming/09_Error_Handling", "title": "에러 처리 전략(Error Handling Strategies)", "topic": "Programming", "topic_display": "Programming", "body": "> 주제: Programming > 레슨: 16 중 9 > 선수 지식: 함수와 메서드, 자료 구조, 프로그램 흐름 제어 > 목표: 프로그래밍 패러다임 전반에 걸친 에러 처리 전략을 이해하고, 예외와 반환 값을 언제 사용할지 배우며, 방어적 프로그래밍 기법을 적용하여 견고한 소프트웨어를 구축합니다. --- 에러 처리는 소프트웨어 개발에서 가장 중요한 측면 중 하나이지만, 종종 나중에 고려되곤 합니다. 잘못된 에러 처리는 충돌, 보안 취약점, 데이터 손상, 그리고 좌절한 사용자로 이어집니다. 좋은 에러 처리는 소프트웨어를 견고하고, 유지보수 가능하며, 사용자 친화적으로 만듭니다. 이 레슨은 다양한 프로그래밍 언어와 패러다임에서 사용되는 에러 처리 전략을 탐구하며, 전통적인 예외부터 현대적인 Result 타입까지 다루고, 각 접근 방식을 언제 어떻게 적용할지 가르칩니다. --- 소프트웨어는 끊임없이 에러를 만납니다: 네트워크 장애, 잘못된 사용자 입력, 파일 누락, 메모리 부족 상황....", "url": "/study/ko/Programming/09_Error_Handling.html"}, {"id": "Programming/10_Testing_Fundamentals", "title": "테스팅 기초(Testing Fundamentals)", "topic": "Programming", "topic_display": "Programming", "body": "> 주제: Programming > 레슨: 16 중 10 > 선수 지식: 함수와 메서드, 에러 처리, 객체 지향 프로그래밍 > 목표: 다양한 유형의 테스트(단위, 통합, E2E)를 마스터하고, TDD와 BDD를 이해하며, 테스트 더블을 효과적으로 사용하는 방법을 배우고, 취약성 없이 신뢰를 제공하는 테스트를 작성합니다. --- 테스팅은 단순히 버그를 찾는 것만이 아닙니다 – 코드에 대한 신뢰를 구축하고, 리팩토링을 가능하게 하며, 문서를 제공하고, 설계를 개선하는 것입니다. 잘 테스트된 코드는 변경, 유지보수, 이해가 더 쉽습니다. 이 레슨은 여러 언어와 테스팅 패러다임에 걸친 테스팅 기초를 다루며, 단위 테스트부터 종단 간 테스트까지, 전통적인 테스팅부터 테스트 주도 개발까지, 목부터 속성 기반 테스팅까지 포함합니다. --- 테스트는 코드가 의도한 대로 작동하고 변경 후에도 계속 작동한다는 신뢰를 줍니다. 테스트는 버그를 도입할 때 잡아내며, 몇 주 후 프로덕션에서가 아닙니다....", "url": "/study/ko/Programming/10_Testing_Fundamentals.html"}, {"id": "Programming/11_Debugging_and_Profiling", "title": "디버깅 및 프로파일링(Debugging & Profiling)", "topic": "Programming", "topic_display": "Programming", "body": "> 주제: Programming > 레슨: 16 중 11 > 선수 지식: 에러 처리, 테스팅 기초, 프로그램 흐름 제어 > 목표: 체계적인 디버깅 기술을 개발하고, 여러 언어의 디버깅 도구를 마스터하며, 프로파일링 기법을 이해하고, 성능 병목 현상을 식별하고 수정하는 방법을 배웁니다. --- 디버깅은 필수적인 프로그래밍 기술입니다. 모든 개발자는 디버깅에 상당한 시간을 소비합니다 – 버그를 찾고 수정하는 것은 종종 코드를 처음 작성하는 것보다 어렵습니다. 초보자와 전문가 개발자의 차이는 얼마나 많은 버그를 만드느냐가 아니라 (모두가 버그를 만듭니다), 얼마나 효율적으로 찾고 수정하느냐입니다. 이 레슨은 체계적인 디버깅 기법을 가르치고, 여러 언어의 디버깅 도구를 소개하며, 성능 프로파일링을 다루고, 경력 전반에 걸쳐 도움이 될 디버깅 마인드셋을 개발하도록 돕습니다. --- 나쁜 디버깅: 좋은 디버깅: 디버깅은 과학적 조사와 같습니다: 1. 버그 관찰 (재현하기!) 버그를 수정하기...", "url": "/study/ko/Programming/11_Debugging_and_Profiling.html"}, {"id": "Programming/12_Concurrency_and_Parallelism", "title": "동시성 및 병렬성(Concurrency & Parallelism)", "topic": "Programming", "topic_display": "Programming", "body": "> 주제: Programming > 레슨: 16 중 12 > 선수 지식: 함수와 메서드, 에러 처리, 디버깅 및 프로파일링 > 목표: 동시성과 병렬성의 차이를 이해하고, 스레드와 async/await, 메시지 전달을 마스터하며, 병렬 패턴을 배우고, 경쟁 조건과 교착 상태 같은 일반적인 함정을 피합니다. --- 현대 애플리케이션은 많은 작업을 동시에 처리해야 합니다: 반응형 사용자 인터페이스, 네트워크 I/O, 데이터베이스 쿼리, 백그라운드 처리. 동시성과 병렬성은 이러한 시스템을 구축하는 필수 도구입니다. 그러나 동시 프로그래밍은 악명 높게 어렵습니다. 경쟁 조건, 교착 상태, 데이터 손상은 일반적인 함정입니다. 이 레슨은 올바른 동시 코드를 작성하는 데 도움이 되는 정신 모델, 패턴, 실용적인 기법을 제공합니다. --- 이 용어들은 종종 혼동되지만, 다른 개념을 나타냅니다: 동시성은 구조에 관한 것 – 프로그램을 여러 작업을 처리하도록 조직하는 방법. 예제: 한 명의...", "url": "/study/ko/Programming/12_Concurrency_and_Parallelism.html"}, {"id": "Programming/13_API_Design", "title": "API 설계 원칙", "topic": "Programming", "topic_display": "Programming", "body": "> 토픽: Programming > 레슨: 13 of 16 > 선수 지식: 객체 지향 프로그래밍, HTTP 기초, JSON/XML 형식 > 목표: 라이브러리, 모듈, 웹 서비스를 위한 명확하고 일관된 유지보수 가능한 API 설계 방법 학습 API(Application Programming Interface)는 소프트웨어 구성 요소가 통신하는 방법을 정의하는 계약입니다. 라이브러리 함수, REST 엔드포인트 또는 시스템 인터페이스를 설계하든, 좋은 API 설계는 소프트웨어를 더 쉽게 사용하고, 유지보수하고, 발전시킬 수 있게 만듭니다. 잘못된 API 설계는 다음을 초래합니다: - 인터페이스를 잘못 사용하는 혼란스러운 사용자 - 작은 변경에도 깨지는 취약한 코드 - 불명확한 문서로 인한 지원 부담 - 소비자의 통합 어려움 훌륭한 API 설계는 보이지 않습니다—사용자는 마찰 없이 목표를 달성합니다. API는 구현 세부 사항을 숨기면서 기능을 노출하는 추상화(abstraction)입니다:...", "url": "/study/ko/Programming/13_API_Design.html"}, {"id": "Programming/14_Version_Control_Workflows", "title": "버전 관리와 협업", "topic": "Programming", "topic_display": "Programming", "body": "> 토픽: Programming > 레슨: 14 of 16 > 선수 지식: 기본 Git 지식(clone, commit, push, pull), 명령줄 익숙함 > 목표: 전문 소프트웨어 개발을 위한 브랜칭 전략, 코드 리뷰 관행, CI/CD 기초, 협업 워크플로우 마스터 버전 관리는 현대 소프트웨어 개발의 기초입니다. 이를 통해: - 히스토리 추적: 모든 변경 사항이 컨텍스트와 함께 기록됨 - 협업: 여러 개발자가 충돌 없이 동시에 작업 - 실험: 위험한 변경을 두려움 없이 시도 - 롤백 기능: 실수를 쉽게 되돌림 - 코드 리뷰: 병합 전 체계적 품질 게이트 이 레슨은 팀을 생산적으로 만드는 버전 관리 도구 위에 구축된 워크플로우—인간 프로세스—를 다룹니다. 진화를 이해하면 현대 도구가 왜 그런 방식으로 작동하는지 이해하는 데 도움이 됩니다: 1. RCS(1982): 단일 파일 잠금, 한 번에 한 개발자 2. CVS(1986): 다중 파일 버전 관리, 동시 편집 3....", "url": "/study/ko/Programming/14_Version_Control_Workflows.html"}, {"id": "Programming/15_Software_Architecture", "title": "소프트웨어 아키텍처 기초", "topic": "Programming", "topic_display": "Programming", "body": "> 토픽: Programming > 레슨: 15 of 16 > 선수 지식: 객체 지향 프로그래밍, 디자인 패턴, 시스템 설계 기초 > 목표: 고수준 아키텍처 패턴, 모노리스와 마이크로서비스 간의 트레이드오프, 유지보수 가능한 시스템 설계 원칙 이해 소프트웨어 아키텍처는 시스템이 어떻게 구축되는지를 형성하는 고수준 구조적 결정의 집합입니다. 설계가 개별 구성 요소(클래스, 함수)에 초점을 맞추는 반면, 아키텍처는 큰 그림에 초점을 맞춥니다: - 구성 요소가 어떻게 조직되는가 - 그들이 어떻게 통신하는가 - 어떤 경계가 존재하는가 - 시스템이 어떻게 확장되고, 발전하고, 실패를 처리하는가 좋은 아키텍처: - 시스템을 이해하기 쉽게 만듦(인지 부하) - 시스템을 변경하기 쉽게 만듦(적응성) - 실패에 탄력적이게 만듦 - 비즈니스 목표와 정렬됨(비용, 출시 시간, 확장성) 나쁜 아키텍처는 시간이 지남에 따라 개발을 늦추는 기술 부채를 만듭니다. | 측면 | 아키텍처 | 설계 |...", "url": "/study/ko/Programming/15_Software_Architecture.html"}, {"id": "Programming/16_Developer_Practices", "title": "개발자 관행과 윤리", "topic": "Programming", "topic_display": "Programming", "body": "> 토픽: Programming > 레슨: 16 of 16 > 선수 지식: 소프트웨어 개발 경험, 버전 관리, 소프트웨어 라이프사이클의 기본 이해 > 목표: 기술 부채 관리, 문서화 전략, 오픈 소스 기여, 소프트웨어 윤리, 경력 성장 원칙을 포함한 전문 개발 관행 학습 코드 작성은 전문 개발자가 되는 것의 일부일 뿐입니다. 이 레슨은 훌륭한 개발자를 단순히 유능한 개발자와 구별하는 관행, 원칙, 윤리를 다룹니다: - 기술 부채 관리: 속도와 품질의 균형 - 문서화: 작업을 이해하기 쉽고 유지보수 가능하게 만들기 - 오픈 소스: 공개 소프트웨어에 기여하고 만들기 - 윤리: 책임감 있게 소프트웨어 구축 - 경력 성장: 지속 가능하고 만족스러운 경력 개발 이러한 관행은 여러분이 일하고, 협업하고, 더 넓은 소프트웨어 커뮤니티에 기여하는 방식을 형성합니다. 기술 부채(Technical debt)는 더 오래 걸릴 더 나은 접근 방식 대신 오늘 빠른 솔루션을 선택함으로써 발생하는 미래...", "url": "/study/ko/Programming/16_Developer_Practices.html"}, {"id": "Python/00_Overview", "title": "파이썬 학습 가이드", "topic": "Python", "topic_display": "Python", "body": "이 폴더는 파이썬의 기초부터 고급 문법까지 체계적으로 학습하기 위한 자료를 담고 있습니다. 대상 독자: - 기초 복습 필요: 15, 16번 레슨(기초 문법, OOP)부터 시작 - 중급 이상: 01번 레슨(타입 힌팅)부터 시작 --- --- - 파이썬 기본 문법 (변수, 자료형, 제어문, 함수) - 객체지향 프로그래밍 기초 (클래스, 상속, 메서드) - 모듈과 패키지 사용법 --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01TypeHints.md | ⭐⭐ | Type Hints, typing 모듈, mypy | | 02Decorators.md | ⭐⭐ | 함수/클래스 데코레이터, @wraps | | 03ContextManagers.md | ⭐⭐ | with문, contextlib | | 04IteratorsandGenerators.md | ⭐⭐⭐ | iter, yield, itertools | |...", "url": "/study/ko/Python/00_Overview.html"}, {"id": "Python/01_Type_Hints", "title": "타입 힌팅 (Type Hints)", "topic": "Python", "topic_display": "Python", "body": "타입 힌팅은 파이썬 3.5+에서 도입된 기능으로, 변수나 함수의 타입을 명시적으로 표시합니다. 파이썬은 여전히 동적 타입 언어이지만, 타입 힌트를 통해 코드의 가독성과 안정성을 높일 수 있습니다. | 장점 | 설명 | |------|------| | 가독성 | 함수의 입력/출력 타입을 명확히 알 수 있음 | | IDE 지원 | 자동완성, 타입 오류 경고 | | 문서화 | 코드 자체가 문서 역할 | | 버그 예방 | 정적 분석으로 런타임 전 오류 발견 | --- --- 값이 None일 수 있음을 표시합니다. 여러 타입 중 하나를 허용합니다. 모든 타입을 허용합니다 (타입 체크 비활성화). 함수 타입을 지정합니다. 제네릭 타입 변수를 정의합니다. --- 딕셔너리의 키와 값 타입을 정의합니다. 덕 타이핑을 타입 힌트로 표현합니다. 특정 리터럴 값만 허용합니다. 상수를 표시합니다 (재할당 불가). --- 복잡한 타입에 이름을 붙입니다. --- --- 같은 함수의 여러 시그니처를...", "url": "/study/ko/Python/01_Type_Hints.html"}, {"id": "Python/02_Decorators", "title": "데코레이터 (Decorators)", "topic": "Python", "topic_display": "Python", "body": "데코레이터는 함수나 클래스를 수정하지 않고 기능을 추가하는 패턴입니다. 문법을 사용하여 적용합니다. --- 출력: 출력: --- 데코레이터를 적용하면 원본 함수의 메타데이터(이름, docstring 등)가 사라집니다. --- 데코레이터 자체에 인자를 전달하려면 한 단계 더 감싸야 합니다. 출력: --- 메서드를 구현하면 클래스를 데코레이터로 사용할 수 있습니다. --- getter/setter/deleter를 정의합니다. 인스턴스나 클래스에 접근하지 않는 메서드입니다. 클래스를 첫 번째 인자로 받는 메서드입니다. --- 참고: Python 내장 를 사용하면 더 편리합니다. --- 여러 데코레이터를 동시에 적용할 수 있습니다. 적용 순서는 아래에서 위입니다. --- 클래스 전체에 데코레이터를 적용할 수 있습니다. --- | 패턴 | 설명 | 예시 | |------|------|------| | 기본 데코레이터 | 함수를 감싸서 기능 추가 | | | 인자 있는 데코레이터 |...", "url": "/study/ko/Python/02_Decorators.html"}, {"id": "Python/03_Context_Managers", "title": "컨텍스트 매니저 (Context Managers)", "topic": "Python", "topic_display": "Python", "body": "컨텍스트 매니저는 문과 함께 사용되어 리소스의 설정(setup)과 정리(cleanup)를 자동으로 처리합니다. --- 와 메서드를 구현합니다. 출력: --- 메서드는 예외 정보를 받아 처리할 수 있습니다. | 매개변수 | 설명 | |----------|------| | exctype | 예외 클래스 (예: ) | | excval | 예외 인스턴스 | | exctb | 트레이스백 객체 | 예외가 없으면 모두 입니다. 출력: --- 제너레이터 함수로 컨텍스트 매니저를 간단히 만들 수 있습니다. 출력: --- 여러 컨텍스트 매니저를 동적으로 관리합니다. --- --- --- 를 사용하려면 와 를 구현합니다. --- | 방법 | 사용 시점 | |------|----------| | 클래스 (, ) | 상태 관리가 필요할 때 | | | 간단한 설정/정리 로직 | | | 특정 예외 무시 | | | 출력 리다이렉트 | | | 동적 컨텍스트 관리 | | | close() 메서드 자동 호출 |...", "url": "/study/ko/Python/03_Context_Managers.html"}, {"id": "Python/04_Iterators_and_Generators", "title": "이터레이터와 제너레이터 (Iterators & Generators)", "topic": "Python", "topic_display": "Python", "body": "| 용어 | 설명 | 예시 | |------|------|------| | Iterable | 메서드가 있는 객체 | list, str, dict, set | | Iterator | 와 메서드가 있는 객체 | iter(list), 파일 객체 | --- 재사용 가능한 이터러블을 만들려면 분리가 필요합니다. --- 키워드를 사용하면 간단하게 이터레이터를 만들 수 있습니다. --- 리스트 컴프리헨션과 비슷하지만 괄호를 사용합니다. --- 다른 이터러블의 값을 위임합니다. --- 제너레이터에 값을 보낼 수 있습니다. --- 효율적인 이터레이터 도구를 제공합니다. --- 제너레이터는 값을 미리 계산하지 않고 필요할 때 생성합니다. --- --- | 개념 | 설명 | |------|------| | Iterable | 구현, for문에 사용 가능 | | Iterator | + 구현 | | Generator | 를 사용하는 함수 | | Generator Expression | | | | 다른...", "url": "/study/ko/Python/04_Iterators_and_Generators.html"}, {"id": "Python/05_Closures_and_Scope", "title": "클로저와 스코프 (Closures & Scope)", "topic": "Python", "topic_display": "Python", "body": "파이썬에서 변수는 정의된 위치에 따라 접근 범위가 결정됩니다. 변수를 찾는 순서입니다. --- 함수 내에서 전역 변수를 수정할 때 사용합니다. --- 감싸는 함수의 변수를 수정할 때 사용합니다. --- 클로저는 자신이 정의된 환경(스코프)을 기억하는 함수입니다. 1. 중첩 함수가 있어야 함 2. 내부 함수가 외부 함수의 변수를 참조 3. 외부 함수가 내부 함수를 반환 --- --- 같은 기능을 클로저와 클래스로 구현할 수 있습니다. | 상황 | 권장 | |------|------| | 단순한 상태 유지 | 클로저 | | 여러 메서드 필요 | 클래스 | | 상속/확장 필요 | 클래스 | | 함수형 스타일 | 클로저 | | 복잡한 상태 관리 | 클래스 | --- --- --- --- | 키워드/개념 | 설명 | |-------------|------| | LEGB | Local → Enclosing → Global → Built-in 순서로 변수 탐색 | | global | 전역 변수...", "url": "/study/ko/Python/05_Closures_and_Scope.html"}, {"id": "Python/06_Metaclasses", "title": "메타클래스 (Metaclasses)", "topic": "Python", "topic_display": "Python", "body": "파이썬에서 모든 것은 객체입니다. 클래스도 예외가 아닙니다. --- 은 클래스를 동적으로 생성할 수 있습니다. --- 메타클래스는 클래스를 생성하는 클래스입니다. | 메서드 | 호출 시점 | 역할 | |--------|----------|------| | | 클래스 객체 생성 전 | 클래스 생성 및 수정 | | | 클래스 객체 생성 후 | 클래스 초기화 | --- --- 메타클래스 없이 서브클래스 생성을 가로챌 수 있습니다. --- 제네릭 문법을 지원하게 합니다. --- 메타클래스도 상속됩니다. --- 인스턴스 생성을 제어합니다. --- 1. ORM 프레임워크 - 모델 클래스 자동 등록 2. 플러그인 시스템 - 플러그인 자동 발견 3. API 프레임워크 - 엔드포인트 자동 등록 4. 검증 프레임워크 - 클래스 정의 시 검증 > \"메타클래스가 필요한지 고민된다면, 필요 없는 것이다.\" > — Tim Peters - 간단한 로직은 데코레이터로 충분 - 로 해결되는 경우 - 코드...", "url": "/study/ko/Python/06_Metaclasses.html"}, {"id": "Python/07_Descriptors", "title": "디스크립터 (Descriptors)", "topic": "Python", "topic_display": "Python", "body": "디스크립터는 속성 접근을 커스터마이징하는 객체입니다. , , 중 하나 이상을 구현합니다. --- | 종류 | 메서드 | 우선순위 | |------|--------|----------| | 데이터 디스크립터 | + | 높음 (인스턴스 dict 보다 우선) | | 비데이터 디스크립터 | 만 | 낮음 (인스턴스 dict 보다 후순위) | --- --- 는 디스크립터로 구현되어 있습니다. --- --- 디스크립터가 클래스에 할당될 때 이름을 자동으로 받습니다. --- --- 참고: Python 3.8+에서는 사용 가능 --- 함수는 비데이터 디스크립터입니다. --- --- | 개념 | 설명 | |------|------| | 디스크립터 | 속성 접근을 커스터마이징하는 객체 | | | 속성 읽기 | | | 속성 쓰기 | | | 속성 삭제 | | | 속성 이름 자동 설정 (3.6+) | | 데이터 디스크립터 | + | | 비데이터 디스크립터 | 만 | --- 한 번 설정되면 수정할 수 없는...", "url": "/study/ko/Python/07_Descriptors.html"}, {"id": "Python/08_Async_Programming", "title": "비동기 프로그래밍 (Async Programming)", "topic": "Python", "topic_display": "Python", "body": "작업이 순차적으로 실행되며, 하나가 끝나야 다음이 시작됩니다. I/O 대기 중에 다른 작업을 수행할 수 있습니다. --- 는 코루틴, Task, Future를 기다립니다. --- --- 코루틴을 태스크로 래핑하여 동시 실행을 예약합니다. 출력: --- 여러 코루틴을 동시에 실행하고 모든 결과를 기다립니다. 예외가 발생해도 다른 태스크는 계속 실행됩니다. 태스크 집합을 기다리며 더 세밀한 제어가 가능합니다. 완료되는 순서대로 결과를 받습니다. --- --- 를 사용합니다. --- 를 사용합니다. --- --- 동기 함수를 비동기적으로 실행합니다. --- --- --- | 개념 | 설명 | |------|------| | | 코루틴 정의 | | | 코루틴 실행 대기 | | | 이벤트 루프 실행 | | | 태스크 생성 | | | 여러 코루틴 동시 실행 | | | 세밀한 태스크 관리 | | | 비동기 컨텍스트 매니저 | | | 비동기 이터레이션 | | | 동시 실행 제한 | --- 여러...", "url": "/study/ko/Python/08_Async_Programming.html"}, {"id": "Python/09_Functional_Programming", "title": "함수형 프로그래밍 (Functional Programming)", "topic": "Python", "topic_display": "Python", "body": "함수형 프로그래밍은 순수 함수와 불변 데이터를 중심으로 프로그램을 구성하는 패러다임입니다. | 원칙 | 설명 | |------|------| | 순수 함수 | 같은 입력 → 같은 출력, 부작용 없음 | | 불변성 | 데이터를 변경하지 않고 새로 생성 | | 일급 함수 | 함수를 값처럼 전달/반환 | | 선언적 | \"어떻게\"보다 \"무엇을\" 기술 | --- 파이썬에서 함수는 일급 객체입니다. --- 함수를 인자로 받거나 함수를 반환하는 함수입니다. 모든 요소에 함수를 적용합니다. 조건을 만족하는 요소만 선택합니다. 요소들을 누적하여 단일 값으로 줄입니다. --- 익명 함수를 간결하게 정의합니다. --- 함수형 프로그래밍을 위한 도구 모음입니다. 함수의 일부 인자를 고정합니다. 함수 결과를 캐싱합니다. 무제한 캐시 (lrucache(maxsize=None)와 동일). 타입에 따라 다른 함수를 호출합니다. --- 연산자를 함수로 사용할 수 있게 합니다. --- --- 파이썬스러운 함수형...", "url": "/study/ko/Python/09_Functional_Programming.html"}, {"id": "Python/10_Performance_Optimization", "title": "성능 최적화 (Performance Optimization)", "topic": "Python", "topic_display": "Python", "body": "최적화 전에 반드시 측정하세요. \"추측하지 말고 측정하라.\" --- --- 출력: --- | 연산 | list | dict | set | |------|------|------|-----| | 인덱스 접근 | O(1) | - | - | | 검색 (in) | O(n) | O(1) | O(1) | | 삽입 (끝) | O(1) | O(1) | O(1) | | 삽입 (중간) | O(n) | - | - | | 삭제 | O(n) | O(1) | O(1) | --- --- --- --- 클래스 인스턴스의 메모리 사용량을 줄입니다. --- --- 과학 계산에서 성능 향상을 제공합니다. --- 파이썬을 C로 컴파일하여 성능을 높입니다. --- 1. 측정 먼저: 추측하지 말고 프로파일링 2. 병목 찾기: 전체의 20%가 80% 시간 소모 3. 알고리즘 개선: 자료구조와 알고리즘이 가장 중요 4. 가독성 유지: 과도한 최적화는 금물 | 항목 | 방법 | |------|------| | 멤버십 테스트...", "url": "/study/ko/Python/10_Performance_Optimization.html"}, {"id": "Python/11_Testing_and_Quality", "title": "11. 테스트 및 품질 관리 (Testing & Quality Assurance)", "topic": "Python", "topic_display": "Python", "body": "- pytest 프레임워크의 기본과 고급 기능 마스터 - 효과적인 테스트 작성 패턴 이해 - 모킹(Mocking)을 활용한 격리 테스트 - 코드 커버리지 측정 및 개선 - 테스트 자동화와 CI/CD 통합 1. pytest 기초 2. Fixtures 3. Parametrize 4. Mocking 5. 커버리지 6. 테스트 패턴 7. 연습 문제 --- --- --- --- --- --- --- 다음 함수에 대한 테스트를 작성하세요. 데이터베이스 연결 fixture를 작성하고 사용하세요. 외부 API를 호출하는 함수를 모킹하여 테스트하세요. --- - 12. 패키징 및 배포 - 13. 데이터클래스 - pytest Documentation - pytest-mock - pytest-cov - unittest.mock", "url": "/study/ko/Python/11_Testing_and_Quality.html"}, {"id": "Python/12_Packaging_and_Distribution", "title": "12. 패키징 및 배포 (Packaging & Distribution)", "topic": "Python", "topic_display": "Python", "body": "- Python 패키지 구조와 표준 이해 - pyproject.toml을 활용한 현대적 패키지 설정 - Poetry를 활용한 의존성 관리 - PyPI 배포 과정 이해 - 버전 관리 및 릴리스 자동화 1. 패키지 구조 2. pyproject.toml 3. 의존성 관리 4. Poetry 활용 5. PyPI 배포 6. 버전 관리 7. 연습 문제 --- --- --- --- --- --- --- 간단한 유틸리티 패키지의 pyproject.toml을 작성하세요. Poetry로 새 프로젝트를 생성하고 의존성을 관리하세요. CLI 도구를 만들고 pyproject.toml에 등록하세요. --- - 13. 데이터클래스 - 14. 패턴 매칭 - Python Packaging User Guide - PEP 621 - Project Metadata - Poetry Documentation - Semantic Versioning - Keep a Changelog", "url": "/study/ko/Python/12_Packaging_and_Distribution.html"}, {"id": "Python/13_Dataclasses", "title": "13. 데이터클래스 (Dataclasses)", "topic": "Python", "topic_display": "Python", "body": "- dataclasses 모듈의 목적과 장점 이해 - @dataclass 데코레이터와 옵션 마스터 - field() 함수를 활용한 고급 필드 설정 - 상속, 불변성, 슬롯 등 고급 기능 활용 - Pydantic과의 비교 및 선택 기준 이해 1. 데이터클래스 기초 2. @dataclass 옵션 3. field() 함수 4. 고급 기능 5. 상속과 조합 6. Pydantic 비교 7. 연습 문제 --- --- --- --- --- --- --- 불변(frozen) 설정 클래스를 작성하세요. 면적과 둘레를 자동 계산하는 Circle 클래스를 작성하세요. 중첩된 데이터클래스를 JSON으로 직렬화/역직렬화하세요. --- - 14. 패턴 매칭 - 11. 테스트 및 품질 관리 - Python dataclasses Documentation - PEP 557 - Data Classes - Pydantic Documentation - attrs Library (대안)", "url": "/study/ko/Python/13_Dataclasses.html"}, {"id": "Python/14_Pattern_Matching", "title": "14. 패턴 매칭 (Pattern Matching)", "topic": "Python", "topic_display": "Python", "body": "- Python 3.10+ match/case 문법 이해 - 다양한 패턴 유형 마스터 - 구조적 패턴 매칭 활용 - 가드와 OR 패턴 사용 - 실무 활용 패턴 학습 1. 패턴 매칭 기초 2. 리터럴 패턴 3. 구조적 패턴 4. 클래스 패턴 5. 가드와 OR 패턴 6. 실전 활용 7. 연습 문제 --- --- --- --- --- --- --- 다양한 도형의 면적을 계산하는 함수를 작성하세요. 간단한 HTTP 요청 라우터를 구현하세요. 트리 구조를 패턴 매칭으로 순회하세요. --- - 11. 테스트 및 품질 관리 - 13. 데이터클래스 - PEP 634 - Structural Pattern Matching - PEP 635 - Motivation and Rationale - PEP 636 - Tutorial - Python 3.10 What's New", "url": "/study/ko/Python/14_Pattern_Matching.html"}, {"id": "Python/15_Python_Basics", "title": "파이썬 기초 문법", "topic": "Python", "topic_display": "Python", "body": "> 참고: 이 레슨은 선수 지식 복습용입니다. 고급 레슨을 시작하기 전에 기초가 부족하다면 이 내용을 먼저 학습하세요. - 파이썬 기본 자료형과 연산자 이해 - 제어문 (조건문, 반복문) 활용 - 함수 정의와 호출 방법 습득 - 자료구조 (리스트, 딕셔너리, 튜플, 세트) 활용 --- --- --- --- --- --- --- --- | 개념 | 설명 | 예시 | |------|------|------| | 변수 | 값을 저장하는 이름 | | | 자료형 | int, float, str, bool, None | | | 리스트 | 순서 있는 가변 시퀀스 | | | 튜플 | 순서 있는 불변 시퀀스 | | | 딕셔너리 | 키-값 쌍 | | | 세트 | 중복 없는 집합 | | | if/elif/else | 조건 분기 | | | for | 시퀀스 순회 | | | while | 조건 반복 | | | 함수 | 재사용 가능한 코드 블록 | | | 예외 처리 | 오류 대응 | | 이 기초를 마쳤다면...", "url": "/study/ko/Python/15_Python_Basics.html"}, {"id": "Python/16_OOP_Basics", "title": "객체지향 프로그래밍 기초", "topic": "Python", "topic_display": "Python", "body": "> 참고: 이 레슨은 선수 지식 복습용입니다. 고급 레슨(데코레이터, 메타클래스 등)을 시작하기 전에 OOP 기초가 부족하다면 이 내용을 먼저 학습하세요. - 클래스와 객체(인스턴스)의 개념 이해 - 생성자, 인스턴스/클래스 변수, 메서드 활용 - 상속, 다형성, 캡슐화 원리 파악 - 특수 메서드(매직 메서드) 기본 활용 --- --- --- --- --- --- --- --- | 개념 | 설명 | |------|------| | 클래스 | 객체의 설계도 | | 객체/인스턴스 | 클래스로 생성된 실체 | | | 생성자, 초기화 메서드 | | | 현재 인스턴스 참조 | | 상속 | 부모 클래스의 속성/메서드 물려받기 | | 오버라이딩 | 부모 메서드 재정의 | | 캡슐화 | 데이터 보호, 접근 제어 | | 다형성 | 같은 인터페이스, 다른 동작 | | 추상 클래스 | 미완성 메서드를 가진 기반 클래스 | | 형식 | 의미 | 예시 | |------|------|------| | |...", "url": "/study/ko/Python/16_OOP_Basics.html"}, {"id": "Reinforcement_Learning/00_Overview", "title": "강화학습 (Reinforcement Learning) Overview", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "이 폴더는 강화학습(Reinforcement Learning, RL)의 기초부터 심화까지 체계적으로 학습할 수 있는 자료를 담고 있습니다. 에이전트가 환경과 상호작용하며 보상을 최대화하는 방법을 학습하는 RL의 핵심 개념과 알고리즘을 다룹니다. - 머신러닝/딥러닝 기초를 이해하고 있는 학습자 - 게임 AI, 로봇공학, 자율주행 등에 관심 있는 개발자 - AlphaGo, ChatGPT(RLHF) 등의 기술 원리를 이해하고 싶은 분 - 필수: Python 프로그래밍, 기초 확률/통계 - 권장: DeepLearning 폴더 학습 완료, PyTorch 기초 --- --- | 번호 | 파일명 | 주제 | 난이도 | 주요 내용 | |:---:|--------|------|:------:|----------| | 00 | Overview.md | 개요 | - | 학습 안내, 로드맵, 환경 설정 | | 01 | RLIntroduction.md | RL 개요 | ⭐ | 에이전트-환경, 보상,...", "url": "/study/ko/Reinforcement_Learning/00_Overview.html"}, {"id": "Reinforcement_Learning/01_RL_Introduction", "title": "01. 강화학습 개요 (Introduction to Reinforcement Learning)", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐ (입문) - 강화학습의 정의와 특징 이해 - 에이전트-환경 상호작용 패러다임 파악 - 보상, 에피소드, 연속 태스크의 개념 학습 - 지도학습/비지도학습과의 차이 이해 --- 강화학습(Reinforcement Learning, RL)은 에이전트(Agent)가 환경(Environment)과 상호작용하면서 보상(Reward)을 최대화하는 행동 방식을 학습하는 기계학습의 한 분야입니다. 1. 시행착오 학습 (Trial and Error): 직접 행동해보고 결과로부터 학습 2. 지연된 보상 (Delayed Reward): 즉각적 보상뿐 아니라 미래 보상도 고려 3. 탐험과 활용 (Exploration vs Exploitation): 새로운 시도와 기존 지식 활용 사이의 균형 4. 순차적 의사결정 (Sequential Decision Making): 연속된 결정들의 누적 효과 고려 | 특성 | 지도학습 | 비지도학습 | 강화학습 |...", "url": "/study/ko/Reinforcement_Learning/01_RL_Introduction.html"}, {"id": "Reinforcement_Learning/02_MDP_Basics", "title": "02. 마르코프 결정 과정 (Markov Decision Process)", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐ (기초) - 마르코프 성질과 MDP의 정의 이해 - 상태 가치 함수 V(s)와 행동 가치 함수 Q(s,a) 이해 - 벨만 기대 방정식과 최적성 방정식 유도 및 해석 - 최적 정책의 존재성과 특성 파악 --- 마르코프 성질: 미래는 오직 현재 상태에만 의존하고, 과거 이력에는 독립적입니다. $$P(S{t+1} | St) = P(S{t+1} | S1, S2, \\ldots, St)$$ 마르코프 성질을 만족하려면 상태가 충분한 정보를 담아야 합니다. --- MDP는 튜플 $(S, A, P, R, \\gamma)$로 정의됩니다. | 요소 | 기호 | 설명 | |------|------|------| | 상태 공간 | $S$ | 가능한 모든 상태의 집합 | | 행동 공간 | $A$ | 가능한 모든 행동의 집합 | | 전이 확률 | $P$ | $P(s'|s, a)$ - 상태 전이 확률 | | 보상 함수 | $R$ | $R(s, a, s')$ - 즉각 보상 | | 할인율 |...", "url": "/study/ko/Reinforcement_Learning/02_MDP_Basics.html"}, {"id": "Reinforcement_Learning/03_Dynamic_Programming", "title": "03. 동적 프로그래밍 (Dynamic Programming)", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐ (기초) - 동적 프로그래밍(DP)의 기본 개념 이해 - 정책 평가 (Policy Evaluation) 알고리즘 구현 - 정책 반복 (Policy Iteration) 알고리즘 이해 및 구현 - 가치 반복 (Value Iteration) 알고리즘 이해 및 구현 - DP 방법의 한계점 파악 --- 동적 프로그래밍(Dynamic Programming, DP)은 복잡한 문제를 더 작은 부분 문제로 나누어 해결하는 방법입니다. RL에서 DP는 완전한 환경 모델(MDP)을 알고 있을 때 최적 정책을 계산합니다. 1. 최적 부분 구조: 최적 해가 부분 문제의 최적 해로 구성됨 2. 중복 부분 문제: 같은 부분 문제가 여러 번 계산됨 3. 메모이제이션: 계산 결과를 저장하여 재사용 | 필요 조건 | 설명 | |-----------|------| | 완전한 MDP | 전이 확률 P(s'|s,a)를 알아야 함 | | 유한 상태/행동 | 테이블로 저장 가능해야 함 | | 계산 자원 |...", "url": "/study/ko/Reinforcement_Learning/03_Dynamic_Programming.html"}, {"id": "Reinforcement_Learning/04_Monte_Carlo_Methods", "title": "04. 몬테카를로 방법 (Monte Carlo Methods)", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐ (기초) - 몬테카를로(MC) 방법의 기본 개념 이해 - 모델 프리(Model-Free) 학습의 의미 파악 - First-visit MC와 Every-visit MC의 차이 이해 - MC 정책 평가 및 제어 알고리즘 구현 - 탐험의 중요성과 해결 방법 학습 --- 몬테카를로(Monte Carlo, MC) 방법은 실제 경험(에피소드)으로부터 가치 함수를 추정하는 방법입니다. 환경 모델 없이 학습하는 모델 프리(Model-Free) 방법입니다. | 특성 | 동적 프로그래밍 (DP) | 몬테카를로 (MC) | |------|---------------------|-----------------| | 환경 모델 | 필요 (P, R 알아야 함) | 불필요 | | 학습 방식 | 계산 (부트스트래핑) | 샘플링 (경험) | | 업데이트 시점 | 매 스텝 가능 | 에피소드 종료 후 | | 적용 환경 | 에피소딕/연속 | 에피소딕만 | $$V(s) \\approx...", "url": "/study/ko/Reinforcement_Learning/04_Monte_Carlo_Methods.html"}, {"id": "Reinforcement_Learning/05_TD_Learning", "title": "05. 시간차 학습 (Temporal Difference Learning)", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐⭐ (중급) - TD 학습의 기본 개념과 TD(0) 알고리즘 이해 - TD Target과 부트스트래핑 개념 파악 - TD와 MC, DP의 차이점 비교 - TD의 편향-분산 트레이드오프 이해 - n-step TD와 TD(λ) 학습 --- 시간차 학습(Temporal Difference, TD)은 DP의 부트스트래핑과 MC의 샘플링을 결합한 방법입니다. | 특성 | DP | MC | TD | |------|-----|-----|-----| | 환경 모델 | 필요 | 불필요 | 불필요 | | 부트스트래핑 | O | X | O | | 샘플링 | X | O | O | | 업데이트 시점 | 매 스텝 | 에피소드 종료 | 매 스텝 | | 연속 태스크 | O | X | O | | 편향 | O | X | O | | 분산 | 낮음 | 높음 | 중간 | --- TD(0)는 다음 상태의 추정값을 사용하여 현재 상태의 가치를 업데이트합니다. TD Target: $R{t+1} + \\gamma...", "url": "/study/ko/Reinforcement_Learning/05_TD_Learning.html"}, {"id": "Reinforcement_Learning/06_Q_Learning_SARSA", "title": "06. Q-Learning과 SARSA", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐⭐ (중급) - Q-Learning의 원리와 off-policy 특성 이해 - SARSA의 원리와 on-policy 특성 이해 - Q-Learning vs SARSA 차이점 비교 - Epsilon-greedy 탐색 전략 구현 - 수렴 조건과 실전 적용 팁 --- 상태-행동 쌍의 가치를 평가하는 함수입니다. $$Q(s, a) = \\mathbb{E}[Gt | St = s, At = a]$$ --- Off-Policy: 행동 정책(behavior policy)과 타겟 정책(target policy)이 다름 - 행동 정책: ε-greedy (탐색용) - 타겟 정책: greedy (학습용) --- On-Policy: 행동 정책과 타겟 정책이 동일 이름의 유래: State, Action, Reward, State, Action 여기서 a'는 실제로 선택될 다음 행동입니다. --- | 특성 | Q-Learning | SARSA |...", "url": "/study/ko/Reinforcement_Learning/06_Q_Learning_SARSA.html"}, {"id": "Reinforcement_Learning/07_Deep_Q_Network", "title": "07. Deep Q-Network (DQN)", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐⭐ (중급) - DQN의 핵심 아이디어와 구조 이해 - Experience Replay의 원리와 구현 - Target Network의 필요성과 동작 방식 - Double DQN, Dueling DQN 등 개선 기법 - PyTorch로 DQN 구현 --- --- 경험을 버퍼에 저장하고 무작위로 샘플링하여 학습합니다. 장점: - 데이터 효율성 향상 (경험 재사용) - 연속 샘플의 상관관계 제거 - 학습 안정화 별도의 타겟 네트워크를 사용하여 학습 안정화합니다. 문제: Q(s,a;θ) 업데이트 시 타겟 y = r + γ max Q(s',a';θ)도 변함 해결: 타겟 네트워크 θ⁻를 고정하고 주기적으로 업데이트 --- --- 일반 DQN의 Q값 과대추정 문제를 해결합니다. Q 함수를 V(상태 가치)와 A(어드밴티지)로 분해합니다. TD 오류가 큰 경험을 더 자주 샘플링합니다. --- --- --- | 기법 | 목적 | 핵심 아이디어 |...", "url": "/study/ko/Reinforcement_Learning/07_Deep_Q_Network.html"}, {"id": "Reinforcement_Learning/08_Policy_Gradient", "title": "08. 정책 경사 (Policy Gradient)", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐⭐⭐ (고급) - 정책 기반 방법의 장단점 이해 - 정책 경사 정리 (Policy Gradient Theorem) 유도 - REINFORCE 알고리즘 구현 - Baseline을 통한 분산 감소 기법 - Actor-Critic으로의 연결 --- | 특성 | 가치 기반 (DQN) | 정책 기반 | |------|----------------|----------| | 학습 대상 | Q(s, a) | π(a\\|s) | | 정책 도출 | Q에서 간접 유도 | 직접 학습 | | 행동 공간 | 이산 (주로) | 이산 + 연속 | | 확률적 정책 | 어려움 | 자연스러움 | | 수렴 | 불안정 가능 | 지역 최적 | --- --- 정책 πθ의 성능을 최대화: $$J(\\theta) = \\mathbb{E}{\\tau \\sim \\pi\\theta} [R(\\tau)]$$ 여기서 τ = (s₀, a₀, r₀, s₁, a₁, r₁, ...) 는 궤적(trajectory) $$\\nabla\\theta...", "url": "/study/ko/Reinforcement_Learning/08_Policy_Gradient.html"}, {"id": "Reinforcement_Learning/09_Actor_Critic", "title": "09. Actor-Critic 방법론", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐⭐⭐ (고급) - Actor-Critic 아키텍처 이해 - Advantage 함수와 GAE 학습 - A2C와 A3C 알고리즘 비교 - PyTorch로 Actor-Critic 구현 --- Actor: 정책 π(a|s;θ)를 학습 Critic: 가치 함수 V(s;w)를 학습 | REINFORCE | Actor-Critic | |-----------|--------------| | 에피소드 종료 후 업데이트 | 매 스텝 업데이트 | | 실제 리턴 G 사용 | TD Target 사용 | | 높은 분산 | 낮은 분산, 약간의 편향 | --- $$A(s, a) = Q(s, a) - V(s)$$ 의미: 평균보다 얼마나 좋은 행동인가 TD Error는 Advantage의 불편 추정량입니다. --- --- | n | 편향 | 분산 | |---|------|------| | 1 (TD) | 높음 | 낮음 | | ∞ (MC) | 낮음 | 높음 | 모든 n-step advantage를...", "url": "/study/ko/Reinforcement_Learning/09_Actor_Critic.html"}, {"id": "Reinforcement_Learning/10_PPO_TRPO", "title": "10. PPO와 TRPO", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐⭐⭐ (고급) - 정책 업데이트의 안정성 문제 이해 - TRPO의 신뢰 영역 개념 학습 - PPO의 클리핑 메커니즘 이해 - PyTorch로 PPO 구현 --- 정책 경사에서 너무 큰 업데이트는 성능을 급격히 저하시킬 수 있습니다. - TRPO: KL divergence로 신뢰 영역 제한 (복잡) - PPO: Clipping으로 간단하게 제한 --- 새 정책과 이전 정책의 비율을 사용: $$L^{CPI}(\\theta) = \\mathbb{E}\\left[\\frac{\\pi\\theta(a|s)}{\\pi{\\theta{old}}(a|s)} A^{\\pi{old}}(s, a)\\right]$$ $$\\text{maximize}\\theta \\quad L^{CPI}(\\theta)$$ $$\\text{subject to} \\quad \\mathbb{E}[D{KL}(\\pi{\\theta{old}} || \\pi\\theta)] \\leq \\delta$$ - 2차 미분(Hessian) 계산 필요 -...", "url": "/study/ko/Reinforcement_Learning/10_PPO_TRPO.html"}, {"id": "Reinforcement_Learning/11_Multi_Agent_RL", "title": "11. 다중 에이전트 강화학습 (Multi-Agent RL)", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐⭐⭐ (고급) - 다중 에이전트 환경의 특성 이해 - 협력, 경쟁, 혼합 시나리오 구분 - 중앙집중/분산 학습 패러다임 - MARL 알고리즘: IQL, QMIX, MAPPO --- | 특성 | 단일 에이전트 | 다중 에이전트 | |------|-------------|--------------| | 환경 | 정적 (에이전트 관점) | 동적 (다른 에이전트) | | 보상 | 개인 보상 | 개인/팀/글로벌 | | 최적성 | 최적 정책 존재 | 내쉬 균형 추구 | | 학습 | 정상성 가정 | 비정상성 (이동 타겟) | --- 다른 에이전트도 학습하므로 환경이 계속 변합니다. 팀 보상에서 개인 기여도를 파악하기 어렵습니다. 에이전트 수가 늘면 상태-행동 공간이 기하급수적으로 증가합니다. --- Centralized Training, Decentralized Execution 각 에이전트가 독립적으로 학습합니다. --- 각 에이전트가 다른 에이전트를 환경의 일부로 취급합니다....", "url": "/study/ko/Reinforcement_Learning/11_Multi_Agent_RL.html"}, {"id": "Reinforcement_Learning/12_Practical_RL_Project", "title": "12. 실전 RL 프로젝트", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐⭐⭐ (고급) - Gymnasium 환경 사용법 숙달 - 완전한 RL 프로젝트 구조 이해 - 학습 모니터링과 디버깅 기법 - Atari 게임 에이전트 구현 - 학습된 모델 저장과 평가 --- --- --- --- --- --- --- --- | 문제 | 원인 | 해결책 | |------|------|--------| | 보상이 증가하지 않음 | 학습률 너무 높음/낮음 | 학습률 그리드 서치 | | 학습 불안정 | 그래디언트 폭발 | 그래디언트 클리핑 | | 갑작스러운 성능 저하 | 정책 급변 | clipepsilon 감소 | | 메모리 부족 | 버퍼 크기 | 배치 크기 조정 | --- 프로젝트 체크리스트: - [ ] 환경 설정 및 테스트 - [ ] 네트워크 아키텍처 정의 - [ ] 에이전트 구현 - [ ] 학습 루프 작성 - [ ] 로깅 설정 - [ ] 하이퍼파라미터 튜닝 - [ ] 모델 저장/로드 - [ ] 평가 및 시각화 핵심 도구:** - Gymnasium: 환경...", "url": "/study/ko/Reinforcement_Learning/12_Practical_RL_Project.html"}, {"id": "Reinforcement_Learning/13_Model_Based_RL", "title": "13. 모델 기반 강화학습(Model-Based Reinforcement Learning)", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐⭐⭐ (고급) - 모델 프리(model-free)와 모델 기반(model-based) 강화학습의 차이 이해 - 학습된 모델을 사용한 계획(planning)을 위한 Dyna 아키텍처 구현 - 세계 모델(world model) 접근법 학습 (Dreamer, MuZero) - 모델 기반 정책 최적화(Model-Based Policy Optimization, MBPO) 적용 - 모델 기반 방법이 모델 프리 방법을 능가하는 경우 이해 --- 1. 모델 프리 vs 모델 기반 강화학습 2. Dyna 아키텍처 3. 세계 모델 학습 4. 모델 기반 정책 최적화(MBPO) 5. MuZero: 알려진 모델 없이 계획하기 6. Dreamer: 연속 제어를 위한 세계 모델 7. 연습 문제 --- --- --- --- --- --- --- Dyna-Q를 구현하고 서로 다른 계획 단계(n=0, 5, 50)에서 성능을 비교하세요. CartPole에서 신경망 동역학 모델을 학습하고 예측 정확도를...", "url": "/study/ko/Reinforcement_Learning/13_Model_Based_RL.html"}, {"id": "Reinforcement_Learning/14_Soft_Actor_Critic", "title": "14. Soft Actor-Critic (SAC)", "topic": "Reinforcement_Learning", "topic_display": "Reinforcement Learning", "body": "난이도: ⭐⭐⭐⭐ (고급) - 최대 엔트로피 강화학습(maximum entropy reinforcement learning) 이해 - 연속 행동 공간을 위한 SAC 알고리즘 구현 - 자동 온도(alpha) 튜닝 학습 - SAC와 PPO, TD3 비교 - 실용적인 연속 제어 태스크에 SAC 적용 --- 1. 최대 엔트로피 강화학습 2. SAC 알고리즘 3. SAC 구현 4. 자동 온도 튜닝 5. SAC vs 다른 알고리즘 6. 실용적 팁 7. 연습 문제 --- --- --- --- --- --- --- 에서 SAC를 학습하고 학습 곡선을 그리세요. 연속 제어 태스크에서 SAC와 PPO를 모두 학습하고 샘플 효율성을 비교하세요. 다음 변형으로 SAC를 실행하고 비교하세요: 1. 고정 alpha = 0.2 (자동 튜닝 없음) 2. 자동 alpha (기본값) 3. 엔트로피 항 없음 (alpha = 0, TD3와 유사) 4. 단일 Q-네트워크 (트윈 크리틱 없음) 커스텀 연속 제어 태스크에...", "url": "/study/ko/Reinforcement_Learning/14_Soft_Actor_Critic.html"}, {"id": "Security/00_Overview", "title": "Security", "topic": "Security", "topic_display": "Security", "body": "이 토픽은 웹 보안, 암호학, 그리고 안전한 소프트웨어 개발 관행을 다룹니다. CIA Triad와 Threat Modeling 같은 기본 개념부터 안전한 API와 취약점 스캐너를 구축하는 실습 프로젝트까지, 이 레슨들은 애플리케이션 보안에 대한 포괄적인 기초를 제공합니다. - Python 중급 수준 (함수, 클래스, 데코레이터) - HTTP와 웹 개발에 대한 기본 이해 - 커맨드라인 도구 사용 경험 - 기본 네트워킹 개념 (TCP/IP, DNS) | 파일명 | 난이도 | 주요 주제 | 비고 | |----------|------------|------------|-------| | 01SecurityFundamentals.md | ⭐ | CIA Triad, Threat Modeling, STRIDE, Defense in Depth | 개념적 기초 | | 02CryptographyBasics.md | ⭐⭐ | AES, RSA, ECDSA, Key Exchange, Digital...", "url": "/study/ko/Security/00_Overview.html"}, {"id": "Security/01_Security_Fundamentals", "title": "Security 기초와 Threat Modeling", "topic": "Security", "topic_display": "Security", "body": "다음: 02. Cryptography 기초 --- 보안 엔지니어링은 악의, 오류, 사고에 직면하여 신뢰할 수 있는 시스템을 구축하는 학문입니다. 암호학이나 TLS 같은 구체적인 기술에 들어가기 전에, 위협, 위험, 방어에 대해 논의하기 위한 공통된 용어가 필요합니다. 이 레슨은 모든 후속 레슨이 기반으로 하는 개념적 기초를 확립합니다. 난이도: ⭐⭐ 학습 목표: - CIA Triad와 확장된 보안 속성 이해하기 - 실제 시스템에 Threat Modeling 방법론(STRIDE, DREAD) 적용하기 - 소프트웨어 아키텍처에서 공격 표면과 위협 벡터 식별하기 - Defense-in-depth 원칙을 사용하여 계층적 방어 설계하기 - 시스템 설계에서 최소 권한 원칙 적용하기 - Security by design과 security by obscurity 구별하기 - 표준 프레임워크를 사용하여 기본 위험 평가 수행하기 - Common Vulnerability Scoring...", "url": "/study/ko/Security/01_Security_Fundamentals.html"}, {"id": "Security/02_Cryptography_Basics", "title": "Cryptography 기초", "topic": "Security", "topic_display": "Security", "body": "이전: 01. Security 기초 | 다음: 03. Hashing과 데이터 무결성 --- 암호학은 의도된 당사자만 접근할 수 있도록 통신과 데이터를 보호하는 관행입니다. 이 레슨은 현대 암호학의 두 가지 주요 분야인 대칭 및 비대칭 암호화와 키 교환 프로토콜, 디지털 서명, 그리고 실용적인 Python 구현을 다룹니다. 이 레슨이 끝나면 주어진 문제에 대해 올바른 암호화 기본 요소를 선택하고 가장 일반적인 함정을 피할 수 있게 됩니다. 난이도: ⭐⭐⭐ 학습 목표: - 대칭 및 비대칭 암호화의 차이점 이해하기 - Python에서 AES-GCM과 ChaCha20-Poly1305 암호화 구현하기 - 비대칭 암호학을 위한 RSA, ECDSA, Ed25519 이해하기 - Diffie-Hellman과 ECDH 키 교환 구현하기 - 디지털 서명 생성 및 검증하기 - 일반적인 암호학적 함정 인식하고 피하기 - 현대 암호학 권장 사항 적용하기 --- 1. 암호학 개요 2. 대칭 암호화 3. 블록...", "url": "/study/ko/Security/02_Cryptography_Basics.html"}, {"id": "Security/03_Hashing_and_Integrity", "title": "해싱과 데이터 무결성", "topic": "Security", "topic_display": "Security", "body": "이전: 02. 암호학 기초 | 다음: 04. TLS/SSL과 공개키 인프라 --- 해시 함수는 현대 보안의 핵심 도구입니다. 패스워드 저장, 디지털 서명, 메시지 인증, 블록체인, 소프트웨어 배포, 데이터 중복 제거 등 모든 곳에서 사용됩니다. 이 레슨은 해시 함수의 유용함을 만드는 수학적 속성부터 패스워드 해싱, HMAC, Merkle 트리의 실용적 구현까지 해시 함수를 심도 있게 다룹니다. 난이도: ⭐⭐⭐ 학습 목표: - 암호학적 해시 함수의 속성 이해 - SHA-256, SHA-3, BLAKE2, BLAKE3를 사용한 해싱 구현 - bcrypt, scrypt, Argon2를 사용한 안전한 패스워드 저장 - 메시지 인증을 위한 HMAC 구성 및 검증 - Merkle 트리 구축 및 이해 - 내용 주소 지정 저장소 구현 - 상수 시간 비교를 사용한 타이밍 공격 인식 및 방지 --- 1. 해시 함수란 무엇인가? 2. 암호학적 해시 속성 3. 해시 함수 조사 4. hashlib를...", "url": "/study/ko/Security/03_Hashing_and_Integrity.html"}, {"id": "Security/04_TLS_and_PKI", "title": "TLS/SSL과 공개 키 인프라", "topic": "Security", "topic_display": "Security", "body": "이전: 03. 해싱과 데이터 무결성 | 다음: 05. 인증 시스템 --- 전송 계층 보안(TLS)은 HTTPS를 가능하게 하는 프로토콜입니다. 이것은 사실상 모든 웹 트래픽, 이메일, 메시징, VPN, API 통신을 보호합니다. 이 레슨은 TLS 1.3, 인증서 신뢰 모델(PKI), 실용적인 OpenSSL 및 Python 사용, 상호 TLS, 보안을 약화시키는 일반적인 잘못된 구성에 대한 깊이 있는 기술적 안내를 제공합니다. 난이도: ⭐⭐⭐⭐ 학습 목표: - TLS 1.3 핸드셰이크를 단계별로 완전히 이해하기 - 인증서 체인과 신뢰 웹 설명하기 - OpenSSL과 Python을 사용하여 X.509 인증서 작업하기 - 인증 기관과 인증서 발급 이해하기 - ACME 프로토콜로 Let's Encrypt 구성하기 - 인증서 피닝과 상호 TLS(mTLS) 구현하기 - 개발용 자체 서명 인증서 생성하기 - 일반적인 TLS 잘못된 구성 식별 및 수정하기 - 표준 도구를 사용하여 TLS 구성...", "url": "/study/ko/Security/04_TLS_and_PKI.html"}, {"id": "Security/05_Authentication", "title": "05. 인증 시스템", "topic": "Security", "topic_display": "Security", "body": "이전: 04. TLS/SSL 및 공개키 기반 구조 | 다음: 06. 접근 제어 및 권한 부여 --- 인증(Authentication)은 사용자나 시스템이 주장하는 신원을 확인하는 프로세스입니다. \"당신은 누구입니까?\"라는 질문에 답하며, 모든 접근 제어 결정의 기반이 됩니다. 잘못 구현된 인증 시스템은 가장 정교한 권한 부여 및 암호화조차 무용지물로 만들 수 있습니다. 이 강의는 비밀번호 기반 인증, 다중 인증, 토큰 기반 시스템, OAuth 2.0/OIDC, 세션 관리, 생체 인증 방식을 실용적인 Python 예제와 함께 다룹니다. - 솔팅과 키 스트레칭을 사용한 안전한 비밀번호 저장 구현 - 다중 인증(TOTP, FIDO2/WebAuthn) 이해 및 구현 - OAuth 2.0 및 OpenID Connect 인증/권한 부여 플로우 설명 - 쿠키, 토큰, JWT를 사용한 안전한 세션 관리 - 일반적인 JWT 함정 식별 및 회피 - 안전한 비밀번호 재설정 플로우 설계 - 생체 인증...", "url": "/study/ko/Security/05_Authentication.html"}, {"id": "Security/06_Authorization", "title": "06. 인가 및 접근 제어", "topic": "Security", "topic_display": "Security", "body": "이전: 05. 인증 시스템 | 다음: 07. OWASP Top 10 (2021) --- 인가(Authorization)는 인증된 사용자가 무엇을 할 수 있는지를 결정합니다. 인증이 \"당신은 누구입니까?\"라는 질문에 답한다면, 인가는 \"당신은 무엇을 할 수 있습니까?\"라는 질문에 답합니다. 강력한 인가 시스템은 최소 권한의 원칙을 강제하여, 사용자와 서비스가 필요한 최소한의 권한만 가지도록 보장합니다. 이 레슨에서는 주요 접근 제어 모델(RBAC, ABAC, ACL), 정책 엔진, JWT 및 OAuth 스코프를 사용한 토큰 기반 인가, Python/Flask에서의 실용적인 구현 패턴, 그리고 일반적인 인가 취약점을 다룹니다. - 인증과 인가의 차이점 구분 - 역할 기반 접근 제어(RBAC) 시스템 구현 - 속성 기반 접근 제어(ABAC)와 사용 시점 이해 - 리소스 수준 권한을 위한 접근 제어 목록(ACL) 작업 - 외부화된 인가를 위한 OPA(Open Policy Agent)와...", "url": "/study/ko/Security/06_Authorization.html"}, {"id": "Security/07_OWASP_Top10", "title": "07. OWASP Top 10 (2021)", "topic": "Security", "topic_display": "Security", "body": "이전: 06. 인가와 접근 제어 | 다음: 08. 인젝션 공격과 방어 --- OWASP (Open Worldwide Application Security Project) Top 10은 웹 애플리케이션 보안 위험에 대해 가장 널리 인정받는 문서입니다. 실제 취약점 데이터를 기반으로 주기적으로 업데이트되며, 개발자와 보안 전문가를 위한 표준 인식 문서 역할을 합니다. 2021년 판은 위협 환경의 중대한 변화를 반영하여 세 가지 새로운 카테고리와 주요 재편성이 있습니다. 이 레슨에서는 설명, 실제 사례, 취약한 코드, 수정된 코드, 방어 전략과 함께 열 가지 카테고리 각각을 다룹니다. - OWASP Top 10 (2021) 모든 카테고리 이해하기 - 각 카테고리의 취약한 코드 패턴 식별하기 - 각 취약점 클래스를 방지하는 안전한 코드 작성하기 - 개발 및 코드 리뷰 시 보안 체크리스트로 OWASP Top 10 적용하기 - 각 취약점의 실제 영향 인식하기 --- --- 접근 제어는...", "url": "/study/ko/Security/07_OWASP_Top10.html"}, {"id": "Security/08_Injection_Attacks", "title": "08. 인젝션 공격과 방어", "topic": "Security", "topic_display": "Security", "body": "이전: 07. OWASP Top 10 (2021) | 다음: 09. 웹 보안 헤더와 CSP --- 인젝션 공격은 웹 애플리케이션에서 가장 치명적인 취약점 중 하나로 남아 있습니다. 인젝션은 신뢰할 수 없는 데이터가 명령어나 쿼리의 일부로 인터프리터에 전송되어 의도하지 않은 실행을 초래할 때 발생합니다. 인젝션이 OWASP Top 10에서 1위에서 3위로 내려갔지만, 단일 인젝션 취약점이 완전한 데이터 유출이나 시스템 침해로 이어질 수 있기 때문에 여전히 매우 위험합니다. 이 레슨에서는 SQL injection, Cross-Site Scripting (XSS), Cross-Site Request Forgery (CSRF), command injection, LDAP injection, Server-Side Template Injection (SSTI)에 대한 심층 분석과 각각에 대한 취약한 코드와 안전한 코드 예제를 제공합니다. - 인젝션 취약점의 근본 원인 이해 (코드와 데이터의...", "url": "/study/ko/Security/08_Injection_Attacks.html"}, {"id": "Security/09_Web_Security_Headers", "title": "Web Security Headers와 CSP", "topic": "Security", "topic_display": "Security", "body": "이전: 08. Injection 공격과 방어 | 다음: 10APISecurity.md --- HTTP 보안 헤더는 웹 애플리케이션의 첫 번째 방어선입니다. 브라우저가 보안 정책을 적용하도록 지시하여 크로스 사이트 스크립팅과 클릭재킹부터 프로토콜 다운그레이드 공격 및 데이터 유출까지 전체 공격 유형을 완화합니다. 단일 헤더가 누락되면 잘 작성된 애플리케이션도 취약해질 수 있습니다. 이 레슨은 Flask와 Django의 실용적인 구성 예제와 함께 모든 주요 보안 헤더에 대한 포괄적인 가이드를 제공합니다. - Content-Security-Policy (CSP)의 목적과 지시문 이해 - HTTPS 연결을 강제하는 HSTS 구성 - X-Content-Type-Options, X-Frame-Options, Referrer-Policy 헤더 적용 - 브라우저 기능을 제한하는 Permissions-Policy 구현 - Cross-Origin 정책 (CORP, COEP, COOP) 구성 -...", "url": "/study/ko/Security/09_Web_Security_Headers.html"}, {"id": "Security/10_API_Security", "title": "API 보안", "topic": "Security", "topic_display": "Security", "body": "이전: 09WebSecurityHeaders.md | 다음: 11SecretsManagement.md --- API는 현대 소프트웨어 시스템의 핵심입니다. 마이크로서비스를 연결하고, 모바일 애플리케이션을 구동하며, 타사 통합을 가능하게 합니다. API는 애플리케이션 로직과 데이터를 직접 노출하기 때문에 공격자의 주요 표적입니다. 단일 엔드포인트의 잘못된 구성으로 수백만 개의 레코드가 노출될 수 있습니다. 이 레슨은 API를 구축, 배포 및 유지하기 위한 필수 보안 관행을 다룹니다 — 인증 및 속도 제한부터 입력 검증 및 CORS 구성까지. - API 키, OAuth 2.0 및 JWT를 사용한 강력한 API 인증 구현 - 남용을 방지하기 위한 속도 제한 전략 설계 및 배포 - 주입 공격을 방지하기 위한 모든 API 입력 검증 및 정제 - cross-origin 접근을 제어하기 위한 CORS 올바르게 구성 - 일반적인 공격 패턴으로부터 GraphQL 엔드포인트 보호 -...", "url": "/study/ko/Security/10_API_Security.html"}, {"id": "Security/11_Secrets_Management", "title": "Secrets Management와 환경 설정", "topic": "Security", "topic_display": "Security", "body": "이전: 10APISecurity.md | 다음: 12ContainerSecurity.md --- Secrets — API 키, 데이터베이스 비밀번호, 암호화 키, OAuth 클라이언트 비밀 — 는 모든 애플리케이션의 가장 중요한 자산입니다. 하나의 유출된 secret만으로도 전체 시스템이 손상될 수 있습니다. 그럼에도 불구하고 secrets 관리는 소프트웨어 개발에서 가장 흔히 잘못 다루어지는 영역 중 하나로 남아있습니다. 이 레슨에서는 secrets의 전체 생명주기를 다룹니다: 저장, 교체, 런타임 주입, 우발적 유출 스캐닝, CI/CD 파이프라인과 클라우드 환경에서의 관리 방법. - 12-factor app의 구성 및 secrets 접근 방식 이해 - python-dotenv를 사용하여 환경 변수와 .env 파일을 안전하게 사용 - 다운타임 없는 secret 교체 전략 구현 - 중앙 집중식 secrets 관리를 위한 HashiCorp Vault 구성 - 클라우드 네이티브...", "url": "/study/ko/Security/11_Secrets_Management.html"}, {"id": "Security/12_Container_Security", "title": "컨테이너 및 클라우드 보안", "topic": "Security", "topic_display": "Security", "body": "이전: 11SecretsManagement.md | 다음: 13. Security Testing --- 컨테이너는 소프트웨어 배포에 혁명을 일으켰지만, 새로운 공격 표면도 도입했습니다. 취약한 베이스 이미지, 지나치게 관대한 Dockerfile, 또는 잘못 구성된 Kubernetes 클러스터는 전체 인프라를 노출시킬 수 있습니다. 클라우드 환경은 IAM 정책, 네트워크 구성, 공유 책임 모델로 더욱 복잡성을 추가합니다. 이 레슨은 컨테이너 및 클라우드 스택 전반의 보안 모범 사례를 다룹니다 — 최소화되고 강화된 이미지 구축부터 Kubernetes 보안 정책 구현 및 클라우드 IAM 거버넌스까지. - 공격 표면을 최소화하는 안전한 Dockerfile 작성 - 최소 베이스 이미지 선택 및 감사(distroless, Alpine, scratch) - Trivy, Snyk, Hadolint를 사용하여 컨테이너 이미지의 취약점 스캔 - cosign과 Sigstore로 컨테이너 이미지 서명...", "url": "/study/ko/Security/12_Container_Security.html"}, {"id": "Security/13_Security_Testing", "title": "보안 테스팅", "topic": "Security", "topic_display": "Security", "body": "--- 보안 테스팅은 공격자보다 먼저 소프트웨어의 취약점을 찾아내는 체계적인 프로세스입니다. 이 레슨에서는 주요 보안 테스팅 카테고리인 정적 애플리케이션 보안 테스팅(SAST), 동적 애플리케이션 보안 테스팅(DAST), 소프트웨어 구성 분석(SCA), 퍼징(fuzzing)과 함께 침투 테스팅 방법론 및 CI/CD 통합을 다룹니다. 이 레슨을 마치면 프로젝트를 위한 포괄적인 보안 테스팅 파이프라인을 구축할 수 있게 됩니다. - SAST, DAST, SCA, 퍼징의 차이점 이해 - Bandit과 Semgrep을 사용하여 Python 코드의 취약점 발견 - 프로젝트별 패턴을 위한 맞춤형 Semgrep 규칙 작성 - CI/CD 파이프라인에 보안 스캐닝 통합 - 침투 테스팅 방법론 적용 - 효과적인 보안 코드 리뷰 수행 --- | 기능 | SAST | DAST | SCA | 퍼징 | PT | |------|------|------|-----|------|----| | 실행 중인 앱 필요...", "url": "/study/ko/Security/13_Security_Testing.html"}, {"id": "Security/14_Incident_Response", "title": "사고 대응 및 포렌식", "topic": "Security", "topic_display": "Security", "body": "--- 보안 사고는 불가피합니다. 회복력 있는 조직과 취약한 조직을 구분하는 것은 침해를 당하느냐 여부가 아니라, 얼마나 효과적으로 대응하느냐입니다. 이 레슨은 NIST 프레임워크를 기반으로 한 완전한 사고 대응 생명주기, 디지털 포렌식 기초, 로그 분석 기법, 침해 지표(IOC) 탐지를 위한 실용적인 Python 스크립트를 다룹니다. 이 레슨을 마치면 사고 대응 플레이북을 작성하고 보안 이벤트를 체계적으로 분석할 수 있습니다. - NIST 사고 대응 생명주기 단계 이해 - 사고 대응 계획 수립 및 유지 - 침해 지표를 찾기 위한 로그 분석 - 디지털 포렌식 기초 및 증거 보관 연속성 이해 - 로그 파싱 및 IOC 탐지를 위한 Python 스크립트 작성 - 일반적인 시나리오에 대한 사고 대응 플레이북 작성 - 효과적인 사고 후 검토 수행 --- 보안 사고는 정보나 시스템의 기밀성, 무결성, 가용성을 손상시키는 모든 이벤트입니다. 모든 보안 이벤트가 사고인 것은 아니며, 트리아지를...", "url": "/study/ko/Security/14_Incident_Response.html"}, {"id": "Security/15_Project_Secure_API", "title": "프로젝트: 안전한 REST API 구축", "topic": "Security", "topic_display": "Security", "body": "--- 이 프로젝트 레슨은 FastAPI를 사용하여 프로덕션 레벨의 안전한 REST API를 처음부터 구축하는 과정을 안내합니다. Argon2를 사용한 적절한 비밀번호 해싱, 리프레시 토큰을 사용한 JWT 인증, 역할 기반 접근 제어, 입력 검증, 속도 제한, 보안 헤더, CORS 설정, 구조화된 로깅, 안전한 오류 처리 등 모든 보안 계층을 구현할 것입니다. 레슨을 마치면 보안 모범 사례를 따르는 완전하고 배포 가능한 API를 갖게 됩니다. - 보안을 최우선 관심사로 하는 REST API 구축 - 적절한 설정으로 Argon2 비밀번호 해싱 구현 - 액세스 토큰 및 리프레시 토큰 로테이션을 사용한 JWT 인증 생성 - 역할 기반 접근 제어(RBAC) 설계 및 구현 - Pydantic 모델을 사용한 모든 입력 검증 - 속도 제한, 보안 헤더, CORS 추가 - 구조화된 보안 로깅 구현 - 민감한 정보를 노출하지 않는 오류 처리 - 보안 중심 테스트 작성 - 프로덕션 배포 준비 ---...", "url": "/study/ko/Security/15_Project_Secure_API.html"}, {"id": "Security/16_Project_Vulnerability_Scanner", "title": "프로젝트: 취약점 스캐너 구축", "topic": "Security", "topic_display": "Security", "body": "이전: 15. 프로젝트: 보안 REST API 구축 --- 이 프로젝트 레슨에서는 Python으로 포괄적인 취약점 스캐너를 구축하는 과정을 살펴봅니다. 스캐너는 포트 스캔, 서비스 배너 수집, HTTP 보안 헤더 검사, SSL/TLS 구성 분석, 디렉터리 브루트포싱, CVE 데이터베이스 조회를 수행합니다. CLI 인터페이스, 구조화된 출력, 책임 있는 스캔을 보장하는 속도 제한 기능을 갖춘 모듈식의 확장 가능한 도구를 구축합니다. 이 프로젝트는 Security 토픽 전체의 여러 개념을 통합합니다. 중요: 귀하가 소유하거나 명시적인 서면 허가를 받은 시스템만 스캔하십시오. 대부분의 관할권에서 무단 스캔은 불법입니다. 이 도구는 교육 목적 및 승인된 보안 평가용으로만 사용됩니다. - Python으로 모듈식 취약점 스캐너 구축 - 서비스 감지를 포함한 TCP 포트 스캔 구현 - HTTP 보안 헤더 및 SSL/TLS 구성 분석 - 디렉터리 및 경로 탐색 수행(교육 목적) - CVE...", "url": "/study/ko/Security/16_Project_Vulnerability_Scanner.html"}, {"id": "Shell_Script/00_Overview", "title": "Shell Scripting 학습 가이드", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "이 폴더는 프로그래밍 분야로서의 쉘 스크립팅을 체계적으로 학습할 수 있도록 제공합니다. Bash를 주 쉘로 사용하여, 기본적인 스크립팅을 넘어서는 고급 기법, 실전 자동화 패턴, 전문적인 모범 사례를 다룹니다. 대상 독자: Linux 토픽을 완료한 학습자 (특히 Lesson 09: Shell Scripting 기초) --- --- - Linux 기초 및 터미널 사용 익숙도 - Linux/09ShellScripting.md - 변수, 조건문, 반복문, 함수, 배열, 디버깅 기초 - Linux/04TextProcessing.md - grep, sed, awk 기초 --- | 파일 | 난이도 | 핵심 주제 | |------|-----------|------------| | 01ShellFundamentals.md | ⭐ | 쉘 종류(bash/sh/zsh/dash), POSIX, login/non-login, profile/bashrc 로딩, exit codes | |...", "url": "/study/ko/Shell_Script/00_Overview.html"}, {"id": "Shell_Script/01_Shell_Fundamentals", "title": "Shell 기초와 실행 환경", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "다음: 02ParameterExpansion.md --- 이 레슨에서는 쉘 실행 환경, 다양한 쉘 종류, 시작 메커니즘, 그리고 스크립트가 다른 컨텍스트에서 어떻게 동작하는지에 영향을 주는 기본 개념을 탐구합니다. 다양한 쉘은 서로 다른 기능과 호환성 수준을 제공합니다. 이러한 차이점을 이해하는 것은 이식 가능한 스크립트를 작성하는 데 중요합니다. | 기능 | bash | sh (dash) | zsh | fish | |---------|------|-----------|-----|------| | POSIX 호환 | 대부분 | 예 | 대부분 | 아니오 | | 배열(Arrays) | 예 | 아니오 | 예 (더 좋음) | 예 | | 연관 배열(Associative arrays) | 예 (4.0+) | 아니오 | 예 | 예 | | [[ ]] 테스트 | 예 | 아니오 | 예 | 아니오 | | 프로세스 치환(Process substitution) | 예 | 아니오 | 예 | 예 | |...", "url": "/study/ko/Shell_Script/01_Shell_Fundamentals.html"}, {"id": "Shell_Script/02_Parameter_Expansion", "title": "매개변수 확장과 변수 속성 ⭐⭐", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "이전: 01ShellFundamentals.md | 다음: 03ArraysandData.md --- 이 레슨에서는 외부 도구 없이 쉘에서 직접 변수를 조작할 수 있는 강력한 기능인 bash 매개변수 확장(Parameter Expansion)을 탐구합니다. 문자열 연산, 기본값, 변수 속성, 그리고 실용적인 패턴을 다룹니다. 매개변수 확장은 문자열의 시작 또는 끝에서 패턴을 제거하는 내장 연산자를 제공합니다. 이는 나 외부 도구를 사용하는 것보다 빠릅니다. | 연산자 | 방향 | 매칭 | 예제 | 결과 | |----------|-----------|-------|---------|--------| | | 시작부터 | 최단 | | 첫 디렉터리 제거 | | | 시작부터 | 최장 | | Basename | | | 끝부터 | 최단 | | 확장자 제거 | | | 끝부터 | 최장 | | 모든 확장자 제거 | 매개변수 확장은 패턴 검색과 치환을 지원하며, 간단한 문자열 연산을 위한 의 경량...", "url": "/study/ko/Shell_Script/02_Parameter_Expansion.html"}, {"id": "Shell_Script/03_Arrays_and_Data", "title": "배열과 데이터 구조 ⭐⭐", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "이전: 02ParameterExpansion.md | 다음: 04AdvancedControlFlow.md --- 이 레슨에서는 bash 배열과 구조화된 데이터 작업 방법을 다룹니다. 인덱스 배열과 연관 배열, 일반적인 데이터 구조 패턴, CSV 및 설정 파일 파싱, 쉘 스크립트에서 복잡한 데이터를 관리하는 실용적인 기술을 탐구합니다. 인덱스 배열(Indexed Arrays)은 0부터 시작하는 숫자 인덱스로 요소를 저장합니다. 연관 배열(Associative Arrays, 해시맵, 딕셔너리)은 숫자 인덱스 대신 문자열을 키로 사용합니다. Bash 4.0+ 이상에서 사용 가능합니다. | 기능 | 인덱스 배열 | 연관 배열 | |---------|---------------|-------------------| | 선언 | 또는 | | | 키 | 정수 (0, 1, 2, ...) | 문자열 | | 순서 | 보존됨 | 정렬되지 않음 | | 사용 가능 버전 | 모든 bash 버전 | Bash...", "url": "/study/ko/Shell_Script/03_Arrays_and_Data.html"}, {"id": "Shell_Script/04_Advanced_Control_Flow", "title": "Advanced Control Flow ⭐⭐", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "이전: 03ArraysandData.md | 다음: 05FunctionsandLibraries.md --- 이 레슨은 bash의 고급 제어 흐름 구조를 다룹니다. 다양한 테스트 명령 변형, 산술 평가, 패턴 매칭, 대화형 메뉴, 그리고 정교한 흐름 제어 패턴을 포함합니다. Bash는 조건을 테스트하는 여러 가지 방법을 제공합니다. 이들의 차이점을 이해하는 것은 올바르고 효율적인 스크립트를 작성하는 데 중요합니다. | 기능 | (test) | (keyword) | (arithmetic) | |---------|-------------|-------------------|---------------------| | POSIX Compliant | Yes | No (bash only) | No (bash only) | | Word Splitting | Yes (dangerous) | No (safe) | N/A | | Pathname Expansion | Yes (dangerous) |...", "url": "/study/ko/Shell_Script/04_Advanced_Control_Flow.html"}, {"id": "Shell_Script/05_Functions_and_Libraries", "title": "레슨 05: 함수와 라이브러리(Functions and Libraries)", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐ 이전: 04AdvancedControlFlow.md | 다음: 06IOandRedirection.md Bash 함수는 전통적인 프로그래밍 언어처럼 값을 반환하지 않습니다. 대신 결과를 호출자에게 전달하기 위해 여러 패턴을 사용합니다. 가장 일반적인 패턴은 결과를 하고 명령 치환으로 캡처하는 것입니다: 장점: 깔끔하고 함수형 스타일; 여러 echo 문을 통해 여러 반환 값 지원. 단점: 서브셸 생성으로 인해 느림; stdout과 반환 값을 구분할 수 없음. 함수는 전역 변수를 직접 수정할 수 있습니다: 장점: 빠름; 여러 값을 쉽게 반환; 서브셸 오버헤드 없음. 단점: 전역 네임스페이스 오염; 추론하기 어려움; 스레드 안전하지 않음. 을 사용하여 변수에 대한 참조를 생성합니다: 장점: 깨끗한 분리; 전역 오염 없음; 호출자의 변수를 직접 수정 가능. 단점: Bash 4.3+ 필요; 약간 복잡한 구문. 을 사용하여 종료 상태(0-255)를 설정합니다: 장점: 표준...", "url": "/study/ko/Shell_Script/05_Functions_and_Libraries.html"}, {"id": "Shell_Script/06_IO_and_Redirection", "title": "Lesson 06: I/O와 리다이렉션(Redirection)", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐⭐ 이전: 05FunctionsandLibraries.md | 다음: 07StringProcessing.md --- 파일 디스크립터(FD)는 열린 파일이나 I/O 스트림을 참조하는 정수입니다. bash에서 I/O 리다이렉션을 마스터하려면 이들을 이해하는 것이 필수적입니다. 모든 프로세스는 세 개의 표준 파일 디스크립터를 가집니다: | FD | 이름 | 목적 | 기본값 | |----|------|---------|---------| | 0 | stdin | 표준 입력(Standard input) | 키보드 | | 1 | stdout | 표준 출력(Standard output) | 터미널 | | 2 | stderr | 표준 에러(Standard error) | 터미널 | 3-9번 파일 디스크립터를 사용자 정의로 생성할 수 있습니다: 기본 와 이외에도, bash는 강력한 리다이렉션 연산자를 제공합니다. Here documents는 임시 파일을 만들지 않고 명령에 여러 줄의...", "url": "/study/ko/Shell_Script/06_IO_and_Redirection.html"}, {"id": "Shell_Script/07_String_Processing", "title": "Lesson 07: 문자열 처리와 텍스트 조작", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐⭐ 이전: 06IOandRedirection.md | 다음: 08RegexinBash.md --- 외부 도구를 탐색하기 전에, bash의 강력한 내장 문자열 연산을 복습해보겠습니다. 명령은 강력한 문자열 포매팅 기능을 제공합니다. (translate) 명령은 문자 단위 변환을 수행합니다. 명령은 각 줄에서 필드나 문자를 추출합니다. 이 명령들은 여러 파일의 데이터를 병합합니다. 명령은 출력을 테이블로 포맷합니다. 는 강력한 커맨드라인 JSON 프로세서입니다. 는 jq와 유사한 YAML 프로세서입니다 (참고: yq라는 이름의 도구가 여러 개 있으며, 예제는 mikefarah/yq 사용). 다음 기능을 가진 스크립트 생성: - 헤더 행이 있는 CSV 파일 읽기 - 각 행 검증 (올바른 필드 수, 데이터 타입) - 열 값에 기반한 행 필터링 지원 (예: age > 30) - 다중 열로 정렬 지원 - 특정 열 선택 지원 - CSV, JSON 또는 포맷된 테이블로 출력 -...", "url": "/study/ko/Shell_Script/07_String_Processing.html"}, {"id": "Shell_Script/08_Regex_in_Bash", "title": "레슨 08: Bash에서의 정규 표현식(Regular Expressions)", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐⭐ 이전: 07StringProcessing.md | 다음: 09ProcessManagement.md --- Bash 스크립팅에서 glob과 regex의 차이점을 이해하는 것은 매우 중요합니다. | 특징 | Glob | Regex | |---------|------|-------| | 목적 | 파일명 매칭 | 문자열 패턴 매칭 | | 컨텍스트 | 파일 작업, case 문 | , grep, sed, awk | | 의미 | 0개 이상의 문자 | 이전 문자의 0개 이상 반복 | | 의미 | 리터럴 점 | 임의의 단일 문자 | | 의미 | 정확히 하나의 문자 | 이전 문자의 0개 또는 1개 | | 문자 클래스 | | (동일) | | 부정 | | | | 앵커 | 없음 (암묵적) | (시작), (끝) | | 그룹 | (중괄호 확장) | (선택) | 연산자는 Bash의 구조에서 regex 매칭을 수행합니다. 배열은 regex 매칭에서 캡처된 그룹을 저장합니다. ERE(확장 정규...", "url": "/study/ko/Shell_Script/08_Regex_in_Bash.html"}, {"id": "Shell_Script/09_Process_Management", "title": "레슨 09: 프로세스 관리 및 작업 제어(Process Management and Job Control)", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐⭐ 이전: 08RegexinBash.md | 다음: 10ErrorHandling.md 셸 스크립트는 백그라운드에서 프로세스를 실행할 수 있어 병렬 실행과 성능 향상을 가능하게 합니다. 독립적인 작업을 병렬로 실행하면 스크립트를 크게 가속화할 수 있습니다. 서브셸은 자체 변수 스코프를 가진 격리된 실행 환경을 생성합니다. 시그널은 프로세스에 이벤트를 알리는 소프트웨어 인터럽트입니다. | 시그널 | 번호 | 설명 | 기본 동작 | |--------|--------|-------------|----------------| | SIGHUP | 1 | 행업 (터미널 닫힘) | 종료 | | SIGINT | 2 | 인터럽트 (Ctrl+C) | 종료 | | SIGQUIT | 3 | 종료 (Ctrl+\\) | 종료 + 코어 덤프 | | SIGKILL | 9 | 킬 (캐치 불가) | 종료 | | SIGTERM | 15 | 종료 요청 | 종료 | | SIGSTOP | 19 | 중지 (캐치...", "url": "/study/ko/Shell_Script/09_Process_Management.html"}, {"id": "Shell_Script/10_Error_Handling", "title": "Lesson 10: 에러 처리 및 디버깅", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐⭐ 이전: 09ProcessManagement.md | 다음: 11ArgumentParsing.md --- 명령어는 셸 동작 및 에러 처리를 제어합니다. 이러한 옵션을 이해하는 것은 견고한 스크립트를 작성하는 데 매우 중요합니다. | 옵션 | 설명 | 효과 | 사용 시기 | |--------|-------------|--------|-------------| | | errexit | 명령어 실패 시 종료 | 프로덕션 스크립트 | | | nounset | 정의되지 않은 변수 접근 시 종료 | 오타를 조기에 발견 | | | pipefail | 파이프라인 내 어떤 명령어라도 실패하면 실패 | 와 함께 | | | xtrace | 실행 전 명령어 출력 | 디버깅 | | | verbose | 셸 입력 라인 출력 | 심층 디버깅 | | | noexec | 명령어를 읽되 실행하지 않음 | 문법 검사 | | | noclobber | 출력 리디렉션이 파일을 덮어쓰는 것을 방지 | 파일...", "url": "/study/ko/Shell_Script/10_Error_Handling.html"}, {"id": "Shell_Script/11_Argument_Parsing", "title": "Lesson 11: 인수 파싱 및 CLI 인터페이스", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐⭐ 이전: 10ErrorHandling.md | 다음: 12PortabilityandBestPractices.md --- 수동 파싱은 인수 처리에 대한 완전한 제어를 제공합니다. 는 옵션 파싱을 위한 POSIX 내장 명령어입니다. GNU 는 긴 옵션과 더 고급 파싱을 지원합니다. | 기능 | getopts (POSIX) | getopt (GNU) | |---------|----------------|--------------| | 이식성 | POSIX (모든 시스템) | GNU (Linux, 설치된 macOS) | | 긴 옵션 | 아니오 | 예 | | 옵션 묶기 | 제한적 | 완전 지원 | | 구분자 | 수동 처리 | 내장 | | 에러 메시지 | 기본 | 상세 | | 옵션 재정렬 | 아니오 | 예 | | 복잡도 | 간단 | 더 복잡 | | 사용 사례 | 간단한 스크립트 | 복잡한 CLI 도구 | 좋은 도움말 메시지는 CLI 도구를 사용자 친화적으로 만듭니다. 색상은...", "url": "/study/ko/Shell_Script/11_Argument_Parsing.html"}, {"id": "Shell_Script/12_Portability_and_Best_Practices", "title": "레슨 12: 이식성과 모범 사례", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐⭐⭐ 이전: 11ArgumentParsing.md | 다음: 13Testing.md --- 셸 간의 차이점을 이해하면 이식성을 보장할 수 있습니다. | 기능 | POSIX sh | Bash | Zsh | 참고 사항 | |---------|----------|------|-----|-------| | 배열(Arrays) | No | Yes | Yes | sh: 위치 매개변수 사용 | | 테스트 | No | Yes | Yes | sh: 사용 | | 프로세스 치환(Process substitution) | No | Yes | Yes | | | Here strings | No | Yes | Yes | | | 키워드 | No | Yes | Yes | 널리 지원되지만 POSIX는 아님 | | 키워드 | No | Yes | Yes | POSIX는 사용 | | | No | Yes | Yes | sh: 사용 | | | No | Yes | Yes | sh: 사용 | | | No |...", "url": "/study/ko/Shell_Script/12_Portability_and_Best_Practices.html"}, {"id": "Shell_Script/13_Testing", "title": "셸 스크립트 테스팅", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐⭐⭐ 이전: 12PortabilityandBestPractices.md | 다음: 14ProjectTaskRunner.md --- 셸 스크립트는 종종 단순한 한 줄짜리로 시작하지만 중요한 인프라 코드로 발전합니다. 테스트가 없으면 취약하고 리팩토링하기 어려우며 회귀(regression)가 발생하기 쉽습니다. 테스팅은 다음을 제공합니다: 1. 리팩토링에 대한 신뢰: 두려움 없이 구현 세부 사항을 변경 2. 문서화: 테스트는 스크립트가 어떻게 동작해야 하는지 보여줌 3. 회귀 방지: 프로덕션에 도달하기 전에 버그 포착 4. CI/CD 통합: 모든 커밋에 대한 자동 검증 5. 복잡성 관리: 스크립트가 커질수록 테스트가 유지보수 가능하게 유지 | 테스트 유형 | 범위 | 테스트 대상 | 예시 | |-----------|-------|---------------|---------| | 단위(Unit) | 단일 함수 | 격리된 로직 | 모의 입력으로 파싱 함수 테스팅 | |...", "url": "/study/ko/Shell_Script/13_Testing.html"}, {"id": "Shell_Script/14_Project_Task_Runner", "title": "프로젝트: 작업 실행기(Task Runner)", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐⭐ 이전: 13Testing.md | 다음: 15ProjectDeployment.md 이 레슨에서는 순수 bash로 완전한 작업 실행기를 구축합니다 — 의존성 해결(dependency resolution), 병렬 실행(parallel execution), 자동 도움말 생성 기능을 갖춘 Makefile과 유사한 도구입니다. --- 작업 실행기는 빌드, 테스트, 린팅, 배포와 같은 반복적인 개발 작업을 자동화하는 도구입니다. 주요 예시는 다음과 같습니다: - Make: 클래식 빌드 자동화 도구 (복잡한 문법, 파일 기반 의존성) - Just: 현대적인 명령어 실행기 (Make보다 간단하지만 별도 설치 필요) - Task: Go로 작성된 작업 실행기 (YAML 설정) - npm scripts: JavaScript 생태계 (Node.js 프로젝트로 제한됨) bash로 작업 실행기를 구축하면 여러 장점이 있습니다: 1. 제로 의존성: bash가 있는 곳이면 어디서나 작동 2....", "url": "/study/ko/Shell_Script/14_Project_Task_Runner.html"}, {"id": "Shell_Script/15_Project_Deployment", "title": "프로젝트: 배포 자동화(Deployment Automation)", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐⭐⭐ 이전: 14ProjectTaskRunner.md | 다음: 16ProjectMonitor.md --- 배포 자동화는 소스 제어에서 프로덕션 서버로 코드를 자동으로 이동하는 프로세스입니다. 수동 단계를 제거하고 에러를 줄이며 더 빠르고 신뢰할 수 있는 릴리스를 가능하게 합니다. 주요 구성 요소는 다음과 같습니다: - 원격 실행: SSH를 통해 대상 서버에서 명령어 실행 - 파일 동기화: 서버로 코드와 자산 복사 - 헬스 체크: 배포가 성공했는지 확인 - 롤백 기능: 실패 시 이전 버전으로 되돌리기 - 다중 서버 오케스트레이션: 여러 호스트에 순차적 또는 병렬로 배포 Ansible, Terraform, Kubernetes와 같은 도구가 존재하지만, bash 배포 스크립트는 다음을 제공합니다: 1. 제로 의존성: 에이전트나 오케스트레이션 도구 불필요 2. 투명성: 각 서버에서 실행되는 것이 정확히 보임 3. 단순성: 소규모에서 중규모 배포에 완벽 4. SSH 네이티브:...", "url": "/study/ko/Shell_Script/15_Project_Deployment.html"}, {"id": "Shell_Script/16_Project_Monitor", "title": "프로젝트: 시스템 모니터링 도구(System Monitoring Tool)", "topic": "Shell_Script", "topic_display": "Shell Script", "body": "난이도: ⭐⭐⭐⭐ 이전: 15ProjectDeployment.md --- 순수 bash로 작성된 포괄적인 터미널 기반 시스템 모니터링 대시보드입니다. 이 도구는 다음에 대한 실시간 가시성을 제공합니다: - CPU 사용량과 부하 평균 - 메모리와 스왑 활용도 - 파일 시스템 전체의 디스크 공간 - 네트워크 I/O 통계 - 활성 프로세스와 리소스 소비 - 에러 탐지를 통한 시스템 로그 - 임계값 초과 시 경고 알림 , , Datadog 에이전트와 같은 도구의 경량 커스터마이징 가능한 대안으로 생각하되, bash로 완전히 자체 포함됩니다. 1. 실시간 대시보드: 컬러와 레이아웃이 있는 실시간 업데이트 터미널 UI 2. 설정 가능한 경고: Slack/Discord 웹훅으로 전송되는 임계값 기반 경고 3. 로그 집계: 에러/경고에 대한 시스템 로그 파싱 및 요약 4. Cron 통합: 주기적 확인 실행 및 보고서 생성 5. 크로스 플랫폼: Linux와 macOS에서 작동 (OS 특화 적응...", "url": "/study/ko/Shell_Script/16_Project_Monitor.html"}, {"id": "Signal_Processing/00_Overview", "title": "신호 처리 - 개요", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "신호 처리(Signal Processing)는 신호를 분석하고, 변형하고, 합성하기 위한 수학적 체계입니다. 신호란 물리적 현상의 특성이나 행동에 관한 정보를 전달하는 양을 말합니다. 음성 인식과 오디오 공학에서부터 레이더 시스템과 의료 영상에 이르기까지, 신호 처리는 현대 기술을 구동하는 근본적인 도구를 제공합니다. 이 강좌는 신호와 시스템에 대한 연속시간 및 이산시간 기술로 시작하여, 주요 변환 영역 기법(푸리에(Fourier), Z-변환, 웨이블릿(wavelet))을 거치고, 디지털 필터의 설계와 구현을 다루며, 스펙트럼 추정, 적응 필터링(adaptive filtering), 영상 처리, 통신 등의 응용까지 체계적으로 학습합니다. 각 레슨은 엄밀한 수학적 유도와 NumPy, SciPy, Matplotlib을 사용한 Python 구현을 함께 제시하여, 개념을 직접 계산하고 시각화할 수 있도록 합니다. --- 이 강좌를 마치면 다음을 할 수 있습니다: 1. 신호 분류 및...", "url": "/study/ko/Signal_Processing/00_Overview.html"}, {"id": "Signal_Processing/01_Signals_and_Systems", "title": "신호와 시스템", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "다음: 02. LTI 시스템과 합성곱 --- 신호는 우리 주변 어디에나 존재합니다. 사람의 목소리, 회로의 전압, 이미지의 픽셀, 시간에 따른 주가 등이 그 예입니다. 신호 처리(Signal Processing)는 이러한 양들을 설명하고, 분석하고, 조작하기 위한 엄밀한 수학적 체계를 제공합니다. 신호를 처리하기 전에, 신호를 설명하고 신호를 처리하는 시스템을 기술하기 위한 정밀한 언어가 필요합니다. 이 레슨에서는 기초 어휘를 확립합니다. 신호가 무엇인지, 신호를 어떻게 분류하는지, 기본 구성 요소 신호들이 어떻게 생겼는지, 기본 연산을 통해 신호를 어떻게 변환하는지, 그리고 신호를 처리하는 시스템이 어떤 특성을 가지는지를 배웁니다. 난이도: ⭐⭐ 학습 목표: - 연속시간(continuous-time) 및 이산시간(discrete-time) 신호를 수학적으로 정의하기 - 신호를 특성에 따라 분류하기 (결정론적/확률적, 주기적/비주기적, 에너지/전력) - 기본 신호 유형 인식 및...", "url": "/study/ko/Signal_Processing/01_Signals_and_Systems.html"}, {"id": "Signal_Processing/02_LTI_Systems_and_Convolution", "title": "LTI 시스템과 합성곱", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "이전: 01. 신호와 시스템 | 다음: 03. 푸리에 급수와 응용 --- 레슨 01에서 우리는 신호를 표현하는 언어와 시스템의 특성을 나타내는 속성들을 정립했습니다. 가능한 모든 시스템 중에서 중요성 면에서 가장 두드러지는 부류가 있습니다: 선형 시불변(LTI, Linear Time-Invariant) 시스템입니다. 모든 LTI 시스템의 동작은 단 하나의 함수인 임펄스 응답(impulse response)에 의해 완전히 결정되며, 임의의 입력에 대한 출력은 합성곱(convolution)을 통해 계산할 수 있습니다. 이 레슨에서는 이러한 개념들을 기초부터 전개하고, 합성곱이 신호 처리에서 핵심 연산인 이유를 설명합니다. 난이도: ⭐⭐⭐ 학습 목표: - LTI 시스템이 신호 처리에서 중요한 이유를 설명할 수 있다 - 중첩 원리로부터 합성곱 적분과 합성곱 합을 유도할 수 있다 - 합성곱을 해석적으로 및 수치적으로 계산할 수 있다 - 합성곱의 성질(교환법칙, 결합법칙, 분배법칙)을 적용할...", "url": "/study/ko/Signal_Processing/02_LTI_Systems_and_Convolution.html"}, {"id": "Signal_Processing/03_Fourier_Series_and_Applications", "title": "푸리에 급수와 응용", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "이전: 02. LTI 시스템과 합성곱 | 다음: 04. 연속 푸리에 변환 --- 레슨 02에서 LTI 시스템이 임펄스 응답에 의해 완전히 특성화되며, 합성곱을 통해 임의의 입력에 대한 출력을 계산할 수 있음을 살펴보았습니다. 하지만 시간 영역에서의 합성곱은 번거로울 수 있습니다. 훨씬 더 우아한 접근 방법이 있습니다. 신호를 복소 지수함수로 분해하는 것인데, 복소 지수함수는 LTI 시스템의 고유함수(eigenfunction)입니다. 각 지수함수에 대한 응답은 단순한 스케일링이며, 전체 출력은 이 스케일된 지수함수들의 합입니다. 주기 신호(periodic signal)의 경우, 이 분해를 푸리에 급수(Fourier series)라고 합니다. 이 레슨에서는 수학적 기초로부터 푸리에 급수를 유도하고, 수렴 특성을 탐구하며, 주기 현상 분석에서의 활용을 보여줍니다. 난이도: ⭐⭐⭐ 학습 목표: - 푸리에 급수의 삼각함수 형태와 복소 지수 형태 유도 - 표준 파형에 대한 푸리에 계수 계산...", "url": "/study/ko/Signal_Processing/03_Fourier_Series_and_Applications.html"}, {"id": "Signal_Processing/04_Continuous_Fourier_Transform", "title": "연속 푸리에 변환(Continuous Fourier Transform)", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "이전: 03. 푸리에 급수와 응용 | 다음: 05. 표본화와 복원 --- 푸리에 급수는 주기 신호를 조화 관련 사인파들로 분해합니다. 그러나 대부분의 실제 신호들 — 음성, 레이더 펄스, 과도 진동 — 은 비주기적입니다. 이러한 신호를 주파수 영역에서 분석하려면 푸리에 급수를 비주기 신호로 확장해야 합니다. 그 결과가 바로 연속시간 푸리에 변환(Continuous-Time Fourier Transform, CTFT)이며, 이는 신호를 시간 영역에서 연속 주파수 영역 표현으로 변환합니다. 푸리에 변환은 과학과 공학 전반에 걸쳐 가장 강력하고 보편적인 도구 중 하나입니다. 이 레슨에서는 변환을 기본 원리로부터 유도하고, 핵심 성질들을 목록화하며, 일반적인 변환 쌍(transform pair) 표를 작성하고, 이를 통해 주파수 영역 분석과 필터링이 어떻게 가능한지 보여줍니다. 난이도: ⭐⭐⭐ 학습 목표: - 비주기 신호에 대한 푸리에 급수의 극한으로서 푸리에 변환 유도 - 주요 CTFT...", "url": "/study/ko/Signal_Processing/04_Continuous_Fourier_Transform.html"}, {"id": "Signal_Processing/05_Sampling_and_Reconstruction", "title": "표본화와 신호 복원", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "표본화(Sampling)는 연속 시간(아날로그) 신호와 이산 시간(디지털) 신호를 연결하는 다리입니다. 표본화 과정, 그 한계, 그리고 원래 신호를 충실히 복원하는 방법을 이해하는 것은 모든 디지털 신호 처리(DSP)의 근본입니다. 이 레슨에서는 나이퀴스트-섀넌(Nyquist-Shannon) 표본화 정리, 에일리어싱(aliasing), 에일리어싱 방지 전략, 복원 기술, 그리고 실용적인 ADC/DAC 고려 사항을 다룹니다. 학습 목표: - 이상적인 표본화의 수학적 체계를 이해한다 - 나이퀴스트-섀넌 표본화 정리를 진술하고 증명한다 - 에일리어싱을 식별하고 방지한다 - sinc 보간법(sinc interpolation)과 홀드 회로를 사용한 복원을 구현한다 - 실용적인 ADC/DAC 시스템과 오버샘플링(oversampling)의 이점을 분석한다 선수 과목: 04. 푸리에 변환과 주파수 영역 --- 디지털 시스템(컴퓨터, DSP 칩, 마이크로컨트롤러)은 연속 시간 신호를 직접 처리할...", "url": "/study/ko/Signal_Processing/05_Sampling_and_Reconstruction.html"}, {"id": "Signal_Processing/06_Discrete_Fourier_Transform", "title": "이산 푸리에 변환(Discrete Fourier Transform)", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "이산 푸리에 변환(Discrete Fourier Transform, DFT)은 디지털 신호 처리의 계산적 핵심 도구입니다. DFT는 유한 길이의 표본 시퀀스를 유한 길이의 주파수 성분 시퀀스로 변환합니다. 고속 푸리에 변환(Fast Fourier Transform, FFT) 알고리즘과 결합하여, DFT는 효율적인 스펙트럼 분석, 필터링, 상관관계 계산 등 수많은 응용을 가능하게 합니다. 이 레슨은 DFT 이론, 성질, FFT 알고리즘, 그리고 실용적 사용법을 다룹니다. 학습 목표: - DTFT, DFT, FFT 간의 관계 이해 - 원형 합성곱과 파르스발 정리를 포함한 DFT 성질 적용 - 스펙트럼 누설과 윈도잉 전략 설명 - 실제 신호의 스펙트럼 분석을 위한 FFT 구현 및 활용 - 쿨리-튜키(Cooley-Tukey) 알고리즘과 그 계산적 이점 이해 선수 과목: 05. 표본화와 복원 --- 이산시간 신호 $x[n]$에 대해 DTFT는: $$X(e^{j\\omega}) =...", "url": "/study/ko/Signal_Processing/06_Discrete_Fourier_Transform.html"}, {"id": "Signal_Processing/07_Z_Transform", "title": "Z 변환(Z-Transform)", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "Z 변환은 라플라스 변환(Laplace Transform)의 이산 시간(discrete-time) 대응 개념입니다. 차분 방정식(difference equation)을 대수 방정식으로 변환하여, 복소 $z$ 평면에서 이산 시간 LTI 시스템을 분석할 수 있게 해줍니다. Z 변환은 시스템 안정성, 주파수 응답, 전달 함수 결정에 강력한 도구를 제공합니다. 이 레슨에서는 Z 변환 이론, 성질, 역변환 방법, 그리고 디지털 시스템 분석 응용을 다룹니다. 학습 목표: - 양방향(bilateral) 및 단방향(unilateral) Z 변환을 정의하고 계산하기 - 수렴 영역(ROC, Region of Convergence)과 그 의미 이해하기 - 시스템 분석을 위한 Z 변환 성질 적용하기 - 다양한 방법으로 역 Z 변환 계산하기 - 전달 함수, 극점(poles), 영점(zeros)을 이용하여 LTI 시스템 분석하기 - Z 변환과 DTFT 및 라플라스 변환의 관계 이해하기 선수 학습: 06....", "url": "/study/ko/Signal_Processing/07_Z_Transform.html"}, {"id": "Signal_Processing/08_Digital_Filter_Fundamentals", "title": "디지털 필터 기초", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "디지털 필터는 신호 처리의 핵심 도구로, 주파수 성분을 선택적으로 통과시키거나 제거함으로써 신호의 스펙트럼을 형성합니다. 이 레슨에서는 두 가지 기본 필터 유형인 FIR과 IIR의 표현 방식, 설계 트레이드오프, 구현 구조, 그리고 양자화 효과를 포함한 실용적인 고려 사항을 다룹니다. 이 기초를 이해하는 것은 구체적인 필터 설계 방법을 배우기 전에 반드시 필요합니다. 학습 목표: - FIR과 IIR 필터의 차이 및 트레이드오프 구분 - 차분 방정식(difference equation), 전달 함수(transfer function), 주파수 응답을 이용한 필터 분석 - 선형 위상(linear phase) 조건과 그 중요성 이해 - 필터 규격(통과대역 리플(passband ripple), 저지대역 감쇠(stopband attenuation), 전이 대역폭(transition width)) 해석 - 다양한 필터 구조(직접형(direct form), 종속형(cascade),...", "url": "/study/ko/Signal_Processing/08_Digital_Filter_Fundamentals.html"}, {"id": "Signal_Processing/09_FIR_Filter_Design", "title": "FIR 필터 설계(FIR Filter Design)", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "- 디지털 필터 설계의 사양과 용어를 이해한다 - FIR 필터 설계를 위한 창함수법(Window Method)을 마스터하고 창함수들을 비교한다 - 주파수 표본화(Frequency Sampling) 및 최적 등리플(Parks-McClellan) 설계 방법을 학습한다 - 선형 위상(Linear Phase) FIR 필터 유형과 그 제약 조건을 이해한다 - Python의 모듈을 사용하여 FIR 필터를 설계한다 - 직접 합성곱(Direct Convolution), 중첩 가산법(Overlap-Add), 중첩 저장법(Overlap-Save)을 이용한 FIR 필터링을 구현한다 - 전이 대역폭(Transition Width), 저지대역 감쇠(Stopband Attenuation), 연산 비용 측면에서 설계 방법들을 비교한다 --- 1. FIR 필터 설계 사양 2. 이상적인 필터와 임펄스 응답 3. 창함수법 4. 창함수 5. 카이저 창함수 설계 6. 주파수 표본화법 7. 최적 등리플 설계:...", "url": "/study/ko/Signal_Processing/09_FIR_Filter_Design.html"}, {"id": "Signal_Processing/10_IIR_Filter_Design", "title": "IIR 필터 설계", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "- 고전적인 아날로그 원형 필터(버터워스(Butterworth), 체비쇼프(Chebyshev), 타원형(Elliptic))의 특성 이해 - 아날로그-디지털 변환을 위한 쌍일차 변환(bilinear transform)과 임펄스 불변 방법(impulse invariance) 마스터 - 주파수 영역 규격으로부터 필터 차수 결정 방법 학습 - Python의 모듈을 사용한 IIR 디지털 필터 설계 - 극-영점 분석(pole-zero analysis)을 통한 필터 안정성 검증 - 필터 유형 비교 및 특정 응용에 적합한 설계 선택 --- 1. IIR 필터 설계 소개 2. 아날로그 원형 필터 3. 버터워스 필터 4. 체비쇼프 Type I 필터 5. 체비쇼프 Type II 필터 6. 타원형(코어) 필터 7. 아날로그-디지털 변환 8. 쌍일차 변환 9. 임펄스 불변 방법 10. 완전한 IIR 설계 절차 11. 안정성 분석 12. 필터 유형 비교 13. Python 구현 14. 연습 문제 ---...", "url": "/study/ko/Signal_Processing/10_IIR_Filter_Design.html"}, {"id": "Signal_Processing/11_Multirate_Processing", "title": "다중률 신호 처리(Multirate Signal Processing)", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "- 데시메이션(Decimation, 다운샘플링)과 보간(Interpolation, 업샘플링)의 기초 이해 - 샘플률 변경이 스펙트럼에 미치는 영향 분석 - 효율적인 다중률 구현을 위한 노블 항등식(Noble Identities) 습득 - 률 변환을 위한 앤티앨리어싱(anti-aliasing) 및 앤티이미징(anti-imaging) 필터 설계 - 계산 효율적인 필터링을 위한 폴리페이즈 분해(polyphase decomposition) 구현 - 연속된 보간과 데시메이션을 이용한 유리수 률 변환(rational rate conversion) 적용 - 직교 미러 필터(QMF, Quadrature Mirror Filters)를 포함한 필터 뱅크 구조 이해 - Python의 모듈을 사용한 다중률 시스템 구현 --- 1. 다중률 시스템 소개 2. 다운샘플링 (데시메이션) 3. 업샘플링 (보간) 4. 데시메이션 및 보간 필터 5. 노블 항등식 6. 폴리페이즈 분해 7. 유리수 률 변환 8....", "url": "/study/ko/Signal_Processing/11_Multirate_Processing.html"}, {"id": "Signal_Processing/12_Spectral_Analysis", "title": "스펙트럼 분석(Spectral Analysis)", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "- 전력 스펙트럼 밀도(Power Spectral Density, PSD)의 정의와 성질 이해 - 자기상관과 PSD를 연결하는 위너-킨친 정리(Wiener-Khinchin theorem) 마스터 - 비모수적 스펙트럼 추정 방법(주기도, Bartlett, Welch, Blackman-Tukey) 학습 - 스펙트럼 추정에서의 해상도-분산 트레이드오프(resolution-variance tradeoff) 이해 - 모수적 스펙트럼 추정 방법(AR, MA, ARMA 모델) 학습 - 모델 차수 선택 기준(AIC, BIC) 적용 - 교차 스펙트럼 분석(Cross-spectral analysis) 및 코히런스(coherence) 계산 - 시변 스펙트럼 분석을 위한 스펙트로그램(spectrogram) 생성 및 해석 - Python의 과 을 사용한 스펙트럼 분석 구현 --- 1. 스펙트럼 분석 소개 2. 전력 스펙트럼 밀도 3. 위너-킨친 정리 4. 주기도 5. Bartlett 방법 6. Welch...", "url": "/study/ko/Signal_Processing/12_Spectral_Analysis.html"}, {"id": "Signal_Processing/13_Adaptive_Filters", "title": "13. 적응 필터", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "이전: 12. 다중 레이트 신호 처리 | 다음: 14. 시간-주파수 분석 --- 적응 필터(adaptive filter)는 최적화 알고리즘에 따라 계수가 자동으로 조정되는 필터입니다. 신호 및 잡음 통계에 대한 완전한 사전 지식을 바탕으로 설계된 고정 필터와 달리, 적응 필터는 데이터로부터 지속적으로 파라미터를 갱신함으로써 미지(未知) 또는 시변(time-varying) 환경에서도 동작할 수 있습니다. 이는 노이즈 캔슬링 헤드폰, 전화기의 에코 제거, 모뎀의 채널 등화(channel equalization) 등 수많은 실제 시스템의 핵심 기술입니다. 난이도: ⭐⭐⭐⭐ 선수 지식: FIR/IIR 필터 설계, 선형대수, 기본 최적화 개념 학습 목표: - 위너 필터(Wiener filter)를 최적 MMSE 선형 필터로 유도 - 최급강하법(method of steepest descent)과 수렴 특성 이해 - LMS 알고리즘 유도 및 구현, 수렴 동작 분석 - 향상된 수렴을 위한 정규화...", "url": "/study/ko/Signal_Processing/13_Adaptive_Filters.html"}, {"id": "Signal_Processing/14_Time_Frequency_Analysis", "title": "14. 시간-주파수 분석(Time-Frequency Analysis)", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "이전: 13. 적응 필터 | 다음: 15. 영상 신호 처리 --- 푸리에 변환(Fourier Transform)은 신호에 어떤 주파수가 포함되어 있는지를 알려주지만, 언제 발생하는지는 알 수 없습니다. 음악, 음성, 지진 신호, 생체 리듬 등 비정상(non-stationary) 신호에는 스펙트럼 내용이 시간에 따라 어떻게 변하는지를 기술하는 도구가 필요합니다. 이 레슨에서는 시간-주파수 분석의 두 가지 주요 프레임워크인 단시간 푸리에 변환(STFT, Short-Time Fourier Transform)과 웨이블릿 변환(Wavelet Transform)을 다룹니다. 두 방법은 시간 및 주파수 국재화(localization)의 균형을 맞추는 방식에서 근본적으로 다른 접근 방식을 취합니다. 난이도: ⭐⭐⭐⭐ 선수 학습: DFT/FFT, 윈도잉(windowing), 컨볼루션(convolution), 기초 선형 대수 학습 목표: - 비정상 신호에 푸리에 변환이 부적합한 이유 설명하기 -...", "url": "/study/ko/Signal_Processing/14_Time_Frequency_Analysis.html"}, {"id": "Signal_Processing/15_Image_Signal_Processing", "title": "15. 영상 신호 처리(Image Signal Processing)", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "이전: 14. 시간-주파수 분석 | 다음: 16. 응용 --- 영상(Image)은 2차원 신호입니다. 시간이 아닌 공간 좌표의 함수로, 1D 신호 처리의 거의 모든 개념 — 합성곱(Convolution), 푸리에 변환(Fourier Transform), 필터링(Filtering), 샘플링(Sampling) — 은 자연스럽게 2D로 확장됩니다. 이 레슨은 영상 분석의 신호 처리 기초를 다루며, 공간 및 주파수 영역 연산, 에지 검출(Edge Detection), 화질 향상(Enhancement), 압축(Compression)을 포함합니다. NumPy와 SciPy를 사용하며, 고수준 컴퓨터 비전 API보다 신호 처리 원리에 집중합니다. 난이도: ⭐⭐⭐ 선수 과목: 1D DFT, 합성곱, FIR 필터 설계, 샘플링 정리 학습 목표: - 영상을 2D 이산 신호로 표현하고 샘플링 구조를 이해하기 - 2D 이산 푸리에 변환(DFT)을 계산하고 해석하기 - 공간 영역 필터링(평활화, 선명화,...", "url": "/study/ko/Signal_Processing/15_Image_Signal_Processing.html"}, {"id": "Signal_Processing/16_Applications", "title": "16. 신호 처리의 응용", "topic": "Signal_Processing", "topic_display": "Signal Processing", "body": "이전: 15. 영상 신호 처리 | 개요 --- 신호 처리는 단순한 이론적 학문이 아니라, 우리가 매일 사용하는 시스템을 지탱하는 공학적 근간입니다. 이 마지막 레슨에서는 오디오, 통신, 레이더/소나, 생체의학 신호 처리라는 네 가지 주요 응용 분야를 살펴봅니다. 각 분야에 대해 핵심 신호 처리 개념을 전개하고, 수학적 기반을 제공하며, 동작하는 Python 시연을 구현합니다. 목표는 앞선 열다섯 레슨에서 배운 도구들이 실제 시스템에서 어떻게 결합되는지를 보여주는 것입니다. 난이도: ⭐⭐⭐ 선수 지식: DFT/FFT, 필터링(FIR/IIR), 변조 기초, 상관관계, 스펙트럼 분석 학습 목표: - 오디오 신호 표현을 이해하고 디지털 오디오 이펙트를 구현한다 - 자기상관(autocorrelation)과 켑스트럼(cepstrum) 방법을 사용한 피치(pitch) 검출을 구현한다 - 아날로그 및 디지털 변조 방식(AM, FM, ASK, FSK, PSK, QAM)을 설명한다 - 펄스...", "url": "/study/ko/Signal_Processing/16_Applications.html"}, {"id": "Software_Engineering/00_Overview", "title": "소프트웨어 공학(Software Engineering)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "소프트웨어 공학을 하나의 학문 분야로서 포괄적으로 다루는 안내서입니다. 개인의 프로그래밍 역량을 대규모의 신뢰할 수 있고 유지보수 가능한 소프트웨어 시스템 구축 능력으로 전환시켜 주는 프로세스, 방법론, 관리 기법, 전문 실무를 다룹니다. 이 토픽은 코드 작성과 소프트웨어 공학 사이의 간극을 연결합니다. 이 토픽은 언어별 코드가 아닌 소프트웨어의 공학적 학문 분야에 초점을 맞춥니다: - 기초: 소프트웨어 공학이 무엇인지, 그 역사, 그리고 왜 중요한지 - 프로세스 모델(Process Models): 폭포수(Waterfall), 애자일(Agile), 나선형(Spiral), 반복적 개발 방식 - 요구사항(Requirements): 소프트웨어가 무엇을 해야 하는지 수집, 명세, 관리하는 방법 - 설계 및 모델링(Design and Modeling): UML, 아키텍처적 사고, 설계 문서화 - 계획 및 추정(Planning and Estimation): 노력을 추정하고, 프로젝트를...", "url": "/study/ko/Software_Engineering/00_Overview.html"}, {"id": "Software_Engineering/01_What_Is_Software_Engineering", "title": "레슨 1: 소프트웨어 공학이란 무엇인가", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 개요 | 다음: 소프트웨어 개발 생명주기 --- 소프트웨어 공학(Software Engineering)은 소프트웨어의 설계, 개발, 테스트, 배포, 유지보수에 공학적 원리를 체계적으로 적용하는 학문입니다. 단순히 코드를 작성하는 것을 넘어, 대규모로 신뢰할 수 있고 효율적이며 유지보수 가능한 소프트웨어를 생산하는 것을 목표로 하는 지식 체계, 프로세스 집합, 전문 실무입니다. 난이도: ⭐⭐ 선수 학습: - 임의의 언어로 된 프로그래밍 경험 - 소프트웨어 프로젝트의 기본 개념에 대한 이해 학습 목표: - 소프트웨어 공학을 정의하고 프로그래밍 및 컴퓨터 과학과 구별하기 - 소프트웨어 위기(Software Crisis)의 기원과 의의 설명하기 - 소프트웨어 공학을 어렵게 만드는 소프트웨어의 본질적 특성 설명하기 - 소프트웨어 시스템의 주요 범주 파악하기 - 소프트웨어 공학 실무를 이끄는 핵심 원리 나열하기 - 소프트웨어 공학 팀에서 발견되는 전문 역할 인식하기 --- \"소프트웨어...", "url": "/study/ko/Software_Engineering/01_What_Is_Software_Engineering.html"}, {"id": "Software_Engineering/02_Software_Development_Life_Cycle", "title": "레슨 2: 소프트웨어 개발 생명주기", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 소프트웨어 공학이란 무엇인가 | 다음: 애자일과 반복적 개발 --- 모든 소프트웨어 시스템은 개념 정립부터 폐기에 이르기까지 예측 가능한 일련의 단계를 거칩니다. 소프트웨어 개발 생명주기(Software Development Life Cycle, SDLC)는 이러한 단계, 각 단계의 활동, 생성되는 산출물, 그리고 한 단계에서 다음 단계로 이동하기 위한 기준을 정의하는 구조화된 프로세스입니다. 적절한 SDLC 모델을 선택하는 것은 프로젝트 시작 시 내리는 가장 중요한 결정 중 하나입니다. 난이도: ⭐⭐ 선수 학습: - 레슨 1: 소프트웨어 공학이란 무엇인가 - 소프트웨어 프로젝트에 대한 기본적인 이해 학습 목표: - 소프트웨어 개발 생명주기의 표준 단계를 설명한다 - 폭포수(Waterfall), V-모델(V-Model), 점진적(Incremental), 나선형(Spiral), RAD, 프로토타이핑(Prototyping) 모델을 설명한다 - 각 모델의 강점, 약점, 적합한...", "url": "/study/ko/Software_Engineering/02_Software_Development_Life_Cycle.html"}, {"id": "Software_Engineering/03_Agile_and_Iterative_Development", "title": "레슨 3: 애자일과 반복적 개발", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 소프트웨어 개발 생명주기 | 다음: 요구사항 공학 --- 애자일(Agile)은 방법론이 아니라 철학입니다. 이 용어는 변화에 대응하고, 작동하는 소프트웨어를 자주 납품하며, 고객과 긴밀하게 협력하는 것을 우선시하는 경량의 반복적 소프트웨어 개발 접근 방식의 모음을 설명합니다. 애자일은 불확실하거나 빠르게 변화하는 요구사항을 가진 프로젝트에서 무거운 계획 중심 프로세스의 실패에 대한 직접적인 반응으로 등장했습니다. 난이도: ⭐⭐ 선수 학습: - 레슨 1: 소프트웨어 공학이란 무엇인가 - 레슨 2: 소프트웨어 개발 생명주기 학습 목표: - 애자일 선언문의 네 가지 가치와 열두 가지 원칙을 설명한다 - 스크럼(Scrum) 프레임워크: 역할, 이벤트, 산출물을 설명한다 - 칸반(Kanban) 원칙을 적용하고 칸반 보드로 작업을 시각화한다 - 익스트림 프로그래밍(XP)의 핵심 실천법을 식별한다 - 린 소프트웨어 개발(Lean Software Development)의 일곱 가지 원칙을...", "url": "/study/ko/Software_Engineering/03_Agile_and_Iterative_Development.html"}, {"id": "Software_Engineering/04_Requirements_Engineering", "title": "레슨 04: 요구사항 공학(Requirements Engineering)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 03. 애자일과 반복 개발 | 다음: 05. 소프트웨어 모델링과 UML --- 요구사항 공학(Requirements Engineering)은 모든 소프트웨어 프로젝트의 성패를 좌우하는 토대입니다. 연구에 따르면, 요구사항 단계에서 발생한 오류 — 잘못 이해된 기능, 누락된 제약, 상충되는 목표 — 는 시스템이 배포된 이후에 수정할 때 초기에 발견했을 때보다 10배에서 100배 더 많은 비용이 든다고 일관되게 밝히고 있습니다. 이 레슨은 요구사항의 전체 생명주기를 다룹니다: 이해관계자가 실제로 필요로 하는 것을 발견하고, 그 필요를 정확히 문서화하고, 검증하고, 프로젝트가 발전함에 따라 통제하는 과정입니다. 난이도: ⭐⭐⭐ 선수 학습: - 레슨 01 — 소프트웨어 공학이란 무엇인가 - 레슨 02 — 소프트웨어 개발 생명주기 - 레슨 03 — 애자일과 반복 개발 학습 목표: - 기능 요구사항(Functional Requirements)과 비기능...", "url": "/study/ko/Software_Engineering/04_Requirements_Engineering.html"}, {"id": "Software_Engineering/05_Software_Modeling_and_UML", "title": "레슨 05: 소프트웨어 모델링과 UML", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 04. 요구사항 공학 | 다음: 06. 추정과 계획 --- 코드 한 줄이 작성되기 전에, 엔지니어들은 모델로 생각합니다. 모델은 일부 측면을 부각하고 나머지를 숨기는 시스템의 추상적이고 단순화된 표현입니다. 좋은 모델은 의사소통을 날카롭게 하고, 설계 문제를 조기에 드러내며, 기억이 희미해진 이후에도 오래도록 문서로 기능합니다. 통합 모델링 언어(UML, Unified Modeling Language)는 소프트웨어 모델을 위한 산업 표준 표기법입니다. 이 레슨은 가장 유용한 UML 다이어그램, 각각을 언제 적용해야 하는지, 그리고 올바르게 읽고 그리는 방법을 가르칩니다. 난이도: ⭐⭐⭐ 선수 학습: - 레슨 01 — 소프트웨어 공학이란 무엇인가 - 레슨 04 — 요구사항 공학 (유스케이스는 여기서 다시 다룸) - 기본 객체지향 프로그래밍 개념 (클래스, 객체, 상속) 학습 목표: - 소프트웨어 모델이 왜 가치 있으며 어느 수준의 세부 사항으로 그려야 하는지 설명한다 -...", "url": "/study/ko/Software_Engineering/05_Software_Modeling_and_UML.html"}, {"id": "Software_Engineering/06_Estimation_and_Planning", "title": "레슨 06: 추정과 계획 (Estimation and Planning)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 05. 소프트웨어 모델링과 UML | 다음: 07. 소프트웨어 품질 보증 --- 소프트웨어 팀에게 다음 프로젝트가 얼마나 걸릴지 물어보면, 대부분 낙관적인 답변을 내놓고 결국 틀리게 된다. Standish Group의 CHAOS 보고서 연구 결과에 따르면, 대다수의 소프트웨어 프로젝트가 일정과 예산을 초과한다. 이는 단순한 무능함이 아니다 — 소프트웨어는 지적 산물이고, 팀마다 특성이 다르며, 요구사항은 변하기 때문에 추정 자체가 본질적으로 어렵다. 이 레슨에서는 더 나은 추정과 현실적인 계획을 만들어내는 기법, 모델, 사고 습관을 익힌다. 난이도: ⭐⭐⭐ 선수 학습: - 레슨 02 — 소프트웨어 개발 생명 주기 - 레슨 03 — 애자일과 반복적 개발 - 레슨 04 — 요구사항 공학 학습 목표: - 소프트웨어 추정이 본질적으로 불확실한 이유를 설명하고 불확실성의 원뿔(Cone of Uncertainty)을 기술할 수 있다 - 코드 라인 수(LOC) 추정을 적용하고 그 한계를...", "url": "/study/ko/Software_Engineering/06_Estimation_and_Planning.html"}, {"id": "Software_Engineering/07_Software_Quality_Assurance", "title": "레슨 07: 소프트웨어 품질 보증(Software Quality Assurance)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 06. 추정 | 다음: 08. 검증 및 확인 --- 소프트웨어 품질은 우연히 생겨나지 않는다. 그것은 소프트웨어 개발 생명주기 전반에 걸쳐 의도적으로 적용되는 프로세스, 표준, 측정, 그리고 문화의 결과물이다. 이 레슨에서는 소프트웨어 품질 보증(SQA, Software Quality Assurance) 분야를 탐구한다 — 소프트웨어 제품과 프로세스의 품질을 정의하고, 측정하고, 체계적으로 개선한다는 것이 무엇을 의미하는지를 다룬다. 난이도: ⭐⭐⭐ 선수 학습: - 소프트웨어 개발 생명주기 기본 이해 (레슨 02) - 소프트웨어 테스팅 개념 친숙도 - 기본 프로그래밍 지식 학습 목표: - IEEE 및 ISO 25010 프레임워크를 사용하여 소프트웨어 품질 정의하기 - 품질 보증(Quality Assurance), 품질 관리(Quality Control), 테스팅의 차이 구별하기 - 소프트웨어 프로젝트에 품질 비용(Cost of Quality) 모델 적용하기 - 일반적인...", "url": "/study/ko/Software_Engineering/07_Software_Quality_Assurance.html"}, {"id": "Software_Engineering/08_Verification_and_Validation", "title": "레슨 08: 검증과 확인 (Verification and Validation)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 07. 소프트웨어 품질 보증 | 다음: 09. 형상 관리 --- \"올바른 방식으로 제품을 만들고 있는가?\" 그리고 \"올바른 제품을 만들고 있는가?\" 1979년 Barry Boehm이 제시한 이 두 질문은 검증(Verification)과 확인(Validation), 즉 V&V의 본질을 담고 있습니다. 이 두 가지는 함께 소프트웨어 공학의 품질 근간을 형성합니다. 소프트웨어가 기술적으로 올바르고 실질적으로 유용한지를 보장하는 체계적이고 규율 있는 접근 방식입니다. 이 레슨에서는 단위 테스트부터 형식적 증명(formal proof)까지 V&V 기법의 전반적인 스펙트럼을 살펴보고, 실제 프로젝트를 위한 포괄적인 테스트 전략을 설계할 수 있는 역량을 갖추도록 합니다. 난이도: ⭐⭐⭐ 선수 학습: - 소프트웨어 품질 보증(Software Quality Assurance) 기초 (레슨 07) - 기본 프로그래밍 및 단위 테스트 경험 - 소프트웨어 개발 생명주기(SDLC) 이해 (레슨...", "url": "/study/ko/Software_Engineering/08_Verification_and_Validation.html"}, {"id": "Software_Engineering/09_Configuration_Management", "title": "레슨 09: 형상 관리(Configuration Management)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 08. 검증과 확인 | 다음: 10. 프로젝트 관리 --- 소프트웨어 시스템은 결코 완성되지 않습니다 — 지속적으로 변경되고, 확장되며, 다양한 환경에 배포됩니다. 이러한 변경을 규율 있게 관리하지 않으면, 프로젝트는 혼돈에 빠집니다: 팀원들이 서로의 작업을 덮어쓰고, 운영 환경에서 아무도 재현할 수 없는 버전이 실행되며, 핫픽스 하나가 찾는 데 석 달이 걸리는 회귀 버그를 유발합니다. 소프트웨어 형상 관리(Software Configuration Management, SCM)는 이를 방지하는 규율입니다. 모든 산출물에 정확한 식별자를 부여하고, 변경 방식을 통제하며, 언제든 시스템의 특정 버전을 재현 가능하게 만듭니다. 난이도: ⭐⭐⭐ 선수 학습: - 버전 관리(Git 토픽 권장)에 대한 기본 이해 - 소프트웨어 개발 생명주기 이해 (레슨 02) - 일반 프로그래밍 경험 학습 목표: - 소프트웨어 형상 관리(SCM)를 정의하고 소프트웨어 공학에서의 역할을 설명한다 - 형상...", "url": "/study/ko/Software_Engineering/09_Configuration_Management.html"}, {"id": "Software_Engineering/10_Project_Management", "title": "레슨 10: 소프트웨어 프로젝트 관리(Software Project Management)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 프로세스 모델과 애자일 | 다음: 소프트웨어 유지보수와 진화 소프트웨어 프로젝트는 악명 높을 정도로 높은 실패율을 보입니다. Standish Group의 연구(CHAOS 보고서)에 따르면 소프트웨어 프로젝트의 약 3분의 1이 완료 전에 취소되고, 나머지 절반은 예산 초과 또는 일정 지연이 심각한 것으로 지속적으로 나타납니다. 효과적인 프로젝트 관리(Project Management)는 가치를 전달하는 프로젝트와 반면교사가 되는 프로젝트를 가르는 핵심 역량입니다. 난이도: ⭐⭐⭐ 선수 학습: - 소프트웨어 개발 프로세스에 대한 기본 이해 - 애자일 및 전통적 SDLC 모델에 대한 친숙함 (레슨 02–03) - 소프트웨어 프로젝트에서의 실무 경험 학습 목표: - 프로젝트 관리 삼각형(Project Management Triangle)과 의사결정에 미치는 영향 이해 - 소프트웨어 프로젝트 계획 방법 학습: 범위, 일정, 자원 - 리스크 레지스터(Risk Register)와 대응...", "url": "/study/ko/Software_Engineering/10_Project_Management.html"}, {"id": "Software_Engineering/11_Software_Maintenance_and_Evolution", "title": "레슨 11: 소프트웨어 유지보수와 진화(Software Maintenance and Evolution)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 프로젝트 관리 | 다음: 프로세스 개선 소프트웨어는 물리적 기계처럼 마모되지 않습니다. 서버에 저장된 데이터베이스 바이너리는 마찰, 부식, 피로를 경험하지 않습니다. 그러나 소프트웨어는 여전히 \"노후화\"됩니다. 비트가 열화되는 것이 아니라, 주변 세상이 변하기 때문입니다. 운영 체제가 진화하고, 보안 취약점이 발견되고, 비즈니스 규칙이 변화하고, 사용자 기대치가 높아집니다. 초기 릴리스 이후 소프트웨어를 유지하고 진화시키는 방법을 이해하는 것은 소프트웨어 공학에서 경제적으로 가장 중요한 기술 중 하나입니다. 난이도: ⭐⭐⭐ 선수 학습: - 소프트웨어 개발 수명 주기 개념 (레슨 02) - 기본 소프트웨어 설계 원칙 - 버전 관리 (Git)에 대한 친숙함 학습 목표: - 네 가지 유형의 소프트웨어 유지보수를 구분하고 각각의 적용 시기 파악 - 레만의 법칙(Lehman's Laws)과 장기 시스템에 대한 시사점 설명 - 레거시 시스템 현대화 전략 평가 - 동작을 변경하지 않고...", "url": "/study/ko/Software_Engineering/11_Software_Maintenance_and_Evolution.html"}, {"id": "Software_Engineering/12_Process_Improvement", "title": "레슨 12: 소프트웨어 프로세스 개선(Software Process Improvement)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 소프트웨어 유지보수와 진화 | 다음: DevOps와 CI/CD 모든 소프트웨어 조직에는 정의되었든 아니든 프로세스가 존재한다. 문제는 프로세스의 존재 여부가 아니라, 그것이 효과적이고 가시적이며 시간이 지남에 따라 개선되고 있는가이다. 소프트웨어 프로세스 개선(SPI, Software Process Improvement)은 소프트웨어가 어떻게 구축되고 운영되는지를 분석하고, 약점을 식별하며, 품질·속도·비용·팀 만족도 측면에서 더 나은 결과를 이끌어내는 목표 지향적 변화를 만드는 체계적인 실천이다. 난이도: ⭐⭐⭐ 선수 학습: - 소프트웨어 개발 생명주기(레슨 02) - 애자일(Agile) 기초(레슨 03) - 소프트웨어 품질 보증 개념(레슨 07) - 기본 프로젝트 관리(레슨 10) 학습 목표: - 소프트웨어 프로세스 개선이 더 나은 결과를 가져오는 이유를 이해한다 - CMM/CMMI 성숙도 모델과 5단계 레벨을 설명한다 - ISO/IEC 12207 및...", "url": "/study/ko/Software_Engineering/12_Process_Improvement.html"}, {"id": "Software_Engineering/13_DevOps_and_CICD", "title": "레슨 13: DevOps와 CI/CD", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 프로세스 개선 | 다음: 기술 문서화 --- DevOps는 지난 10년간 소프트웨어 팀이 소프트웨어를 구축하고 납품하는 방식을 변화시켰다. 그러나 DevOps는 도구도, 제품도, 직함도 아니다 — 소프트웨어 개발과 IT 운영 사이의 전통적인 장벽을 허무는 문화와 실천의 집합이다. 이 레슨에서는 DevOps의 진정한 의미, 지속적 통합(Continuous Integration)과 지속적 납품(Continuous Delivery) 뒤에 있는 원칙, 그리고 성숙한 엔지니어링 조직이 납품 프로세스의 속도와 신뢰성을 어떻게 측정하고 개선하는지 탐구한다. 난이도: ⭐⭐⭐ 선수 학습: - 형상 관리 — 브랜칭 전략, 버전 관리 워크플로우 - 프로세스 개선 — 메트릭, 회고, 개선 사이클 - 빌드 시스템과 자동화 테스트 개념에 대한 기본 이해 학습 목표: - DevOps가 무엇인지 설명하고 전통적인 운영 및 SRE와 구별한다 - CALMS 프레임워크와 문화가 DevOps의 기반인 이유를...", "url": "/study/ko/Software_Engineering/13_DevOps_and_CICD.html"}, {"id": "Software_Engineering/14_Technical_Documentation", "title": "레슨 14: 기술 문서화(Technical Documentation)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: DevOps와 CI/CD | 다음: 팀 역학과 커뮤니케이션 --- 문서는 코드의 기억이다. 코드는 시스템이 무엇을 하는지 알려주지만, 문서는 왜 그런 방식으로 동작하는지, 어떻게 사용하는지, 그리고 개발 과정에서 어떤 결정이 내려졌는지 알려준다. 좋은 문서는 팀의 효율을 배가시킨다 — 반복적인 질문에 답하는 시간을 줄이고, 새 팀원의 온보딩(onboarding)을 가속화하며, 엔지니어가 이직할 때 함께 사라질 조직의 지식을 보존한다. 이 레슨에서는 소프트웨어 엔지니어링에서 중요한 문서의 유형, 잘 작성하는 방법, 그리고 문서가 점점 쓸모없어지는 것을 막는 방법을 다룬다. 난이도: ⭐⭐ 선수 학습: - 소프트웨어 엔지니어링이란 — 소프트웨어 생명주기 이해 - 마크다운 문법에 대한 기본 지식 학습 목표: - 기술 문서의 각 유형과 해당 대상 독자를 식별한다 - 소스 코드와 함께 문서를 관리하는 코드로서의 문서(docs-as-code) 워크플로를 적용한다 - 표준 형식으로...", "url": "/study/ko/Software_Engineering/14_Technical_Documentation.html"}, {"id": "Software_Engineering/15_Team_Dynamics_and_Communication", "title": "레슨 15: 팀 역학과 커뮤니케이션(Team Dynamics and Communication)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 기술 문서화 | 다음: 윤리와 직업 의식 --- 소프트웨어 엔지니어링은 근본적으로 팀의 노력이다. 기술적으로 뛰어난 엔지니어라 하더라도 효과적으로 소통하지 못하고, 압박 하에서 협업하지 못하며, 지식을 너그럽게 공유하지 못한다면 팀의 성과를 제한할 것이다. 엔지니어링 팀 효과성에 대한 연구는 팀워크의 방식 — 커뮤니케이션 패턴, 심리적 안전감(psychological safety), 피드백 문화 — 이 개인의 기술 역량만큼이나 결과를 예측한다는 것을 일관되게 보여준다. 이 레슨에서는 소프트웨어 팀이 어떻게 구성되고, 어떻게 소통하며, 장기적으로 팀을 진정으로 효과적으로 만드는 습관을 어떻게 형성하는지 살펴본다. 난이도: ⭐⭐ 선수 학습: - 소프트웨어 엔지니어링이란 — 역할과 조직 맥락 - 애자일과 반복적 개발 — 스크럼 의식과 팀 관행 학습 목표: - 기능팀(functional team), 다기능팀(cross-functional team), 피처팀(feature team)...", "url": "/study/ko/Software_Engineering/15_Team_Dynamics_and_Communication.html"}, {"id": "Software_Engineering/16_Ethics_and_Professionalism", "title": "레슨 16: 윤리와 직업 의식(Ethics and Professionalism)", "topic": "Software_Engineering", "topic_display": "Software Engineering", "body": "이전: 팀 역학과 커뮤니케이션 | 다음: 개요 --- 소프트웨어 엔지니어링은 화성에 우주선을 착륙시키고, 인간 게놈을 해독하며, 수십억 명의 사람들을 연결하는 시스템을 만들어냈다. 또한 인종에 따라 대출 신청자를 차별하고, 여객기의 안전 제어 장치를 고장냈으며, 실질적인 동의 없이 개인 데이터를 수집하는 시스템도 만들어냈다. 소프트웨어가 인간의 삶에 대규모로 미치는 영향력 — 선과 악 모두 — 은 그것을 만드는 사람들에게 진정한 윤리적 의무를 부과한다. 이 레슨에서는 그 의무를 검토한다: 의무를 정의하는 직업 윤리 규범, 이를 무시했을 때 어떤 일이 일어나는지 보여주는 역사적 실패 사례, 그리고 모든 현직 엔지니어가 결국 직면하게 되는 실질적인 질문들. 난이도: ⭐⭐ 선수 학습: - 소프트웨어 엔지니어링이란 — 해당 분야의 범위와 책임 - 사전 윤리학 배경 불필요 학습 목표: - ACM/IEEE 소프트웨어 엔지니어링 윤리 강령과 여덟 가지 원칙을 요약한다 - 역사적 소프트웨어 실패...", "url": "/study/ko/Software_Engineering/16_Ethics_and_Professionalism.html"}, {"id": "Spanish/00_Overview", "title": "스페인어 학습 가이드", "topic": "Spanish", "topic_display": "Spanish", "body": "이 폴더는 스페인어 문법과 어휘를 학습하기 위한 참고 자료를 담고 있습니다. 품사별로 정리된 자료를 통해 체계적으로 스페인어를 학습할 수 있습니다. 대상 독자: 스페인어 입문자 ~ 중급자 --- | 파일명 | 주요 내용 | 항목 수 | |--------|----------|---------| | 01Grammar.md | 스페인어 문법 종합 정리 | 16개 섹션 | | 02Verbs.md | 동사 활용, 시제, 불규칙 동사 | 270개 | | 03Nouns.md | 명사, 성/수 일치, 관사 | 860개+ | | 04Adjectives.md | 형용사, 비교급, 최상급 | 215개 | | 05OtherPartsofSpeech.md | 대명사, 부사, 전치사, 접속사, 감탄사, 담화 표지 | 465개+ | | 06SubjunctiveAdvanced.md | Subjuntivo 사용 상황, 시제별 활용 | - | | 07VerbConjugationSystem.md | 불규칙 패턴,...", "url": "/study/ko/Spanish/00_Overview.html"}, {"id": "Spanish/01_Grammar", "title": "스페인어 종합 문법", "topic": "Spanish", "topic_display": "Spanish", "body": "--- 1. 동사 기초 (SER, ESTAR, TENER) 2. 관사 (Articles) 3. 전치사 (Prepositions) 4. 명사의 성과 수 (Gender and Number) 5. 형용사의 일치 (Adjective Agreement) 6. 동사 활용 (Verb Conjugation) 7. 의문사 (Question Words) 8. 부정 (Negation) 9. 소유형용사와 소유대명사 (Possessives) 10. 지시형용사와 지시대명사 (Demonstratives) 11. 대명사 (Pronouns) 12. 접속사 (Conjunctions) 13. 비교급과 최상급 (Comparatives and Superlatives) 14. 시제 (Tenses) 15. 명령법 (Imperative) 16. 접속법 (Subjunctive) --- 활용 (Conjugation): - yo soy / I am / 나는 ~이다 - tú eres / you are / 너는 ~이다 -...", "url": "/study/ko/Spanish/01_Grammar.html"}, {"id": "Spanish/02_Verbs", "title": "스페인어 동사 완전 정리", "topic": "Spanish", "topic_display": "Spanish", "body": "--- 1. 기초 필수 동사 100개 2. 행동 동사 추가 3. 자주 쓰이는 재귀동사 4. 동사 활용 패턴 --- 1. ser / to be (permanent) / ~이다 (영구적) 2. estar / to be (temporary) / ~이다 (일시적) 3. haber / to have (auxiliary) / ~했다 (조동사) 4. tener / to have / 가지다 5. hacer / to do, to make / 하다, 만들다 6. ir / to go / 가다 7. venir / to come / 오다 8. decir / to say, to tell / 말하다 9. poder / to be able to, can / 할 수 있다 10. deber / must, should / ~해야 하다 11. dar / to give / 주다 12. saber / to know (facts) / 알다 (사실) 13. conocer / to know (people/places) /...", "url": "/study/ko/Spanish/02_Verbs.html"}, {"id": "Spanish/03_Nouns", "title": "스페인어 명사 완전 정리", "topic": "Spanish", "topic_display": "Spanish", "body": "--- 1. 사람과 가족 2. 신체 3. 집과 가구 4. 음식 5. 의류 6. 장소 7. 교통 8. 자연과 환경 9. 동물 10. 시간 11. 교육과 직업 12. 기술과 현대 생활 13. 건강과 의료 14. 취미와 스포츠 15. 쇼핑 16. 개념 --- 1. familia / family / 가족 2. padre / father / 아버지 3. madre / mother / 어머니 4. hijo/a / son/daughter / 아들/딸 5. hermano/a / brother/sister / 형제/자매 6. abuelo/a / grandfather/grandmother / 할아버지/할머니 7. tío/a / uncle/aunt / 삼촌/이모 8. primo/a / cousin / 사촌 9. esposo/a / husband/wife / 남편/아내 10. nieto/a / grandson/granddaughter / 손자/손녀 11. sobrino/a / nephew/niece /...", "url": "/study/ko/Spanish/03_Nouns.html"}, {"id": "Spanish/04_Adjectives", "title": "스페인어 형용사 완전 정리", "topic": "Spanish", "topic_display": "Spanish", "body": "--- 1. 기초 형용사 100개 2. 추가 형용사 3. 형용사 일치 규칙 --- 1. grande / big, large / 큰 2. pequeño/a / small / 작은 3. largo/a / long / 긴 4. corto/a / short / 짧은 5. alto/a / tall, high / 높은, 키 큰 6. bajo/a / short, low / 낮은, 키 작은 7. ancho/a / wide / 넓은 8. estrecho/a / narrow / 좁은 9. mucho/a / much, many / 많은 10. poco/a / little, few / 적은 11. blanco/a / white / 하얀 12. negro/a / black / 검은 13. rojo/a / red / 빨간 14. azul / blue / 파란 15. verde / green / 초록 16. amarillo/a / yellow / 노란 17. gris / gray / 회색 18. marrón...", "url": "/study/ko/Spanish/04_Adjectives.html"}, {"id": "Spanish/05_Other_Parts_of_Speech", "title": "스페인어 기타 품사 완전 정리", "topic": "Spanish", "topic_display": "Spanish", "body": "--- 1. 대명사 (Pronouns) 2. 접속사 (Conjunctions) 3. 전치사 (Prepositions) 4. 부사 (Adverbs) 5. 의문사 (Interrogatives) 6. 관사 (Articles) 7. 수사 (Numerals) 8. 구어체 표현과 관용어 (Colloquial Expressions) 9. 감탄사 (Interjections) 10. 담화 표지 (Discourse Markers) --- | 대명사 | 의미 | |--------|------| | yo / I / 나 | | tú / you (informal) / 너 | | él / he / 그 | | ella / she / 그녀 | | usted / you (formal) / 당신 | | nosotros/as / we / 우리 | | vosotros/as / you all (informal) / 너희 | | ellos / they (masculine) / 그들 | | ellas / they...", "url": "/study/ko/Spanish/05_Other_Parts_of_Speech.html"}, {"id": "Spanish/06_Subjunctive_Advanced", "title": "06. 접속법 심화 (El Subjuntivo Avanzado)", "topic": "Spanish", "topic_display": "Spanish", "body": "- 접속법(Subjuntivo)의 용도와 사용 상황 이해 - 현재/과거/미완료 접속법 활용법 마스터 - 접속법을 유발하는 트리거 표현 습득 - 직설법과 접속법의 선택 기준 이해 - 실전 회화에서 접속법 활용 1. 접속법 개요 2. 현재 접속법 3. 과거 접속법 4. 접속법 트리거 5. 조건문과 접속법 6. 연습 문제 --- --- --- --- --- --- 올바른 형태를 선택하세요. 빈칸을 채우세요. 주어진 상황에 맞게 접속법을 사용하여 문장을 작성하세요. --- - 07. 동사 활용 체계 - 08. 지역 변형 및 방언 - Real Academia Española (RAE) - Practice Makes Perfect: Spanish Verb Tenses - SpanishDict Subjunctive Guide", "url": "/study/ko/Spanish/06_Subjunctive_Advanced.html"}, {"id": "Spanish/07_Verb_Conjugation_System", "title": "07. 동사 활용 체계 (Sistema de Conjugación Verbal)", "topic": "Spanish", "topic_display": "Spanish", "body": "- 스페인어 동사의 시제와 법 체계 이해 - 불규칙 동사 패턴 분류 및 암기 전략 습득 - 어간 변화 동사 규칙 마스터 - 재귀 동사의 활용법 이해 - 복합 시제의 형성과 사용 1. 동사 체계 개요 2. 어간 변화 동사 3. 불규칙 동사 패턴 4. 재귀 동사 5. 복합 시제 6. 연습 문제 --- --- --- --- --- --- 빈칸을 채우세요. 단순 과거로 바꾸세요. 적절한 재귀 대명사를 넣으세요. 주어진 시제로 바꾸세요. --- - 06. 접속법 심화 - 08. 지역 변형 및 방언 - Real Academia Española (RAE) - Conjugación - 501 Spanish Verbs (Barron's) - SpanishDict Conjugation Tool", "url": "/study/ko/Spanish/07_Verb_Conjugation_System.html"}, {"id": "Spanish/08_Regional_Variations_Dialects", "title": "08. 지역 변형 및 방언 (Variaciones Regionales y Dialectos)", "topic": "Spanish", "topic_display": "Spanish", "body": "- 스페인어의 지역별 차이점 이해 - 스페인 vs 라틴아메리카 스페인어 비교 - 주요 국가별 특징적 표현 학습 - vosotros vs ustedes 사용 구분 - 지역별 발음 특성 이해 1. 스페인어 지역 변형 개요 2. 스페인 스페인어 3. 멕시코 스페인어 4. 아르헨티나/우루과이 스페인어 5. 기타 라틴아메리카 변형 6. 연습 문제 --- --- --- --- --- --- 다음 문장이 어느 지역의 스페인어인지 맞추세요. 스페인 스페인어를 멕시코 스페인어로 바꾸세요. 적절한 형태를 선택하세요. 다음 단어의 발음을 스페인과 라틴아메리카로 구분하세요. --- - 06. 접속법 심화 - 09. 일상 회화 및 관용어 - Real Academia Española (RAE) - Diccionario de americanismos - \"El español en el mundo\" - Instituto Cervantes", "url": "/study/ko/Spanish/08_Regional_Variations_Dialects.html"}, {"id": "Spanish/09_Daily_Conversation_Idioms", "title": "09. 일상 회화 및 관용어 (Conversación Cotidiana y Expresiones Idiomáticas)", "topic": "Spanish", "topic_display": "Spanish", "body": "- 일상 회화에서 자주 사용되는 표현 습득 - 스페인어 관용어와 숙어 이해 - 상황별 적절한 표현 선택 능력 배양 - 비즈니스 스페인어 기초 학습 - 구어체와 문어체의 차이 이해 1. 인사와 소개 2. 일상 표현 3. 관용어와 숙어 4. 감정 표현 5. 비즈니스 스페인어 6. 연습 문제 --- --- --- --- --- --- 적절한 표현을 고르세요. 의미를 연결하세요. 빈칸을 채우세요. 형식적(F) 또는 비형식적(I) 표현으로 분류하세요. --- - 06. 접속법 심화 - 07. 동사 활용 체계 - \"Español coloquial\" - Real Academia Española - \"Business Spanish\" - Barron's - \"Diccionario de modismos\" - Espasa - SpanishDict Idioms", "url": "/study/ko/Spanish/09_Daily_Conversation_Idioms.html"}, {"id": "Spanish/10_Advanced_Grammar_Topics", "title": "고급 문법", "topic": "Spanish", "topic_display": "Spanish", "body": "--- 1. 관계절 (Relative Clauses) 2. 수동태 (Passive Voice) 3. 고급 조건문 (Advanced Conditionals) 4. 연습 문제 (Practice Exercises) --- 관계절은 명사를 수식하는 절로, 관계대명사나 관계부사로 시작합니다. | 관계대명사 | 용도 | 예시 | 의미 | |-----------|------|------|------| | que | 사람/사물 (가장 흔함) | El libro que leo | 내가 읽는 책 | | quien(es) | 사람만 (전치사와 함께) | La persona con quien hablo | 내가 대화하는 사람 | | el/la cual, los/las cuales | 격식체, 전치사 후 | El motivo por el cual vine | 내가 온 이유 | | cuyo/a/os/as | 소유 (whose) | El autor cuyo libro leí | 내가 책을 읽은 작가 | |...", "url": "/study/ko/Spanish/10_Advanced_Grammar_Topics.html"}, {"id": "Spanish/11_Vocabulary_by_Theme", "title": "주제별 어휘와 표현", "topic": "Spanish", "topic_display": "Spanish", "body": "--- 1. 축소사와 확대사 (Diminutives and Augmentatives) 2. 주제별 관용어 (Idioms by Theme) 3. 현대 주제 어휘 (Modern Thematic Vocabulary) --- 스페인어에서 명사, 형용사, 부사에 접미사를 붙여 크기, 애정, 경멸 등의 뉘앙스를 표현합니다. 애정, 작은 크기, 친근함을 표현 | 원형 | 축소형 | 의미 | 뉘앙스 | |------|--------|------|--------| | casa | casita | 작은 집 | 아담한, 귀여운 | | perro | perrito | 강아지, 작은 개 | 귀여움 | | gato | gatito | 새끼 고양이 | 귀여움 | | libro | librito | 작은 책 | 작은 크기 | | momento | momentito | 잠깐 | 부담 완화 | | ahora | ahorita | 지금 바로 | 즉시성 강조 | | café | cafecito | 커피 한 잔 |...", "url": "/study/ko/Spanish/11_Vocabulary_by_Theme.html"}, {"id": "System_Design/00_Overview", "title": "시스템 디자인 학습 가이드", "topic": "System_Design", "topic_display": "System Design", "body": "이 폴더는 시스템 디자인(System Design)을 체계적으로 학습하기 위한 자료를 담고 있습니다. 대규모 시스템을 설계하는 데 필요한 핵심 개념부터 실전 패턴까지 단계별로 학습할 수 있습니다. 기술 면접 준비와 실무 아키텍처 설계 역량 향상에 도움이 됩니다. 대상 독자: 백엔드 개발자, 시스템 아키텍트, 기술 면접 준비자 --- --- - 필수 - 네트워크 기초 (HTTP, DNS, TCP/IP) → Networking/ - 데이터베이스 기초 (SQL, 트랜잭션) → PostgreSQL/ - 프로그래밍 언어 1개 이상 - 권장 - Linux 기본 명령어 → Linux/ - Docker 기초 → Docker/ - REST API 개념 → WebDevelopment/ --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01SystemDesignOverview.md | ⭐ | 시스템 설계란, 면접 평가 기준, 문제 접근 프레임워크...", "url": "/study/ko/System_Design/00_Overview.html"}, {"id": "System_Design/01_System_Design_Overview", "title": "시스템 설계 개요", "topic": "System_Design", "topic_display": "System Design", "body": "이 문서에서는 시스템 설계(System Design)의 기본 개념과 면접에서의 접근법을 다룹니다. 대규모 시스템을 설계하기 위한 기본 프레임워크와 규모 추정(Back-of-the-envelope) 계산 방법을 학습합니다. 난이도: ⭐ 예상 학습 시간: 2시간 선수 지식: 프로그래밍 기초, 웹 서비스 기본 개념 --- 1. 시스템 설계란? 2. 면접 평가 기준 3. 문제 접근 프레임워크 4. Back-of-the-envelope 계산 5. 자주 사용하는 수치 6. 연습 문제 7. 다음 단계 8. 참고 자료 --- 시스템 설계는 복잡한 소프트웨어 시스템의 아키텍처를 정의하는 과정입니다. 요구사항을 분석하고, 컴포넌트를 설계하며, 확장성과 신뢰성을 갖춘 시스템을 만드는 것이 목표입니다. | 구분 | 코딩 면접 | 시스템 설계 면접 | |------|----------|-----------------| | 목적 | 알고리즘 능력 평가 | 아키텍처 설계 능력 평가 | | 정답 | 명확한...", "url": "/study/ko/System_Design/01_System_Design_Overview.html"}, {"id": "System_Design/02_Scalability_Basics", "title": "확장성 기초", "topic": "System_Design", "topic_display": "System Design", "body": "이 문서에서는 시스템 확장성(Scalability)의 핵심 개념을 다룹니다. 수직/수평 확장의 차이, Stateless vs Stateful 아키텍처, 그리고 분산 시스템에서 중요한 CAP 정리와 PACELC 이론을 학습합니다. 난이도: ⭐⭐ 예상 학습 시간: 2-3시간 선수 지식: 01SystemDesignOverview.md --- 1. 확장성이란? 2. 수직 확장 vs 수평 확장 3. Stateless vs Stateful 4. 세션 관리 방법 5. CAP 정리 6. PACELC 이론 7. 연습 문제 8. 다음 단계 9. 참고 자료 --- 확장성(Scalability)은 시스템이 증가하는 부하(load)를 처리하기 위해 리소스를 추가할 수 있는 능력입니다. --- | 항목 | 수직 확장 | 수평 확장 | |------|----------|----------| | 방법 | 더 강력한 서버 | 더 많은 서버 | | 확장 한계 | 하드웨어 한계 | 이론적 무한 | | 비용 |...", "url": "/study/ko/System_Design/02_Scalability_Basics.html"}, {"id": "System_Design/03_Network_Fundamentals_Review", "title": "네트워크 기초 복습", "topic": "System_Design", "topic_display": "System Design", "body": "이 문서에서는 시스템 설계에 필수적인 네트워크 개념을 복습합니다. DNS 동작 원리와 DNS 기반 로드밸런싱, CDN의 Push/Pull 모델, HTTP/2와 HTTP/3의 특징, 그리고 REST와 gRPC의 선택 기준을 학습합니다. 난이도: ⭐⭐ 예상 학습 시간: 2-3시간 선수 지식: Networking 폴더 기초 --- 1. DNS 동작과 로드밸런싱 2. CDN (Content Delivery Network) 3. HTTP/2와 HTTP/3 4. REST vs gRPC 5. 연습 문제 6. 다음 단계 7. 참고 자료 --- --- | 항목 | Push CDN | Pull CDN | |------|----------|----------| | 배포 방식 | 관리자가 직접 업로드 | 요청 시 자동 캐싱 | | 첫 요청 | 즉시 응답 | Origin 접근 필요 | | 캐시 관리 | 수동 | 자동 (TTL) | | 저장 비용 | 높음 (전체 배포) | 낮음 (필요시만) | | 적합한...", "url": "/study/ko/System_Design/03_Network_Fundamentals_Review.html"}, {"id": "System_Design/04_Load_Balancing", "title": "로드 밸런싱", "topic": "System_Design", "topic_display": "System Design", "body": "이 문서에서는 로드 밸런싱(Load Balancing)의 핵심 개념을 다룹니다. L4/L7 로드 밸런서의 차이, 다양한 트래픽 분배 알고리즘, Sticky Session, 그리고 헬스 체크 메커니즘을 학습합니다. 난이도: ⭐⭐⭐ 예상 학습 시간: 2-3시간 선수 지식: 03NetworkFundamentalsReview.md --- 1. 로드 밸런싱이란? 2. L4 vs L7 로드 밸런서 3. 분배 알고리즘 4. Sticky Session 5. 헬스 체크 6. 고가용성 구성 7. 연습 문제 8. 다음 단계 9. 참고 자료 --- 로드 밸런싱은 들어오는 네트워크 트래픽을 여러 서버에 분산시켜 시스템의 가용성과 성능을 향상시키는 기술입니다. --- | 항목 | L4 로드 밸런서 | L7 로드 밸런서 | |------|---------------|---------------| | OSI 계층 | 4 (Transport) | 7 (Application) | | 분석 대상 | IP, Port...", "url": "/study/ko/System_Design/04_Load_Balancing.html"}, {"id": "System_Design/05_Reverse_Proxy_API_Gateway", "title": "리버스 프록시와 API 게이트웨이", "topic": "System_Design", "topic_display": "System Design", "body": "이 문서에서는 리버스 프록시의 역할과 API 게이트웨이 패턴을 다룹니다. SSL 종료, 압축, 캐싱 등 리버스 프록시의 핵심 기능과 인증/인가, 라우팅, Rate Limiting 알고리즘을 학습합니다. 난이도: ⭐⭐⭐ 예상 학습 시간: 2-3시간 선수 지식: 04LoadBalancing.md --- 1. 리버스 프록시란? 2. 리버스 프록시 핵심 기능 3. API 게이트웨이 패턴 4. Rate Limiting 5. 연습 문제 6. 다음 단계 7. 참고 자료 --- --- --- --- | 알고리즘 | 버스트 | 메모리 | 정확도 | 사용 사례 | |----------|--------|--------|--------|----------| | 토큰 버킷 | 허용 | 작음 | 높음 | API 제한 | | 리키 버킷 | 불가 | 작음 | 높음 | 트래픽 쉐이핑 | | 고정 윈도우 | 경계 버스트 | 작음 | 낮음 | 단순 구현 | | 슬라이딩 윈도우 | 허용 | 큼/중간 | 높음 |...", "url": "/study/ko/System_Design/05_Reverse_Proxy_API_Gateway.html"}, {"id": "System_Design/06_Caching_Strategies", "title": "캐싱 전략", "topic": "System_Design", "topic_display": "System Design", "body": "이 문서에서는 캐싱의 핵심 전략과 패턴을 다룹니다. Cache-Aside, Read-Through, Write-Through, Write-Behind 패턴의 차이를 이해하고, 캐시 무효화, TTL 설정, 그리고 캐시 침투/눈사태/핫키 문제와 해결책을 학습합니다. 난이도: ⭐⭐⭐ 예상 학습 시간: 2-3시간 선수 지식: 05ReverseProxyAPIGateway.md --- 1. 캐싱이란? 2. 캐싱 전략 패턴 3. 캐시 무효화 4. 캐시 문제와 해결책 5. CDN 캐싱 6. 연습 문제 7. 다음 단계 8. 참고 자료 --- --- | 패턴 | 읽기 | 쓰기 | 일관성 | 성능 | 복잡도 | |------|------|------|--------|------|--------| | Cache-Aside | 앱이 관리 | DB 직접, 캐시 무효화 | 약함 | 좋음 | 낮음 | | Read-Through | 캐시가 관리 | - | - | 좋음 | 중간 | | Write-Through |...", "url": "/study/ko/System_Design/06_Caching_Strategies.html"}, {"id": "System_Design/07_Distributed_Cache_Systems", "title": "분산 캐시 시스템", "topic": "System_Design", "topic_display": "System Design", "body": "이 문서에서는 분산 캐시 시스템의 핵심 개념을 다룹니다. Redis의 데이터 구조와 클러스터 구성, Memcached와의 비교, 그리고 일관성 해싱(Consistent Hashing)을 학습합니다. 난이도: ⭐⭐⭐ 예상 학습 시간: 2-3시간 선수 지식: 06CachingStrategies.md --- 1. 분산 캐시란? 2. Redis 데이터 구조 3. Redis 클러스터와 Sentinel 4. Memcached 비교 5. 일관성 해싱 6. 연습 문제 7. 다음 단계 8. 참고 자료 --- | 항목 | 로컬 캐시 | 분산 캐시 | |------|----------|----------| | 저장 위치 | 애플리케이션 메모리 | 별도 서버 (Redis 등) | | 속도 | 매우 빠름 (ns~us) | 빠름 (ms) | | 용량 | 서버 메모리 제한 | 확장 가능 | | 일관성 | 서버별 다름 | 공유/일관 | | 장애 | 서버 재시작 시 손실 | 독립적 관리 가능 | | 사용 예 |...", "url": "/study/ko/System_Design/07_Distributed_Cache_Systems.html"}, {"id": "System_Design/08_Database_Scaling", "title": "데이터베이스 확장", "topic": "System_Design", "topic_display": "System Design", "body": "이 문서에서는 데이터베이스 확장 전략을 다룹니다. 파티셔닝과 샤딩의 차이, 다양한 샤딩 전략(Range, Hash, Directory), 샤딩 키 선택, 핫스팟 방지, 그리고 리밸런싱을 학습합니다. 난이도: ⭐⭐⭐ 예상 학습 시간: 2-3시간 선수 지식: 07DistributedCacheSystems.md, PostgreSQL 폴더 --- 1. 데이터베이스 확장의 필요성 2. 파티셔닝 vs 샤딩 3. 샤딩 전략 4. 샤딩 키 선택 5. 핫스팟 방지 6. 리밸런싱 7. 연습 문제 8. 다음 단계 9. 참고 자료 --- --- | 항목 | 파티셔닝 | 샤딩 | |------|----------|------| | 위치 | 단일 서버 내 | 여러 서버 | | 확장성 | 제한적 | 높음 | | 복잡도 | 낮음 | 높음 | | 트랜잭션 | 전체 가능 | 샤드 내만 | | JOIN | 가능 | 크로스 샤드 어려움 | | 관리 | DB가 자동 | 애플리케이션이 관리 | --- | 전략 | 균등...", "url": "/study/ko/System_Design/08_Database_Scaling.html"}, {"id": "System_Design/09_Database_Replication", "title": "데이터베이스 복제 (Database Replication)", "topic": "System_Design", "topic_display": "System Design", "body": "데이터베이스 복제(Replication)는 동일한 데이터를 여러 노드에 복사하여 가용성, 내결함성, 읽기 성능을 향상시키는 기술입니다. 이 문서에서는 다양한 복제 전략과 일관성 보장 메커니즘, 장애 복구 방법을 학습합니다. --- 1. 복제의 개념과 목적 2. 단일 리더 복제 3. 다중 리더 복제 4. 리더 없는 복제 5. 동기/비동기 복제 6. 복제 지연과 일관성 문제 7. 장애 복구와 리더 선출 8. Quorum과 일관성 수준 9. 연습 문제 10. 다음 단계 11. 참고 자료 --- --- --- --- --- --- --- --- --- 다음 시나리오에서 적절한 복제 전략을 선택하고 이유를 설명하세요. 예시 답안: 예시 답안: 예시 답안: 예시 답안: 예시 답안: python class Client: def init(self): self.lastwritetimestamp = 0 def write(self, data): result = leader.write(data)...", "url": "/study/ko/System_Design/09_Database_Replication.html"}, {"id": "System_Design/10_Data_Consistency_Patterns", "title": "데이터 일관성 패턴 (Data Consistency Patterns)", "topic": "System_Design", "topic_display": "System Design", "body": "난이도: ⭐⭐⭐⭐ 분산 시스템에서 데이터 일관성은 가장 도전적인 문제 중 하나입니다. 이 장에서는 Strong Consistency와 Eventual Consistency의 트레이드오프, 읽기 일관성 패턴, 분산 트랜잭션의 한계, 그리고 Saga 패턴을 학습합니다. --- 1. 일관성 모델 개요 2. Strong vs Eventual Consistency 3. 읽기 일관성 패턴 4. 분산 트랜잭션과 2PC 5. Saga 패턴 6. 실전 적용 가이드 7. 연습 문제 --- --- 모든 읽기가 가장 최근 쓰기 결과를 반환합니다. 충분한 시간이 지나면 모든 읽기가 같은 값을 반환합니다. | 특성 | Strong Consistency | Eventual Consistency | |------|-------------------|---------------------| | 읽기 일관성 | 항상 최신 | 일시적 지연 | | 쓰기 지연 | 높음 | 낮음 | | 가용성 | 낮음 | 높음 | |...", "url": "/study/ko/System_Design/10_Data_Consistency_Patterns.html"}, {"id": "System_Design/11_Message_Queue_Basics", "title": "메시지 큐 기초 (Message Queue Fundamentals)", "topic": "System_Design", "topic_display": "System Design", "body": "난이도: ⭐⭐⭐ 메시지 큐는 분산 시스템에서 서비스 간 비동기 통신을 가능하게 하는 핵심 인프라입니다. 이 장에서는 동기와 비동기 통신의 차이, 큐와 토픽의 개념, 메시지 전달 보장 수준, 그리고 멱등성에 대해 학습합니다. --- 1. 동기 vs 비동기 통신 2. 메시지 큐의 이점 3. 큐 vs 토픽 4. 메시지 전달 보장 5. 멱등성 (Idempotency) 6. 메시지 큐 패턴 7. 연습 문제 --- 요청 후 응답을 기다리는 방식입니다. 메시지를 보내고 즉시 다른 작업을 계속합니다. | 특성 | 동기 | 비동기 | |------|------|--------| | 응답 대기 | 필요 | 불필요 | | 결합도 | 강함 | 느슨함 | | 장애 전파 | 즉시 전파 | 격리됨 | | 실시간성 | 즉시 | 지연 가능 | | 복잡도 | 낮음 | 높음 | | 처리량 | 제한적 | 높음 | --- --- 하나의 메시지는 하나의 Consumer만 처리합니다. 하나의 메시지가 모든...", "url": "/study/ko/System_Design/11_Message_Queue_Basics.html"}, {"id": "System_Design/12_Message_System_Comparison", "title": "메시지 시스템 비교 (Message Systems Comparison)", "topic": "System_Design", "topic_display": "System Design", "body": "난이도: ⭐⭐⭐ 다양한 메시지 시스템들은 각각의 설계 철학과 강점을 가지고 있습니다. 이 장에서는 Apache Kafka, RabbitMQ, AWS SQS/SNS의 핵심 개념과 차이점을 학습하고, 사용 사례에 맞는 시스템을 선택하는 기준을 알아봅니다. --- 1. Apache Kafka 2. RabbitMQ 3. AWS SQS/SNS 4. 시스템 비교 및 선택 기준 5. 하이브리드 아키텍처 6. 연습 문제 --- Kafka는 LinkedIn에서 개발한 분산 스트리밍 플랫폼으로, 높은 처리량과 내구성을 제공합니다. --- RabbitMQ는 AMQP 프로토콜 기반의 전통적인 메시지 브로커입니다. --- --- --- --- 다음 요구사항에 적합한 메시지 시스템을 선택하고 이유를 설명하세요: 1. 실시간 주식 거래 시스템 (밀리초 지연) 2. 이커머스 주문 이벤트 로그 (3년 보존) 3. 이미지 리사이징 작업 큐 (우선순위 필요) 4. 서버리스 기반 스타트업 MVP 5. IoT 센서...", "url": "/study/ko/System_Design/12_Message_System_Comparison.html"}, {"id": "System_Design/13_Microservices_Basics", "title": "마이크로서비스 기초 (Microservices Fundamentals)", "topic": "System_Design", "topic_display": "System Design", "body": "난이도: ⭐⭐⭐ 마이크로서비스 아키텍처는 애플리케이션을 작고 독립적인 서비스들의 집합으로 구성하는 설계 방식입니다. 이 장에서는 모놀리스와 마이크로서비스의 차이, 서비스 경계 정의, 데이터 관리 원칙, 그리고 서비스 간 통신 방식을 학습합니다. --- 1. 모놀리스 vs 마이크로서비스 2. 마이크로서비스의 특성 3. 서비스 경계 정의 4. Database per Service 5. 서비스 간 통신 6. 마이크로서비스 도입 전략 7. 연습 문제 --- --- --- --- --- --- --- 온라인 서점 시스템을 마이크로서비스로 분해하세요: - 핵심 Bounded Context 식별 - 각 서비스의 책임 정의 - 서비스 간 관계 (Context Mapping) 설계 - 데이터베이스 분리 전략 다음 시나리오에서 동기/비동기 통신 중 적절한 방식을 선택하세요: 1. 상품 상세 페이지 로딩 시 재고 확인 2. 주문 완료 후 이메일 발송 3. 결제 처리 후 재고 차감 4. 사용자 프로필...", "url": "/study/ko/System_Design/13_Microservices_Basics.html"}, {"id": "System_Design/14_Microservices_Patterns", "title": "마이크로서비스 패턴 (Microservices Patterns)", "topic": "System_Design", "topic_display": "System Design", "body": "난이도: ⭐⭐⭐⭐ 마이크로서비스 아키텍처를 성공적으로 운영하기 위해서는 다양한 패턴과 도구가 필요합니다. 이 장에서는 서비스 디스커버리, 서킷 브레이커, Bulkhead 패턴, 서비스 메시, 그리고 분산 추적에 대해 학습합니다. --- 1. 서비스 디스커버리 2. 서킷 브레이커 3. Bulkhead 패턴 4. 서비스 메시 5. 분산 추적 6. 기타 중요 패턴 7. 연습 문제 --- | 도구 | 타입 | 특징 | |------|------|------| | Consul | CP | 헬스체크, KV 스토어, DNS 인터페이스 | | Eureka | AP | Netflix OSS, Spring Cloud 통합 | | etcd | CP | Raft 합의, Kubernetes 기반 | | ZooKeeper | CP | 분산 조정, 복잡한 API | | Kubernetes | - | Service + DNS 내장, 클라우드 네이티브 | --- | 도구 | 언어 | 특징 |...", "url": "/study/ko/System_Design/14_Microservices_Patterns.html"}, {"id": "System_Design/15_Distributed_Systems_Concepts", "title": "분산 시스템 개념 (Distributed Systems Concepts)", "topic": "System_Design", "topic_display": "System Design", "body": "난이도: ⭐⭐⭐⭐ 분산 시스템은 네트워크로 연결된 여러 컴퓨터가 협력하여 하나의 시스템처럼 동작하는 것입니다. 이 장에서는 분산 시스템의 근본적인 도전과제, 시간 개념, 그리고 리더 선출 알고리즘에 대해 학습합니다. --- 1. 분산 시스템의 8가지 오류 2. 시간과 순서 3. 논리 시계 4. 리더 선출 5. 분산 시스템의 도전 과제 6. 연습 문제 --- 분산 시스템 초보자들이 흔히 하는 잘못된 가정들입니다. --- --- | 특성 | Lamport Clock | Vector Clock | |------|---------------|--------------| | 크기 | 정수 1개 | N개 정수 | | 인과관계 감지 | 부분적 | 완전 | | 동시성 감지 | 불가 | 가능 | | 확장성 | 우수 | 제한적 | | 구현 복잡도 | 간단 | 중간 | --- --- --- 다음 이벤트 시퀀스에서 각 이벤트의 Lamport 타임스탬프를 계산하세요: 다음 Vector Clock 값들의...", "url": "/study/ko/System_Design/15_Distributed_Systems_Concepts.html"}, {"id": "System_Design/16_Consensus_Algorithms", "title": "합의 알고리즘 (Consensus Algorithms)", "topic": "System_Design", "topic_display": "System Design", "body": "난이도: ⭐⭐⭐⭐ 분산 시스템에서 합의(Consensus)는 여러 노드가 하나의 값에 동의하는 것입니다. 이 장에서는 합의 문제의 정의, Paxos와 Raft 알고리즘, Byzantine Fault Tolerance, 그리고 ZooKeeper와 etcd의 활용을 학습합니다. --- 1. 합의 문제 정의 2. Paxos 알고리즘 3. Raft 알고리즘 4. Byzantine Fault Tolerance 5. 실전 활용 6. 연습 문제 --- | 모델 | 설명 | 필요 노드 수 | |------|------|-------------| | Crash Failure | 노드가 멈춤, 복구 가능 | 2f + 1 | | Omission Failure | 메시지 손실 가능 | 2f + 1 | | Byzantine Failure | 악의적/임의의 행동 | 3f + 1 | --- --- | 특성 | Raft | Paxos | |------|------|-------| | 이해 용이성 | 높음 |...", "url": "/study/ko/System_Design/16_Consensus_Algorithms.html"}, {"id": "System_Design/17_Design_Example_1", "title": "실전 설계 예제 1 (Practical Design Examples 1)", "topic": "System_Design", "topic_display": "System Design", "body": "난이도: ⭐⭐⭐⭐ 이 장에서는 실제 시스템 설계 면접에서 자주 등장하는 세 가지 시스템을 설계합니다: URL 단축기, 페이스트빈, Rate Limiter. 각 예제는 요구사항 정의, 용량 추정, 고수준 설계, 상세 설계의 순서로 진행됩니다. --- 1. URL 단축기 (URL Shortener) 2. 페이스트빈 (Pastebin) 3. Rate Limiter 4. 연습 문제 --- --- --- --- 기존 URL 단축기에 다음 기능을 추가하는 설계를 하세요: - 국가별 다른 URL로 리다이렉트 - A/B 테스트 지원 (50%는 URL-A, 50%는 URL-B) - 하루 100만 클릭 분석 대시보드 다음 보안 요구사항을 만족하는 설계를 하세요: - 비밀번호로 보호된 페이스트 - 조회 후 자동 삭제 (burn after read) - 클라이언트 사이드 암호화 옵션 다음 요구사항의 Rate Limiter를 설계하세요: - 사용자 티어별 다른 한도 (무료/유료/기업) - 피크 시간 자동...", "url": "/study/ko/System_Design/17_Design_Example_1.html"}, {"id": "System_Design/18_Design_Example_2", "title": "실전 설계 예제 2 (Practical Design Examples 2)", "topic": "System_Design", "topic_display": "System Design", "body": "난이도: ⭐⭐⭐⭐ 이 장에서는 소셜 미디어와 실시간 통신 시스템을 설계합니다: 뉴스 피드/타임라인, 채팅 시스템, 알림 시스템. 이러한 시스템은 대규모 사용자를 다루며, 실시간성과 확장성이 중요한 과제입니다. --- 1. 뉴스 피드 / 타임라인 2. 채팅 시스템 3. 알림 시스템 4. 연습 문제 --- --- --- --- 다음 기능을 추가하는 설계를 하세요: - 광고 삽입 (5번째 포스트마다) - 트렌딩 포스트 추천 - \"관심 없음\" 피드백 반영 다음 요구사항을 만족하는 설계를 하세요: - End-to-End 암호화 - 메시지 편집/삭제 (24시간 내) - 화상/음성 통화 시그널링 다음 상황을 처리하는 설계를 하세요: - 글로벌 서비스: 다국어 알림 - 알림 배칭: 유사 알림 묶음 - A/B 테스트: 알림 문구 최적화 --- 이 시리즈를 통해 시스템 설계의 핵심 개념과 패턴을 학습했습니다. 실제 면접이나 프로젝트에서는 요구사항을 명확히 하고, 트레이드오프를 고려하며, 확장 가능한...", "url": "/study/ko/System_Design/18_Design_Example_2.html"}, {"id": "System_Design/19_Observability_Monitoring", "title": "19. 관측 가능성과 모니터링", "topic": "System_Design", "topic_display": "System Design", "body": "난이도: ⭐⭐⭐⭐ 관측 가능성(Observability)은 시스템의 외부 출력으로부터 내부 상태를 이해할 수 있는 능력입니다. 이 레슨에서는 관측 가능성의 세 가지 기둥(three pillars)인 메트릭(metrics), 로그(logs), 트레이스(traces)와 더불어 대규모 분산 시스템 모니터링을 위한 실용적인 도구 및 프레임워크를 다룹니다. --- 1. 관측 가능성의 기초 2. 메트릭과 시계열 데이터 3. 대규모 로깅 4. 분산 트레이싱 5. 경보와 SLO 6. OpenTelemetry 7. 연습 문제 --- --- --- 모범 사례: - 일반 텍스트보다 구조화된 로깅(JSON) 사용 - 모든 로그에 상관 관계 ID(traceid) 포함 - 적절한 레벨로 로깅 (프로덕션에서 INFO 스팸 금지) - 보존 정책 설정 (7일 hot, 30일 warm, 90일 cold) - 민감한 데이터 로깅 금지 (PII, 자격 증명) --- --- 경보 안티 패턴: - 경보 피로(Alert...", "url": "/study/ko/System_Design/19_Observability_Monitoring.html"}, {"id": "System_Design/20_Search_Systems", "title": "20. 검색 시스템", "topic": "System_Design", "topic_display": "System Design", "body": "난이도: ⭐⭐⭐⭐ 검색(Search)은 대부분의 애플리케이션에서 기본적인 구성 요소입니다. 이 레슨에서는 검색 엔진이 내부적으로 어떻게 작동하는지 다룹니다 — 역색인(inverted index)과 텍스트 분석부터 분산 검색 아키텍처 및 랭킹 알고리즘까지. 가장 널리 채택된 솔루션인 Elasticsearch를 중심으로 설명합니다. --- 1. 검색 엔진의 기초 2. 역색인 3. Elasticsearch 아키텍처 4. 인덱싱과 매핑 5. 검색 쿼리 6. 랭킹과 관련성 7. 검색 시스템 확장 8. 연습 문제 --- --- --- --- --- --- --- --- 천만 개의 제품이 있는 이커머스 플랫폼을 위한 검색 시스템을 설계하세요. 하루 50TB의 로그를 위한 중앙 집중식 로그 검색 시스템을 설계하세요. 50ms 미만으로 결과를 반환하는 검색 자동완성을 설계하세요. --- - 19. 관측 가능성과 모니터링 - 15. 분산 시스템 개념 - Elasticsearch: The...", "url": "/study/ko/System_Design/20_Search_Systems.html"}, {"id": "Web_Development/00_Overview", "title": "웹 개발 학습 가이드", "topic": "Web_Development", "topic_display": "Web Development", "body": "이 폴더는 웹 프론트엔드 개발을 처음부터 체계적으로 학습하기 위한 자료를 담고 있습니다. HTML, CSS, JavaScript를 단계별로 학습할 수 있습니다. 대상 독자: 웹 개발 입문자 ~ 중급자 --- --- | 파일명 | 난이도 | 주요 내용 | |--------|--------|----------| | 01HTMLBasics.md | ⭐ | 태그, 구조, 시맨틱 HTML | | 02HTMLFormsTables.md | ⭐ | form, input, table | | 03CSSBasics.md | ⭐⭐ | 선택자, 속성, 박스 모델 | | 04CSSLayout.md | ⭐⭐ | Flexbox, Grid | | 05CSSResponsive.md | ⭐⭐ | 미디어 쿼리, 모바일 대응 | | 06JSBasics.md | ⭐⭐ | 변수, 함수, 자료형 | | 07JSEventsDOM.md | ⭐⭐⭐ | DOM 조작, 이벤트 핸들링 | | 08JSAsync.md | ⭐⭐⭐ |...", "url": "/study/ko/Web_Development/00_Overview.html"}, {"id": "Web_Development/01_HTML_Basics", "title": "HTML 기초", "topic": "Web_Development", "topic_display": "Web Development", "body": "HTML(HyperText Markup Language)은 웹 페이지의 구조를 정의하는 마크업 언어입니다. --- | 요소 | 설명 | |------|------| | | HTML5 문서 선언 | | | 문서의 루트 요소 | | | 메타 정보 (브라우저에 표시 안 됨) | | | 실제 화면에 표시되는 내용 | | | 문서 언어 (한국어) | | | 문자 인코딩 | | | 반응형 웹을 위한 설정 | --- --- 주의: h1은 페이지당 하나만 사용 권장 (SEO) --- 결과: - 항목 1 - 항목 2 - 항목 3 --- --- alt 속성은: - 이미지 로드 실패 시 대체 텍스트 - 스크린 리더 (접근성) - SEO 최적화 --- 시맨틱(Semantic) 태그는 의미를 가진 태그입니다. | 태그 | 용도 | |------|------| | | 머리말, 로고, 네비게이션 | | | 주요 네비게이션 링크 | | | 문서의 주요 콘텐츠 (페이지당 1개) | | | 독립적인 콘텐츠...", "url": "/study/ko/Web_Development/01_HTML_Basics.html"}, {"id": "Web_Development/02_HTML_Forms_Tables", "title": "HTML 폼과 테이블", "topic": "Web_Development", "topic_display": "Web Development", "body": "폼은 사용자로부터 데이터를 입력받아 서버로 전송하는 요소입니다. | 속성 | 설명 | 예시 | |------|------|------| | | 데이터를 보낼 URL | | | | 전송 방식 | , | | | 인코딩 타입 | (파일 업로드 시) | | | 자동완성 | , | | | 유효성 검사 비활성화 | | --- --- --- 1. 접근성: 스크린 리더가 읽어줌 2. 사용성: label 클릭 시 input에 포커스 3. 체크박스/라디오: 텍스트 클릭으로 선택 가능 --- --- --- --- --- | 태그 | 설명 | |------|------| | | 테이블 전체 | | | 행 (table row) | | | 헤더 셀 (굵게 표시) | | | 데이터 셀 | | | 헤더 영역 | | | 본문 영역 | | | 푸터 영역 | | | 테이블 제목 | --- --- --- --- --- --- | 요소 | 용도 | |------|------| | | 폼 컨테이너 | | | 다양한 입력...", "url": "/study/ko/Web_Development/02_HTML_Forms_Tables.html"}, {"id": "Web_Development/03_CSS_Basics", "title": "CSS 기초", "topic": "Web_Development", "topic_display": "Web Development", "body": "CSS(Cascading Style Sheets)는 HTML 요소의 스타일을 정의하는 언어입니다. --- --- --- --- --- --- --- --- --- | 용도 | 권장 단위 | |------|-----------| | 폰트 크기 | | | 패딩/마진 | 또는 | | 너비 | , , | | 높이 | , , | | 테두리 | | --- --- 나중에 선언된 스타일이 적용됩니다. --- --- 브라우저마다 기본 스타일이 달라서 초기화가 필요합니다. --- --- | 개념 | 설명 | |------|------| | 선택자 | 스타일을 적용할 요소 지정 | | 박스 모델 | content, padding, border, margin | | 단위 | px, rem, em, %, vw, vh | | 우선순위 | !important > inline > ID > class > 태그 | | 상속 | 텍스트 관련 속성은 상속됨 | --- 다양한 색상의 버튼을 만들어보세요. -...", "url": "/study/ko/Web_Development/03_CSS_Basics.html"}, {"id": "Web_Development/04_CSS_Layout", "title": "CSS 레이아웃", "topic": "Web_Development", "topic_display": "Web Development", "body": "CSS 레이아웃은 웹 페이지의 요소들을 원하는 위치에 배치하는 기술입니다. 현대 웹 개발에서는 주로 Flexbox와 CSS Grid를 사용합니다. 선수 지식: 03CSSBasics.md --- 1. 전통적 레이아웃 2. Flexbox 3. CSS Grid 4. Flexbox vs Grid 5. Position 6. 실전 레이아웃 예제 --- 과거에 사용되던 방식으로, 현재는 텍스트 감싸기 정도에만 사용합니다. > 참고: 새 프로젝트에서는 Flexbox나 Grid를 사용하세요. --- 1차원 레이아웃 시스템으로, 행(row) 또는 열(column) 단위로 요소를 배치합니다. 주 축(main axis) 방향을 설정합니다. 줄바꿈 설정입니다. 주 축 정렬 (가로 방향 정렬, flex-direction: row 기준) 교차 축 정렬 (세로 방향 정렬, flex-direction: row 기준) 여러 줄일 때 줄 간격 정렬 (flex-wrap: wrap 필요) 아이템 사이 간격 남은 공간을...", "url": "/study/ko/Web_Development/04_CSS_Layout.html"}, {"id": "Web_Development/05_CSS_Responsive", "title": "CSS 반응형 디자인", "topic": "Web_Development", "topic_display": "Web Development", "body": "반응형 웹 디자인은 다양한 화면 크기(데스크톱, 태블릿, 모바일)에서 최적의 사용자 경험을 제공하는 설계 방식입니다. 선수 지식: 04CSSLayout.md --- 1. 반응형 디자인 기초 2. 뷰포트 설정 3. 미디어 쿼리 4. 반응형 단위 5. 반응형 이미지 6. 반응형 타이포그래피 7. 반응형 레이아웃 패턴 8. 모바일 퍼스트 9. 실전 예제 --- 1. 유동적 그리드: 고정 픽셀 대신 비율(%, fr) 사용 2. 유연한 이미지: 컨테이너에 맞게 크기 조정 3. 미디어 쿼리: 화면 크기별 스타일 적용 --- 모든 반응형 페이지에 필수입니다. | 속성 | 설명 | |------|------| | | 뷰포트 너비를 기기 너비에 맞춤 | | | 초기 확대/축소 비율 | | | 최대 확대 비율 (접근성 문제로 비권장) | | | 사용자 확대/축소 금지 (비권장) | --- --- | 단위 | 기준 | 사용처 | |------|------|--------| | | 부모 요소 | 너비,...", "url": "/study/ko/Web_Development/05_CSS_Responsive.html"}, {"id": "Web_Development/06_JS_Basics", "title": "JavaScript 기초", "topic": "Web_Development", "topic_display": "Web Development", "body": "JavaScript는 웹 페이지에 동적인 기능을 추가하는 프로그래밍 언어입니다. HTML이 구조, CSS가 스타일이라면, JavaScript는 동작을 담당합니다. 선수 지식: HTML, CSS 기초 --- 1. JavaScript 시작하기 2. 변수와 상수 3. 자료형 4. 연산자 5. 조건문 6. 반복문 7. 함수 8. 배열 9. 객체 10. ES6+ 문법 --- | 속성 | 실행 시점 | 순서 보장 | 용도 | |------|-----------|-----------|------| | (없음) | 즉시 | O | - | | | DOM 파싱 후 | O | 일반 스크립트 | | | 다운로드 후 | X | 분석, 광고 | 브라우저에서 F12 → Console 탭에서 JavaScript를 바로 실행할 수 있습니다. --- 값을 변경할 수 있습니다. 값을 변경할 수 없습니다. --- --- --- --- --- --- --- --- --- 나이를 받아 구분하는 함수를 작성하세요. -...", "url": "/study/ko/Web_Development/06_JS_Basics.html"}, {"id": "Web_Development/07_JS_Events_DOM", "title": "JavaScript 이벤트와 DOM", "topic": "Web_Development", "topic_display": "Web Development", "body": "DOM(Document Object Model)은 HTML 문서를 JavaScript로 조작할 수 있게 해주는 인터페이스입니다. 이벤트는 사용자 상호작용(클릭, 입력 등)을 처리하는 메커니즘입니다. 선수 지식: 06JSBasics.md --- 1. DOM 기초 2. 요소 선택 3. 요소 내용 조작 4. 속성 조작 5. 클래스 조작 6. 스타일 조작 7. 요소 생성과 삭제 8. 이벤트 기초 9. 이벤트 종류 10. 이벤트 위임 11. 폼 처리 --- --- 가장 가까운 조상 요소 찾기 선택자와 일치하는지 확인 --- 텍스트만 다룹니다 (HTML 태그 무시). HTML을 포함한 내용을 다룹니다. 요소 자체를 포함한 HTML --- --- --- 실제 적용된 스타일 읽기 --- --- --- --- 부모 요소에 이벤트 리스너를 등록하여 자식 요소의 이벤트를 처리합니다. 1. 메모리 효율: 리스너 수 감소 2. 동적 요소: 나중에 추가된 요소도 처리 3. 간단한 관리: 하나의 리스너로...", "url": "/study/ko/Web_Development/07_JS_Events_DOM.html"}, {"id": "Web_Development/08_JS_Async", "title": "JavaScript 비동기 프로그래밍", "topic": "Web_Development", "topic_display": "Web Development", "body": "JavaScript는 단일 스레드로 동작하지만, 비동기 프로그래밍을 통해 네트워크 요청, 파일 읽기 등의 작업을 효율적으로 처리합니다. 이 문서에서는 콜백, Promise, async/await, 그리고 fetch API를 다룹니다. 선수 지식: 07JSEventsDOM.md --- 1. 동기 vs 비동기 2. 콜백 3. Promise 4. async/await 5. Fetch API 6. 에러 처리 7. 실전 패턴 --- 코드가 순서대로 실행됩니다. 한 작업이 끝나야 다음 작업이 시작됩니다. 작업을 기다리지 않고 다음 코드를 실행합니다. - 서버 요청 (API 호출) - 파일 읽기/쓰기 - 타이머 (setTimeout, setInterval) - 이벤트 리스너 - 데이터베이스 쿼리 --- 다른 함수에 인자로 전달되어 나중에 실행되는 함수입니다. 중첩된 콜백으로 코드가 복잡해지는 문제 --- 비동기 작업의 최종 완료(또는 실패)와 그 결과값을 나타내는 객체입니다. --- async...", "url": "/study/ko/Web_Development/08_JS_Async.html"}, {"id": "Web_Development/09_Practical_Projects", "title": "실전 프로젝트", "topic": "Web_Development", "topic_display": "Web Development", "body": "이 문서에서는 앞서 배운 HTML, CSS, JavaScript를 종합하여 실제 동작하는 웹 애플리케이션을 만들어봅니다. 선수 지식: 이전 모든 챕터 --- 1. 프로젝트 1: Todo 앱 2. 프로젝트 2: 날씨 앱 3. 프로젝트 3: 이미지 갤러리 4. 다음 단계 --- 로컬 스토리지를 활용한 할 일 관리 애플리케이션입니다. - 할 일 추가/삭제/완료 처리 - 로컬 스토리지에 저장 - 필터링 (전체/진행중/완료) - 반응형 디자인 --- 외부 API를 활용한 날씨 정보 조회 애플리케이션입니다. - 도시명으로 날씨 검색 - 현재 위치 날씨 조회 - 날씨 아이콘 및 상세 정보 표시 - 로딩 상태 및 에러 처리 OpenWeatherMap에서 무료 API 키를 발급받으세요. --- 무한 스크롤과 라이트박스 기능이 있는 이미지 갤러리입니다. - Unsplash API로 이미지 로드 - 무한 스크롤 - 라이트박스 (클릭 시 확대) - 반응형 그리드 Unsplash에서 API 키를...", "url": "/study/ko/Web_Development/09_Practical_Projects.html"}, {"id": "Web_Development/10_TypeScript_Basics", "title": "10. TypeScript 기초 (TypeScript Fundamentals)", "topic": "Web_Development", "topic_display": "Web Development", "body": "- TypeScript의 장점과 JavaScript와의 관계 이해 - 기본 타입 시스템 마스터 - 인터페이스와 타입 별칭 활용 - 제네릭을 통한 재사용 가능한 코드 작성 - 유틸리티 타입과 고급 타입 기능 이해 1. TypeScript 소개 2. 기본 타입 3. 인터페이스와 타입 4. 함수 타입 5. 제네릭 6. 유틸리티 타입 7. 연습 문제 --- --- --- --- --- --- --- 다음 데이터 구조에 대한 타입을 정의하세요. 배열에서 조건에 맞는 첫 번째 요소를 찾는 제네릭 함수를 작성하세요. API 응답 타입을 정의하세요. --- - 11. 웹 접근성 - 12. SEO 기초 - TypeScript Handbook - TypeScript Playground - DefinitelyTyped - TypeScript Deep Dive", "url": "/study/ko/Web_Development/10_TypeScript_Basics.html"}, {"id": "Web_Development/11_Web_Accessibility", "title": "11. 웹 접근성 (Web Accessibility - A11y)", "topic": "Web_Development", "topic_display": "Web Development", "body": "- 웹 접근성의 중요성과 법적 요구사항 이해 - WCAG 가이드라인과 준수 수준 학습 - ARIA 속성을 활용한 접근성 향상 - 키보드 네비게이션 구현 - 스크린 리더 호환성 테스트 1. 접근성 개요 2. WCAG 가이드라인 3. 시맨틱 HTML 4. ARIA 속성 5. 키보드 접근성 6. 테스트와 도구 7. 연습 문제 --- --- --- --- --- --- --- 다음 코드의 접근성을 개선하세요. 다음 폼의 접근성을 개선하세요. 드롭다운 메뉴에 키보드 접근성을 추가하세요. --- - 10. TypeScript 기초 - 12. SEO 기초 - WCAG 2.1 가이드라인 - MDN Accessibility - WebAIM - A11y Project - Deque University", "url": "/study/ko/Web_Development/11_Web_Accessibility.html"}, {"id": "Web_Development/12_SEO_Basics", "title": "12. SEO 기초 (Search Engine Optimization)", "topic": "Web_Development", "topic_display": "Web Development", "body": "- SEO의 기본 원리와 중요성 이해 - 기술적 SEO 요소 구현 - 메타 태그와 구조화 데이터 활용 - 콘텐츠 최적화 전략 학습 - SEO 도구 활용법 습득 1. SEO 개요 2. 메타 태그 3. 구조화 데이터 4. 기술적 SEO 5. 콘텐츠 SEO 6. 측정과 도구 7. 연습 문제 --- --- --- --- --- --- --- 블로그 포스트에 필요한 메타 태그를 작성하세요. 레시피 페이지의 구조화 데이터를 작성하세요. 다음 요구사항에 맞는 robots.txt를 작성하세요. - 관리자 페이지 (/admin/) 차단 - API 엔드포인트 (/api/) 차단 - 검색 결과 페이지 (/search?*) 차단 - 나머지는 허용 --- - 11. 웹 접근성 - 13. 빌드 도구 환경 - Google Search Central - Schema.org - Web.dev SEO Guide - Moz Beginner's Guide to SEO", "url": "/study/ko/Web_Development/12_SEO_Basics.html"}, {"id": "Web_Development/13_Build_Tools_Environment", "title": "13. 빌드 도구와 개발 환경 (Build Tools & Development Environment)", "topic": "Web_Development", "topic_display": "Web Development", "body": "- 패키지 관리자(npm, yarn, pnpm) 이해와 활용 - 모던 빌드 도구(Vite, webpack) 설정 - 개발 환경 구성 및 최적화 - 환경 변수 관리 - 프로덕션 빌드 최적화 1. 패키지 관리자 2. Vite 3. webpack 기초 4. 환경 변수 5. 코드 품질 도구 6. 연습 문제 --- --- --- --- --- --- React + TypeScript 프로젝트를 Vite로 설정하세요. 개발/프로덕션 환경별 API URL을 설정하세요. ESLint + Prettier + Husky를 설정하세요. --- - 10. TypeScript 기초 - 11. 웹 접근성 - Vite Documentation - webpack Documentation - npm Documentation - ESLint - Prettier", "url": "/study/ko/Web_Development/13_Build_Tools_Environment.html"}, {"id": "Web_Development/14_CSS_Animations", "title": "CSS 애니메이션", "topic": "Web_Development", "topic_display": "Web Development", "body": "- CSS transition으로 부드러운 상태 변화 구현 - CSS transform으로 요소 변형 적용 - @keyframes를 사용한 복잡한 애니메이션 생성 - 성능 최적화와 접근성 고려 사항 이해 --- --- --- --- --- --- --- | 기능 | Transition | Animation | |------|------------|-----------| | 트리거 | 상태 변화 필요 (hover 등) | 자동/수동 모두 가능 | | 복잡도 | 단순 (시작→끝) | 복잡 (다단계 가능) | | 반복 | 불가 | 가능 (infinite) | | 중간 상태 | 불가 | 가능 (@keyframes) | | 사용 사례 | 호버 효과, 상태 전환 | 로딩, 배경 애니메이션 | | 함수 | 설명 | 예시 | |------|------|------| | translate | 이동 | | | scale | 크기 | | | rotate | 회전 | | | skew | 기울이기 | |...", "url": "/study/ko/Web_Development/14_CSS_Animations.html"}, {"id": "Web_Development/15_JS_Modules", "title": "JavaScript 모듈 시스템", "topic": "Web_Development", "topic_display": "Web Development", "body": "- ES Modules (ESM)의 import/export 문법 이해 - CommonJS와 ESM의 차이점 파악 - 동적 import와 코드 스플리팅 활용 - 모듈 번들러의 역할 이해 --- --- --- --- --- --- --- --- | 기능 | 문법 | |------|------| | Named Export | | | Default Export | | | Named Import | | | Default Import | | | 전체 Import | | | 동적 Import | | | Re-export | | 1. Named Export 선호: IDE 자동완성, Tree Shaking 용이 2. 배럴 파일 사용: 깔끔한 import 경로 3. 순환 참조 피하기: 의존성 방향 정리 4. 동적 import 활용: 큰 모듈 지연 로딩 - 13BuildTools_Environment.md: 빌드 도구 (Vite, webpack) --- - MDN JavaScript Modules...", "url": "/study/ko/Web_Development/15_JS_Modules.html"}, {"id": "Web_Development/16_Flask_Basics", "title": "16. Flask 웹 프레임워크 기초", "topic": "Web_Development", "topic_display": "Web Development", "body": "- Flask의 핵심 개념과 구조 이해 - 라우팅, 템플릿, 폼 처리 습득 - 데이터베이스 연동 및 RESTful API 구현 - 블루프린트를 활용한 대규모 애플리케이션 구조화 --- Flask는 Python으로 작성된 마이크로 웹 프레임워크입니다. --- --- --- --- --- --- --- --- --- --- --- 전체 구조와 주요 파일을 포함한 완전한 블로그 앱 예제는 폴더를 참조하세요. --- 간단한 할 일 목록(Todo) 앱을 만드세요: - 할 일 목록 보기 - 새 할 일 추가 - 완료 표시 - 삭제 위 앱에 사용자 인증을 추가하세요: - 회원가입/로그인/로그아웃 - 각 사용자는 자신의 할 일만 볼 수 있음 할 일 목록 API를 만드세요: - CRUD 엔드포인트 - JWT 인증 - Swagger 문서화 --- - Flask 공식 문서 - Flask-SQLAlchemy 문서 - Flask Mega-Tutorial - Real Python Flask Tutorials", "url": "/study/ko/Web_Development/16_Flask_Basics.html"}]}